var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target2, all) => {
  for (var name2 in all)
    __defProp(target2, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target2) => (target2 = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target2, "default", { value: mod3, enumerable: true }) : target2,
  mod3
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter2) => {
  __accessCheck(obj, member, "write to private field");
  setter2 ? setter2.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/geotiff/dist-module/globals.js
var fieldTagNames, fieldTags, arrayFields, fieldTypeNames, fieldTypes, LercParameters, LercAddCompression, geoKeyNames, geoKeys;
var init_globals = __esm({
  "node_modules/geotiff/dist-module/globals.js"() {
    fieldTagNames = {
      // TIFF Baseline
      315: "Artist",
      258: "BitsPerSample",
      265: "CellLength",
      264: "CellWidth",
      320: "ColorMap",
      259: "Compression",
      33432: "Copyright",
      306: "DateTime",
      338: "ExtraSamples",
      266: "FillOrder",
      289: "FreeByteCounts",
      288: "FreeOffsets",
      291: "GrayResponseCurve",
      290: "GrayResponseUnit",
      316: "HostComputer",
      270: "ImageDescription",
      257: "ImageLength",
      256: "ImageWidth",
      271: "Make",
      281: "MaxSampleValue",
      280: "MinSampleValue",
      272: "Model",
      254: "NewSubfileType",
      274: "Orientation",
      262: "PhotometricInterpretation",
      284: "PlanarConfiguration",
      296: "ResolutionUnit",
      278: "RowsPerStrip",
      277: "SamplesPerPixel",
      305: "Software",
      279: "StripByteCounts",
      273: "StripOffsets",
      255: "SubfileType",
      263: "Threshholding",
      282: "XResolution",
      283: "YResolution",
      // TIFF Extended
      326: "BadFaxLines",
      327: "CleanFaxData",
      343: "ClipPath",
      328: "ConsecutiveBadFaxLines",
      433: "Decode",
      434: "DefaultImageColor",
      269: "DocumentName",
      336: "DotRange",
      321: "HalftoneHints",
      346: "Indexed",
      347: "JPEGTables",
      285: "PageName",
      297: "PageNumber",
      317: "Predictor",
      319: "PrimaryChromaticities",
      532: "ReferenceBlackWhite",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      559: "StripRowCounts",
      330: "SubIFDs",
      292: "T4Options",
      293: "T6Options",
      325: "TileByteCounts",
      323: "TileLength",
      324: "TileOffsets",
      322: "TileWidth",
      301: "TransferFunction",
      318: "WhitePoint",
      344: "XClipPathUnits",
      286: "XPosition",
      529: "YCbCrCoefficients",
      531: "YCbCrPositioning",
      530: "YCbCrSubSampling",
      345: "YClipPathUnits",
      287: "YPosition",
      // EXIF
      37378: "ApertureValue",
      40961: "ColorSpace",
      36868: "DateTimeDigitized",
      36867: "DateTimeOriginal",
      34665: "Exif IFD",
      36864: "ExifVersion",
      33434: "ExposureTime",
      41728: "FileSource",
      37385: "Flash",
      40960: "FlashpixVersion",
      33437: "FNumber",
      42016: "ImageUniqueID",
      37384: "LightSource",
      37500: "MakerNote",
      37377: "ShutterSpeedValue",
      37510: "UserComment",
      // IPTC
      33723: "IPTC",
      // ICC
      34675: "ICC Profile",
      // XMP
      700: "XMP",
      // GDAL
      42112: "GDAL_METADATA",
      42113: "GDAL_NODATA",
      // Photoshop
      34377: "Photoshop",
      // GeoTiff
      33550: "ModelPixelScale",
      33922: "ModelTiepoint",
      34264: "ModelTransformation",
      34735: "GeoKeyDirectory",
      34736: "GeoDoubleParams",
      34737: "GeoAsciiParams",
      // LERC
      50674: "LercParameters"
    };
    fieldTags = {};
    for (const key in fieldTagNames) {
      if (fieldTagNames.hasOwnProperty(key)) {
        fieldTags[fieldTagNames[key]] = parseInt(key, 10);
      }
    }
    arrayFields = [
      fieldTags.BitsPerSample,
      fieldTags.ExtraSamples,
      fieldTags.SampleFormat,
      fieldTags.StripByteCounts,
      fieldTags.StripOffsets,
      fieldTags.StripRowCounts,
      fieldTags.TileByteCounts,
      fieldTags.TileOffsets,
      fieldTags.SubIFDs
    ];
    fieldTypeNames = {
      1: "BYTE",
      2: "ASCII",
      3: "SHORT",
      4: "LONG",
      5: "RATIONAL",
      6: "SBYTE",
      7: "UNDEFINED",
      8: "SSHORT",
      9: "SLONG",
      10: "SRATIONAL",
      11: "FLOAT",
      12: "DOUBLE",
      // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html
      13: "IFD",
      // introduced by BigTIFF
      16: "LONG8",
      17: "SLONG8",
      18: "IFD8"
    };
    fieldTypes = {};
    for (const key in fieldTypeNames) {
      if (fieldTypeNames.hasOwnProperty(key)) {
        fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);
      }
    }
    LercParameters = {
      Version: 0,
      AddCompression: 1
    };
    LercAddCompression = {
      None: 0,
      Deflate: 1,
      Zstandard: 2
    };
    geoKeyNames = {
      1024: "GTModelTypeGeoKey",
      1025: "GTRasterTypeGeoKey",
      1026: "GTCitationGeoKey",
      2048: "GeographicTypeGeoKey",
      2049: "GeogCitationGeoKey",
      2050: "GeogGeodeticDatumGeoKey",
      2051: "GeogPrimeMeridianGeoKey",
      2052: "GeogLinearUnitsGeoKey",
      2053: "GeogLinearUnitSizeGeoKey",
      2054: "GeogAngularUnitsGeoKey",
      2055: "GeogAngularUnitSizeGeoKey",
      2056: "GeogEllipsoidGeoKey",
      2057: "GeogSemiMajorAxisGeoKey",
      2058: "GeogSemiMinorAxisGeoKey",
      2059: "GeogInvFlatteningGeoKey",
      2060: "GeogAzimuthUnitsGeoKey",
      2061: "GeogPrimeMeridianLongGeoKey",
      2062: "GeogTOWGS84GeoKey",
      3072: "ProjectedCSTypeGeoKey",
      3073: "PCSCitationGeoKey",
      3074: "ProjectionGeoKey",
      3075: "ProjCoordTransGeoKey",
      3076: "ProjLinearUnitsGeoKey",
      3077: "ProjLinearUnitSizeGeoKey",
      3078: "ProjStdParallel1GeoKey",
      3079: "ProjStdParallel2GeoKey",
      3080: "ProjNatOriginLongGeoKey",
      3081: "ProjNatOriginLatGeoKey",
      3082: "ProjFalseEastingGeoKey",
      3083: "ProjFalseNorthingGeoKey",
      3084: "ProjFalseOriginLongGeoKey",
      3085: "ProjFalseOriginLatGeoKey",
      3086: "ProjFalseOriginEastingGeoKey",
      3087: "ProjFalseOriginNorthingGeoKey",
      3088: "ProjCenterLongGeoKey",
      3089: "ProjCenterLatGeoKey",
      3090: "ProjCenterEastingGeoKey",
      3091: "ProjCenterNorthingGeoKey",
      3092: "ProjScaleAtNatOriginGeoKey",
      3093: "ProjScaleAtCenterGeoKey",
      3094: "ProjAzimuthAngleGeoKey",
      3095: "ProjStraightVertPoleLongGeoKey",
      3096: "ProjRectifiedGridAngleGeoKey",
      4096: "VerticalCSTypeGeoKey",
      4097: "VerticalCitationGeoKey",
      4098: "VerticalDatumGeoKey",
      4099: "VerticalUnitsGeoKey"
    };
    geoKeys = {};
    for (const key in geoKeyNames) {
      if (geoKeyNames.hasOwnProperty(key)) {
        geoKeys[geoKeyNames[key]] = parseInt(key, 10);
      }
    }
  }
});

// node_modules/geotiff/dist-module/predictor.js
function decodeRowAcc(row, stride) {
  let length5 = row.length - stride;
  let offset = 0;
  do {
    for (let i3 = stride; i3 > 0; i3--) {
      row[offset + stride] += row[offset];
      offset++;
    }
    length5 -= stride;
  } while (length5 > 0);
}
function decodeRowFloatingPoint(row, stride, bytesPerSample) {
  let index = 0;
  let count2 = row.length;
  const wc = count2 / bytesPerSample;
  while (count2 > stride) {
    for (let i3 = stride; i3 > 0; --i3) {
      row[index + stride] += row[index];
      ++index;
    }
    count2 -= stride;
  }
  const copy6 = row.slice();
  for (let i3 = 0; i3 < wc; ++i3) {
    for (let b2 = 0; b2 < bytesPerSample; ++b2) {
      row[bytesPerSample * i3 + b2] = copy6[(bytesPerSample - b2 - 1) * wc + i3];
    }
  }
}
function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {
  if (!predictor || predictor === 1) {
    return block;
  }
  for (let i3 = 0; i3 < bitsPerSample.length; ++i3) {
    if (bitsPerSample[i3] % 8 !== 0) {
      throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");
    }
    if (bitsPerSample[i3] !== bitsPerSample[0]) {
      throw new Error("When decoding with predictor, all samples must have the same size.");
    }
  }
  const bytesPerSample = bitsPerSample[0] / 8;
  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;
  for (let i3 = 0; i3 < height; ++i3) {
    if (i3 * stride * width * bytesPerSample >= block.byteLength) {
      break;
    }
    let row;
    if (predictor === 2) {
      switch (bitsPerSample[0]) {
        case 8:
          row = new Uint8Array(
            block,
            i3 * stride * width * bytesPerSample,
            stride * width * bytesPerSample
          );
          break;
        case 16:
          row = new Uint16Array(
            block,
            i3 * stride * width * bytesPerSample,
            stride * width * bytesPerSample / 2
          );
          break;
        case 32:
          row = new Uint32Array(
            block,
            i3 * stride * width * bytesPerSample,
            stride * width * bytesPerSample / 4
          );
          break;
        default:
          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);
      }
      decodeRowAcc(row, stride, bytesPerSample);
    } else if (predictor === 3) {
      row = new Uint8Array(
        block,
        i3 * stride * width * bytesPerSample,
        stride * width * bytesPerSample
      );
      decodeRowFloatingPoint(row, stride, bytesPerSample);
    }
  }
  return block;
}
var init_predictor = __esm({
  "node_modules/geotiff/dist-module/predictor.js"() {
  }
});

// node_modules/geotiff/dist-module/compression/basedecoder.js
var BaseDecoder;
var init_basedecoder = __esm({
  "node_modules/geotiff/dist-module/compression/basedecoder.js"() {
    init_predictor();
    BaseDecoder = class {
      async decode(fileDirectory, buffer) {
        const decoded = await this.decodeBlock(buffer);
        const predictor = fileDirectory.Predictor || 1;
        if (predictor !== 1) {
          const isTiled = !fileDirectory.StripOffsets;
          const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;
          const tileHeight = isTiled ? fileDirectory.TileLength : fileDirectory.RowsPerStrip || fileDirectory.ImageLength;
          return applyPredictor(
            decoded,
            predictor,
            tileWidth,
            tileHeight,
            fileDirectory.BitsPerSample,
            fileDirectory.PlanarConfiguration
          );
        }
        return decoded;
      }
    };
  }
});

// node_modules/geotiff/dist-module/compression/raw.js
var raw_exports = {};
__export(raw_exports, {
  default: () => RawDecoder
});
var RawDecoder;
var init_raw = __esm({
  "node_modules/geotiff/dist-module/compression/raw.js"() {
    init_basedecoder();
    RawDecoder = class extends BaseDecoder {
      decodeBlock(buffer) {
        return buffer;
      }
    };
  }
});

// node_modules/geotiff/dist-module/compression/lzw.js
var lzw_exports = {};
__export(lzw_exports, {
  default: () => LZWDecoder
});
function getByte(array, position, length5) {
  const d2 = position % 8;
  const a2 = Math.floor(position / 8);
  const de2 = 8 - d2;
  const ef = position + length5 - (a2 + 1) * 8;
  let fg = 8 * (a2 + 2) - (position + length5);
  const dg = (a2 + 2) * 8 - position;
  fg = Math.max(0, fg);
  if (a2 >= array.length) {
    console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)");
    return EOI_CODE;
  }
  let chunk1 = array[a2] & 2 ** (8 - d2) - 1;
  chunk1 <<= length5 - de2;
  let chunks = chunk1;
  if (a2 + 1 < array.length) {
    let chunk2 = array[a2 + 1] >>> fg;
    chunk2 <<= Math.max(0, length5 - dg);
    chunks += chunk2;
  }
  if (ef > 8 && a2 + 2 < array.length) {
    const hi = (a2 + 3) * 8 - (position + length5);
    const chunk3 = array[a2 + 2] >>> hi;
    chunks += chunk3;
  }
  return chunks;
}
function appendReversed(dest, source3) {
  for (let i3 = source3.length - 1; i3 >= 0; i3--) {
    dest.push(source3[i3]);
  }
  return dest;
}
function decompress(input) {
  const dictionaryIndex = new Uint16Array(4093);
  const dictionaryChar = new Uint8Array(4093);
  for (let i3 = 0; i3 <= 257; i3++) {
    dictionaryIndex[i3] = 4096;
    dictionaryChar[i3] = i3;
  }
  let dictionaryLength = 258;
  let byteLength = MIN_BITS;
  let position = 0;
  function initDictionary() {
    dictionaryLength = 258;
    byteLength = MIN_BITS;
  }
  function getNext(array2) {
    const byte = getByte(array2, position, byteLength);
    position += byteLength;
    return byte;
  }
  function addToDictionary(i3, c2) {
    dictionaryChar[dictionaryLength] = c2;
    dictionaryIndex[dictionaryLength] = i3;
    dictionaryLength++;
    return dictionaryLength - 1;
  }
  function getDictionaryReversed(n2) {
    const rev = [];
    for (let i3 = n2; i3 !== 4096; i3 = dictionaryIndex[i3]) {
      rev.push(dictionaryChar[i3]);
    }
    return rev;
  }
  const result = [];
  initDictionary();
  const array = new Uint8Array(input);
  let code = getNext(array);
  let oldCode;
  while (code !== EOI_CODE) {
    if (code === CLEAR_CODE) {
      initDictionary();
      code = getNext(array);
      while (code === CLEAR_CODE) {
        code = getNext(array);
      }
      if (code === EOI_CODE) {
        break;
      } else if (code > CLEAR_CODE) {
        throw new Error(`corrupted code at scanline ${code}`);
      } else {
        const val = getDictionaryReversed(code);
        appendReversed(result, val);
        oldCode = code;
      }
    } else if (code < dictionaryLength) {
      const val = getDictionaryReversed(code);
      appendReversed(result, val);
      addToDictionary(oldCode, val[val.length - 1]);
      oldCode = code;
    } else {
      const oldVal = getDictionaryReversed(oldCode);
      if (!oldVal) {
        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);
      }
      appendReversed(result, oldVal);
      result.push(oldVal[oldVal.length - 1]);
      addToDictionary(oldCode, oldVal[oldVal.length - 1]);
      oldCode = code;
    }
    if (dictionaryLength + 1 >= 2 ** byteLength) {
      if (byteLength === MAX_BYTELENGTH) {
        oldCode = void 0;
      } else {
        byteLength++;
      }
    }
    code = getNext(array);
  }
  return new Uint8Array(result);
}
var MIN_BITS, CLEAR_CODE, EOI_CODE, MAX_BYTELENGTH, LZWDecoder;
var init_lzw = __esm({
  "node_modules/geotiff/dist-module/compression/lzw.js"() {
    init_basedecoder();
    MIN_BITS = 9;
    CLEAR_CODE = 256;
    EOI_CODE = 257;
    MAX_BYTELENGTH = 12;
    LZWDecoder = class extends BaseDecoder {
      decodeBlock(buffer) {
        return decompress(buffer, false).buffer;
      }
    };
  }
});

// node_modules/geotiff/dist-module/compression/jpeg.js
var jpeg_exports = {};
__export(jpeg_exports, {
  default: () => JpegDecoder
});
function buildHuffmanTable(codeLengths, values) {
  let k2 = 0;
  const code = [];
  let length5 = 16;
  while (length5 > 0 && !codeLengths[length5 - 1]) {
    --length5;
  }
  code.push({ children: [], index: 0 });
  let p2 = code[0];
  let q2;
  for (let i3 = 0; i3 < length5; i3++) {
    for (let j2 = 0; j2 < codeLengths[i3]; j2++) {
      p2 = code.pop();
      p2.children[p2.index] = values[k2];
      while (p2.index > 0) {
        p2 = code.pop();
      }
      p2.index++;
      code.push(p2);
      while (code.length <= i3) {
        code.push(q2 = { children: [], index: 0 });
        p2.children[p2.index] = q2.children;
        p2 = q2;
      }
      k2++;
    }
    if (i3 + 1 < length5) {
      code.push(q2 = { children: [], index: 0 });
      p2.children[p2.index] = q2.children;
      p2 = q2;
    }
  }
  return code[0].children;
}
function decodeScan(data, initialOffset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
  const { mcusPerLine, progressive } = frame;
  const startOffset = initialOffset;
  let offset = initialOffset;
  let bitsData = 0;
  let bitsCount = 0;
  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return bitsData >> bitsCount & 1;
    }
    bitsData = data[offset++];
    if (bitsData === 255) {
      const nextByte = data[offset++];
      if (nextByte) {
        throw new Error(`unexpected marker: ${(bitsData << 8 | nextByte).toString(16)}`);
      }
    }
    bitsCount = 7;
    return bitsData >>> 7;
  }
  function decodeHuffman(tree) {
    let node = tree;
    let bit;
    while ((bit = readBit()) !== null) {
      node = node[bit];
      if (typeof node === "number") {
        return node;
      }
      if (typeof node !== "object") {
        throw new Error("invalid huffman sequence");
      }
    }
    return null;
  }
  function receive(initialLength) {
    let length5 = initialLength;
    let n3 = 0;
    while (length5 > 0) {
      const bit = readBit();
      if (bit === null) {
        return void 0;
      }
      n3 = n3 << 1 | bit;
      --length5;
    }
    return n3;
  }
  function receiveAndExtend(length5) {
    const n3 = receive(length5);
    if (n3 >= 1 << length5 - 1) {
      return n3;
    }
    return n3 + (-1 << length5) + 1;
  }
  function decodeBaseline(component2, zz) {
    const t2 = decodeHuffman(component2.huffmanTableDC);
    const diff = t2 === 0 ? 0 : receiveAndExtend(t2);
    component2.pred += diff;
    zz[0] = component2.pred;
    let k3 = 1;
    while (k3 < 64) {
      const rs = decodeHuffman(component2.huffmanTableAC);
      const s2 = rs & 15;
      const r2 = rs >> 4;
      if (s2 === 0) {
        if (r2 < 15) {
          break;
        }
        k3 += 16;
      } else {
        k3 += r2;
        const z2 = dctZigZag[k3];
        zz[z2] = receiveAndExtend(s2);
        k3++;
      }
    }
  }
  function decodeDCFirst(component2, zz) {
    const t2 = decodeHuffman(component2.huffmanTableDC);
    const diff = t2 === 0 ? 0 : receiveAndExtend(t2) << successive;
    component2.pred += diff;
    zz[0] = component2.pred;
  }
  function decodeDCSuccessive(component2, zz) {
    zz[0] |= readBit() << successive;
  }
  let eobrun = 0;
  function decodeACFirst(component2, zz) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }
    let k3 = spectralStart;
    const e2 = spectralEnd;
    while (k3 <= e2) {
      const rs = decodeHuffman(component2.huffmanTableAC);
      const s2 = rs & 15;
      const r2 = rs >> 4;
      if (s2 === 0) {
        if (r2 < 15) {
          eobrun = receive(r2) + (1 << r2) - 1;
          break;
        }
        k3 += 16;
      } else {
        k3 += r2;
        const z2 = dctZigZag[k3];
        zz[z2] = receiveAndExtend(s2) * (1 << successive);
        k3++;
      }
    }
  }
  let successiveACState = 0;
  let successiveACNextValue;
  function decodeACSuccessive(component2, zz) {
    let k3 = spectralStart;
    const e2 = spectralEnd;
    let r2 = 0;
    while (k3 <= e2) {
      const z2 = dctZigZag[k3];
      const direction = zz[z2] < 0 ? -1 : 1;
      switch (successiveACState) {
        case 0: {
          const rs = decodeHuffman(component2.huffmanTableAC);
          const s2 = rs & 15;
          r2 = rs >> 4;
          if (s2 === 0) {
            if (r2 < 15) {
              eobrun = receive(r2) + (1 << r2);
              successiveACState = 4;
            } else {
              r2 = 16;
              successiveACState = 1;
            }
          } else {
            if (s2 !== 1) {
              throw new Error("invalid ACn encoding");
            }
            successiveACNextValue = receiveAndExtend(s2);
            successiveACState = r2 ? 2 : 3;
          }
          continue;
        }
        case 1:
        case 2:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction;
          } else {
            r2--;
            if (r2 === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }
          break;
        case 3:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction;
          } else {
            zz[z2] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction;
          }
          break;
        default:
          break;
      }
      k3++;
    }
    if (successiveACState === 4) {
      eobrun--;
      if (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }
  function decodeMcu(component2, decodeFunction, mcu2, row, col) {
    const mcuRow = mcu2 / mcusPerLine | 0;
    const mcuCol = mcu2 % mcusPerLine;
    const blockRow = mcuRow * component2.v + row;
    const blockCol = mcuCol * component2.h + col;
    decodeFunction(component2, component2.blocks[blockRow][blockCol]);
  }
  function decodeBlock(component2, decodeFunction, mcu2) {
    const blockRow = mcu2 / component2.blocksPerLine | 0;
    const blockCol = mcu2 % component2.blocksPerLine;
    decodeFunction(component2, component2.blocks[blockRow][blockCol]);
  }
  const componentsLength = components.length;
  let component;
  let i3;
  let j2;
  let k2;
  let n2;
  let decodeFn;
  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }
  let mcu = 0;
  let marker;
  let mcuExpected;
  if (componentsLength === 1) {
    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
  } else {
    mcuExpected = mcusPerLine * frame.mcusPerColumn;
  }
  const usedResetInterval = resetInterval || mcuExpected;
  while (mcu < mcuExpected) {
    for (i3 = 0; i3 < componentsLength; i3++) {
      components[i3].pred = 0;
    }
    eobrun = 0;
    if (componentsLength === 1) {
      component = components[0];
      for (n2 = 0; n2 < usedResetInterval; n2++) {
        decodeBlock(component, decodeFn, mcu);
        mcu++;
      }
    } else {
      for (n2 = 0; n2 < usedResetInterval; n2++) {
        for (i3 = 0; i3 < componentsLength; i3++) {
          component = components[i3];
          const { h: h2, v: v2 } = component;
          for (j2 = 0; j2 < v2; j2++) {
            for (k2 = 0; k2 < h2; k2++) {
              decodeMcu(component, decodeFn, mcu, j2, k2);
            }
          }
        }
        mcu++;
        if (mcu === mcuExpected) {
          break;
        }
      }
    }
    bitsCount = 0;
    marker = data[offset] << 8 | data[offset + 1];
    if (marker < 65280) {
      throw new Error("marker was not found");
    }
    if (marker >= 65488 && marker <= 65495) {
      offset += 2;
    } else {
      break;
    }
  }
  return offset - startOffset;
}
function buildComponentData(frame, component) {
  const lines = [];
  const { blocksPerLine, blocksPerColumn } = component;
  const samplesPerLine = blocksPerLine << 3;
  const R2 = new Int32Array(64);
  const r2 = new Uint8Array(64);
  function quantizeAndInverse(zz, dataOut, dataIn) {
    const qt = component.quantizationTable;
    let v0;
    let v1;
    let v2;
    let v3;
    let v4;
    let v5;
    let v6;
    let v7;
    let t2;
    const p2 = dataIn;
    let i3;
    for (i3 = 0; i3 < 64; i3++) {
      p2[i3] = zz[i3] * qt[i3];
    }
    for (i3 = 0; i3 < 8; ++i3) {
      const row = 8 * i3;
      if (p2[1 + row] === 0 && p2[2 + row] === 0 && p2[3 + row] === 0 && p2[4 + row] === 0 && p2[5 + row] === 0 && p2[6 + row] === 0 && p2[7 + row] === 0) {
        t2 = dctSqrt2 * p2[0 + row] + 512 >> 10;
        p2[0 + row] = t2;
        p2[1 + row] = t2;
        p2[2 + row] = t2;
        p2[3 + row] = t2;
        p2[4 + row] = t2;
        p2[5 + row] = t2;
        p2[6 + row] = t2;
        p2[7 + row] = t2;
        continue;
      }
      v0 = dctSqrt2 * p2[0 + row] + 128 >> 8;
      v1 = dctSqrt2 * p2[4 + row] + 128 >> 8;
      v2 = p2[2 + row];
      v3 = p2[6 + row];
      v4 = dctSqrt1d2 * (p2[1 + row] - p2[7 + row]) + 128 >> 8;
      v7 = dctSqrt1d2 * (p2[1 + row] + p2[7 + row]) + 128 >> 8;
      v5 = p2[3 + row] << 4;
      v6 = p2[5 + row] << 4;
      t2 = v0 - v1 + 1 >> 1;
      v0 = v0 + v1 + 1 >> 1;
      v1 = t2;
      t2 = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
      v3 = t2;
      t2 = v4 - v6 + 1 >> 1;
      v4 = v4 + v6 + 1 >> 1;
      v6 = t2;
      t2 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5 + 1 >> 1;
      v7 = t2;
      t2 = v0 - v3 + 1 >> 1;
      v0 = v0 + v3 + 1 >> 1;
      v3 = t2;
      t2 = v1 - v2 + 1 >> 1;
      v1 = v1 + v2 + 1 >> 1;
      v2 = t2;
      t2 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t2;
      t2 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t2;
      p2[0 + row] = v0 + v7;
      p2[7 + row] = v0 - v7;
      p2[1 + row] = v1 + v6;
      p2[6 + row] = v1 - v6;
      p2[2 + row] = v2 + v5;
      p2[5 + row] = v2 - v5;
      p2[3 + row] = v3 + v4;
      p2[4 + row] = v3 - v4;
    }
    for (i3 = 0; i3 < 8; ++i3) {
      const col = i3;
      if (p2[1 * 8 + col] === 0 && p2[2 * 8 + col] === 0 && p2[3 * 8 + col] === 0 && p2[4 * 8 + col] === 0 && p2[5 * 8 + col] === 0 && p2[6 * 8 + col] === 0 && p2[7 * 8 + col] === 0) {
        t2 = dctSqrt2 * dataIn[i3 + 0] + 8192 >> 14;
        p2[0 * 8 + col] = t2;
        p2[1 * 8 + col] = t2;
        p2[2 * 8 + col] = t2;
        p2[3 * 8 + col] = t2;
        p2[4 * 8 + col] = t2;
        p2[5 * 8 + col] = t2;
        p2[6 * 8 + col] = t2;
        p2[7 * 8 + col] = t2;
        continue;
      }
      v0 = dctSqrt2 * p2[0 * 8 + col] + 2048 >> 12;
      v1 = dctSqrt2 * p2[4 * 8 + col] + 2048 >> 12;
      v2 = p2[2 * 8 + col];
      v3 = p2[6 * 8 + col];
      v4 = dctSqrt1d2 * (p2[1 * 8 + col] - p2[7 * 8 + col]) + 2048 >> 12;
      v7 = dctSqrt1d2 * (p2[1 * 8 + col] + p2[7 * 8 + col]) + 2048 >> 12;
      v5 = p2[3 * 8 + col];
      v6 = p2[5 * 8 + col];
      t2 = v0 - v1 + 1 >> 1;
      v0 = v0 + v1 + 1 >> 1;
      v1 = t2;
      t2 = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
      v3 = t2;
      t2 = v4 - v6 + 1 >> 1;
      v4 = v4 + v6 + 1 >> 1;
      v6 = t2;
      t2 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5 + 1 >> 1;
      v7 = t2;
      t2 = v0 - v3 + 1 >> 1;
      v0 = v0 + v3 + 1 >> 1;
      v3 = t2;
      t2 = v1 - v2 + 1 >> 1;
      v1 = v1 + v2 + 1 >> 1;
      v2 = t2;
      t2 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t2;
      t2 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t2;
      p2[0 * 8 + col] = v0 + v7;
      p2[7 * 8 + col] = v0 - v7;
      p2[1 * 8 + col] = v1 + v6;
      p2[6 * 8 + col] = v1 - v6;
      p2[2 * 8 + col] = v2 + v5;
      p2[5 * 8 + col] = v2 - v5;
      p2[3 * 8 + col] = v3 + v4;
      p2[4 * 8 + col] = v3 - v4;
    }
    for (i3 = 0; i3 < 64; ++i3) {
      const sample = 128 + (p2[i3] + 8 >> 4);
      if (sample < 0) {
        dataOut[i3] = 0;
      } else if (sample > 255) {
        dataOut[i3] = 255;
      } else {
        dataOut[i3] = sample;
      }
    }
  }
  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    const scanLine = blockRow << 3;
    for (let i3 = 0; i3 < 8; i3++) {
      lines.push(new Uint8Array(samplesPerLine));
    }
    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      quantizeAndInverse(component.blocks[blockRow][blockCol], r2, R2);
      let offset = 0;
      const sample = blockCol << 3;
      for (let j2 = 0; j2 < 8; j2++) {
        const line = lines[scanLine + j2];
        for (let i3 = 0; i3 < 8; i3++) {
          line[sample + i3] = r2[offset++];
        }
      }
    }
  }
  return lines;
}
var dctZigZag, dctCos1, dctSin1, dctCos3, dctSin3, dctCos6, dctSin6, dctSqrt2, dctSqrt1d2, JpegStreamReader, JpegDecoder;
var init_jpeg = __esm({
  "node_modules/geotiff/dist-module/compression/jpeg.js"() {
    init_basedecoder();
    dctZigZag = new Int32Array([
      0,
      1,
      8,
      16,
      9,
      2,
      3,
      10,
      17,
      24,
      32,
      25,
      18,
      11,
      4,
      5,
      12,
      19,
      26,
      33,
      40,
      48,
      41,
      34,
      27,
      20,
      13,
      6,
      7,
      14,
      21,
      28,
      35,
      42,
      49,
      56,
      57,
      50,
      43,
      36,
      29,
      22,
      15,
      23,
      30,
      37,
      44,
      51,
      58,
      59,
      52,
      45,
      38,
      31,
      39,
      46,
      53,
      60,
      61,
      54,
      47,
      55,
      62,
      63
    ]);
    dctCos1 = 4017;
    dctSin1 = 799;
    dctCos3 = 3406;
    dctSin3 = 2276;
    dctCos6 = 1567;
    dctSin6 = 3784;
    dctSqrt2 = 5793;
    dctSqrt1d2 = 2896;
    JpegStreamReader = class {
      constructor() {
        this.jfif = null;
        this.adobe = null;
        this.quantizationTables = [];
        this.huffmanTablesAC = [];
        this.huffmanTablesDC = [];
        this.resetFrames();
      }
      resetFrames() {
        this.frames = [];
      }
      parse(data) {
        let offset = 0;
        function readUint16() {
          const value = data[offset] << 8 | data[offset + 1];
          offset += 2;
          return value;
        }
        function readDataBlock() {
          const length5 = readUint16();
          const array = data.subarray(offset, offset + length5 - 2);
          offset += array.length;
          return array;
        }
        function prepareComponents(frame) {
          let maxH = 0;
          let maxV = 0;
          let component;
          let componentId;
          for (componentId in frame.components) {
            if (frame.components.hasOwnProperty(componentId)) {
              component = frame.components[componentId];
              if (maxH < component.h) {
                maxH = component.h;
              }
              if (maxV < component.v) {
                maxV = component.v;
              }
            }
          }
          const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
          const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
          for (componentId in frame.components) {
            if (frame.components.hasOwnProperty(componentId)) {
              component = frame.components[componentId];
              const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
              const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);
              const blocksPerLineForMcu = mcusPerLine * component.h;
              const blocksPerColumnForMcu = mcusPerColumn * component.v;
              const blocks = [];
              for (let i3 = 0; i3 < blocksPerColumnForMcu; i3++) {
                const row = [];
                for (let j2 = 0; j2 < blocksPerLineForMcu; j2++) {
                  row.push(new Int32Array(64));
                }
                blocks.push(row);
              }
              component.blocksPerLine = blocksPerLine;
              component.blocksPerColumn = blocksPerColumn;
              component.blocks = blocks;
            }
          }
          frame.maxH = maxH;
          frame.maxV = maxV;
          frame.mcusPerLine = mcusPerLine;
          frame.mcusPerColumn = mcusPerColumn;
        }
        let fileMarker = readUint16();
        if (fileMarker !== 65496) {
          throw new Error("SOI not found");
        }
        fileMarker = readUint16();
        while (fileMarker !== 65497) {
          switch (fileMarker) {
            case 65280:
              break;
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534: {
              const appData = readDataBlock();
              if (fileMarker === 65504) {
                if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                  this.jfif = {
                    version: { major: appData[5], minor: appData[6] },
                    densityUnits: appData[7],
                    xDensity: appData[8] << 8 | appData[9],
                    yDensity: appData[10] << 8 | appData[11],
                    thumbWidth: appData[12],
                    thumbHeight: appData[13],
                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                  };
                }
              }
              if (fileMarker === 65518) {
                if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                  this.adobe = {
                    version: appData[6],
                    flags0: appData[7] << 8 | appData[8],
                    flags1: appData[9] << 8 | appData[10],
                    transformCode: appData[11]
                  };
                }
              }
              break;
            }
            case 65499: {
              const quantizationTablesLength = readUint16();
              const quantizationTablesEnd = quantizationTablesLength + offset - 2;
              while (offset < quantizationTablesEnd) {
                const quantizationTableSpec = data[offset++];
                const tableData = new Int32Array(64);
                if (quantizationTableSpec >> 4 === 0) {
                  for (let j2 = 0; j2 < 64; j2++) {
                    const z2 = dctZigZag[j2];
                    tableData[z2] = data[offset++];
                  }
                } else if (quantizationTableSpec >> 4 === 1) {
                  for (let j2 = 0; j2 < 64; j2++) {
                    const z2 = dctZigZag[j2];
                    tableData[z2] = readUint16();
                  }
                } else {
                  throw new Error("DQT: invalid table spec");
                }
                this.quantizationTables[quantizationTableSpec & 15] = tableData;
              }
              break;
            }
            case 65472:
            case 65473:
            case 65474: {
              readUint16();
              const frame = {
                extended: fileMarker === 65473,
                progressive: fileMarker === 65474,
                precision: data[offset++],
                scanLines: readUint16(),
                samplesPerLine: readUint16(),
                components: {},
                componentsOrder: []
              };
              const componentsCount = data[offset++];
              let componentId;
              for (let i3 = 0; i3 < componentsCount; i3++) {
                componentId = data[offset];
                const h2 = data[offset + 1] >> 4;
                const v2 = data[offset + 1] & 15;
                const qId = data[offset + 2];
                frame.componentsOrder.push(componentId);
                frame.components[componentId] = {
                  h: h2,
                  v: v2,
                  quantizationIdx: qId
                };
                offset += 3;
              }
              prepareComponents(frame);
              this.frames.push(frame);
              break;
            }
            case 65476: {
              const huffmanLength = readUint16();
              for (let i3 = 2; i3 < huffmanLength; ) {
                const huffmanTableSpec = data[offset++];
                const codeLengths = new Uint8Array(16);
                let codeLengthSum = 0;
                for (let j2 = 0; j2 < 16; j2++, offset++) {
                  codeLengths[j2] = data[offset];
                  codeLengthSum += codeLengths[j2];
                }
                const huffmanValues = new Uint8Array(codeLengthSum);
                for (let j2 = 0; j2 < codeLengthSum; j2++, offset++) {
                  huffmanValues[j2] = data[offset];
                }
                i3 += 17 + codeLengthSum;
                if (huffmanTableSpec >> 4 === 0) {
                  this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(
                    codeLengths,
                    huffmanValues
                  );
                } else {
                  this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(
                    codeLengths,
                    huffmanValues
                  );
                }
              }
              break;
            }
            case 65501:
              readUint16();
              this.resetInterval = readUint16();
              break;
            case 65498: {
              readUint16();
              const selectorsCount = data[offset++];
              const components = [];
              const frame = this.frames[0];
              for (let i3 = 0; i3 < selectorsCount; i3++) {
                const component = frame.components[data[offset++]];
                const tableSpec = data[offset++];
                component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];
                component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];
                components.push(component);
              }
              const spectralStart = data[offset++];
              const spectralEnd = data[offset++];
              const successiveApproximation = data[offset++];
              const processed = decodeScan(
                data,
                offset,
                frame,
                components,
                this.resetInterval,
                spectralStart,
                spectralEnd,
                successiveApproximation >> 4,
                successiveApproximation & 15
              );
              offset += processed;
              break;
            }
            case 65535:
              if (data[offset] !== 255) {
                offset--;
              }
              break;
            default:
              if (data[offset - 3] === 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                offset -= 3;
                break;
              }
              throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);
          }
          fileMarker = readUint16();
        }
      }
      getResult() {
        const { frames } = this;
        if (this.frames.length === 0) {
          throw new Error("no frames were decoded");
        } else if (this.frames.length > 1) {
          console.warn("more than one frame is not supported");
        }
        for (let i3 = 0; i3 < this.frames.length; i3++) {
          const cp = this.frames[i3].components;
          for (const j2 of Object.keys(cp)) {
            cp[j2].quantizationTable = this.quantizationTables[cp[j2].quantizationIdx];
            delete cp[j2].quantizationIdx;
          }
        }
        const frame = frames[0];
        const { components, componentsOrder } = frame;
        const outComponents = [];
        const width = frame.samplesPerLine;
        const height = frame.scanLines;
        for (let i3 = 0; i3 < componentsOrder.length; i3++) {
          const component = components[componentsOrder[i3]];
          outComponents.push({
            lines: buildComponentData(frame, component),
            scaleX: component.h / frame.maxH,
            scaleY: component.v / frame.maxV
          });
        }
        const out = new Uint8Array(width * height * outComponents.length);
        let oi = 0;
        for (let y2 = 0; y2 < height; ++y2) {
          for (let x2 = 0; x2 < width; ++x2) {
            for (let i3 = 0; i3 < outComponents.length; ++i3) {
              const component = outComponents[i3];
              out[oi] = component.lines[0 | y2 * component.scaleY][0 | x2 * component.scaleX];
              ++oi;
            }
          }
        }
        return out;
      }
    };
    JpegDecoder = class extends BaseDecoder {
      constructor(fileDirectory) {
        super();
        this.reader = new JpegStreamReader();
        if (fileDirectory.JPEGTables) {
          this.reader.parse(fileDirectory.JPEGTables);
        }
      }
      decodeBlock(buffer) {
        this.reader.resetFrames();
        this.reader.parse(new Uint8Array(buffer));
        return this.reader.getResult().buffer;
      }
    };
  }
});

// node_modules/geotiff/node_modules/pako/dist/pako.esm.mjs
function zero$1(buf) {
  let len4 = buf.length;
  while (--len4 >= 0) {
    buf[len4] = 0;
  }
}
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Z_FIXED$1, Z_BINARY, Z_TEXT, Z_UNKNOWN$1, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH$1, MAX_MATCH$1, LENGTH_CODES$1, LITERALS$1, L_CODES$1, D_CODES$1, BL_CODES$1, HEAP_SIZE$1, MAX_BITS$1, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, d_code, put_short, send_bits, send_code, bi_reverse, bi_flush, gen_bitlen, gen_codes, tr_static_init, init_block, bi_windup, smaller, pqdownheap, compress_block, build_tree, scan_tree, send_tree, build_bl_tree, send_all_trees, detect_data_type, static_init_done, _tr_init$1, _tr_stored_block$1, _tr_align$1, _tr_flush_block$1, _tr_tally$1, _tr_init_1, _tr_stored_block_1, _tr_flush_block_1, _tr_tally_1, _tr_align_1, trees, adler32, adler32_1, makeTable, crcTable, crc32, crc32_1, messages, constants$2, _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align, Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH$1, Z_FINISH$3, Z_BLOCK$1, Z_OK$3, Z_STREAM_END$3, Z_STREAM_ERROR$2, Z_DATA_ERROR$2, Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED$2, MAX_MEM_LEVEL, MAX_WBITS$1, DEF_MEM_LEVEL, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, MIN_MATCH, MAX_MATCH, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, GZIP_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, err, rank, zero, slide_hash, HASH_ZLIB, HASH, flush_pending, flush_block_only, put_byte, putShortMSB, read_buf, longest_match, fill_window, deflate_stored, deflate_fast, deflate_slow, deflate_rle, deflate_huff, configuration_table, lm_init, deflateStateCheck, deflateResetKeep, deflateReset, deflateSetHeader, deflateInit2, deflateInit, deflate$2, deflateEnd, deflateSetDictionary, deflateInit_1, deflateInit2_1, deflateReset_1, deflateResetKeep_1, deflateSetHeader_1, deflate_2$1, deflateEnd_1, deflateSetDictionary_1, deflateInfo, deflate_1$2, _has, assign, flattenChunks, common, STR_APPLY_UIA_OK, _utf8len, string2buf, buf2binstring, buf2string, utf8border, strings, zstream, toString$1, Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH$2, Z_OK$2, Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED$1, Deflate_1$1, deflate_2, deflateRaw_1$1, gzip_1$1, constants$1, deflate_1$1, BAD$1, TYPE$1, inffast, MAXBITS, ENOUGH_LENS$1, ENOUGH_DISTS$1, CODES$1, LENS$1, DISTS$1, lbase, lext, dbase, dext, inflate_table, inftrees, CODES, LENS, DISTS, Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK$1, Z_STREAM_END$1, Z_NEED_DICT$1, Z_STREAM_ERROR$1, Z_DATA_ERROR$1, Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED, HEAD, FLAGS, TIME, OS, EXLEN, EXTRA, NAME, COMMENT, HCRC, DICTID, DICT, TYPE, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD, MEM, SYNC, ENOUGH_LENS, ENOUGH_DISTS, MAX_WBITS, DEF_WBITS, zswap32, inflateStateCheck, inflateResetKeep, inflateReset, inflateReset2, inflateInit2, inflateInit, virgin, lenfix, distfix, fixedtables, updatewindow, inflate$2, inflateEnd, inflateGetHeader, inflateSetDictionary, inflateReset_1, inflateReset2_1, inflateResetKeep_1, inflateInit_1, inflateInit2_1, inflate_2$1, inflateEnd_1, inflateGetHeader_1, inflateSetDictionary_1, inflateInfo, inflate_1$2, gzheader, toString, Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Inflate_1$1, inflate_2, inflateRaw_1$1, ungzip$1, constants, inflate_1$1, Deflate, deflate, deflateRaw, gzip, Inflate, inflate, inflateRaw, ungzip, inflate_1;
var init_pako_esm = __esm({
  "node_modules/geotiff/node_modules/pako/dist/pako.esm.mjs"() {
    Z_FIXED$1 = 4;
    Z_BINARY = 0;
    Z_TEXT = 1;
    Z_UNKNOWN$1 = 2;
    STORED_BLOCK = 0;
    STATIC_TREES = 1;
    DYN_TREES = 2;
    MIN_MATCH$1 = 3;
    MAX_MATCH$1 = 258;
    LENGTH_CODES$1 = 29;
    LITERALS$1 = 256;
    L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    D_CODES$1 = 30;
    BL_CODES$1 = 19;
    HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    MAX_BITS$1 = 15;
    Buf_size = 16;
    MAX_BL_BITS = 7;
    END_BLOCK = 256;
    REP_3_6 = 16;
    REPZ_3_10 = 17;
    REPZ_11_138 = 18;
    extra_lbits = /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    extra_dbits = /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    extra_blbits = /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    DIST_CODE_LEN = 512;
    static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    d_code = (dist4) => {
      return dist4 < 256 ? _dist_code[dist4] : _dist_code[256 + (dist4 >>> 7)];
    };
    put_short = (s2, w3) => {
      s2.pending_buf[s2.pending++] = w3 & 255;
      s2.pending_buf[s2.pending++] = w3 >>> 8 & 255;
    };
    send_bits = (s2, value, length5) => {
      if (s2.bi_valid > Buf_size - length5) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length5 - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length5;
      }
    };
    send_code = (s2, c2, tree) => {
      send_bits(
        s2,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    };
    bi_reverse = (code, len4) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len4 > 0);
      return res >>> 1;
    };
    bi_flush = (s2) => {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    };
    gen_bitlen = (s2, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h2;
      let n2, m2;
      let bits;
      let xbits;
      let f2;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
        n2 = s2.heap[h2];
        bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n2 * 2 + 1] = bits;
        if (n2 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n2 >= base) {
          xbits = extra[n2 - base];
        }
        f2 = tree[n2 * 2];
        s2.opt_len += f2 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n2 = s2.bl_count[bits];
        while (n2 !== 0) {
          m2 = s2.heap[--h2];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n2--;
        }
      }
    };
    gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS$1 + 1);
      let code = 0;
      let bits;
      let n2;
      for (bits = 1; bits <= MAX_BITS$1; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        let len4 = tree[n2 * 2 + 1];
        if (len4 === 0) {
          continue;
        }
        tree[n2 * 2] = bi_reverse(next_code[len4]++, len4);
      }
    };
    tr_static_init = () => {
      let n2;
      let bits;
      let length5;
      let code;
      let dist4;
      const bl_count = new Array(MAX_BITS$1 + 1);
      length5 = 0;
      for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
        base_length[code] = length5;
        for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
          _length_code[length5++] = code;
        }
      }
      _length_code[length5 - 1] = code;
      dist4 = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist4;
        for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
          _dist_code[dist4++] = code;
        }
      }
      dist4 >>= 7;
      for (; code < D_CODES$1; code++) {
        base_dist[code] = dist4 << 7;
        for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
          _dist_code[256 + dist4++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        bl_count[bits] = 0;
      }
      n2 = 0;
      while (n2 <= 143) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      while (n2 <= 255) {
        static_ltree[n2 * 2 + 1] = 9;
        n2++;
        bl_count[9]++;
      }
      while (n2 <= 279) {
        static_ltree[n2 * 2 + 1] = 7;
        n2++;
        bl_count[7]++;
      }
      while (n2 <= 287) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
      for (n2 = 0; n2 < D_CODES$1; n2++) {
        static_dtree[n2 * 2 + 1] = 5;
        static_dtree[n2 * 2] = bi_reverse(n2, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    init_block = (s2) => {
      let n2;
      for (n2 = 0; n2 < L_CODES$1; n2++) {
        s2.dyn_ltree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < D_CODES$1; n2++) {
        s2.dyn_dtree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < BL_CODES$1; n2++) {
        s2.bl_tree[n2 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.sym_next = s2.matches = 0;
    };
    bi_windup = (s2) => {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    };
    smaller = (tree, n2, m2, depth) => {
      const _n2 = n2 * 2;
      const _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
    };
    pqdownheap = (s2, tree, k2) => {
      const v2 = s2.heap[k2];
      let j2 = k2 << 1;
      while (j2 <= s2.heap_len) {
        if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
          j2++;
        }
        if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
          break;
        }
        s2.heap[k2] = s2.heap[j2];
        k2 = j2;
        j2 <<= 1;
      }
      s2.heap[k2] = v2;
    };
    compress_block = (s2, ltree, dtree) => {
      let dist4;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s2.sym_next !== 0) {
        do {
          dist4 = s2.pending_buf[s2.sym_buf + sx++] & 255;
          dist4 += (s2.pending_buf[s2.sym_buf + sx++] & 255) << 8;
          lc = s2.pending_buf[s2.sym_buf + sx++];
          if (dist4 === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS$1 + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist4--;
            code = d_code(dist4);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist4 -= base_dist[code];
              send_bits(s2, dist4, extra);
            }
          }
        } while (sx < s2.sym_next);
      }
      send_code(s2, END_BLOCK, ltree);
    };
    build_tree = (s2, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n2, m2;
      let max_code = -1;
      let node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE$1;
      for (n2 = 0; n2 < elems; n2++) {
        if (tree[n2 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n2;
          s2.depth[n2] = 0;
        } else {
          tree[n2 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
        pqdownheap(s2, tree, n2);
      }
      node = elems;
      do {
        n2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n2;
        s2.heap[--s2.heap_max] = m2;
        tree[node * 2] = tree[n2 * 2] + tree[m2 * 2];
        s2.depth[node] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
        tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    };
    scan_tree = (s2, tree, max_code) => {
      let n2;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          s2.bl_tree[curlen * 2] += count2;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count2 <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    send_tree = (s2, tree, max_code) => {
      let n2;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count2 !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count2--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count2 - 3, 2);
        } else if (count2 <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count2 - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count2 - 11, 7);
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    build_bl_tree = (s2) => {
      let max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    send_all_trees = (s2, lcodes, dcodes, blcodes) => {
      let rank2;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    };
    detect_data_type = (s2) => {
      let block_mask = 4093624447;
      let n2;
      for (n2 = 0; n2 <= 31; n2++, block_mask >>>= 1) {
        if (block_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n2 = 32; n2 < LITERALS$1; n2++) {
        if (s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    static_init_done = false;
    _tr_init$1 = (s2) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    };
    _tr_stored_block$1 = (s2, buf, stored_len, last) => {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s2);
      put_short(s2, stored_len);
      put_short(s2, ~stored_len);
      if (stored_len) {
        s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
      }
      s2.pending += stored_len;
    };
    _tr_align$1 = (s2) => {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    };
    _tr_flush_block$1 = (s2, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN$1) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    };
    _tr_tally$1 = (s2, dist4, lc) => {
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist4;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist4 >> 8;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc;
      if (dist4 === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist4--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
        s2.dyn_dtree[d_code(dist4) * 2]++;
      }
      return s2.sym_next === s2.sym_end;
    };
    _tr_init_1 = _tr_init$1;
    _tr_stored_block_1 = _tr_stored_block$1;
    _tr_flush_block_1 = _tr_flush_block$1;
    _tr_tally_1 = _tr_tally$1;
    _tr_align_1 = _tr_align$1;
    trees = {
      _tr_init: _tr_init_1,
      _tr_stored_block: _tr_stored_block_1,
      _tr_flush_block: _tr_flush_block_1,
      _tr_tally: _tr_tally_1,
      _tr_align: _tr_align_1
    };
    adler32 = (adler, buf, len4, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
      while (len4 !== 0) {
        n2 = len4 > 2e3 ? 2e3 : len4;
        len4 -= n2;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n2);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    adler32_1 = adler32;
    makeTable = () => {
      let c2, table = [];
      for (var n2 = 0; n2 < 256; n2++) {
        c2 = n2;
        for (var k2 = 0; k2 < 8; k2++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n2] = c2;
      }
      return table;
    };
    crcTable = new Uint32Array(makeTable());
    crc32 = (crc, buf, len4, pos) => {
      const t2 = crcTable;
      const end = pos + len4;
      crc ^= -1;
      for (let i3 = pos; i3 < end; i3++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i3]) & 255];
      }
      return crc ^ -1;
    };
    crc32_1 = crc32;
    messages = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
    constants$2 = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
    ({ _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees);
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$2,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH: Z_FULL_FLUSH$1,
      Z_FINISH: Z_FINISH$3,
      Z_BLOCK: Z_BLOCK$1,
      Z_OK: Z_OK$3,
      Z_STREAM_END: Z_STREAM_END$3,
      Z_STREAM_ERROR: Z_STREAM_ERROR$2,
      Z_DATA_ERROR: Z_DATA_ERROR$2,
      Z_BUF_ERROR: Z_BUF_ERROR$1,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
      Z_UNKNOWN,
      Z_DEFLATED: Z_DEFLATED$2
    } = constants$2);
    MAX_MEM_LEVEL = 9;
    MAX_WBITS$1 = 15;
    DEF_MEM_LEVEL = 8;
    LENGTH_CODES = 29;
    LITERALS = 256;
    L_CODES = LITERALS + 1 + LENGTH_CODES;
    D_CODES = 30;
    BL_CODES = 19;
    HEAP_SIZE = 2 * L_CODES + 1;
    MAX_BITS = 15;
    MIN_MATCH = 3;
    MAX_MATCH = 258;
    MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    PRESET_DICT = 32;
    INIT_STATE = 42;
    GZIP_STATE = 57;
    EXTRA_STATE = 69;
    NAME_STATE = 73;
    COMMENT_STATE = 91;
    HCRC_STATE = 103;
    BUSY_STATE = 113;
    FINISH_STATE = 666;
    BS_NEED_MORE = 1;
    BS_BLOCK_DONE = 2;
    BS_FINISH_STARTED = 3;
    BS_FINISH_DONE = 4;
    OS_CODE = 3;
    err = (strm, errorCode) => {
      strm.msg = messages[errorCode];
      return errorCode;
    };
    rank = (f2) => {
      return f2 * 2 - (f2 > 4 ? 9 : 0);
    };
    zero = (buf) => {
      let len4 = buf.length;
      while (--len4 >= 0) {
        buf[len4] = 0;
      }
    };
    slide_hash = (s2) => {
      let n2, m2;
      let p2;
      let wsize = s2.w_size;
      n2 = s2.hash_size;
      p2 = n2;
      do {
        m2 = s2.head[--p2];
        s2.head[p2] = m2 >= wsize ? m2 - wsize : 0;
      } while (--n2);
      n2 = wsize;
      p2 = n2;
      do {
        m2 = s2.prev[--p2];
        s2.prev[p2] = m2 >= wsize ? m2 - wsize : 0;
      } while (--n2);
    };
    HASH_ZLIB = (s2, prev, data) => (prev << s2.hash_shift ^ data) & s2.hash_mask;
    HASH = HASH_ZLIB;
    flush_pending = (strm) => {
      const s2 = strm.state;
      let len4 = s2.pending;
      if (len4 > strm.avail_out) {
        len4 = strm.avail_out;
      }
      if (len4 === 0) {
        return;
      }
      strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len4), strm.next_out);
      strm.next_out += len4;
      s2.pending_out += len4;
      strm.total_out += len4;
      strm.avail_out -= len4;
      s2.pending -= len4;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    };
    flush_block_only = (s2, last) => {
      _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    };
    put_byte = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2;
    };
    putShortMSB = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b2 & 255;
    };
    read_buf = (strm, buf, start, size) => {
      let len4 = strm.avail_in;
      if (len4 > size) {
        len4 = size;
      }
      if (len4 === 0) {
        return 0;
      }
      strm.avail_in -= len4;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len4), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len4, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len4, start);
      }
      strm.next_in += len4;
      strm.total_in += len4;
      return len4;
    };
    longest_match = (s2, cur_match) => {
      let chain_length = s2.max_chain_length;
      let scan = s2.strstart;
      let match;
      let len4;
      let best_len = s2.prev_length;
      let nice_match = s2.nice_match;
      const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s2.window;
      const wmask = s2.w_mask;
      const prev = s2.prev;
      const strend = s2.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len4 = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len4 > best_len) {
          s2.match_start = cur_match;
          best_len = len4;
          if (len4 >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    };
    fill_window = (s2) => {
      const _w_size = s2.w_size;
      let n2, more, str5;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          if (s2.insert > s2.strstart) {
            s2.insert = s2.strstart;
          }
          slide_hash(s2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n2;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str5 = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str5];
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str5 + 1]);
          while (s2.insert) {
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[str5 + MIN_MATCH - 1]);
            s2.prev[str5 & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str5;
            str5++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    };
    deflate_stored = (s2, flush) => {
      let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
      let len4, left, have, last = 0;
      let used = s2.strm.avail_in;
      do {
        len4 = 65535;
        have = s2.bi_valid + 42 >> 3;
        if (s2.strm.avail_out < have) {
          break;
        }
        have = s2.strm.avail_out - have;
        left = s2.strstart - s2.block_start;
        if (len4 > left + s2.strm.avail_in) {
          len4 = left + s2.strm.avail_in;
        }
        if (len4 > have) {
          len4 = have;
        }
        if (len4 < min_block && (len4 === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len4 !== left + s2.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH$3 && len4 === left + s2.strm.avail_in ? 1 : 0;
        _tr_stored_block(s2, 0, 0, last);
        s2.pending_buf[s2.pending - 4] = len4;
        s2.pending_buf[s2.pending - 3] = len4 >> 8;
        s2.pending_buf[s2.pending - 2] = ~len4;
        s2.pending_buf[s2.pending - 1] = ~len4 >> 8;
        flush_pending(s2.strm);
        if (left) {
          if (left > len4) {
            left = len4;
          }
          s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
          s2.strm.next_out += left;
          s2.strm.avail_out -= left;
          s2.strm.total_out += left;
          s2.block_start += left;
          len4 -= left;
        }
        if (len4) {
          read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len4);
          s2.strm.next_out += len4;
          s2.strm.avail_out -= len4;
          s2.strm.total_out += len4;
        }
      } while (last === 0);
      used -= s2.strm.avail_in;
      if (used) {
        if (used >= s2.w_size) {
          s2.matches = 2;
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
          s2.strstart = s2.w_size;
          s2.insert = s2.strstart;
        } else {
          if (s2.window_size - s2.strstart <= used) {
            s2.strstart -= s2.w_size;
            s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
            if (s2.matches < 2) {
              s2.matches++;
            }
            if (s2.insert > s2.strstart) {
              s2.insert = s2.strstart;
            }
          }
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
          s2.strstart += used;
          s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
        }
        s2.block_start = s2.strstart;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s2.window_size - s2.strstart;
      if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
        s2.block_start -= s2.w_size;
        s2.strstart -= s2.w_size;
        s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
        if (s2.matches < 2) {
          s2.matches++;
        }
        have += s2.w_size;
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
      }
      if (have > s2.strm.avail_in) {
        have = s2.strm.avail_in;
      }
      if (have) {
        read_buf(s2.strm, s2.window, s2.strstart, have);
        s2.strstart += have;
        s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      have = s2.bi_valid + 42 >> 3;
      have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
      min_block = have > s2.w_size ? s2.w_size : have;
      left = s2.strstart - s2.block_start;
      if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s2.strm.avail_in === 0 && left <= have) {
        len4 = left > have ? have : left;
        last = flush === Z_FINISH$3 && s2.strm.avail_in === 0 && len4 === left ? 1 : 0;
        _tr_stored_block(s2, s2.block_start, len4, last);
        s2.block_start += len4;
        flush_pending(s2.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    deflate_fast = (s2, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_slow = (s2, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_rle = (s2, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_huff = (s2, flush) => {
      let bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    lm_init = (s2) => {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    };
    deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s2 = strm.state;
      if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && //#ifdef GZIP
      s2.status !== GZIP_STATE && //#endif
      s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = //#ifdef GZIP
      s2.wrap === 2 ? GZIP_STATE : (
        //#endif
        s2.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = -2;
      _tr_init(s2);
      return Z_OK$3;
    };
    deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK$3) {
        lm_init(strm.state);
      }
      return ret;
    };
    deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$2;
      }
      strm.state.gzhead = head;
      return Z_OK$3;
    };
    deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR$2;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.status = INIT_STATE;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new Uint8Array(s2.w_size * 2);
      s2.head = new Uint16Array(s2.hash_size);
      s2.prev = new Uint16Array(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new Uint8Array(s2.pending_buf_size);
      s2.sym_buf = s2.lit_bufsize;
      s2.sym_end = (s2.lit_bufsize - 1) * 3;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    };
    deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    };
    deflate$2 = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
      }
      const s2 = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
      }
      const old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s2.status === INIT_STATE && s2.wrap === 0) {
        s2.status = BUSY_STATE;
      }
      if (s2.status === INIT_STATE) {
        let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        strm.adler = 1;
        s2.status = BUSY_STATE;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
      if (s2.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s2, 31);
        put_byte(s2, 139);
        put_byte(s2, 8);
        if (!s2.gzhead) {
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, OS_CODE);
          s2.status = BUSY_STATE;
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
        } else {
          put_byte(
            s2,
            (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
          );
          put_byte(s2, s2.gzhead.time & 255);
          put_byte(s2, s2.gzhead.time >> 8 & 255);
          put_byte(s2, s2.gzhead.time >> 16 & 255);
          put_byte(s2, s2.gzhead.time >> 24 & 255);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte(s2, s2.gzhead.extra.length & 255);
            put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          let beg = s2.pending;
          let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
          while (s2.pending + left > s2.pending_buf_size) {
            let copy6 = s2.pending_buf_size - s2.pending;
            s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy6), s2.pending);
            s2.pending = s2.pending_buf_size;
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            s2.gzindex += copy6;
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
            left -= copy6;
          }
          let gzhead_extra = new Uint8Array(s2.gzhead.extra);
          s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
          s2.pending += left;
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = NAME_STATE;
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK$3;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = COMMENT_STATE;
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK$3;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
        }
        s2.status = HCRC_STATE;
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
          }
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s2.status = BUSY_STATE;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
        let bstate = s2.level === 0 ? deflate_stored(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK$3;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s2);
          } else if (flush !== Z_BLOCK$1) {
            _tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH$1) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
        }
      }
      if (flush !== Z_FINISH$3) {
        return Z_OK$3;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END$3;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
      }
      const s2 = strm.state;
      const wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR$2;
      }
      if (wrap === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        let tmpDict = new Uint8Array(s2.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        let str5 = s2.strstart;
        let n2 = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str5 + MIN_MATCH - 1]);
          s2.prev[str5 & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str5;
          str5++;
        } while (--n2);
        s2.strstart = str5;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK$3;
    };
    deflateInit_1 = deflateInit;
    deflateInit2_1 = deflateInit2;
    deflateReset_1 = deflateReset;
    deflateResetKeep_1 = deflateResetKeep;
    deflateSetHeader_1 = deflateSetHeader;
    deflate_2$1 = deflate$2;
    deflateEnd_1 = deflateEnd;
    deflateSetDictionary_1 = deflateSetDictionary;
    deflateInfo = "pako deflate (from Nodeca project)";
    deflate_1$2 = {
      deflateInit: deflateInit_1,
      deflateInit2: deflateInit2_1,
      deflateReset: deflateReset_1,
      deflateResetKeep: deflateResetKeep_1,
      deflateSetHeader: deflateSetHeader_1,
      deflate: deflate_2$1,
      deflateEnd: deflateEnd_1,
      deflateSetDictionary: deflateSetDictionary_1,
      deflateInfo
    };
    _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source3 = sources.shift();
        if (!source3) {
          continue;
        }
        if (typeof source3 !== "object") {
          throw new TypeError(source3 + "must be non-object");
        }
        for (const p2 in source3) {
          if (_has(source3, p2)) {
            obj[p2] = source3[p2];
          }
        }
      }
      return obj;
    };
    flattenChunks = (chunks) => {
      let len4 = 0;
      for (let i3 = 0, l2 = chunks.length; i3 < l2; i3++) {
        len4 += chunks[i3].length;
      }
      const result = new Uint8Array(len4);
      for (let i3 = 0, pos = 0, l2 = chunks.length; i3 < l2; i3++) {
        let chunk = chunks[i3];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
    common = {
      assign,
      flattenChunks
    };
    STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    _utf8len = new Uint8Array(256);
    for (let q2 = 0; q2 < 256; q2++) {
      _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    string2buf = (str5) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str5);
      }
      let buf, c2, c22, m_pos, i3, str_len = str5.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str5.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str5.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i3 = 0, m_pos = 0; i3 < buf_len; m_pos++) {
        c2 = str5.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str5.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i3++] = c2;
        } else if (c2 < 2048) {
          buf[i3++] = 192 | c2 >>> 6;
          buf[i3++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i3++] = 224 | c2 >>> 12;
          buf[i3++] = 128 | c2 >>> 6 & 63;
          buf[i3++] = 128 | c2 & 63;
        } else {
          buf[i3++] = 240 | c2 >>> 18;
          buf[i3++] = 128 | c2 >>> 12 & 63;
          buf[i3++] = 128 | c2 >>> 6 & 63;
          buf[i3++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    buf2binstring = (buf, len4) => {
      if (len4 < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len4 ? buf : buf.subarray(0, len4));
        }
      }
      let result = "";
      for (let i3 = 0; i3 < len4; i3++) {
        result += String.fromCharCode(buf[i3]);
      }
      return result;
    };
    buf2string = (buf, max4) => {
      const len4 = max4 || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max4));
      }
      let i3, out;
      const utf16buf = new Array(len4 * 2);
      for (out = 0, i3 = 0; i3 < len4; ) {
        let c2 = buf[i3++];
        if (c2 < 128) {
          utf16buf[out++] = c2;
          continue;
        }
        let c_len = _utf8len[c2];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i3 += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i3 < len4) {
          c2 = c2 << 6 | buf[i3++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    utf8border = (buf, max4) => {
      max4 = max4 || buf.length;
      if (max4 > buf.length) {
        max4 = buf.length;
      }
      let pos = max4 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max4;
      }
      if (pos === 0) {
        return max4;
      }
      return pos + _utf8len[buf[pos]] > max4 ? pos : max4;
    };
    strings = {
      string2buf,
      buf2string,
      utf8border
    };
    zstream = ZStream;
    toString$1 = Object.prototype.toString;
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$1,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH: Z_FINISH$2,
      Z_OK: Z_OK$2,
      Z_STREAM_END: Z_STREAM_END$2,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED: Z_DEFLATED$1
    } = constants$2);
    Deflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString$1.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$2.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK$2) {
        this.result = common.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Deflate_1$1 = Deflate$1;
    deflate_2 = deflate$1;
    deflateRaw_1$1 = deflateRaw$1;
    gzip_1$1 = gzip$1;
    constants$1 = constants$2;
    deflate_1$1 = {
      Deflate: Deflate_1$1,
      deflate: deflate_2,
      deflateRaw: deflateRaw_1$1,
      gzip: gzip_1$1,
      constants: constants$1
    };
    BAD$1 = 16209;
    TYPE$1 = 16191;
    inffast = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len4;
      let dist4;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len4 = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len4 += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist4 = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist4 += hold & (1 << op) - 1;
                      if (dist4 > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist4 > op) {
                        op = dist4 - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$1;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len4) {
                            len4 -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist4;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len4) {
                            len4 -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len4) {
                              op = wnext;
                              len4 -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist4;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len4) {
                            len4 -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist4;
                            from_source = output;
                          }
                        }
                        while (len4 > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len4 -= 3;
                        }
                        if (len4) {
                          output[_out++] = from_source[from++];
                          if (len4 > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist4;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len4 -= 3;
                        } while (len4 > 2);
                        if (len4) {
                          output[_out++] = output[from++];
                          if (len4 > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD$1;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE$1;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD$1;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len4 = bits >> 3;
      _in -= len4;
      bits -= len4 << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
    MAXBITS = 15;
    ENOUGH_LENS$1 = 852;
    ENOUGH_DISTS$1 = 592;
    CODES$1 = 0;
    LENS$1 = 1;
    DISTS$1 = 2;
    lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    inflate_table = (type, lens2, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len4 = 0;
      let sym = 0;
      let min4 = 0, max4 = 0;
      let root2 = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count2 = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len4 = 0; len4 <= MAXBITS; len4++) {
        count2[len4] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count2[lens2[lens_index + sym]]++;
      }
      root2 = bits;
      for (max4 = MAXBITS; max4 >= 1; max4--) {
        if (count2[max4] !== 0) {
          break;
        }
      }
      if (root2 > max4) {
        root2 = max4;
      }
      if (max4 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min4 = 1; min4 < max4; min4++) {
        if (count2[min4] !== 0) {
          break;
        }
      }
      if (root2 < min4) {
        root2 = min4;
      }
      left = 1;
      for (len4 = 1; len4 <= MAXBITS; len4++) {
        left <<= 1;
        left -= count2[len4];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES$1 || max4 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len4 = 1; len4 < MAXBITS; len4++) {
        offs[len4 + 1] = offs[len4] + count2[len4];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens2[lens_index + sym] !== 0) {
          work[offs[lens2[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES$1) {
        base = extra = work;
        match = 20;
      } else if (type === LENS$1) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len4 = min4;
      next = table_index;
      curr = root2;
      drop = 0;
      low = -1;
      used = 1 << root2;
      mask = used - 1;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      for (; ; ) {
        here_bits = len4 - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len4 - drop;
        fill = 1 << curr;
        min4 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len4 - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count2[len4] === 0) {
          if (len4 === max4) {
            break;
          }
          len4 = lens2[lens_index + work[sym]];
        }
        if (len4 > root2 && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root2;
          }
          next += min4;
          curr = len4 - drop;
          left = 1 << curr;
          while (curr + drop < max4) {
            left -= count2[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
          }
          low = huff & mask;
          table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len4 - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root2;
      return 0;
    };
    inftrees = inflate_table;
    CODES = 0;
    LENS = 1;
    DISTS = 2;
    ({
      Z_FINISH: Z_FINISH$1,
      Z_BLOCK,
      Z_TREES,
      Z_OK: Z_OK$1,
      Z_STREAM_END: Z_STREAM_END$1,
      Z_NEED_DICT: Z_NEED_DICT$1,
      Z_STREAM_ERROR: Z_STREAM_ERROR$1,
      Z_DATA_ERROR: Z_DATA_ERROR$1,
      Z_MEM_ERROR: Z_MEM_ERROR$1,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = constants$2);
    HEAD = 16180;
    FLAGS = 16181;
    TIME = 16182;
    OS = 16183;
    EXLEN = 16184;
    EXTRA = 16185;
    NAME = 16186;
    COMMENT = 16187;
    HCRC = 16188;
    DICTID = 16189;
    DICT = 16190;
    TYPE = 16191;
    TYPEDO = 16192;
    STORED = 16193;
    COPY_ = 16194;
    COPY = 16195;
    TABLE = 16196;
    LENLENS = 16197;
    CODELENS = 16198;
    LEN_ = 16199;
    LEN = 16200;
    LENEXT = 16201;
    DIST = 16202;
    DISTEXT = 16203;
    MATCH = 16204;
    LIT = 16205;
    CHECK = 16206;
    LENGTH = 16207;
    DONE = 16208;
    BAD = 16209;
    MEM = 16210;
    SYNC = 16211;
    ENOUGH_LENS = 852;
    ENOUGH_DISTS = 592;
    MAX_WBITS = 15;
    DEF_WBITS = MAX_WBITS;
    zswap32 = (q2) => {
      return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    };
    inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK$1;
    };
    inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR$1;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK$1) {
        strm.state = null;
      }
      return ret;
    };
    inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    virgin = true;
    fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    updatewindow = (strm, src, end, copy6) => {
      let dist4;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy6 >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist4 = state.wsize - state.wnext;
        if (dist4 > copy6) {
          dist4 = copy6;
        }
        state.window.set(src.subarray(end - copy6, end - copy6 + dist4), state.wnext);
        copy6 -= dist4;
        if (copy6) {
          state.window.set(src.subarray(end - copy6, end), 0);
          state.wnext = copy6;
          state.whave = state.wsize;
        } else {
          state.wnext += dist4;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist4;
          }
        }
      }
      return 0;
    };
    inflate$2 = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy6;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len4;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n2;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK$1;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len4 = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len4;
              }
              if (len4 > 15 || len4 > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32_1(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy6 = state.length;
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6) {
                  if (state.head) {
                    len4 = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy6
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len4
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32_1(state.check, input, copy6, next);
                  }
                  have -= copy6;
                  next += copy6;
                  state.length -= copy6;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len4 = input[next + copy6++];
                  if (state.head && len4 && state.length < 65536) {
                    state.head.name += String.fromCharCode(len4);
                  }
                } while (len4 && copy6 < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy6, next);
                }
                have -= copy6;
                next += copy6;
                if (len4) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len4 = input[next + copy6++];
                  if (state.head && len4 && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len4);
                  }
                } while (len4 && copy6 < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy6, next);
                }
                have -= copy6;
                next += copy6;
                if (len4) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT$1;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy6 = state.length;
              if (copy6) {
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6 > left) {
                  copy6 = left;
                }
                if (copy6 === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy6), put);
                have -= copy6;
                next += copy6;
                left -= copy6;
                put += copy6;
                state.length -= copy6;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n2 = here_bits + 2;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len4 = state.lens[state.have - 1];
                    copy6 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n2 = here_bits + 3;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len4 = 0;
                    copy6 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n2 = here_bits + 7;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len4 = 0;
                    copy6 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy6 > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy6--) {
                    state.lens[state.have++] = len4;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inffast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy6 = _out - left;
              if (state.offset > copy6) {
                copy6 = state.offset - copy6;
                if (copy6 > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy6 > state.wnext) {
                  copy6 -= state.wnext;
                  from = state.wsize - copy6;
                } else {
                  from = state.wnext - copy6;
                }
                if (copy6 > state.length) {
                  copy6 = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy6 = state.length;
              }
              if (copy6 > left) {
                copy6 = left;
              }
              left -= copy6;
              state.length -= copy6;
              do {
                output[put++] = from_source[from++];
              } while (--copy6);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END$1;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR$1;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR$1;
            case SYNC:
            default:
              return Z_STREAM_ERROR$1;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
          ;
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$1;
    };
    inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$1;
      }
      state.head = head;
      head.done = false;
      return Z_OK$1;
    };
    inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR$1;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$1;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
      }
      state.havedict = 1;
      return Z_OK$1;
    };
    inflateReset_1 = inflateReset;
    inflateReset2_1 = inflateReset2;
    inflateResetKeep_1 = inflateResetKeep;
    inflateInit_1 = inflateInit;
    inflateInit2_1 = inflateInit2;
    inflate_2$1 = inflate$2;
    inflateEnd_1 = inflateEnd;
    inflateGetHeader_1 = inflateGetHeader;
    inflateSetDictionary_1 = inflateSetDictionary;
    inflateInfo = "pako inflate (from Nodeca project)";
    inflate_1$2 = {
      inflateReset: inflateReset_1,
      inflateReset2: inflateReset2_1,
      inflateResetKeep: inflateResetKeep_1,
      inflateInit: inflateInit_1,
      inflateInit2: inflateInit2_1,
      inflate: inflate_2$1,
      inflateEnd: inflateEnd_1,
      inflateGetHeader: inflateGetHeader_1,
      inflateSetDictionary: inflateSetDictionary_1,
      inflateInfo
    };
    gzheader = GZheader;
    toString = Object.prototype.toString;
    ({
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = constants$2);
    Inflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = inflate_1$2.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = inflate_1$2.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          inflate_1$2.inflateReset(strm);
          status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = inflate_1$2.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = common.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Inflate_1$1 = Inflate$1;
    inflate_2 = inflate$1;
    inflateRaw_1$1 = inflateRaw$1;
    ungzip$1 = inflate$1;
    constants = constants$2;
    inflate_1$1 = {
      Inflate: Inflate_1$1,
      inflate: inflate_2,
      inflateRaw: inflateRaw_1$1,
      ungzip: ungzip$1,
      constants
    };
    ({ Deflate, deflate, deflateRaw, gzip } = deflate_1$1);
    ({ Inflate, inflate, inflateRaw, ungzip } = inflate_1$1);
    inflate_1 = inflate;
  }
});

// node_modules/geotiff/dist-module/compression/deflate.js
var deflate_exports = {};
__export(deflate_exports, {
  default: () => DeflateDecoder
});
var DeflateDecoder;
var init_deflate = __esm({
  "node_modules/geotiff/dist-module/compression/deflate.js"() {
    init_pako_esm();
    init_basedecoder();
    DeflateDecoder = class extends BaseDecoder {
      decodeBlock(buffer) {
        return inflate_1(new Uint8Array(buffer)).buffer;
      }
    };
  }
});

// node_modules/geotiff/dist-module/compression/packbits.js
var packbits_exports = {};
__export(packbits_exports, {
  default: () => PackbitsDecoder
});
var PackbitsDecoder;
var init_packbits = __esm({
  "node_modules/geotiff/dist-module/compression/packbits.js"() {
    init_basedecoder();
    PackbitsDecoder = class extends BaseDecoder {
      decodeBlock(buffer) {
        const dataView = new DataView(buffer);
        const out = [];
        for (let i3 = 0; i3 < buffer.byteLength; ++i3) {
          let header = dataView.getInt8(i3);
          if (header < 0) {
            const next = dataView.getUint8(i3 + 1);
            header = -header;
            for (let j2 = 0; j2 <= header; ++j2) {
              out.push(next);
            }
            i3 += 1;
          } else {
            for (let j2 = 0; j2 <= header; ++j2) {
              out.push(dataView.getUint8(i3 + j2 + 1));
            }
            i3 += header + 1;
          }
        }
        return new Uint8Array(out).buffer;
      }
    };
  }
});

// node_modules/lerc/LercDecode.js
var require_LercDecode = __commonJS({
  "node_modules/lerc/LercDecode.js"(exports, module) {
    (function() {
      var LercDecode = function() {
        var CntZImage = {};
        CntZImage.defaultNoDataValue = -34027999387901484e22;
        CntZImage.decode = function(input, options) {
          options = options || {};
          var skipMask = options.encodedMaskData || options.encodedMaskData === null;
          var parsedData = parse2(input, options.inputOffset || 0, skipMask);
          var noDataValue = options.noDataValue !== null ? options.noDataValue : CntZImage.defaultNoDataValue;
          var uncompressedData = uncompressPixelValues(
            parsedData,
            options.pixelType || Float32Array,
            options.encodedMaskData,
            noDataValue,
            options.returnMask
          );
          var result = {
            width: parsedData.width,
            height: parsedData.height,
            pixelData: uncompressedData.resultPixels,
            minValue: uncompressedData.minValue,
            maxValue: parsedData.pixels.maxValue,
            noDataValue
          };
          if (uncompressedData.resultMask) {
            result.maskData = uncompressedData.resultMask;
          }
          if (options.returnEncodedMask && parsedData.mask) {
            result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;
          }
          if (options.returnFileInfo) {
            result.fileInfo = formatFileInfo(parsedData);
            if (options.computeUsedBitDepths) {
              result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);
            }
          }
          return result;
        };
        var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {
          var blockIdx = 0;
          var numX = data.pixels.numBlocksX;
          var numY = data.pixels.numBlocksY;
          var blockWidth = Math.floor(data.width / numX);
          var blockHeight = Math.floor(data.height / numY);
          var scale7 = 2 * data.maxZError;
          var minValue = Number.MAX_VALUE, currentValue;
          maskBitset = maskBitset || (data.mask ? data.mask.bitset : null);
          var resultPixels, resultMask;
          resultPixels = new TypedArrayClass(data.width * data.height);
          if (storeDecodedMask && maskBitset) {
            resultMask = new Uint8Array(data.width * data.height);
          }
          var blockDataBuffer = new Float32Array(blockWidth * blockHeight);
          var xx, yy;
          for (var y2 = 0; y2 <= numY; y2++) {
            var thisBlockHeight = y2 !== numY ? blockHeight : data.height % numY;
            if (thisBlockHeight === 0) {
              continue;
            }
            for (var x2 = 0; x2 <= numX; x2++) {
              var thisBlockWidth = x2 !== numX ? blockWidth : data.width % numX;
              if (thisBlockWidth === 0) {
                continue;
              }
              var outPtr = y2 * data.width * blockHeight + x2 * blockWidth;
              var outStride = data.width - thisBlockWidth;
              var block = data.pixels.blocks[blockIdx];
              var blockData, blockPtr, constValue;
              if (block.encoding < 2) {
                if (block.encoding === 0) {
                  blockData = block.rawData;
                } else {
                  unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale7, blockDataBuffer, data.pixels.maxValue);
                  blockData = blockDataBuffer;
                }
                blockPtr = 0;
              } else if (block.encoding === 2) {
                constValue = 0;
              } else {
                constValue = block.offset;
              }
              var maskByte;
              if (maskBitset) {
                for (yy = 0; yy < thisBlockHeight; yy++) {
                  if (outPtr & 7) {
                    maskByte = maskBitset[outPtr >> 3];
                    maskByte <<= outPtr & 7;
                  }
                  for (xx = 0; xx < thisBlockWidth; xx++) {
                    if (!(outPtr & 7)) {
                      maskByte = maskBitset[outPtr >> 3];
                    }
                    if (maskByte & 128) {
                      if (resultMask) {
                        resultMask[outPtr] = 1;
                      }
                      currentValue = block.encoding < 2 ? blockData[blockPtr++] : constValue;
                      minValue = minValue > currentValue ? currentValue : minValue;
                      resultPixels[outPtr++] = currentValue;
                    } else {
                      if (resultMask) {
                        resultMask[outPtr] = 0;
                      }
                      resultPixels[outPtr++] = noDataValue;
                    }
                    maskByte <<= 1;
                  }
                  outPtr += outStride;
                }
              } else {
                if (block.encoding < 2) {
                  for (yy = 0; yy < thisBlockHeight; yy++) {
                    for (xx = 0; xx < thisBlockWidth; xx++) {
                      currentValue = blockData[blockPtr++];
                      minValue = minValue > currentValue ? currentValue : minValue;
                      resultPixels[outPtr++] = currentValue;
                    }
                    outPtr += outStride;
                  }
                } else {
                  minValue = minValue > constValue ? constValue : minValue;
                  for (yy = 0; yy < thisBlockHeight; yy++) {
                    for (xx = 0; xx < thisBlockWidth; xx++) {
                      resultPixels[outPtr++] = constValue;
                    }
                    outPtr += outStride;
                  }
                }
              }
              if (block.encoding === 1 && blockPtr !== block.numValidPixels) {
                throw "Block and Mask do not match";
              }
              blockIdx++;
            }
          }
          return {
            resultPixels,
            resultMask,
            minValue
          };
        };
        var formatFileInfo = function(data) {
          return {
            "fileIdentifierString": data.fileIdentifierString,
            "fileVersion": data.fileVersion,
            "imageType": data.imageType,
            "height": data.height,
            "width": data.width,
            "maxZError": data.maxZError,
            "eofOffset": data.eofOffset,
            "mask": data.mask ? {
              "numBlocksX": data.mask.numBlocksX,
              "numBlocksY": data.mask.numBlocksY,
              "numBytes": data.mask.numBytes,
              "maxValue": data.mask.maxValue
            } : null,
            "pixels": {
              "numBlocksX": data.pixels.numBlocksX,
              "numBlocksY": data.pixels.numBlocksY,
              "numBytes": data.pixels.numBytes,
              "maxValue": data.pixels.maxValue,
              "noDataValue": data.noDataValue
            }
          };
        };
        var computeUsedBitDepths = function(data) {
          var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;
          var bitDepths = {};
          for (var i3 = 0; i3 < numBlocks; i3++) {
            var block = data.pixels.blocks[i3];
            if (block.encoding === 0) {
              bitDepths.float32 = true;
            } else if (block.encoding === 1) {
              bitDepths[block.bitsPerPixel] = true;
            } else {
              bitDepths[0] = true;
            }
          }
          return Object.keys(bitDepths);
        };
        var parse2 = function(input, fp, skipMask) {
          var data = {};
          var fileIdView = new Uint8Array(input, fp, 10);
          data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
          if (data.fileIdentifierString.trim() !== "CntZImage") {
            throw "Unexpected file identifier string: " + data.fileIdentifierString;
          }
          fp += 10;
          var view = new DataView(input, fp, 24);
          data.fileVersion = view.getInt32(0, true);
          data.imageType = view.getInt32(4, true);
          data.height = view.getUint32(8, true);
          data.width = view.getUint32(12, true);
          data.maxZError = view.getFloat64(16, true);
          fp += 24;
          if (!skipMask) {
            view = new DataView(input, fp, 16);
            data.mask = {};
            data.mask.numBlocksY = view.getUint32(0, true);
            data.mask.numBlocksX = view.getUint32(4, true);
            data.mask.numBytes = view.getUint32(8, true);
            data.mask.maxValue = view.getFloat32(12, true);
            fp += 16;
            if (data.mask.numBytes > 0) {
              var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
              view = new DataView(input, fp, data.mask.numBytes);
              var cnt = view.getInt16(0, true);
              var ip = 2, op = 0;
              do {
                if (cnt > 0) {
                  while (cnt--) {
                    bitset[op++] = view.getUint8(ip++);
                  }
                } else {
                  var val = view.getUint8(ip++);
                  cnt = -cnt;
                  while (cnt--) {
                    bitset[op++] = val;
                  }
                }
                cnt = view.getInt16(ip, true);
                ip += 2;
              } while (ip < data.mask.numBytes);
              if (cnt !== -32768 || op < bitset.length) {
                throw "Unexpected end of mask RLE encoding";
              }
              data.mask.bitset = bitset;
              fp += data.mask.numBytes;
            } else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {
              data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
            }
          }
          view = new DataView(input, fp, 16);
          data.pixels = {};
          data.pixels.numBlocksY = view.getUint32(0, true);
          data.pixels.numBlocksX = view.getUint32(4, true);
          data.pixels.numBytes = view.getUint32(8, true);
          data.pixels.maxValue = view.getFloat32(12, true);
          fp += 16;
          var numBlocksX = data.pixels.numBlocksX;
          var numBlocksY = data.pixels.numBlocksY;
          var actualNumBlocksX = numBlocksX + (data.width % numBlocksX > 0 ? 1 : 0);
          var actualNumBlocksY = numBlocksY + (data.height % numBlocksY > 0 ? 1 : 0);
          data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);
          var blockI = 0;
          for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {
            for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {
              var size = 0;
              var bytesLeft = input.byteLength - fp;
              view = new DataView(input, fp, Math.min(10, bytesLeft));
              var block = {};
              data.pixels.blocks[blockI++] = block;
              var headerByte = view.getUint8(0);
              size++;
              block.encoding = headerByte & 63;
              if (block.encoding > 3) {
                throw "Invalid block encoding (" + block.encoding + ")";
              }
              if (block.encoding === 2) {
                fp++;
                continue;
              }
              if (headerByte !== 0 && headerByte !== 2) {
                headerByte >>= 6;
                block.offsetType = headerByte;
                if (headerByte === 2) {
                  block.offset = view.getInt8(1);
                  size++;
                } else if (headerByte === 1) {
                  block.offset = view.getInt16(1, true);
                  size += 2;
                } else if (headerByte === 0) {
                  block.offset = view.getFloat32(1, true);
                  size += 4;
                } else {
                  throw "Invalid block offset type";
                }
                if (block.encoding === 1) {
                  headerByte = view.getUint8(size);
                  size++;
                  block.bitsPerPixel = headerByte & 63;
                  headerByte >>= 6;
                  block.numValidPixelsType = headerByte;
                  if (headerByte === 2) {
                    block.numValidPixels = view.getUint8(size);
                    size++;
                  } else if (headerByte === 1) {
                    block.numValidPixels = view.getUint16(size, true);
                    size += 2;
                  } else if (headerByte === 0) {
                    block.numValidPixels = view.getUint32(size, true);
                    size += 4;
                  } else {
                    throw "Invalid valid pixel count type";
                  }
                }
              }
              fp += size;
              if (block.encoding === 3) {
                continue;
              }
              var arrayBuf, store8;
              if (block.encoding === 0) {
                var numPixels = (data.pixels.numBytes - 1) / 4;
                if (numPixels !== Math.floor(numPixels)) {
                  throw "uncompressed block has invalid length";
                }
                arrayBuf = new ArrayBuffer(numPixels * 4);
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, fp, numPixels * 4));
                var rawData = new Float32Array(arrayBuf);
                block.rawData = rawData;
                fp += numPixels * 4;
              } else if (block.encoding === 1) {
                var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);
                var dataWords = Math.ceil(dataBytes / 4);
                arrayBuf = new ArrayBuffer(dataWords * 4);
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, fp, dataBytes));
                block.stuffedData = new Uint32Array(arrayBuf);
                fp += dataBytes;
              }
            }
          }
          data.eofOffset = fp;
          return data;
        };
        var unstuff = function(src, bitsPerPixel, numPixels, offset, scale7, dest, maxValue) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i3 = 0, o3;
          var bitsLeft = 0;
          var n2, buffer;
          var nmax = Math.ceil((maxValue - offset) / scale7);
          var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
          src[src.length - 1] <<= 8 * numInvalidTailBytes;
          for (o3 = 0; o3 < numPixels; o3++) {
            if (bitsLeft === 0) {
              buffer = src[i3++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n2 = buffer >>> bitsLeft - bitsPerPixel & bitMask;
              bitsLeft -= bitsPerPixel;
            } else {
              var missingBits = bitsPerPixel - bitsLeft;
              n2 = (buffer & bitMask) << missingBits & bitMask;
              buffer = src[i3++];
              bitsLeft = 32 - missingBits;
              n2 += buffer >>> bitsLeft;
            }
            dest[o3] = n2 < nmax ? offset + n2 * scale7 : maxValue;
          }
          return dest;
        };
        return CntZImage;
      }();
      var Lerc2Decode = function() {
        "use strict";
        var BitStuffer = {
          //methods ending with 2 are for the new byte order used by Lerc2.3 and above.
          //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.
          unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale7, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i3 = 0, o3;
            var bitsLeft = 0;
            var n2, buffer, missingBits, nmax;
            var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
            src[src.length - 1] <<= 8 * numInvalidTailBytes;
            if (lutArr) {
              for (o3 = 0; o3 < numPixels; o3++) {
                if (bitsLeft === 0) {
                  buffer = src[i3++];
                  bitsLeft = 32;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n2 = buffer >>> bitsLeft - bitsPerPixel & bitMask;
                  bitsLeft -= bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n2 = (buffer & bitMask) << missingBits & bitMask;
                  buffer = src[i3++];
                  bitsLeft = 32 - missingBits;
                  n2 += buffer >>> bitsLeft;
                }
                dest[o3] = lutArr[n2];
              }
            } else {
              nmax = Math.ceil((maxValue - offset) / scale7);
              for (o3 = 0; o3 < numPixels; o3++) {
                if (bitsLeft === 0) {
                  buffer = src[i3++];
                  bitsLeft = 32;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n2 = buffer >>> bitsLeft - bitsPerPixel & bitMask;
                  bitsLeft -= bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n2 = (buffer & bitMask) << missingBits & bitMask;
                  buffer = src[i3++];
                  bitsLeft = 32 - missingBits;
                  n2 += buffer >>> bitsLeft;
                }
                dest[o3] = n2 < nmax ? offset + n2 * scale7 : maxValue;
              }
            }
          },
          unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale7, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i3 = 0, o3 = 0, missingBits = 0, bitsLeft = 0, n2 = 0;
            var buffer;
            var dest = [];
            var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
            src[src.length - 1] <<= 8 * numInvalidTailBytes;
            var nmax = Math.ceil((maxValue - offset) / scale7);
            for (o3 = 0; o3 < numPixels; o3++) {
              if (bitsLeft === 0) {
                buffer = src[i3++];
                bitsLeft = 32;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer >>> bitsLeft - bitsPerPixel & bitMask;
                bitsLeft -= bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = (buffer & bitMask) << missingBits & bitMask;
                buffer = src[i3++];
                bitsLeft = 32 - missingBits;
                n2 += buffer >>> bitsLeft;
              }
              dest[o3] = n2 < nmax ? offset + n2 * scale7 : maxValue;
            }
            dest.unshift(offset);
            return dest;
          },
          unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale7, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i3 = 0, o3;
            var bitsLeft = 0, bitPos = 0;
            var n2, buffer, missingBits;
            if (lutArr) {
              for (o3 = 0; o3 < numPixels; o3++) {
                if (bitsLeft === 0) {
                  buffer = src[i3++];
                  bitsLeft = 32;
                  bitPos = 0;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n2 = buffer >>> bitPos & bitMask;
                  bitsLeft -= bitsPerPixel;
                  bitPos += bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n2 = buffer >>> bitPos & bitMask;
                  buffer = src[i3++];
                  bitsLeft = 32 - missingBits;
                  n2 |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                  bitPos = missingBits;
                }
                dest[o3] = lutArr[n2];
              }
            } else {
              var nmax = Math.ceil((maxValue - offset) / scale7);
              for (o3 = 0; o3 < numPixels; o3++) {
                if (bitsLeft === 0) {
                  buffer = src[i3++];
                  bitsLeft = 32;
                  bitPos = 0;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n2 = buffer >>> bitPos & bitMask;
                  bitsLeft -= bitsPerPixel;
                  bitPos += bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n2 = buffer >>> bitPos & bitMask;
                  buffer = src[i3++];
                  bitsLeft = 32 - missingBits;
                  n2 |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                  bitPos = missingBits;
                }
                dest[o3] = n2 < nmax ? offset + n2 * scale7 : maxValue;
              }
            }
            return dest;
          },
          unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale7, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i3 = 0, o3 = 0, missingBits = 0, bitsLeft = 0, n2 = 0, bitPos = 0;
            var buffer;
            var dest = [];
            var nmax = Math.ceil((maxValue - offset) / scale7);
            for (o3 = 0; o3 < numPixels; o3++) {
              if (bitsLeft === 0) {
                buffer = src[i3++];
                bitsLeft = 32;
                bitPos = 0;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer >>> bitPos & bitMask;
                bitsLeft -= bitsPerPixel;
                bitPos += bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = buffer >>> bitPos & bitMask;
                buffer = src[i3++];
                bitsLeft = 32 - missingBits;
                n2 |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                bitPos = missingBits;
              }
              dest[o3] = n2 < nmax ? offset + n2 * scale7 : maxValue;
            }
            dest.unshift(offset);
            return dest;
          },
          originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i3 = 0, o3;
            var bitsLeft = 0;
            var n2, buffer, missingBits;
            var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
            src[src.length - 1] <<= 8 * numInvalidTailBytes;
            for (o3 = 0; o3 < numPixels; o3++) {
              if (bitsLeft === 0) {
                buffer = src[i3++];
                bitsLeft = 32;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer >>> bitsLeft - bitsPerPixel & bitMask;
                bitsLeft -= bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = (buffer & bitMask) << missingBits & bitMask;
                buffer = src[i3++];
                bitsLeft = 32 - missingBits;
                n2 += buffer >>> bitsLeft;
              }
              dest[o3] = n2;
            }
            return dest;
          },
          originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i3 = 0, o3;
            var bitsLeft = 0, bitPos = 0;
            var n2, buffer, missingBits;
            for (o3 = 0; o3 < numPixels; o3++) {
              if (bitsLeft === 0) {
                buffer = src[i3++];
                bitsLeft = 32;
                bitPos = 0;
              }
              if (bitsLeft >= bitsPerPixel) {
                n2 = buffer >>> bitPos & bitMask;
                bitsLeft -= bitsPerPixel;
                bitPos += bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n2 = buffer >>> bitPos & bitMask;
                buffer = src[i3++];
                bitsLeft = 32 - missingBits;
                n2 |= (buffer & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                bitPos = missingBits;
              }
              dest[o3] = n2;
            }
            return dest;
          }
        };
        var Lerc2Helpers = {
          HUFFMAN_LUT_BITS_MAX: 12,
          //use 2^12 lut, treat it like constant
          computeChecksumFletcher32: function(input) {
            var sum1 = 65535, sum2 = 65535;
            var len4 = input.length;
            var words = Math.floor(len4 / 2);
            var i3 = 0;
            while (words) {
              var tlen = words >= 359 ? 359 : words;
              words -= tlen;
              do {
                sum1 += input[i3++] << 8;
                sum2 += sum1 += input[i3++];
              } while (--tlen);
              sum1 = (sum1 & 65535) + (sum1 >>> 16);
              sum2 = (sum2 & 65535) + (sum2 >>> 16);
            }
            if (len4 & 1) {
              sum2 += sum1 += input[i3] << 8;
            }
            sum1 = (sum1 & 65535) + (sum1 >>> 16);
            sum2 = (sum2 & 65535) + (sum2 >>> 16);
            return (sum2 << 16 | sum1) >>> 0;
          },
          readHeaderInfo: function(input, data) {
            var ptr = data.ptr;
            var fileIdView = new Uint8Array(input, ptr, 6);
            var headerInfo = {};
            headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
            if (headerInfo.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) {
              throw "Unexpected file identifier string (expect Lerc2 ): " + headerInfo.fileIdentifierString;
            }
            ptr += 6;
            var view = new DataView(input, ptr, 8);
            var fileVersion = view.getInt32(0, true);
            headerInfo.fileVersion = fileVersion;
            ptr += 4;
            if (fileVersion >= 3) {
              headerInfo.checksum = view.getUint32(4, true);
              ptr += 4;
            }
            view = new DataView(input, ptr, 12);
            headerInfo.height = view.getUint32(0, true);
            headerInfo.width = view.getUint32(4, true);
            ptr += 8;
            if (fileVersion >= 4) {
              headerInfo.numDims = view.getUint32(8, true);
              ptr += 4;
            } else {
              headerInfo.numDims = 1;
            }
            view = new DataView(input, ptr, 40);
            headerInfo.numValidPixel = view.getUint32(0, true);
            headerInfo.microBlockSize = view.getInt32(4, true);
            headerInfo.blobSize = view.getInt32(8, true);
            headerInfo.imageType = view.getInt32(12, true);
            headerInfo.maxZError = view.getFloat64(16, true);
            headerInfo.zMin = view.getFloat64(24, true);
            headerInfo.zMax = view.getFloat64(32, true);
            ptr += 40;
            data.headerInfo = headerInfo;
            data.ptr = ptr;
            var checksum, keyLength;
            if (fileVersion >= 3) {
              keyLength = fileVersion >= 4 ? 52 : 48;
              checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));
              if (checksum !== headerInfo.checksum) {
                throw "Checksum failed.";
              }
            }
            return true;
          },
          checkMinMaxRanges: function(input, data) {
            var headerInfo = data.headerInfo;
            var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);
            var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);
            var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);
            var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);
            data.ptr += 2 * rangeBytes;
            var i3, equal = true;
            for (i3 = 0; i3 < headerInfo.numDims; i3++) {
              if (minValues[i3] !== maxValues[i3]) {
                equal = false;
                break;
              }
            }
            headerInfo.minValues = minValues;
            headerInfo.maxValues = maxValues;
            return equal;
          },
          readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {
            var rawData;
            if (OutPixelTypeArray === Uint8Array) {
              rawData = new Uint8Array(input, ptr, numBytes);
            } else {
              var arrayBuf = new ArrayBuffer(numBytes);
              var store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, ptr, numBytes));
              rawData = new OutPixelTypeArray(arrayBuf);
            }
            return rawData;
          },
          readMask: function(input, data) {
            var ptr = data.ptr;
            var headerInfo = data.headerInfo;
            var numPixels = headerInfo.width * headerInfo.height;
            var numValidPixel = headerInfo.numValidPixel;
            var view = new DataView(input, ptr, 4);
            var mask = {};
            mask.numBytes = view.getUint32(0, true);
            ptr += 4;
            if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {
              throw "invalid mask";
            }
            var bitset, resultMask;
            if (numValidPixel === 0) {
              bitset = new Uint8Array(Math.ceil(numPixels / 8));
              mask.bitset = bitset;
              resultMask = new Uint8Array(numPixels);
              data.pixels.resultMask = resultMask;
              ptr += mask.numBytes;
            } else if (mask.numBytes > 0) {
              bitset = new Uint8Array(Math.ceil(numPixels / 8));
              view = new DataView(input, ptr, mask.numBytes);
              var cnt = view.getInt16(0, true);
              var ip = 2, op = 0, val = 0;
              do {
                if (cnt > 0) {
                  while (cnt--) {
                    bitset[op++] = view.getUint8(ip++);
                  }
                } else {
                  val = view.getUint8(ip++);
                  cnt = -cnt;
                  while (cnt--) {
                    bitset[op++] = val;
                  }
                }
                cnt = view.getInt16(ip, true);
                ip += 2;
              } while (ip < mask.numBytes);
              if (cnt !== -32768 || op < bitset.length) {
                throw "Unexpected end of mask RLE encoding";
              }
              resultMask = new Uint8Array(numPixels);
              var mb = 0, k2 = 0;
              for (k2 = 0; k2 < numPixels; k2++) {
                if (k2 & 7) {
                  mb = bitset[k2 >> 3];
                  mb <<= k2 & 7;
                } else {
                  mb = bitset[k2 >> 3];
                }
                if (mb & 128) {
                  resultMask[k2] = 1;
                }
              }
              data.pixels.resultMask = resultMask;
              mask.bitset = bitset;
              ptr += mask.numBytes;
            }
            data.ptr = ptr;
            data.mask = mask;
            return true;
          },
          readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
            var ptr = data.ptr;
            var headerInfo = data.headerInfo;
            var numDims = headerInfo.numDims;
            var numPixels = headerInfo.width * headerInfo.height;
            var imageType = headerInfo.imageType;
            var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;
            var rawData;
            var mask = data.pixels.resultMask;
            if (OutPixelTypeArray === Uint8Array) {
              rawData = new Uint8Array(input, ptr, numBytes);
            } else {
              var arrayBuf = new ArrayBuffer(numBytes);
              var store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, ptr, numBytes));
              rawData = new OutPixelTypeArray(arrayBuf);
            }
            if (rawData.length === numPixels * numDims) {
              if (useBSQForOutputDim) {
                data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);
              } else {
                data.pixels.resultPixels = rawData;
              }
            } else {
              data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);
              var z2 = 0, k2 = 0, i3 = 0, nStart = 0;
              if (numDims > 1) {
                if (useBSQForOutputDim) {
                  for (k2 = 0; k2 < numPixels; k2++) {
                    if (mask[k2]) {
                      nStart = k2;
                      for (i3 = 0; i3 < numDims; i3++, nStart += numPixels) {
                        data.pixels.resultPixels[nStart] = rawData[z2++];
                      }
                    }
                  }
                } else {
                  for (k2 = 0; k2 < numPixels; k2++) {
                    if (mask[k2]) {
                      nStart = k2 * numDims;
                      for (i3 = 0; i3 < numDims; i3++) {
                        data.pixels.resultPixels[nStart + i3] = rawData[z2++];
                      }
                    }
                  }
                }
              } else {
                for (k2 = 0; k2 < numPixels; k2++) {
                  if (mask[k2]) {
                    data.pixels.resultPixels[k2] = rawData[z2++];
                  }
                }
              }
            }
            ptr += numBytes;
            data.ptr = ptr;
            return true;
          },
          readHuffmanTree: function(input, data) {
            var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX;
            var view = new DataView(input, data.ptr, 16);
            data.ptr += 16;
            var version2 = view.getInt32(0, true);
            if (version2 < 2) {
              throw "unsupported Huffman version";
            }
            var size = view.getInt32(4, true);
            var i0 = view.getInt32(8, true);
            var i1 = view.getInt32(12, true);
            if (i0 >= i1) {
              return false;
            }
            var blockDataBuffer = new Uint32Array(i1 - i0);
            Lerc2Helpers.decodeBits(input, data, blockDataBuffer);
            var codeTable = [];
            var i3, j2, k2, len4;
            for (i3 = i0; i3 < i1; i3++) {
              j2 = i3 - (i3 < size ? 0 : size);
              codeTable[j2] = { first: blockDataBuffer[i3 - i0], second: null };
            }
            var dataBytes = input.byteLength - data.ptr;
            var dataWords = Math.ceil(dataBytes / 4);
            var arrayBuf = new ArrayBuffer(dataWords * 4);
            var store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, data.ptr, dataBytes));
            var stuffedData = new Uint32Array(arrayBuf);
            var bitPos = 0, word, srcPtr = 0;
            word = stuffedData[0];
            for (i3 = i0; i3 < i1; i3++) {
              j2 = i3 - (i3 < size ? 0 : size);
              len4 = codeTable[j2].first;
              if (len4 > 0) {
                codeTable[j2].second = word << bitPos >>> 32 - len4;
                if (32 - bitPos >= len4) {
                  bitPos += len4;
                  if (bitPos === 32) {
                    bitPos = 0;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }
                } else {
                  bitPos += len4 - 32;
                  srcPtr++;
                  word = stuffedData[srcPtr];
                  codeTable[j2].second |= word >>> 32 - bitPos;
                }
              }
            }
            var numBitsLUT = 0, numBitsLUTQick = 0;
            var tree = new TreeNode();
            for (i3 = 0; i3 < codeTable.length; i3++) {
              if (codeTable[i3] !== void 0) {
                numBitsLUT = Math.max(numBitsLUT, codeTable[i3].first);
              }
            }
            if (numBitsLUT >= BITS_MAX) {
              numBitsLUTQick = BITS_MAX;
            } else {
              numBitsLUTQick = numBitsLUT;
            }
            var decodeLut = [], entry, code, numEntries, jj, currentBit, node;
            for (i3 = i0; i3 < i1; i3++) {
              j2 = i3 - (i3 < size ? 0 : size);
              len4 = codeTable[j2].first;
              if (len4 > 0) {
                entry = [len4, j2];
                if (len4 <= numBitsLUTQick) {
                  code = codeTable[j2].second << numBitsLUTQick - len4;
                  numEntries = 1 << numBitsLUTQick - len4;
                  for (k2 = 0; k2 < numEntries; k2++) {
                    decodeLut[code | k2] = entry;
                  }
                } else {
                  code = codeTable[j2].second;
                  node = tree;
                  for (jj = len4 - 1; jj >= 0; jj--) {
                    currentBit = code >>> jj & 1;
                    if (currentBit) {
                      if (!node.right) {
                        node.right = new TreeNode();
                      }
                      node = node.right;
                    } else {
                      if (!node.left) {
                        node.left = new TreeNode();
                      }
                      node = node.left;
                    }
                    if (jj === 0 && !node.val) {
                      node.val = entry[1];
                    }
                  }
                }
              }
            }
            return {
              decodeLut,
              numBitsLUTQick,
              numBitsLUT,
              tree,
              stuffedData,
              srcPtr,
              bitPos
            };
          },
          readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
            var headerInfo = data.headerInfo;
            var numDims = headerInfo.numDims;
            var height = data.headerInfo.height;
            var width = data.headerInfo.width;
            var numPixels = width * height;
            var huffmanInfo = this.readHuffmanTree(input, data);
            var decodeLut = huffmanInfo.decodeLut;
            var tree = huffmanInfo.tree;
            var stuffedData = huffmanInfo.stuffedData;
            var srcPtr = huffmanInfo.srcPtr;
            var bitPos = huffmanInfo.bitPos;
            var numBitsLUTQick = huffmanInfo.numBitsLUTQick;
            var numBitsLUT = huffmanInfo.numBitsLUT;
            var offset = data.headerInfo.imageType === 0 ? 128 : 0;
            var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;
            var i3, j2, k2, ii;
            var prevVal = 0;
            if (bitPos > 0) {
              srcPtr++;
              bitPos = 0;
            }
            var word = stuffedData[srcPtr];
            var deltaEncode = data.encodeMode === 1;
            var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);
            var resultPixels = resultPixelsAllDim;
            var iDim;
            if (numDims < 2 || deltaEncode) {
              for (iDim = 0; iDim < numDims; iDim++) {
                if (numDims > 1) {
                  resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);
                  prevVal = 0;
                }
                if (data.headerInfo.numValidPixel === width * height) {
                  for (k2 = 0, i3 = 0; i3 < height; i3++) {
                    for (j2 = 0; j2 < width; j2++, k2++) {
                      val = 0;
                      valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                      valTmpQuick = valTmp;
                      if (32 - bitPos < numBitsLUTQick) {
                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                        valTmpQuick = valTmp;
                      }
                      if (decodeLut[valTmpQuick]) {
                        val = decodeLut[valTmpQuick][1];
                        bitPos += decodeLut[valTmpQuick][0];
                      } else {
                        valTmp = word << bitPos >>> 32 - numBitsLUT;
                        valTmpQuick = valTmp;
                        if (32 - bitPos < numBitsLUT) {
                          valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                          valTmpQuick = valTmp;
                        }
                        node = tree;
                        for (ii = 0; ii < numBitsLUT; ii++) {
                          currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                          node = currentBit ? node.right : node.left;
                          if (!(node.left || node.right)) {
                            val = node.val;
                            bitPos = bitPos + ii + 1;
                            break;
                          }
                        }
                      }
                      if (bitPos >= 32) {
                        bitPos -= 32;
                        srcPtr++;
                        word = stuffedData[srcPtr];
                      }
                      delta = val - offset;
                      if (deltaEncode) {
                        if (j2 > 0) {
                          delta += prevVal;
                        } else if (i3 > 0) {
                          delta += resultPixels[k2 - width];
                        } else {
                          delta += prevVal;
                        }
                        delta &= 255;
                        resultPixels[k2] = delta;
                        prevVal = delta;
                      } else {
                        resultPixels[k2] = delta;
                      }
                    }
                  }
                } else {
                  for (k2 = 0, i3 = 0; i3 < height; i3++) {
                    for (j2 = 0; j2 < width; j2++, k2++) {
                      if (mask[k2]) {
                        val = 0;
                        valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                        valTmpQuick = valTmp;
                        if (32 - bitPos < numBitsLUTQick) {
                          valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                          valTmpQuick = valTmp;
                        }
                        if (decodeLut[valTmpQuick]) {
                          val = decodeLut[valTmpQuick][1];
                          bitPos += decodeLut[valTmpQuick][0];
                        } else {
                          valTmp = word << bitPos >>> 32 - numBitsLUT;
                          valTmpQuick = valTmp;
                          if (32 - bitPos < numBitsLUT) {
                            valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                            valTmpQuick = valTmp;
                          }
                          node = tree;
                          for (ii = 0; ii < numBitsLUT; ii++) {
                            currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                            node = currentBit ? node.right : node.left;
                            if (!(node.left || node.right)) {
                              val = node.val;
                              bitPos = bitPos + ii + 1;
                              break;
                            }
                          }
                        }
                        if (bitPos >= 32) {
                          bitPos -= 32;
                          srcPtr++;
                          word = stuffedData[srcPtr];
                        }
                        delta = val - offset;
                        if (deltaEncode) {
                          if (j2 > 0 && mask[k2 - 1]) {
                            delta += prevVal;
                          } else if (i3 > 0 && mask[k2 - width]) {
                            delta += resultPixels[k2 - width];
                          } else {
                            delta += prevVal;
                          }
                          delta &= 255;
                          resultPixels[k2] = delta;
                          prevVal = delta;
                        } else {
                          resultPixels[k2] = delta;
                        }
                      }
                    }
                  }
                }
              }
            } else {
              for (k2 = 0, i3 = 0; i3 < height; i3++) {
                for (j2 = 0; j2 < width; j2++) {
                  k2 = i3 * width + j2;
                  if (!mask || mask[k2]) {
                    for (iDim = 0; iDim < numDims; iDim++, k2 += numPixels) {
                      val = 0;
                      valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                      valTmpQuick = valTmp;
                      if (32 - bitPos < numBitsLUTQick) {
                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                        valTmpQuick = valTmp;
                      }
                      if (decodeLut[valTmpQuick]) {
                        val = decodeLut[valTmpQuick][1];
                        bitPos += decodeLut[valTmpQuick][0];
                      } else {
                        valTmp = word << bitPos >>> 32 - numBitsLUT;
                        valTmpQuick = valTmp;
                        if (32 - bitPos < numBitsLUT) {
                          valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                          valTmpQuick = valTmp;
                        }
                        node = tree;
                        for (ii = 0; ii < numBitsLUT; ii++) {
                          currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                          node = currentBit ? node.right : node.left;
                          if (!(node.left || node.right)) {
                            val = node.val;
                            bitPos = bitPos + ii + 1;
                            break;
                          }
                        }
                      }
                      if (bitPos >= 32) {
                        bitPos -= 32;
                        srcPtr++;
                        word = stuffedData[srcPtr];
                      }
                      delta = val - offset;
                      resultPixels[k2] = delta;
                    }
                  }
                }
              }
            }
            data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);
            data.pixels.resultPixels = resultPixelsAllDim;
            if (numDims > 1 && !useBSQForOutputDim) {
              data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);
            }
          },
          decodeBits: function(input, data, blockDataBuffer, offset, iDim) {
            {
              var headerInfo = data.headerInfo;
              var fileVersion = headerInfo.fileVersion;
              var blockPtr = 0;
              var viewByteLength = input.byteLength - data.ptr >= 5 ? 5 : input.byteLength - data.ptr;
              var view = new DataView(input, data.ptr, viewByteLength);
              var headerByte = view.getUint8(0);
              blockPtr++;
              var bits67 = headerByte >> 6;
              var n2 = bits67 === 0 ? 4 : 3 - bits67;
              var doLut = (headerByte & 32) > 0 ? true : false;
              var numBits = headerByte & 31;
              var numElements = 0;
              if (n2 === 1) {
                numElements = view.getUint8(blockPtr);
                blockPtr++;
              } else if (n2 === 2) {
                numElements = view.getUint16(blockPtr, true);
                blockPtr += 2;
              } else if (n2 === 4) {
                numElements = view.getUint32(blockPtr, true);
                blockPtr += 4;
              } else {
                throw "Invalid valid pixel count type";
              }
              var scale7 = 2 * headerInfo.maxZError;
              var stuffedData, arrayBuf, store8, dataBytes, dataWords;
              var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;
              var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;
              if (doLut) {
                data.counter.lut++;
                lutBytes = view.getUint8(blockPtr);
                lutBitsPerElement = numBits;
                blockPtr++;
                dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);
                dataWords = Math.ceil(dataBytes / 4);
                arrayBuf = new ArrayBuffer(dataWords * 4);
                store8 = new Uint8Array(arrayBuf);
                data.ptr += blockPtr;
                store8.set(new Uint8Array(input, data.ptr, dataBytes));
                lutData = new Uint32Array(arrayBuf);
                data.ptr += dataBytes;
                bitsPerPixel = 0;
                while (lutBytes - 1 >>> bitsPerPixel) {
                  bitsPerPixel++;
                }
                dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
                dataWords = Math.ceil(dataBytes / 4);
                arrayBuf = new ArrayBuffer(dataWords * 4);
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, data.ptr, dataBytes));
                stuffedData = new Uint32Array(arrayBuf);
                data.ptr += dataBytes;
                if (fileVersion >= 3) {
                  lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale7, zMax);
                } else {
                  lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale7, zMax);
                }
                if (fileVersion >= 3) {
                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
                } else {
                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
                }
              } else {
                data.counter.bitstuffer++;
                bitsPerPixel = numBits;
                data.ptr += blockPtr;
                if (bitsPerPixel > 0) {
                  dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
                  dataWords = Math.ceil(dataBytes / 4);
                  arrayBuf = new ArrayBuffer(dataWords * 4);
                  store8 = new Uint8Array(arrayBuf);
                  store8.set(new Uint8Array(input, data.ptr, dataBytes));
                  stuffedData = new Uint32Array(arrayBuf);
                  data.ptr += dataBytes;
                  if (fileVersion >= 3) {
                    if (offset == null) {
                      BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                    } else {
                      BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale7, zMax);
                    }
                  } else {
                    if (offset == null) {
                      BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                    } else {
                      BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale7, zMax);
                    }
                  }
                }
              }
            }
          },
          readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
            var headerInfo = data.headerInfo;
            var width = headerInfo.width;
            var height = headerInfo.height;
            var numPixels = width * height;
            var microBlockSize = headerInfo.microBlockSize;
            var imageType = headerInfo.imageType;
            var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);
            var numBlocksX = Math.ceil(width / microBlockSize);
            var numBlocksY = Math.ceil(height / microBlockSize);
            data.pixels.numBlocksY = numBlocksY;
            data.pixels.numBlocksX = numBlocksX;
            data.pixels.ptr = 0;
            var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z2 = 0, blockPtr = 0;
            var view, block, arrayBuf, store8, rawData;
            var blockEncoding;
            var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);
            var lastBlockHeight = height % microBlockSize || microBlockSize;
            var lastBlockWidth = width % microBlockSize || microBlockSize;
            var offsetType, offset;
            var numDims = headerInfo.numDims, iDim;
            var mask = data.pixels.resultMask;
            var resultPixels = data.pixels.resultPixels;
            var fileVersion = headerInfo.fileVersion;
            var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;
            var isDiffEncoding;
            var zMax = headerInfo.zMax;
            var resultPixelsPrevDim;
            for (blockY = 0; blockY < numBlocksY; blockY++) {
              thisBlockHeight = blockY !== numBlocksY - 1 ? microBlockSize : lastBlockHeight;
              for (blockX = 0; blockX < numBlocksX; blockX++) {
                thisBlockWidth = blockX !== numBlocksX - 1 ? microBlockSize : lastBlockWidth;
                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                outStride = width - thisBlockWidth;
                for (iDim = 0; iDim < numDims; iDim++) {
                  if (numDims > 1) {
                    resultPixelsPrevDim = resultPixels;
                    outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                    resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);
                    zMax = headerInfo.maxValues[iDim];
                  } else {
                    resultPixelsPrevDim = null;
                  }
                  bytesLeft = input.byteLength - data.ptr;
                  view = new DataView(input, data.ptr, Math.min(10, bytesLeft));
                  block = {};
                  blockPtr = 0;
                  headerByte = view.getUint8(0);
                  blockPtr++;
                  isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;
                  bits67 = headerByte >> 6 & 255;
                  testCode = headerByte >> 2 & fileVersionCheckNum;
                  if (testCode !== (blockX * microBlockSize >> 3 & fileVersionCheckNum)) {
                    throw "integrity issue";
                  }
                  if (isDiffEncoding && iDim === 0) {
                    throw "integrity issue";
                  }
                  blockEncoding = headerByte & 3;
                  if (blockEncoding > 3) {
                    data.ptr += blockPtr;
                    throw "Invalid block encoding (" + blockEncoding + ")";
                  } else if (blockEncoding === 2) {
                    if (isDiffEncoding) {
                      if (mask) {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            if (mask[outPtr]) {
                              resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                            }
                            outPtr++;
                          }
                        }
                      } else {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                            outPtr++;
                          }
                        }
                      }
                    }
                    data.counter.constant++;
                    data.ptr += blockPtr;
                    continue;
                  } else if (blockEncoding === 0) {
                    if (isDiffEncoding) {
                      throw "integrity issue";
                    }
                    data.counter.uncompressed++;
                    data.ptr += blockPtr;
                    numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;
                    bytesleft = input.byteLength - data.ptr;
                    numBytes = numBytes < bytesleft ? numBytes : bytesleft;
                    arrayBuf = new ArrayBuffer(numBytes % dataTypeSize === 0 ? numBytes : numBytes + dataTypeSize - numBytes % dataTypeSize);
                    store8 = new Uint8Array(arrayBuf);
                    store8.set(new Uint8Array(input, data.ptr, numBytes));
                    rawData = new OutPixelTypeArray(arrayBuf);
                    z2 = 0;
                    if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = rawData[z2++];
                          }
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    } else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr++] = rawData[z2++];
                        }
                        outPtr += outStride;
                      }
                    }
                    data.ptr += z2 * dataTypeSize;
                  } else {
                    offsetType = Lerc2Helpers.getDataTypeUsed(isDiffEncoding && imageType < 6 ? 4 : imageType, bits67);
                    offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);
                    blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);
                    if (blockEncoding === 3) {
                      data.ptr += blockPtr;
                      data.counter.constantoffset++;
                      if (mask) {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            if (mask[outPtr]) {
                              resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                            }
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      } else {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      }
                    } else {
                      data.ptr += blockPtr;
                      Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);
                      blockPtr = 0;
                      if (isDiffEncoding) {
                        if (mask) {
                          for (row = 0; row < thisBlockHeight; row++) {
                            for (col = 0; col < thisBlockWidth; col++) {
                              if (mask[outPtr]) {
                                resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                              }
                              outPtr++;
                            }
                            outPtr += outStride;
                          }
                        } else {
                          for (row = 0; row < thisBlockHeight; row++) {
                            for (col = 0; col < thisBlockWidth; col++) {
                              resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                              outPtr++;
                            }
                            outPtr += outStride;
                          }
                        }
                      } else if (mask) {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            if (mask[outPtr]) {
                              resultPixels[outPtr] = blockDataBuffer[blockPtr++];
                            }
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      } else {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            resultPixels[outPtr++] = blockDataBuffer[blockPtr++];
                          }
                          outPtr += outStride;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (numDims > 1 && !useBSQForOutputDim) {
              data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);
            }
          },
          /*****************
          *  private methods (helper methods)
          *****************/
          formatFileInfo: function(data) {
            return {
              "fileIdentifierString": data.headerInfo.fileIdentifierString,
              "fileVersion": data.headerInfo.fileVersion,
              "imageType": data.headerInfo.imageType,
              "height": data.headerInfo.height,
              "width": data.headerInfo.width,
              "numValidPixel": data.headerInfo.numValidPixel,
              "microBlockSize": data.headerInfo.microBlockSize,
              "blobSize": data.headerInfo.blobSize,
              "maxZError": data.headerInfo.maxZError,
              "pixelType": Lerc2Helpers.getPixelType(data.headerInfo.imageType),
              "eofOffset": data.eofOffset,
              "mask": data.mask ? {
                "numBytes": data.mask.numBytes
              } : null,
              "pixels": {
                "numBlocksX": data.pixels.numBlocksX,
                "numBlocksY": data.pixels.numBlocksY,
                //"numBytes": data.pixels.numBytes,
                "maxValue": data.headerInfo.zMax,
                "minValue": data.headerInfo.zMin,
                "noDataValue": data.noDataValue
              }
            };
          },
          constructConstantSurface: function(data, useBSQForOutputDim) {
            var val = data.headerInfo.zMax;
            var valMin = data.headerInfo.zMin;
            var maxValues = data.headerInfo.maxValues;
            var numDims = data.headerInfo.numDims;
            var numPixels = data.headerInfo.height * data.headerInfo.width;
            var i3 = 0, k2 = 0, nStart = 0;
            var mask = data.pixels.resultMask;
            var resultPixels = data.pixels.resultPixels;
            if (mask) {
              if (numDims > 1) {
                if (useBSQForOutputDim) {
                  for (i3 = 0; i3 < numDims; i3++) {
                    nStart = i3 * numPixels;
                    val = maxValues[i3];
                    for (k2 = 0; k2 < numPixels; k2++) {
                      if (mask[k2]) {
                        resultPixels[nStart + k2] = val;
                      }
                    }
                  }
                } else {
                  for (k2 = 0; k2 < numPixels; k2++) {
                    if (mask[k2]) {
                      nStart = k2 * numDims;
                      for (i3 = 0; i3 < numDims; i3++) {
                        resultPixels[nStart + numDims] = maxValues[i3];
                      }
                    }
                  }
                }
              } else {
                for (k2 = 0; k2 < numPixels; k2++) {
                  if (mask[k2]) {
                    resultPixels[k2] = val;
                  }
                }
              }
            } else {
              if (numDims > 1 && valMin !== val) {
                if (useBSQForOutputDim) {
                  for (i3 = 0; i3 < numDims; i3++) {
                    nStart = i3 * numPixels;
                    val = maxValues[i3];
                    for (k2 = 0; k2 < numPixels; k2++) {
                      resultPixels[nStart + k2] = val;
                    }
                  }
                } else {
                  for (k2 = 0; k2 < numPixels; k2++) {
                    nStart = k2 * numDims;
                    for (i3 = 0; i3 < numDims; i3++) {
                      resultPixels[nStart + i3] = maxValues[i3];
                    }
                  }
                }
              } else {
                for (k2 = 0; k2 < numPixels * numDims; k2++) {
                  resultPixels[k2] = val;
                }
              }
            }
            return;
          },
          getDataTypeArray: function(t2) {
            var tp;
            switch (t2) {
              case 0:
                tp = Int8Array;
                break;
              case 1:
                tp = Uint8Array;
                break;
              case 2:
                tp = Int16Array;
                break;
              case 3:
                tp = Uint16Array;
                break;
              case 4:
                tp = Int32Array;
                break;
              case 5:
                tp = Uint32Array;
                break;
              case 6:
                tp = Float32Array;
                break;
              case 7:
                tp = Float64Array;
                break;
              default:
                tp = Float32Array;
            }
            return tp;
          },
          getPixelType: function(t2) {
            var tp;
            switch (t2) {
              case 0:
                tp = "S8";
                break;
              case 1:
                tp = "U8";
                break;
              case 2:
                tp = "S16";
                break;
              case 3:
                tp = "U16";
                break;
              case 4:
                tp = "S32";
                break;
              case 5:
                tp = "U32";
                break;
              case 6:
                tp = "F32";
                break;
              case 7:
                tp = "F64";
                break;
              default:
                tp = "F32";
            }
            return tp;
          },
          isValidPixelValue: function(t2, val) {
            if (val == null) {
              return false;
            }
            var isValid2;
            switch (t2) {
              case 0:
                isValid2 = val >= -128 && val <= 127;
                break;
              case 1:
                isValid2 = val >= 0 && val <= 255;
                break;
              case 2:
                isValid2 = val >= -32768 && val <= 32767;
                break;
              case 3:
                isValid2 = val >= 0 && val <= 65536;
                break;
              case 4:
                isValid2 = val >= -2147483648 && val <= 2147483647;
                break;
              case 5:
                isValid2 = val >= 0 && val <= 4294967296;
                break;
              case 6:
                isValid2 = val >= -34027999387901484e22 && val <= 34027999387901484e22;
                break;
              case 7:
                isValid2 = val >= -17976931348623157e292 && val <= 17976931348623157e292;
                break;
              default:
                isValid2 = false;
            }
            return isValid2;
          },
          getDataTypeSize: function(t2) {
            var s2 = 0;
            switch (t2) {
              case 0:
              case 1:
                s2 = 1;
                break;
              case 2:
              case 3:
                s2 = 2;
                break;
              case 4:
              case 5:
              case 6:
                s2 = 4;
                break;
              case 7:
                s2 = 8;
                break;
              default:
                s2 = t2;
            }
            return s2;
          },
          getDataTypeUsed: function(dt2, tc) {
            var t2 = dt2;
            switch (dt2) {
              case 2:
              case 4:
                t2 = dt2 - tc;
                break;
              case 3:
              case 5:
                t2 = dt2 - 2 * tc;
                break;
              case 6:
                if (0 === tc) {
                  t2 = dt2;
                } else if (1 === tc) {
                  t2 = 2;
                } else {
                  t2 = 1;
                }
                break;
              case 7:
                if (0 === tc) {
                  t2 = dt2;
                } else {
                  t2 = dt2 - 2 * tc + 1;
                }
                break;
              default:
                t2 = dt2;
                break;
            }
            return t2;
          },
          getOnePixel: function(block, blockPtr, offsetType, view) {
            var temp = 0;
            switch (offsetType) {
              case 0:
                temp = view.getInt8(blockPtr);
                break;
              case 1:
                temp = view.getUint8(blockPtr);
                break;
              case 2:
                temp = view.getInt16(blockPtr, true);
                break;
              case 3:
                temp = view.getUint16(blockPtr, true);
                break;
              case 4:
                temp = view.getInt32(blockPtr, true);
                break;
              case 5:
                temp = view.getUInt32(blockPtr, true);
                break;
              case 6:
                temp = view.getFloat32(blockPtr, true);
                break;
              case 7:
                temp = view.getFloat64(blockPtr, true);
                break;
              default:
                throw "the decoder does not understand this pixel type";
            }
            return temp;
          },
          swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {
            var i3 = 0, j2 = 0, iDim = 0, temp = 0, swap = pixels;
            if (numDims > 1) {
              swap = new OutPixelTypeArray(numPixels * numDims);
              if (inputIsBIP) {
                for (i3 = 0; i3 < numPixels; i3++) {
                  temp = i3;
                  for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {
                    swap[temp] = pixels[j2++];
                  }
                }
              } else {
                for (i3 = 0; i3 < numPixels; i3++) {
                  temp = i3;
                  for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {
                    swap[j2++] = pixels[temp];
                  }
                }
              }
            }
            return swap;
          }
        };
        var TreeNode = function(val, left, right) {
          this.val = val;
          this.left = left;
          this.right = right;
        };
        var Lerc2Decode2 = {
          /*
          * ********removed options compared to LERC1. We can bring some of them back if needed.
           * removed pixel type. LERC2 is typed and doesn't require user to give pixel type
           * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.
           * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.
           * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,
           *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.
           *       We can add it back later if their's a clear requirement.
           * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)
           * removed computeUsedBitDepths.
           *
           *
           * response changes compared to LERC1
           * 1. encodedMaskData is not available
           * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)
           * 3. maskData is always available
          */
          /*****************
          *  public properties
          ******************/
          //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable
          /*****************
          *  public methods
          *****************/
          /**
           * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.
           *
           * @param {ArrayBuffer} input The LERC input byte stream
           * @param {object} [options] options Decoding options
           * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position
           * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process
           * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
           */
          decode: function(input, options) {
            options = options || {};
            var noDataValue = options.noDataValue;
            var i3 = 0, data = {};
            data.ptr = options.inputOffset || 0;
            data.pixels = {};
            if (!Lerc2Helpers.readHeaderInfo(input, data)) {
              return;
            }
            var headerInfo = data.headerInfo;
            var fileVersion = headerInfo.fileVersion;
            var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);
            if (fileVersion > 5) {
              throw "unsupported lerc version 2." + fileVersion;
            }
            Lerc2Helpers.readMask(input, data);
            if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {
              data.pixels.resultMask = options.maskData;
            }
            var numPixels = headerInfo.width * headerInfo.height;
            data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);
            data.counter = {
              onesweep: 0,
              uncompressed: 0,
              lut: 0,
              bitstuffer: 0,
              constant: 0,
              constantoffset: 0
            };
            var useBSQForOutputDim = !options.returnPixelInterleavedDims;
            if (headerInfo.numValidPixel !== 0) {
              if (headerInfo.zMax === headerInfo.zMin) {
                Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
              } else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {
                Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
              } else {
                var view = new DataView(input, data.ptr, 2);
                var bReadDataOneSweep = view.getUint8(0);
                data.ptr++;
                if (bReadDataOneSweep) {
                  Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);
                } else {
                  if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 1e-5) {
                    var flagHuffman = view.getUint8(1);
                    data.ptr++;
                    data.encodeMode = flagHuffman;
                    if (flagHuffman > 2 || fileVersion < 4 && flagHuffman > 1) {
                      throw "Invalid Huffman flag " + flagHuffman;
                    }
                    if (flagHuffman) {
                      Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);
                    } else {
                      Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
                    }
                  } else {
                    Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
                  }
                }
              }
            }
            data.eofOffset = data.ptr;
            var diff;
            if (options.inputOffset) {
              diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;
              if (Math.abs(diff) >= 1) {
                data.eofOffset = options.inputOffset + data.headerInfo.blobSize;
              }
            } else {
              diff = data.headerInfo.blobSize - data.ptr;
              if (Math.abs(diff) >= 1) {
                data.eofOffset = data.headerInfo.blobSize;
              }
            }
            var result = {
              width: headerInfo.width,
              height: headerInfo.height,
              pixelData: data.pixels.resultPixels,
              minValue: headerInfo.zMin,
              maxValue: headerInfo.zMax,
              validPixelCount: headerInfo.numValidPixel,
              dimCount: headerInfo.numDims,
              dimStats: {
                minValues: headerInfo.minValues,
                maxValues: headerInfo.maxValues
              },
              maskData: data.pixels.resultMask
              //noDataValue: noDataValue
            };
            if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {
              var mask = data.pixels.resultMask;
              for (i3 = 0; i3 < numPixels; i3++) {
                if (!mask[i3]) {
                  result.pixelData[i3] = noDataValue;
                }
              }
              result.noDataValue = noDataValue;
            }
            data.noDataValue = noDataValue;
            if (options.returnFileInfo) {
              result.fileInfo = Lerc2Helpers.formatFileInfo(data);
            }
            return result;
          },
          getBandCount: function(input) {
            var count2 = 0;
            var i3 = 0;
            var temp = {};
            temp.ptr = 0;
            temp.pixels = {};
            while (i3 < input.byteLength - 58) {
              Lerc2Helpers.readHeaderInfo(input, temp);
              i3 += temp.headerInfo.blobSize;
              count2++;
              temp.ptr = i3;
            }
            return count2;
          }
        };
        return Lerc2Decode2;
      }();
      var isPlatformLittleEndian = function() {
        var a2 = new ArrayBuffer(4);
        var b2 = new Uint8Array(a2);
        var c2 = new Uint32Array(a2);
        c2[0] = 1;
        return b2[0] === 1;
      }();
      var Lerc2 = {
        /************wrapper**********************************************/
        /**
         * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.
         *
         * @alias module:Lerc
         * @param {ArrayBuffer} input The LERC input byte stream
         * @param {object} [options] The decoding options below are optional.
         * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.
         * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.
         * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.
         * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
         * @returns {{width, height, pixels, pixelType, mask, statistics}}
           * @property {number} width Width of decoded image.
           * @property {number} height Height of decoded image.
           * @property {array} pixels [band1, band2, ] Each band is a typed array of width*height.
           * @property {string} pixelType The type of pixels represented in the output.
           * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.
           * @property {array} statistics [statistics_band1, statistics_band2, ] Each element is a statistics object representing min and max values
        **/
        decode: function(encodedData, options) {
          if (!isPlatformLittleEndian) {
            throw "Big endian system is not supported.";
          }
          options = options || {};
          var inputOffset = options.inputOffset || 0;
          var fileIdView = new Uint8Array(encodedData, inputOffset, 10);
          var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
          var lerc, majorVersion;
          if (fileIdentifierString.trim() === "CntZImage") {
            lerc = LercDecode;
            majorVersion = 1;
          } else if (fileIdentifierString.substring(0, 5) === "Lerc2") {
            lerc = Lerc2Decode;
            majorVersion = 2;
          } else {
            throw "Unexpected file identifier string: " + fileIdentifierString;
          }
          var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;
          var decodedPixelBlock = {
            width: 0,
            height: 0,
            pixels: [],
            pixelType: options.pixelType,
            mask: null,
            statistics: []
          };
          var uniqueBandMaskCount = 0;
          while (inputOffset < eof) {
            var result = lerc.decode(encodedData, {
              inputOffset,
              //for both lerc1 and lerc2
              encodedMaskData,
              //lerc1 only
              maskData,
              //lerc2 only
              returnMask: iPlane === 0 ? true : false,
              //lerc1 only
              returnEncodedMask: iPlane === 0 ? true : false,
              //lerc1 only
              returnFileInfo: true,
              //for both lerc1 and lerc2
              returnPixelInterleavedDims: options.returnPixelInterleavedDims,
              //for ndim lerc2 only
              pixelType: options.pixelType || null,
              //lerc1 only
              noDataValue: options.noDataValue || null
              //lerc1 only
            });
            inputOffset = result.fileInfo.eofOffset;
            maskData = result.maskData;
            if (iPlane === 0) {
              encodedMaskData = result.encodedMaskData;
              decodedPixelBlock.width = result.width;
              decodedPixelBlock.height = result.height;
              decodedPixelBlock.dimCount = result.dimCount || 1;
              decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;
              decodedPixelBlock.mask = maskData;
            }
            if (majorVersion > 1) {
              if (maskData) {
                bandMasks.push(maskData);
              }
              if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {
                uniqueBandMaskCount++;
              }
            }
            iPlane++;
            decodedPixelBlock.pixels.push(result.pixelData);
            decodedPixelBlock.statistics.push({
              minValue: result.minValue,
              maxValue: result.maxValue,
              noDataValue: result.noDataValue,
              dimStats: result.dimStats
            });
          }
          var i3, j2, numPixels;
          if (majorVersion > 1 && uniqueBandMaskCount > 1) {
            numPixels = decodedPixelBlock.width * decodedPixelBlock.height;
            decodedPixelBlock.bandMasks = bandMasks;
            maskData = new Uint8Array(numPixels);
            maskData.set(bandMasks[0]);
            for (i3 = 1; i3 < bandMasks.length; i3++) {
              bandMask = bandMasks[i3];
              for (j2 = 0; j2 < numPixels; j2++) {
                maskData[j2] = maskData[j2] & bandMask[j2];
              }
            }
            decodedPixelBlock.maskData = maskData;
          }
          return decodedPixelBlock;
        }
      };
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return Lerc2;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = Lerc2;
      } else {
        this.Lerc = Lerc2;
      }
    })();
  }
});

// node_modules/zstddec/dist/zstddec.modern.js
var init, instance, heap, IMPORT_OBJECT, ZSTDDecoder, wasm;
var init_zstddec_modern = __esm({
  "node_modules/zstddec/dist/zstddec.modern.js"() {
    IMPORT_OBJECT = {
      env: {
        emscripten_notify_memory_growth: function(index) {
          heap = new Uint8Array(instance.exports.memory.buffer);
        }
      }
    };
    ZSTDDecoder = class {
      init() {
        if (init)
          return init;
        if (typeof fetch !== "undefined") {
          init = fetch("data:application/wasm;base64," + wasm).then((response) => response.arrayBuffer()).then((arrayBuffer2) => WebAssembly.instantiate(arrayBuffer2, IMPORT_OBJECT)).then(this._init);
        } else {
          init = WebAssembly.instantiate(Buffer.from(wasm, "base64"), IMPORT_OBJECT).then(this._init);
        }
        return init;
      }
      _init(result) {
        instance = result.instance;
        IMPORT_OBJECT.env.emscripten_notify_memory_growth(0);
      }
      decode(array, uncompressedSize = 0) {
        if (!instance)
          throw new Error(`ZSTDDecoder: Await .init() before decoding.`);
        const compressedSize = array.byteLength;
        const compressedPtr = instance.exports.malloc(compressedSize);
        heap.set(array, compressedPtr);
        uncompressedSize = uncompressedSize || Number(instance.exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));
        const uncompressedPtr = instance.exports.malloc(uncompressedSize);
        const actualSize = instance.exports.ZSTD_decompress(uncompressedPtr, uncompressedSize, compressedPtr, compressedSize);
        const dec = heap.slice(uncompressedPtr, uncompressedPtr + actualSize);
        instance.exports.free(compressedPtr);
        instance.exports.free(uncompressedPtr);
        return dec;
      }
    };
    wasm = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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";
  }
});

// node_modules/geotiff/dist-module/compression/lerc.js
var lerc_exports = {};
__export(lerc_exports, {
  default: () => LercDecoder,
  zstd: () => zstd
});
var import_lerc, zstd, LercDecoder;
var init_lerc = __esm({
  "node_modules/geotiff/dist-module/compression/lerc.js"() {
    init_pako_esm();
    import_lerc = __toESM(require_LercDecode(), 1);
    init_zstddec_modern();
    init_basedecoder();
    init_globals();
    zstd = new ZSTDDecoder();
    LercDecoder = class extends BaseDecoder {
      constructor(fileDirectory) {
        super();
        this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== "undefined" ? fileDirectory.PlanarConfiguration : 1;
        this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== "undefined" ? fileDirectory.SamplesPerPixel : 1;
        this.addCompression = fileDirectory.LercParameters[LercParameters.AddCompression];
      }
      decodeBlock(buffer) {
        switch (this.addCompression) {
          case LercAddCompression.None:
            break;
          case LercAddCompression.Deflate:
            buffer = inflate_1(new Uint8Array(buffer)).buffer;
            break;
          case LercAddCompression.Zstandard:
            buffer = zstd.decode(new Uint8Array(buffer)).buffer;
            break;
          default:
            throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
        }
        const lercResult = import_lerc.default.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });
        const lercData = lercResult.pixels[0];
        return lercData.buffer;
      }
    };
  }
});

// node_modules/geotiff/dist-module/compression/webimage.js
var webimage_exports = {};
__export(webimage_exports, {
  default: () => WebImageDecoder
});
var WebImageDecoder;
var init_webimage = __esm({
  "node_modules/geotiff/dist-module/compression/webimage.js"() {
    init_basedecoder();
    WebImageDecoder = class extends BaseDecoder {
      constructor() {
        super();
        if (typeof createImageBitmap === "undefined") {
          throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");
        } else if (typeof document === "undefined" && typeof OffscreenCanvas === "undefined") {
          throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");
        }
      }
      async decode(fileDirectory, buffer) {
        const blob = new Blob([buffer]);
        const imageBitmap = await createImageBitmap(blob);
        let canvas2;
        if (typeof document !== "undefined") {
          canvas2 = document.createElement("canvas");
          canvas2.width = imageBitmap.width;
          canvas2.height = imageBitmap.height;
        } else {
          canvas2 = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
        }
        const ctx2 = canvas2.getContext("2d");
        ctx2.drawImage(imageBitmap, 0, 0);
        return ctx2.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;
      }
    };
  }
});

// node_modules/numcodecs/dist/chunk-INHXZS53.js
var __toBinary;
var init_chunk_INHXZS53 = __esm({
  "node_modules/numcodecs/dist/chunk-INHXZS53.js"() {
    __toBinary = /* @__PURE__ */ (() => {
      var table = new Uint8Array(128);
      for (var i3 = 0; i3 < 64; i3++)
        table[i3 < 26 ? i3 + 65 : i3 < 52 ? i3 + 71 : i3 < 62 ? i3 - 4 : i3 * 4 - 205] = i3;
      return (base64) => {
        var n2 = base64.length, bytes = new Uint8Array((n2 - (base64[n2 - 1] == "=") - (base64[n2 - 2] == "=")) * 3 / 4 | 0);
        for (var i22 = 0, j2 = 0; i22 < n2; ) {
          var c0 = table[base64.charCodeAt(i22++)], c1 = table[base64.charCodeAt(i22++)];
          var c2 = table[base64.charCodeAt(i22++)], c3 = table[base64.charCodeAt(i22++)];
          bytes[j2++] = c0 << 2 | c1 >> 4;
          bytes[j2++] = c1 << 4 | c2 >> 2;
          bytes[j2++] = c2 << 6 | c3;
        }
        return bytes;
      };
    })();
  }
});

// node_modules/numcodecs/dist/blosc.js
var blosc_exports = {};
__export(blosc_exports, {
  default: () => blosc_default
});
var blosc_codec, blosc_codec_default, blosc_codec_default2, COMPRESSORS, emscriptenModule, init2, _a, Blosc, blosc_default;
var init_blosc = __esm({
  "node_modules/numcodecs/dist/blosc.js"() {
    init_chunk_INHXZS53();
    blosc_codec = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      return function(moduleArg = {}) {
        var f2 = moduleArg, aa, q2;
        f2.ready = new Promise((a2, b2) => {
          aa = a2;
          q2 = b2;
        });
        var ba = Object.assign({}, f2), ca = "./this.program", ea = f2.print || console.log.bind(console), t2 = f2.printErr || console.error.bind(console);
        Object.assign(f2, ba);
        ba = null;
        f2.thisProgram && (ca = f2.thisProgram);
        var u2;
        f2.wasmBinary && (u2 = f2.wasmBinary);
        "object" != typeof WebAssembly && x2("no native wasm support detected");
        var y2, fa = false, A3, B3, D3, E3, F2, G3, ha, ia;
        function ja() {
          var a2 = y2.buffer;
          f2.HEAP8 = A3 = new Int8Array(a2);
          f2.HEAP16 = D3 = new Int16Array(a2);
          f2.HEAPU8 = B3 = new Uint8Array(a2);
          f2.HEAPU16 = E3 = new Uint16Array(a2);
          f2.HEAP32 = F2 = new Int32Array(a2);
          f2.HEAPU32 = G3 = new Uint32Array(a2);
          f2.HEAPF32 = ha = new Float32Array(a2);
          f2.HEAPF64 = ia = new Float64Array(a2);
        }
        var ka = [], la = [], ma = [];
        function na() {
          var a2 = f2.preRun.shift();
          ka.unshift(a2);
        }
        var H2 = 0, I3 = null, J2 = null;
        function x2(a2) {
          f2.onAbort?.(a2);
          a2 = "Aborted(" + a2 + ")";
          t2(a2);
          fa = true;
          a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
          q2(a2);
          throw a2;
        }
        var oa = (a2) => a2.startsWith("data:application/octet-stream;base64,"), pa = (a2) => a2.startsWith("file://"), L2;
        L2 = "blosc_codec.wasm";
        if (!oa(L2)) {
          var qa = L2;
          L2 = f2.locateFile ? f2.locateFile(qa, "") : "" + qa;
        }
        function ra(a2) {
          return Promise.resolve().then(() => {
            if (a2 == L2 && u2)
              var b2 = new Uint8Array(u2);
            else
              throw "both async and sync fetching of the wasm failed";
            return b2;
          });
        }
        function sa(a2, b2, c2) {
          return ra(a2).then((d2) => WebAssembly.instantiate(d2, b2)).then((d2) => d2).then(c2, (d2) => {
            t2(`failed to asynchronously prepare wasm: ${d2}`);
            x2(d2);
          });
        }
        function ta(a2, b2) {
          var c2 = L2;
          return u2 || "function" != typeof WebAssembly.instantiateStreaming || oa(c2) || pa(c2) || "function" != typeof fetch ? sa(c2, a2, b2) : fetch(c2, { credentials: "same-origin" }).then((d2) => WebAssembly.instantiateStreaming(d2, a2).then(b2, function(e2) {
            t2(`wasm streaming compile failed: ${e2}`);
            t2("falling back to ArrayBuffer instantiation");
            return sa(c2, a2, b2);
          }));
        }
        var M2 = (a2) => {
          for (; 0 < a2.length; )
            a2.shift()(f2);
        };
        function ua(a2) {
          this.H = a2 - 24;
          this.N = function(b2) {
            G3[this.H + 4 >> 2] = b2;
          };
          this.M = function(b2) {
            G3[this.H + 8 >> 2] = b2;
          };
          this.I = function(b2, c2) {
            this.J();
            this.N(b2);
            this.M(c2);
          };
          this.J = function() {
            G3[this.H + 16 >> 2] = 0;
          };
        }
        var va = 0, wa = 0, xa, N3 = (a2) => {
          for (var b2 = ""; B3[a2]; )
            b2 += xa[B3[a2++]];
          return b2;
        }, O2 = {}, P2 = {}, Q3 = {}, R2, ya = (a2) => {
          throw new R2(a2);
        }, S2, za = (a2, b2) => {
          function c2(l2) {
            l2 = b2(l2);
            if (l2.length !== d2.length)
              throw new S2("Mismatched type converter count");
            for (var g3 = 0; g3 < d2.length; ++g3)
              T2(d2[g3], l2[g3]);
          }
          var d2 = [];
          d2.forEach(function(l2) {
            Q3[l2] = a2;
          });
          var e2 = Array(a2.length), h2 = [], k2 = 0;
          a2.forEach((l2, g3) => {
            P2.hasOwnProperty(l2) ? e2[g3] = P2[l2] : (h2.push(l2), O2.hasOwnProperty(l2) || (O2[l2] = []), O2[l2].push(() => {
              e2[g3] = P2[l2];
              ++k2;
              k2 === h2.length && c2(e2);
            }));
          });
          0 === h2.length && c2(e2);
        };
        function Aa(a2, b2, c2 = {}) {
          var d2 = b2.name;
          if (!a2)
            throw new R2(`type "${d2}" must have a positive integer typeid pointer`);
          if (P2.hasOwnProperty(a2)) {
            if (c2.P)
              return;
            throw new R2(`Cannot register type '${d2}' twice`);
          }
          P2[a2] = b2;
          delete Q3[a2];
          O2.hasOwnProperty(a2) && (b2 = O2[a2], delete O2[a2], b2.forEach((e2) => e2()));
        }
        function T2(a2, b2, c2 = {}) {
          if (!("argPackAdvance" in b2))
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          Aa(a2, b2, c2);
        }
        function Ba() {
          this.F = [void 0];
          this.K = [];
        }
        var U2 = new Ba(), Ca = (a2) => {
          a2 >= U2.H && 0 === --U2.get(a2).L && U2.J(a2);
        }, Da = (a2) => {
          switch (a2) {
            case void 0:
              return 1;
            case null:
              return 2;
            case true:
              return 3;
            case false:
              return 4;
            default:
              return U2.I({ L: 1, value: a2 });
          }
        };
        function Ea(a2) {
          return this.fromWireType(F2[a2 >> 2]);
        }
        var Fa = (a2, b2) => {
          switch (b2) {
            case 4:
              return function(c2) {
                return this.fromWireType(ha[c2 >> 2]);
              };
            case 8:
              return function(c2) {
                return this.fromWireType(ia[c2 >> 3]);
              };
            default:
              throw new TypeError(`invalid float width (${b2}): ${a2}`);
          }
        }, V2 = (a2, b2) => Object.defineProperty(b2, "name", { value: a2 }), Ga = (a2) => {
          for (; a2.length; ) {
            var b2 = a2.pop();
            a2.pop()(b2);
          }
        };
        function Ha(a2) {
          for (var b2 = 1; b2 < a2.length; ++b2)
            if (null !== a2[b2] && void 0 === a2[b2].G)
              return true;
          return false;
        }
        function La(a2) {
          var b2 = Function;
          if (!(b2 instanceof Function))
            throw new TypeError(`new_ called with constructor type ${typeof b2} which is not a function`);
          var c2 = V2(b2.name || "unknownFunctionName", function() {
          });
          c2.prototype = b2.prototype;
          c2 = new c2();
          a2 = b2.apply(c2, a2);
          return a2 instanceof Object ? a2 : c2;
        }
        var Ma = (a2, b2) => {
          if (void 0 === f2[a2].C) {
            var c2 = f2[a2];
            f2[a2] = function() {
              if (!f2[a2].C.hasOwnProperty(arguments.length))
                throw new R2(`Function '${b2}' called with an invalid number of arguments (${arguments.length}) - expects one of (${f2[a2].C})!`);
              return f2[a2].C[arguments.length].apply(this, arguments);
            };
            f2[a2].C = [];
            f2[a2].C[c2.O] = c2;
          }
        }, Na = (a2, b2, c2) => {
          if (f2.hasOwnProperty(a2)) {
            if (void 0 === c2 || void 0 !== f2[a2].C && void 0 !== f2[a2].C[c2])
              throw new R2(`Cannot register public name '${a2}' twice`);
            Ma(a2, a2);
            if (f2.hasOwnProperty(c2))
              throw new R2(`Cannot register multiple overloads of a function with the same number of arguments (${c2})!`);
            f2[a2].C[c2] = b2;
          } else
            f2[a2] = b2, void 0 !== c2 && (f2[a2].S = c2);
        }, Oa = (a2, b2) => {
          for (var c2 = [], d2 = 0; d2 < a2; d2++)
            c2.push(G3[b2 + 4 * d2 >> 2]);
          return c2;
        }, Pa, Qa = (a2, b2) => {
          var c2 = [];
          return function() {
            c2.length = 0;
            Object.assign(c2, arguments);
            if (a2.includes("j")) {
              var d2 = f2["dynCall_" + a2];
              d2 = c2 && c2.length ? d2.apply(null, [b2].concat(c2)) : d2.call(null, b2);
            } else
              d2 = Pa.get(b2).apply(null, c2);
            return d2;
          };
        }, Ra = (a2, b2) => {
          a2 = N3(a2);
          var c2 = a2.includes("j") ? Qa(a2, b2) : Pa.get(b2);
          if ("function" != typeof c2)
            throw new R2(`unknown function pointer with signature ${a2}: ${b2}`);
          return c2;
        }, Sa, Ua = (a2) => {
          a2 = Ta(a2);
          var b2 = N3(a2);
          W2(a2);
          return b2;
        }, Va = (a2, b2) => {
          function c2(h2) {
            e2[h2] || P2[h2] || (Q3[h2] ? Q3[h2].forEach(c2) : (d2.push(h2), e2[h2] = true));
          }
          var d2 = [], e2 = {};
          b2.forEach(c2);
          throw new Sa(`${a2}: ` + d2.map(Ua).join([", "]));
        }, Wa = (a2) => {
          a2 = a2.trim();
          const b2 = a2.indexOf("(");
          return -1 !== b2 ? a2.substr(0, b2) : a2;
        }, Xa = (a2, b2, c2) => {
          switch (b2) {
            case 1:
              return c2 ? (d2) => A3[d2 >> 0] : (d2) => B3[d2 >> 0];
            case 2:
              return c2 ? (d2) => D3[d2 >> 1] : (d2) => E3[d2 >> 1];
            case 4:
              return c2 ? (d2) => F2[d2 >> 2] : (d2) => G3[d2 >> 2];
            default:
              throw new TypeError(`invalid integer width (${b2}): ${a2}`);
          }
        };
        function Ya(a2) {
          return this.fromWireType(G3[a2 >> 2]);
        }
        for (var Za = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, $a = (a2, b2, c2) => {
          var d2 = b2 + c2;
          for (c2 = b2; a2[c2] && !(c2 >= d2); )
            ++c2;
          if (16 < c2 - b2 && a2.buffer && Za)
            return Za.decode(a2.subarray(b2, c2));
          for (d2 = ""; b2 < c2; ) {
            var e2 = a2[b2++];
            if (e2 & 128) {
              var h2 = a2[b2++] & 63;
              if (192 == (e2 & 224))
                d2 += String.fromCharCode((e2 & 31) << 6 | h2);
              else {
                var k2 = a2[b2++] & 63;
                e2 = 224 == (e2 & 240) ? (e2 & 15) << 12 | h2 << 6 | k2 : (e2 & 7) << 18 | h2 << 12 | k2 << 6 | a2[b2++] & 63;
                65536 > e2 ? d2 += String.fromCharCode(e2) : (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023));
              }
            } else
              d2 += String.fromCharCode(e2);
          }
          return d2;
        }, ab = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, bb = (a2, b2) => {
          var c2 = a2 >> 1;
          for (var d2 = c2 + b2 / 2; !(c2 >= d2) && E3[c2]; )
            ++c2;
          c2 <<= 1;
          if (32 < c2 - a2 && ab)
            return ab.decode(B3.subarray(a2, c2));
          c2 = "";
          for (d2 = 0; !(d2 >= b2 / 2); ++d2) {
            var e2 = D3[a2 + 2 * d2 >> 1];
            if (0 == e2)
              break;
            c2 += String.fromCharCode(e2);
          }
          return c2;
        }, cb = (a2, b2, c2) => {
          c2 ?? (c2 = 2147483647);
          if (2 > c2)
            return 0;
          c2 -= 2;
          var d2 = b2;
          c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
          for (var e2 = 0; e2 < c2; ++e2)
            D3[b2 >> 1] = a2.charCodeAt(e2), b2 += 2;
          D3[b2 >> 1] = 0;
          return b2 - d2;
        }, db = (a2) => 2 * a2.length, eb = (a2, b2) => {
          for (var c2 = 0, d2 = ""; !(c2 >= b2 / 4); ) {
            var e2 = F2[a2 + 4 * c2 >> 2];
            if (0 == e2)
              break;
            ++c2;
            65536 <= e2 ? (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023)) : d2 += String.fromCharCode(e2);
          }
          return d2;
        }, fb = (a2, b2, c2) => {
          c2 ?? (c2 = 2147483647);
          if (4 > c2)
            return 0;
          var d2 = b2;
          c2 = d2 + c2 - 4;
          for (var e2 = 0; e2 < a2.length; ++e2) {
            var h2 = a2.charCodeAt(e2);
            if (55296 <= h2 && 57343 >= h2) {
              var k2 = a2.charCodeAt(++e2);
              h2 = 65536 + ((h2 & 1023) << 10) | k2 & 1023;
            }
            F2[b2 >> 2] = h2;
            b2 += 4;
            if (b2 + 4 > c2)
              break;
          }
          F2[b2 >> 2] = 0;
          return b2 - d2;
        }, gb = (a2) => {
          for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
            var d2 = a2.charCodeAt(c2);
            55296 <= d2 && 57343 >= d2 && ++c2;
            b2 += 4;
          }
          return b2;
        }, hb = {}, jb = () => {
          if (!ib) {
            var a2 = {
              USER: "web_user",
              LOGNAME: "web_user",
              PATH: "/",
              PWD: "/",
              HOME: "/home/web_user",
              LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
              _: ca || "./this.program"
            }, b2;
            for (b2 in hb)
              void 0 === hb[b2] ? delete a2[b2] : a2[b2] = hb[b2];
            var c2 = [];
            for (b2 in a2)
              c2.push(`${b2}=${a2[b2]}`);
            ib = c2;
          }
          return ib;
        }, ib, kb = [null, [], []], lb = Array(256), X2 = 0; 256 > X2; ++X2)
          lb[X2] = String.fromCharCode(X2);
        xa = lb;
        R2 = f2.BindingError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "BindingError";
          }
        };
        S2 = f2.InternalError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "InternalError";
          }
        };
        Object.assign(Ba.prototype, { get(a2) {
          return this.F[a2];
        }, has(a2) {
          return void 0 !== this.F[a2];
        }, I(a2) {
          var b2 = this.K.pop() || this.F.length;
          this.F[b2] = a2;
          return b2;
        }, J(a2) {
          this.F[a2] = void 0;
          this.K.push(a2);
        } });
        U2.F.push({ value: void 0 }, { value: null }, { value: true }, { value: false });
        U2.H = U2.F.length;
        f2.count_emval_handles = () => {
          for (var a2 = 0, b2 = U2.H; b2 < U2.F.length; ++b2)
            void 0 !== U2.F[b2] && ++a2;
          return a2;
        };
        Sa = f2.UnboundTypeError = ((a2, b2) => {
          var c2 = V2(b2, function(d2) {
            this.name = b2;
            this.message = d2;
            d2 = Error(d2).stack;
            void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
          });
          c2.prototype = Object.create(a2.prototype);
          c2.prototype.constructor = c2;
          c2.prototype.toString = function() {
            return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;
          };
          return c2;
        })(Error, "UnboundTypeError");
        var nb = {
          p: (a2, b2, c2) => {
            new ua(a2).I(b2, c2);
            va = a2;
            wa++;
            throw va;
          },
          o: () => {
          },
          l: (a2, b2, c2, d2) => {
            b2 = N3(b2);
            T2(a2, { name: b2, fromWireType: function(e2) {
              return !!e2;
            }, toWireType: function(e2, h2) {
              return h2 ? c2 : d2;
            }, argPackAdvance: 8, readValueFromPointer: function(e2) {
              return this.fromWireType(B3[e2]);
            }, G: null });
          },
          k: (a2, b2) => {
            b2 = N3(b2);
            T2(a2, { name: b2, fromWireType: (c2) => {
              if (!c2)
                throw new R2("Cannot use deleted val. handle = " + c2);
              var d2 = U2.get(c2).value;
              Ca(c2);
              return d2;
            }, toWireType: (c2, d2) => Da(d2), argPackAdvance: 8, readValueFromPointer: Ea, G: null });
          },
          i: (a2, b2, c2) => {
            b2 = N3(b2);
            T2(a2, { name: b2, fromWireType: (d2) => d2, toWireType: (d2, e2) => e2, argPackAdvance: 8, readValueFromPointer: Fa(b2, c2), G: null });
          },
          d: (a2, b2, c2, d2, e2, h2, k2) => {
            var l2 = Oa(b2, c2);
            a2 = N3(a2);
            a2 = Wa(a2);
            e2 = Ra(d2, e2);
            Na(a2, function() {
              Va(`Cannot call ${a2} due to unbound types`, l2);
            }, b2 - 1);
            za(l2, function(g3) {
              var m2 = a2;
              var p2 = a2;
              g3 = [g3[0], null].concat(g3.slice(1));
              var r2 = e2, n2 = g3.length;
              if (2 > n2)
                throw new R2("argTypes array size mismatch! Must at least get return value and 'this' types!");
              var v2 = null !== g3[1] && false, C3 = Ha(g3), Ia = "void" !== g3[0].name;
              r2 = [ya, r2, h2, Ga, g3[0], g3[1]];
              for (var w3 = 0; w3 < n2 - 2; ++w3)
                r2.push(g3[w3 + 2]);
              if (!C3)
                for (w3 = v2 ? 1 : 2; w3 < g3.length; ++w3)
                  null !== g3[w3].G && r2.push(g3[w3].G);
              C3 = Ha(g3);
              w3 = g3.length;
              var z2 = "", K2 = "";
              for (n2 = 0; n2 < w3 - 2; ++n2)
                z2 += (0 !== n2 ? ", " : "") + "arg" + n2, K2 += (0 !== n2 ? ", " : "") + "arg" + n2 + "Wired";
              z2 = `
        return function (${z2}) {
        if (arguments.length !== ${w3 - 2}) {
          throwBindingError('function ${p2} called with ' + arguments.length + ' arguments, expected ${w3 - 2}');
        }`;
              C3 && (z2 += "var destructors = [];\n");
              var Ja = C3 ? "destructors" : "null", da = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
              v2 && (z2 += "var thisWired = classParam['toWireType'](" + Ja + ", this);\n");
              for (n2 = 0; n2 < w3 - 2; ++n2)
                z2 += "var arg" + n2 + "Wired = argType" + n2 + "['toWireType'](" + Ja + ", arg" + n2 + "); // " + g3[n2 + 2].name + "\n", da.push("argType" + n2);
              v2 && (K2 = "thisWired" + (0 < K2.length ? ", " : "") + K2);
              z2 += (Ia || k2 ? "var rv = " : "") + "invoker(fn" + (0 < K2.length ? ", " : "") + K2 + ");\n";
              if (C3)
                z2 += "runDestructors(destructors);\n";
              else
                for (n2 = v2 ? 1 : 2; n2 < g3.length; ++n2)
                  v2 = 1 === n2 ? "thisWired" : "arg" + (n2 - 2) + "Wired", null !== g3[n2].G && (z2 += v2 + "_dtor(" + v2 + "); // " + g3[n2].name + "\n", da.push(v2 + "_dtor"));
              Ia && (z2 += "var ret = retType['fromWireType'](rv);\nreturn ret;\n");
              let [Ka, ob] = [da, z2 + "}\n"];
              Ka.push(ob);
              g3 = La(Ka).apply(null, r2);
              p2 = V2(p2, g3);
              g3 = b2 - 1;
              if (!f2.hasOwnProperty(m2))
                throw new S2("Replacing nonexistant public symbol");
              void 0 !== f2[m2].C && void 0 !== g3 ? f2[m2].C[g3] = p2 : (f2[m2] = p2, f2[m2].O = g3);
              return [];
            });
          },
          b: (a2, b2, c2, d2, e2) => {
            b2 = N3(b2);
            -1 === e2 && (e2 = 4294967295);
            e2 = (l2) => l2;
            if (0 === d2) {
              var h2 = 32 - 8 * c2;
              e2 = (l2) => l2 << h2 >>> h2;
            }
            var k2 = b2.includes("unsigned") ? function(l2, g3) {
              return g3 >>> 0;
            } : function(l2, g3) {
              return g3;
            };
            T2(a2, {
              name: b2,
              fromWireType: e2,
              toWireType: k2,
              argPackAdvance: 8,
              readValueFromPointer: Xa(b2, c2, 0 !== d2),
              G: null
            });
          },
          a: (a2, b2, c2) => {
            function d2(h2) {
              return new e2(A3.buffer, G3[h2 + 4 >> 2], G3[h2 >> 2]);
            }
            var e2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b2];
            c2 = N3(c2);
            T2(a2, { name: c2, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { P: true });
          },
          e: (a2, b2) => {
            b2 = N3(b2);
            var c2 = "std::string" === b2;
            T2(a2, { name: b2, fromWireType: function(d2) {
              var e2 = G3[d2 >> 2], h2 = d2 + 4;
              if (c2)
                for (var k2 = h2, l2 = 0; l2 <= e2; ++l2) {
                  var g3 = h2 + l2;
                  if (l2 == e2 || 0 == B3[g3]) {
                    k2 = k2 ? $a(B3, k2, g3 - k2) : "";
                    if (void 0 === m2)
                      var m2 = k2;
                    else
                      m2 += String.fromCharCode(0), m2 += k2;
                    k2 = g3 + 1;
                  }
                }
              else {
                m2 = Array(e2);
                for (l2 = 0; l2 < e2; ++l2)
                  m2[l2] = String.fromCharCode(B3[h2 + l2]);
                m2 = m2.join("");
              }
              W2(d2);
              return m2;
            }, toWireType: function(d2, e2) {
              e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2));
              var h2, k2 = "string" == typeof e2;
              if (!(k2 || e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray || e2 instanceof Int8Array))
                throw new R2("Cannot pass non-string to std::string");
              var l2;
              if (c2 && k2)
                for (h2 = l2 = 0; h2 < e2.length; ++h2) {
                  var g3 = e2.charCodeAt(h2);
                  127 >= g3 ? l2++ : 2047 >= g3 ? l2 += 2 : 55296 <= g3 && 57343 >= g3 ? (l2 += 4, ++h2) : l2 += 3;
                }
              else
                l2 = e2.length;
              h2 = l2;
              l2 = mb(4 + h2 + 1);
              g3 = l2 + 4;
              G3[l2 >> 2] = h2;
              if (c2 && k2) {
                if (k2 = g3, g3 = h2 + 1, h2 = B3, 0 < g3) {
                  g3 = k2 + g3 - 1;
                  for (var m2 = 0; m2 < e2.length; ++m2) {
                    var p2 = e2.charCodeAt(m2);
                    if (55296 <= p2 && 57343 >= p2) {
                      var r2 = e2.charCodeAt(++m2);
                      p2 = 65536 + ((p2 & 1023) << 10) | r2 & 1023;
                    }
                    if (127 >= p2) {
                      if (k2 >= g3)
                        break;
                      h2[k2++] = p2;
                    } else {
                      if (2047 >= p2) {
                        if (k2 + 1 >= g3)
                          break;
                        h2[k2++] = 192 | p2 >> 6;
                      } else {
                        if (65535 >= p2) {
                          if (k2 + 2 >= g3)
                            break;
                          h2[k2++] = 224 | p2 >> 12;
                        } else {
                          if (k2 + 3 >= g3)
                            break;
                          h2[k2++] = 240 | p2 >> 18;
                          h2[k2++] = 128 | p2 >> 12 & 63;
                        }
                        h2[k2++] = 128 | p2 >> 6 & 63;
                      }
                      h2[k2++] = 128 | p2 & 63;
                    }
                  }
                  h2[k2] = 0;
                }
              } else if (k2)
                for (k2 = 0; k2 < h2; ++k2) {
                  m2 = e2.charCodeAt(k2);
                  if (255 < m2)
                    throw W2(g3), new R2("String has UTF-16 code units that do not fit in 8 bits");
                  B3[g3 + k2] = m2;
                }
              else
                for (k2 = 0; k2 < h2; ++k2)
                  B3[g3 + k2] = e2[k2];
              null !== d2 && d2.push(W2, l2);
              return l2;
            }, argPackAdvance: 8, readValueFromPointer: Ya, G(d2) {
              W2(d2);
            } });
          },
          c: (a2, b2, c2) => {
            c2 = N3(c2);
            if (2 === b2) {
              var d2 = bb;
              var e2 = cb;
              var h2 = db;
              var k2 = () => E3;
              var l2 = 1;
            } else
              4 === b2 && (d2 = eb, e2 = fb, h2 = gb, k2 = () => G3, l2 = 2);
            T2(a2, { name: c2, fromWireType: (g3) => {
              for (var m2 = G3[g3 >> 2], p2 = k2(), r2, n2 = g3 + 4, v2 = 0; v2 <= m2; ++v2) {
                var C3 = g3 + 4 + v2 * b2;
                if (v2 == m2 || 0 == p2[C3 >> l2])
                  n2 = d2(n2, C3 - n2), void 0 === r2 ? r2 = n2 : (r2 += String.fromCharCode(0), r2 += n2), n2 = C3 + b2;
              }
              W2(g3);
              return r2;
            }, toWireType: (g3, m2) => {
              if ("string" != typeof m2)
                throw new R2(`Cannot pass non-string to C++ string type ${c2}`);
              var p2 = h2(m2), r2 = mb(4 + p2 + b2);
              G3[r2 >> 2] = p2 >> l2;
              e2(m2, r2 + 4, p2 + b2);
              null !== g3 && g3.push(W2, r2);
              return r2;
            }, argPackAdvance: 8, readValueFromPointer: Ea, G(g3) {
              W2(g3);
            } });
          },
          m: (a2, b2) => {
            b2 = N3(b2);
            T2(a2, { R: true, name: b2, argPackAdvance: 0, fromWireType: () => {
            }, toWireType: () => {
            } });
          },
          g: Ca,
          j: (a2) => {
            4 < a2 && (U2.get(a2).L += 1);
          },
          f: (a2, b2) => {
            var c2 = P2[a2];
            if (void 0 === c2)
              throw a2 = "_emval_take_value has unknown type " + Ua(a2), new R2(a2);
            a2 = c2;
            a2 = a2.readValueFromPointer(b2);
            return Da(a2);
          },
          h: () => {
            x2("");
          },
          v: (a2, b2, c2) => B3.copyWithin(a2, b2, b2 + c2),
          q: (a2) => {
            var b2 = B3.length;
            a2 >>>= 0;
            if (2147483648 < a2)
              return false;
            for (var c2 = 1; 4 >= c2; c2 *= 2) {
              var d2 = b2 * (1 + 0.2 / c2);
              d2 = Math.min(d2, a2 + 100663296);
              var e2 = Math;
              d2 = Math.max(a2, d2);
              a: {
                e2 = (e2.min.call(e2, 2147483648, d2 + (65536 - d2 % 65536) % 65536) - y2.buffer.byteLength + 65535) / 65536;
                try {
                  y2.grow(e2);
                  ja();
                  var h2 = 1;
                  break a;
                } catch (k2) {
                }
                h2 = void 0;
              }
              if (h2)
                return true;
            }
            return false;
          },
          t: (a2, b2) => {
            var c2 = 0;
            jb().forEach((d2, e2) => {
              var h2 = b2 + c2;
              e2 = G3[a2 + 4 * e2 >> 2] = h2;
              for (h2 = 0; h2 < d2.length; ++h2)
                A3[e2++ >> 0] = d2.charCodeAt(h2);
              A3[e2 >> 0] = 0;
              c2 += d2.length + 1;
            });
            return 0;
          },
          u: (a2, b2) => {
            var c2 = jb();
            G3[a2 >> 2] = c2.length;
            var d2 = 0;
            c2.forEach((e2) => d2 += e2.length + 1);
            G3[b2 >> 2] = d2;
            return 0;
          },
          s: () => 52,
          n: function() {
            return 70;
          },
          r: (a2, b2, c2, d2) => {
            for (var e2 = 0, h2 = 0; h2 < c2; h2++) {
              var k2 = G3[b2 >> 2], l2 = G3[b2 + 4 >> 2];
              b2 += 8;
              for (var g3 = 0; g3 < l2; g3++) {
                var m2 = B3[k2 + g3], p2 = kb[a2];
                0 === m2 || 10 === m2 ? ((1 === a2 ? ea : t2)($a(p2, 0)), p2.length = 0) : p2.push(m2);
              }
              e2 += l2;
            }
            G3[d2 >> 2] = e2;
            return 0;
          }
        }, Y2 = function() {
          function a2(c2) {
            Y2 = c2.exports;
            y2 = Y2.w;
            ja();
            Pa = Y2.A;
            la.unshift(Y2.x);
            H2--;
            f2.monitorRunDependencies?.(H2);
            0 == H2 && (null !== I3 && (clearInterval(I3), I3 = null), J2 && (c2 = J2, J2 = null, c2()));
            return Y2;
          }
          var b2 = { a: nb };
          H2++;
          f2.monitorRunDependencies?.(H2);
          if (f2.instantiateWasm)
            try {
              return f2.instantiateWasm(
                b2,
                a2
              );
            } catch (c2) {
              t2(`Module.instantiateWasm callback failed with error: ${c2}`), q2(c2);
            }
          ta(b2, function(c2) {
            a2(c2.instance);
          }).catch(q2);
          return {};
        }(), mb = (a2) => (mb = Y2.y)(a2), W2 = (a2) => (W2 = Y2.z)(a2), Ta = (a2) => (Ta = Y2.B)(a2);
        f2.dynCall_jiji = (a2, b2, c2, d2, e2) => (f2.dynCall_jiji = Y2.D)(a2, b2, c2, d2, e2);
        var Z2;
        J2 = function pb() {
          Z2 || qb();
          Z2 || (J2 = pb);
        };
        function qb() {
          function a2() {
            if (!Z2 && (Z2 = true, f2.calledRun = true, !fa)) {
              M2(la);
              aa(f2);
              if (f2.onRuntimeInitialized)
                f2.onRuntimeInitialized();
              if (f2.postRun)
                for ("function" == typeof f2.postRun && (f2.postRun = [f2.postRun]); f2.postRun.length; ) {
                  var b2 = f2.postRun.shift();
                  ma.unshift(b2);
                }
              M2(ma);
            }
          }
          if (!(0 < H2)) {
            if (f2.preRun)
              for ("function" == typeof f2.preRun && (f2.preRun = [f2.preRun]); f2.preRun.length; )
                na();
            M2(ka);
            0 < H2 || (f2.setStatus ? (f2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                f2.setStatus("");
              }, 1);
              a2();
            }, 1)) : a2());
          }
        }
        if (f2.preInit)
          for ("function" == typeof f2.preInit && (f2.preInit = [f2.preInit]); 0 < f2.preInit.length; )
            f2.preInit.pop()();
        qb();
        return moduleArg.ready;
      };
    })();
    blosc_codec_default = blosc_codec;
    blosc_codec_default2 = __toBinary("AGFzbQEAAAABvwEWYAJ/fwBgBX9/f39/AX9gAn9/AX9gAX8Bf2ADf39/AX9gA39/fwBgBH9/f38Bf2AAAGABfwBgBH9/f38AYAZ/f39/f38AYAV/f39/fwBgBn9/f39/fwF/YAN/fn8BfmAHf39/f39/fwBgB39/f39/f38Bf2APf39/f39/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gCH9/f39/f39/AX9gDX9/f39/f39/f39/f38Bf2ABfwF+YAR/f35+AAKFARYBYQFhAAUBYQFiAAsBYQFjAAUBYQFkAA4BYQFlAAABYQFmAAIBYQFnAAgBYQFoAAcBYQFpAAUBYQFqAAgBYQFrAAABYQFsAAkBYQFtAAABYQFuAAEBYQFvAA4BYQFwAAUBYQFxAAMBYQFyAAYBYQFzAAMBYQF0AAIBYQF1AAIBYQF2AAUDogGgAQEEBAgEAQkDBAQAAwYJAgsGBAgFAQgEAwAPBwMDBgwGAwEMAQEADAQIEBEBBQMEAgQHBBITBgcAAAwDAQYFBQIJCBQMBQcDBwIDFQgFBQkCAgUDAwEDAwgFBwQBAQEGAQEBAQEBAQEBAQEEAgICBgYFBgYGAAACBwgKDAADAgEDAwMKCwkJCwoEBAcHDQMNBAMDAQEBAQEBAQEBAQEBAQEEBQFwAVFRBQcBAYACgIACBg0CfwFBwPQFC38BQQALByQIAXcCAAF4AEwBeQAdAXoAGQFBAQABQgCnAQFDAJcBAUQAlAEJiAEBAEEBC1AyKJIBjAGLATIohgGAAV2TAZEBkAGPAY4BjQGJAYgBhwGFAYQBXFssigFvgwGCAYEBfH92d3h5rgGtAawBen2yAbEBsAGvAakBqAF7frMBtAG1AXWrAaoBpgGlAaQBowGiAaABMihtbZ8BYZUBYSieAZgBmQGaASidAZwBmwEyKJYBCvuTGaABggMBBH8gAyABAn8CQAJAIAAiBSAFIAMgASIGa2oiASACIAEgAkkbIgFBA2siCE8NACAFKAAAIAYoAABzIgcNAQNAIAZBBGohBiAFQQRqIgUgCE8NASAFKAAAIAYoAABzIgdFDQALIAUgB2hBA3ZqIABrDAILAkAgBSABQQFrTw0AIAYvAAAgBS8AAEcNACAGQQJqIQYgBUECaiEFCyABIAVLBH8gBSAGLQAAIAUtAABGagUgBQsgAGsMAQsgB2hBA3YLIgZqRgR/An8CQCACQQNrIgEgACAGaiIATQRAIAAhBQwBCyAAKAAAIAQoAABzIgNFBEAgACEFA0AgBEEEaiEEIAVBBGoiBSABTw0CIAUoAAAgBCgAAHMiA0UNAAsgBSADaEEDdmogAGsMAgsgA2hBA3YMAQsCQCAFIAJBAWtPDQAgBC8AACAFLwAARw0AIARBAmohBCAFQQJqIQULIAIgBUsEfyAFIAQtAAAgBS0AAEZqBSAFCyAAawsgBmoFIAYLC4AEAQN/IAJBgARPBEAgACABIAIQFSAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAvyAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkEEayABNgIAIARBCUkNACADIAE2AgggAyAB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ACABLQAUOgAUIAAgAS0AFToAFSAAIAEtABY6ABYgACABLQAXOgAXIAAgAS0AGDoAGCAAIAEtABk6ABkgACABLQAaOgAaIAAgAS0AGzoAGyAAIAEtABw6ABwgACABLQAdOgAdIAAgAS0AHjoAHiAAIAEtAB86AB8gAEEgag8LIAAgAS0AADoAACAAIAEtAAE6AAEgACABLQACOgACIAAgAS0AAzoAAyAAIAEtAAQ6AAQgACABLQAFOgAFIAAgAS0ABjoABiAAIAEtAAc6AAcgACABLQAIOgAIIAAgAS0ACToACSAAIAEtAAo6AAogACABLQALOgALIAAgAS0ADDoADCAAIAEtAA06AA0gACABLQAOOgAOIAAgAS0ADzoADyAAQRBqDwsgACABKQAANwAAIABBCGoPCwJAIAJBB00EQCACRQ0BIAAgAS0AADoAACACQQFGBEAgAEEBag8LIAAgAS0AAToAASACQQJGBEAgAEECag8LIAAgAS0AAjoAAiACQQNGBEAgAEEDag8LIAAgAS0AAzoAAyACQQRGBEAgAEEEag8LIAAgAS0ABDoABCACQQVGBEAgAEEFag8LIAAgAS0ABToABSACQQZGBEAgAEEGag8LIAAgAS0ABjoABiAAQQdqDwsgACABKQAANwAAIAJBA3YiBEH4////AXEhAyABIAJBB3EiAmohASAAIAJqIQACQAJAAkACQAJAAkACQAJAIARBB3FBAWsOBwYFBAMCAQAHCyAAIAEpAAA3AAAgAUEIaiEBIABBCGohAAsgACABKQAANwAAIAFBCGohASAAQQhqIQALIAAgASkAADcAACABQQhqIQEgAEEIaiEACyAAIAEpAAA3AAAgAUEIaiEBIABBCGohAAsgACABKQAANwAAIAFBCGohASAAQQhqIQALIAAgASkAADcAACABQQhqIQEgAEEIaiEACyAAIAEpAAA3AAAgAUEIaiEBIABBCGohAAsgA0UNAANAIAAgASkAADcAACAAIAEpAAg3AAggACABKQAQNwAQIAAgASkAGDcAGCAAIAEpACA3ACAgACABKQAoNwAoIAAgASkAMDcAMCAAIAEpADg3ADggAUFAayEBIABBQGshACADQQhrIgMNAAsLIAALBgAgABAZCxcAIAAtAABBIHFFBEAgASACIAAQSBoLC7UEAQd/An9BACABQQhJDQAaIANBfHEhCSAAIAFqQQRrIQYgACEBIANBA3EiAyEIAkACQAJAAkAgA0EBaw4DAgEAAwsgBCACIAlBAnJqLQAAQQJ0aiIBLQACIQMgACABLwEAIgU2AAAgBiAAIANBA3ZqIgEgASAGSxshASAFIANB+AFxdiEHIANBB3EhBQsgBCACIAlBAXJqLQAAQQJ0aiIDLwEAIAV0IAdyIQcgBSADLQACaiEFCyAEIAIgCWotAABBAnRqIgMtAAIhCCABIAMvAQAgBXQgB3IiBzYAACAGIAEgBSAIaiIDQQN2aiIBIAEgBksbIQEgByADQfgHcXYhCCADQQdxIQMLIAkEQANAIAQgAiAJaiIFQQJrLQAAQQJ0aiIHLQACIQogASAIIAQgBUEBay0AAEECdGoiCC8BACADdHIgBy8BACADIAgtAAJqIgN0ciIINgAAIAQgAiAJQQRrIglqLQAAQQJ0aiIHLQACIQsgBiABIAMgCmoiA0EDdmoiASABIAZLGyIBIAQgBUEDay0AAEECdGoiBS8BACADQQdxIgp0IAggA0F4cXZyIAcvAQAgCiAFLQACaiIDdHIiBTYAACAGIAEgAyALaiIDQQN2aiIBIAEgBksbIQEgBSADQfgHcXYhCCADQQdxIQMgCQ0ACwsgASAIQQEgA3RyNgAAQQAgBiABIANBAWoiAkEDdmoiASABIAZLGyIBIAZPDQAaIAJBB3FBAEcgAGsgAWoLC+gIARB/IAAoAiwiBEF8cSEIIARBA3EhCyAEQYYCayEMIAAoAnQhAiAEQQFrQQNJIQ0DQCAAKAI8IAIgACgCbCIHamshBiAMIAAoAixqIAdNBEAgACgCOCIBIAEgBGogBBAXGiAAIAAoAnAgBGs2AnAgACAAKAJsIARrIgc2AmwgACAAKAJcIARrNgJcIAAoAkwiAkEBayEPIAAoAkQgAkEBdGohAyACQQNxIgkEQCACQXxxIQJBACEFA0AgA0ECayIDIAMvAQAiCiAEayIOQQAgCiAOTxs7AQAgBUEBaiIFIAlHDQALCyAPQQNPBEADQCADQQJrIgEgAS8BACIBIARrIgVBACABIAVPGzsBACADQQRrIgEgAS8BACIBIARrIgVBACABIAVPGzsBACADQQZrIgEgAS8BACIBIARrIgVBACABIAVPGzsBACADQQhrIgMgAy8BACIBIARrIgVBACABIAVPGzsBACACQQRrIgINAAsLIAAoAkAgBEEBdGohA0EAIQUgBCEBIAsEQANAIANBAmsiAyADLwEAIgEgBGsiAkEAIAEgAk8bOwEAIAVBAWoiBSALRw0ACyAIIQELIA1FBEADQCADQQJrIgIgAi8BACICIARrIgVBACACIAVPGzsBACADQQRrIgIgAi8BACICIARrIgVBACACIAVPGzsBACADQQZrIgIgAi8BACICIARrIgVBACACIAVPGzsBACADQQhrIgMgAy8BACICIARrIgVBACACIAVPGzsBACABQQRrIgENAAsLIAQgBmohBgsCQCAAKAIAIgEoAgQiAkUNACACIAYgAiAGSRshAyAAKAJ0IQUgACAGBH8gACgCOCEQIAEgAiADazYCBCAQIAdqIAVqIAEoAgAgAxAXIQICQAJAAkAgASgCHCgCGEEBaw4CAAECCyABIAEoAjAgAiADED02AjAMAQsgASABKAIwIAIgAxAaNgIwCyABIAEoAgAgA2o2AgAgASABKAIIIANqNgIIIAAoAnQFIAULIANqIgI2AnQCQCAAKAK0LSIFIAJqQQNJDQAgACAAKAI4IgYgACgCbCAFayIDaiIBLQAAIgc2AkggACAAKAJUIgkgAS0AASAHIAAoAlgiB3RzcSIBNgJIIAZBAmohBgNAIAVFDQEgACADIAZqLQAAIAEgB3RzIAlxIgE2AkggACgCQCAAKAI0IANxQQF0aiAAKAJEIAFBAXRqIgovAQA7AQAgCiADOwEAIAAgBUEBayIFNgK0LSADQQFqIQMgAiAFakECSw0ACwsgAkGFAksNACAAKAIAKAIEDQELCwJAIAAoAjwiCCAAKALALSIBTQ0AIAACfyAAKAJ0IAAoAmxqIgQgAUsEQCAAKAI4IARqQQBBggIgCCAEayIBIAFBggJPGyIBEBgaIAEgBGoMAQsgBEGCAmoiBCABTQ0BIAAoAjggAWpBACAEIAFrIgQgCCABayIBIAEgBEsbIgEQGBogACgCwC0gAWoLNgLALQsLCQAgASACbBAdCzYBAX9BASAAIABBAU0bIQACQANAIAAQHSIBDQFBuPQBKAIAIgEEQCABEQcADAELCxAHAAsgAQs3ACABAn9BvOABKAIAQQBIBEAgACABQfDfARBIDAELIAAgAUHw3wEQSAsiAEYEQA8LIAAg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LwEANgJ8IAYoAiwiAUUNAQJAAkACQAJAAkACQAJAAkACQAJ/AkACQCAGKAIcRQ0AIAYoAhBFBEAgBigCFA0BCyAGKAIgRQRAIAZBww42AigMDQsgAUEENgIoIAEgBkEQajYCAAJAAkACQCABKAIEIgRBKkYEQCABKAIYQQJGBEAgBkEANgJAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBHzoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQYsBOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBCDoAACABKAIcIgJFBEAgASABKAIUIgJBAWo2AhQgAiABKAIIakEAOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQA6AAAgASABKAIUIgJBAWo2AhQgAiABKAIIakEAOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAAEECIQQgASgChAEiAkEJRwRAQQQgASgCiAFBAUpBAnQgAkECSBshBAsgASABKAIUIgJBAWo2AhQgAiABKAIIaiAEOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBAzoAAAwQCyACKAIkIQMgAigCHCELIAIoAhAhBSACKAIsIQggAigCACECIAEgASgCFCINQQFqNgIUQQIhBCANIAEoAghqIAhBAEdBAXQgAkEAR3IgBUEAR0ECdHIgC0EAR0EDdHIgA0EAR0EEdHI6AAAgASgCHCgCBCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACABKAIcKAIEIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQQh2OgAAIAEoAhwvAQYhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgASgCHC0AByECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACABKAKEASICQQlHBEBBBCABKAKIAUEBSkECdCACQQJIGyEECyABIAEoAhQiAkEBajYCFCACIAEoAghqIAQ6AAAgASgCHCgCDCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACABKAIcIgQoAhAEQCAEKAIUIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAEoAhwoAhQhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBCHY6AAAgASgCHCEECyAEKAIsBEAgBiAGKAJAIAEoAgggASgCFBAaNgJACyABQcUANgIEIAFBADYCIAwCCyABKAIwQQx0QYDwAWshA0EAIQQCQCABKAKIAUEBSg0AIAEoAoQBIgJBAkgNAEHAACEEIAJBBkkNAEGAAUHAASACQQZGGyEECyABQfEANgIEIAEgASgCFCICQQFqNgIUIAIgASgCCGogAyAEciICQSByIAIgASgCbBsiAkEIdjoAACABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBH3AgAnJBH3M6AAAgASgCbARAIAYoAkAhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBGHY6AAAgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQRB2OgAAIAYoAkAhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBCHY6AAAgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAACyAGQQE2AkAgASgCBCEECyAEQcUARw0BIAEoAhwhBAsCQCAEKAIQBEAgASgCFCEDAkAgASgCICICIAQvARRPDQADQCABKAIUIg0gASgCDEYEfyAEKAIsRSADIA1PckUEQCAGIAYoAkAgASgCCCADaiANIANrEBo2AkALAkACfyAGKAIsIgIoArwtIgNBEEYEQCACIAIoAhQiA0EBajYCFCADIAIoAghqIAItALgtOgAAIAIgAigCFCIDQQFqNgIUIAMgAigCCGogAkG5LWotAAA6AAAgAkEAOwG4LUEADAELIANBCEgNASACIAIoAhQiA0EBajYCFCADIAIoAghqIAItALgtOgAAIAIgAkG5LWotAAA7AbgtIAIoArwtQQhrCyEDIAIgAzYCvC0LAkAgAigCFCIDIAYoAiAiBCADIARJGyIDRQ0AIAYoAhwgAigCECADEBcaIAYgBigCHCADajYCHCACIAIoAhAgA2o2AhAgBiAGKAIkIANqNgIkIAYgBigCICADazYCICACIAIoAhQiBCADazYCFCADIARHDQAgAiACKAIINgIQCyABKAIcIQQgASgCFCINIAEoAgxGBEAgDSEDDAMLIA0hAyABKAIgBSACCyAEKAIQai0AACECIAEgDUEBajYCFCABKAIIIA1qIAI6AAAgASABKAIgQQFqIgI2AiAgAiABKAIcIgQvARRJDQALCwJAIAQoAixFDQAgASgCFCICIANNDQAgBiAGKAJAIAEoAgggA2ogAiADaxAaNgJACyABKAIgIAQoAhRHDQEgAUHJADYCBCABQQA2AiAMAwsgAUHJADYCBAwCCyABKAIEIQQLIARByQBHDQQgASgCHCEECyAEKAIcRQ0FIAEoAhQhAwNAIAEoAhwhBCABKAIUIg0gASgCDEYEQCAEKAIsRSADIA1PckUEQCAGIAYoAkAgASgCCCADaiANIANrEBo2AkALAkACfyAGKAIsIgIoArwtIgNBEEYEQCACIAIoAhQiA0EBajYCFCADIAIoAghqIAItALgtOgAAIAIgAigCFCIDQQFqNgIUIAMgAigCCGogAkG5LWotAAA6AAAgAkEAOwG4LUEADAELIANBCEgNASACIAIoAhQiA0EBajYCFCADIAIoAghqIAItALgtOgAAIAIgAkG5LWotAAA7AbgtIAIoArwtQQhrCyEDIAIgAzYCvC0LAkAgAigCFCIDIAYoAiAiBCADIARJGyIDRQ0AIAYoAhwgAigCECADEBcaIAYgBigCHCADajYCHCACIAIoAhAgA2o2AhAgBiAGKAIkIANqNgIkIAYgBigCICADazYCICACIAIoAhQiBCADazYCFCADIARHDQAgAiACKAIINgIQCyABKAIcIQQgASgCFCINIAEoAgxGDQMgDSEDCyAEKAIcIXMgASABKAIgIgRBAWo2AiAgcyAEai0AACECIAEgDUEBajYCFCABKAIIIA1qIAI6AAAgAg0ACyABKAIcIQQgAyENQQEMAgsgBkHQDjYCKAwLC0EACyF0AkAgBCgCLEUNACABKAIUIgMgDU0NACAGIAYoAkAgASgCCCANaiADIA1rEBo2AkALIHQNASABKAIEIQQLIARB2wBHDQMgASgCHCEEDAILIAFBADYCIAsgAUHbADYCBAsgBCgCJEUNASABKAIUIQMCfwJAA0AgASgCHCEEIAEoAhQiDSABKAIMRgRAIAQoAixFIAMgDU9yRQRAIAYgBigCQCABKAIIIANqIA0gA2sQGjYCQAsCQAJ/IAYoAiwiAigCvC0iA0EQRgRAIAIgAigCFCIDQQFqNgIUIAMgAigCCGogAi0AuC06AAAgAiACKAIUIgNBAWo2AhQgAyACKAIIaiACQbktai0AADoAACACQQA7AbgtQQAMAQsgA0EISA0BIAIgAigCFCIDQQFqNgIUIAMgAigCCGogAi0AuC06AAAgAiACQbktai0AADsBuC0gAigCvC1BCGsLIQMgAiADNgK8LQsCQCACKAIUIgMgBigCICIEIAMgBEkbIgNFDQAgBigCHCACKAIQIAMQFxogBiAGKAIcIANqNgIcIAIgAigCECADajYCECAGIAYoAiQgA2o2AiQgBiAGKAIgIANrNgIgIAIgAigCFCIEIANrNgIUIAMgBEcNACACIAIoAgg2AhALIAEoAhwhBCABKAIUIg0gASgCDEYNAiANIQMLIAQoAiQhdSABIAEoAiAiBEEBajYCICB1IARqLQAAIQIgASANQQFqNgIUIAEoAgggDWogAjoAACACDQALIAEoAhwhBCADIQ1BAQwBC0EACyF2AkAgBCgCLEUNACABKAIUIgMgDU0NACAGIAYoAkAgASgCCCANaiADIA1rEBo2AkALIHYNASABKAIEIQQLIARB5wBHDQMgASgCHCEEDAELIAFB5wA2AgQLIAQoAixFDQAgASgCFCIEQQJqIg0gASgCDCICSwR/IAZBEGoQPiABKAIUIgRBAmohDSABKAIMBSACCyANSQ0BIAYoAkAhAiABIARBAWo2AhQgASgCCCAEaiACOgAAIAYoAkAhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBCHY6AAAgBkEANgJACyABQfEANgIECwJAIAEoAhRFDQACQAJ/IAYoAiwiAygCvC0iAkEQRgRAIAMgAygCFCICQQFqNgIUIAIgAygCCGogAy0AuC06AAAgAyADKAIUIgJBAWo2AhQgAiADKAIIaiADQbktai0AADoAACADQQA7AbgtQQAMAQsgAkEISA0BIAMgAygCFCICQQFqNgIUIAIgAygCCGogAy0AuC06AAAgAyADQbktai0AADsBuC0gAygCvC1BCGsLIQIgAyACNgK8LQsCQCADKAIUIgQgBigCICICIAIgBEsbIgRFDQAgBigCHCADKAIQIAQQFxogBiAGKAIcIARqNgIcIAMgAygCECAEajYCECAGIAYoAiQgBGo2AiQgBiAGKAIgIARrIgI2AiAgAyADKAIUIgsgBGs2AhQgBCALRw0AIAMgAygCCDYCEAsgAg0AIAFBfzYCKAwBCwJAIAEoAgRBmgVGBEAgBigCFARAIAZBww42AigMAwsgASgCdEUNAQsCfwJAAkACQCABKAKIAUECaw4CAAECCwJ/AkADQCABKAJ0RQRAIAEQKyABKAJ0RQ0CCyABQQA2AmAgASgCOCABKAJsai0AACECIAEoAqQtIAEoAqAtIgNBAXRqQQA7AQAgASADQQFqNgKgLSADIAEoApgtaiACOgAAIAEgAkECdGoiAiACLwGUAUEBajsBlAEgASABKAJ0QQFrNgJ0IAEgASgCbEEBaiIDNgJsIAEoAqAtIAEoApwtQQFrRw0AIAEgASgCXCICQQBOBH8gASgCOCACagVBAAsgAyACa0EAEBwgASABKAJsNgJcAkACfyABKAIAIgMoAhwiAigCvC0iBEEQRgRAIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAi0AuC06AAAgAiACKAIUIgRBAWo2AhQgBCACKAIIaiACQbktai0AADoAACACQQA7AbgtQQAMAQsgBEEISA0BIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAi0AuC06AAAgAiACQbktai0AADsBuC0gAigCvC1BCGsLIQQgAiAENgK8LQsCQCACKAIUIgQgAygCECILIAQgC0kbIgRFDQAgAygCDCACKAIQIAQQFxogAyADKAIMIARqNgIMIAIgAigCECAEajYCECADIAMoAhQgBGo2AhQgAyADKAIQIARrNgIQIAIgAigCFCIDIARrNgIUIAMgBEcNACACIAIoAgg2AhALIAEoAgAoAhANAAtBAAwBCyABQQA2ArQtIAEgASgCXCICQQBOBH8gASgCOCACagVBAAsgASgCbCACa0EBEBwgASABKAJsNgJcAkACfyABKAIAIgMoAhwiAigCvC0iBEEQRgRAIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAi0AuC06AAAgAiACKAIUIgRBAWo2AhQgBCACKAIIaiACQbktai0AADoAACACQQA7AbgtQQAMAQsgBEEISA0BIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAi0AuC06AAAgAiACQbktai0AADsBuC0gAigCvC1BCGsLIQQgAiAENgK8LQsCQCACKAIUIgQgAygCECILIAQgC0kbIgRFDQAgAygCDCACKAIQIAQQFxogAyADKAIMIARqNgIMIAIgAigCECAEajYCECADIAMoAhQgBGo2AhQgAyADKAIQIARrNgIQIAIgAigCFCIDIARrNgIUIAMgBEcNACACIAIoAgg2AhALQQNBAiABKAIAKAIQGwsMAgsCfwNAAkACfwJAAkAgASgCdCILQYMCTwRAIAFBADYCYCABKAJsIQUMAQsgARArIAEoAnQiCwRAIAFBADYCYCABKAJsIQUgC0ECSw0BIAEoAjghDQwCCyABQQA2ArQtIAEgASgCXCICQQBOBH8gASgCOCACagVBAAsgASgCbCACa0EBEBwgASABKAJsNgJcAkACfyABKAIAIgMoAhwiAigCvC0iBEEQRgRAIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAi0AuC06AAAgAiACKAIUIgRBAWo2AhQgBCACKAIIaiACQbktai0AADoAACACQQA7AbgtQQAMAQsgBEEISA0BIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAi0AuC06AAAgAiACQbktai0AADsBuC0gAigCvC1BCGsLIQQgAiAENgK8LQsCQCACKAIUIgQgAygCECILIAQgC0kbIgRFDQAgAygCDCACKAIQIAQQFxogAyADKAIMIARqNgIMIAIgAigCECAEajYCECADIAMoAhQgBGo2AhQgAyADKAIQIARrNgIQIAIgAigCFCIDIARrNgIUIAMgBEcNACACIAIoAgg2AhALQQNBAiABKAIAKAIQGwwFCyABKAI4IQ0gBUUEQEEAIQUMAQsgBSANaiIEQQFrLQAAIgMgBC0AAEcNACADIAQtAAFHDQAgAyAELQACRw0AIARBggJqIQdBAiEIAkACQAJAAkACQAJAAkADQCAEIAhqIgItAAEgA0YEQCADIAItAAJHDQIgAyACLQADRw0DIAMgAi0ABEcNBCADIAItAAVHDQUgAyACLQAGRw0GIAMgAi0AB0cNByAIQfkBSyF3IAQgCEEIaiIIaiECIHcNCCADIAItAABGDQEMCAsLIAJBAWohAgwGCyACQQJqIQIMBQsgAkEDaiECDAQLIAJBBGohAgwDCyACQQVqIQIMAgsgAkEGaiECDAELIAJBB2ohAgsgASACIAdrQYICaiICIAsgAiALSRsiAzYCYCABKAKgLSICIANBA0kNARogASgCpC0gAkEBdGpBATsBACABIAJBAWo2AqAtIAEoApgtIAJqIANBA2siAjoAACACQf8BcUGA4QBqLQAAQQJ0IAFqQZgJaiICIAIvAQBBAWo7AQAgASgCYCECIAFBADYCYCABIAEvAYgTQQFqOwGIEyABIAEoAnQgAms2AnQgASACIAEoAmxqIgI2AmwMAgsgASgCoC0LIQIgBSANai0AACEDIAEoAqQtIAJBAXRqQQA7AQAgASACQQFqNgKgLSABKAKYLSACaiADOgAAIAEgA0ECdGoiAiACLwGUAUEBajsBlAEgASABKAJ0QQFrNgJ0IAEgASgCbEEBaiICNgJsCyABKAKgLSABKAKcLUEBa0cNACABIAEoAlwiA0EATgR/IAEoAjggA2oFQQALIAIgA2tBABAcIAEgASgCbDYCXAJAAn8gASgCACIDKAIcIgIoArwtIgRBEEYEQCACIAIoAhQiBEEBajYCFCAEIAIoAghqIAItALgtOgAAIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAkG5LWotAAA6AAAgAkEAOwG4LUEADAELIARBCEgNASACIAIoAhQiBEEBajYCFCAEIAIoAghqIAItALgtOgAAIAIgAkG5LWotAAA7AbgtIAIoArwtQQhrCyEEIAIgBDYCvC0LAkAgAigCFCIEIAMoAhAiCyAEIAtJGyIERQ0AIAMoAgwgAigCECAEEBcaIAMgAygCDCAEajYCDCACIAIoAhAgBGo2AhAgAyADKAIUIARqNgIUIAMgAygCECAEazYCECACIAIoAhQiAyAEazYCFCADIARHDQAgAiACKAIINgIQCyABKAIAKAIQDQALQQALDAELIAFBBCABKAKEAUEMbEGIHGooAgARAgALIgJBfnFBAkYEQCABQZoFNgIECyACQX1xRQRAIAYoAiANAiABQX82AigMAgsgAkEBRw0AIAFBAEEAQQAQViAGQRBqED4gBigCIA0AIAFBfzYCKAwBCwJAIAEoAhgiA0EATA0AIAYoAkAhAgJAIANBAkYEQCABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgBigCQCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACAGLwFCIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAYtAEMhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgBigCGCECIAEgASgCFCIDQQFqNgIUIAMg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PiABIgJNBEAgAUEEayIBKAAAIAVGDQELCyATIQECQCACIBFNDQADQCACQQFrIgUtAAAgAS0AAEcNASABQQFrIQEgBSICIBFLDQALIBEhAgsgICACayAIagtrIgEgNCABIDRLGyIKayAbaiIBICJJIBsgIktyRQRAIBkgJSAiayAbaiIBIAEgGWtBfEsbIQpBAiEbDAELQQIhGyAKIBlrQXxLBEAgGSEKDAELIAsgJEcNAAJAIAEgIiABICJJGyICIARNBEAgDSEBIAMhBSAEIQIMAQsgCyEBICQgCiAqaiIFa0H//wNKDQILIDMgCkH//wNxQQF0ai8BACIDIApLBEAgASENIAUhAyACIQQMAgsgCiADayEKIAIhBCAFIQMgASENCyAKIDRJDQAgGEEBayIYDQELCyAEICdHDQEgAyEICyArRSALIBdrIgIgFUEBaiIKIAJB/wFuampBCGogLE1yRQRAQQAhAgwKCwJAIAJBD08EQCAVQfABOgAAIAJBD2siAUH/AU8EQCAKQf8BIAJBjgJrIgNB/wFuIgFBAWoQGBogASAVakECaiEKIAFBgX5sIANqIQELIAogAToAACAKQQFqIQoMAQsgFSACQQR0OgAACyACIApqIQMgFyECIAohAQNAIAEgAikAADcAACACQQhqIQIgAUEIaiIBIANJDQALIAMgCyAJazsAACArRSADQQJqIg4gJ0EEayIBQf8BbmpBBmogLE1yRQRAQQAhAgwKCyAVLQAAIQIgAUEPTwRAIBUgAkEPajoAACAnQRNrIgJB/gNPBEAgDkH/ASAnQZEEayIBQf4DbiICQQF0IgNBAmoQGBogCiAXayALaiADakEEaiEOIAJBgnxsIAFqIQILIAJB/wFPBEAgDkH/AToAACAOQQFqIQ4gAkH/AWshAgsgDiACOgAAIA5BAWohDgwECyAVIAEgAmo6AAAMAwsgDiALIA0gCyAWakkgCyAOS3EiARshIiADIQggDSILICJrQQNIDQAgFiAnIAEbIQ4gFCAJIAEbIQkgFyEQA0AgDiAiaiIXQQNqIUcgIkESIA4gDkESThsiLmohPAJAA0ACQAJAAn8CQCALICJrIgFBEUoNACAiIAtrIAEgBGpBBGsgLiA8IAQgC2pBBGtLG2oiAUEATA0AIAQgAWshFiABIANqIQggASALagwBCyADIQggBCEWIAsLIg0gFmoiDyA2Sw0AIBwoApCAECI7IA9BA2siHiAcKAKEgBAiJGsiAUH//wNrIDtBgIAEaiABSxshNCAeKAAAIRIgASAcKAKUgBAiAksEQANAIDMgAkH//wNxQQF0akH//wMgAiAcIAIgJGooAABBsfPd8XlsQQ92Qfz/B3FqIgMoAgBrIgQgBEH//wNPGzsBACADIAI2AgAgAkEBaiICIAFJDQALCyAcKAKMgBAhESAcKAKIgBAhMiAcIAE2ApSAECAcIB4oAABBsfPd8XlsQQ92Qfz/B3FqKAIAIgogNEkNACANIB5rIS0gDUEBayE+IBJB//8DcSASQRB2RiASQf8BcSASQRh2RnEhQiARIDJqIRkgESAkaiIUQQRqISAgD0EFaiE/IA9BAWohISAyIDtqIidBBGohSUEAIRsgFiEEIBohGEEAISogByEDIAwhCwNAAkACQAJ/AkACQCAKIBFPBEAgBCA+ai8AACAKICRqIgcgLWogBGpBAWsvAABHDQUgBygAACASRw0FAkAgDSAeRgRAQQAhBQwBCyAtIBQgB2siASABIC1IGyIMQR91IAxxIQFBACECA0AgDCACIgVOBEAgASEFDAILIB4gBUEBayICai0AACACIAdqLQAARg0ACwsgB0EEaiECIB8gHyAhTQR/ICEFICEoAAAgAigAAHMiAQ0CIAdBCGohAiA/CyIBSwRAA0AgASgAACACKAAAcyIMBEAgASAMaEEDdmogIWshAgwHCyACQQRqIQIgAUEEaiIBIB9JDQALCwJAIAEgNU8NACACLwAAIAEvAABHDQAgAkECaiECIAFBAmohAQsgASAdSQR/IAEgAi0AACABLQAARmoFIAELICFrIQIMBAsgCiAyaiIHKAAAIBJHDQQgB0EEaiECICEgHSAeIBEgCmtqIgEgASAdSxsiBUEDayIMTwR/ICEFICEoAAAgAigAAHMiAQ0CIAdBCGohAiA/CyIBIAxJBEADQCABKAAAIAIoAABzIiUEQCABICVoQQN2aiAhawwFCyACQQRqIQIgAUEEaiIBIAxJDQALCwJAIAEgBUEBa08NACACLwAAIAEvAABHDQAgAkECaiECIAFBAmohAQsgASAFSQR/IAEgAi0AACABLQAARmoFIAELICFrDAILIAFoQQN2IQIMAgsgAWhBA3YLIQEgHiABQQRqIiVqIAVHIAUgHU9yRQRAIBQhAQJ/AkAgBSICIB9JBEAgAigAACABKAAAcyIBDQEgAkEEaiECICAhAQsgAiAfSQRAA0AgAigAACABKAAAcyIMBEAgAiAMaEEDdmogBWsMBAsgAUEEaiEBIAJBBGoiAiAfSQ0ACwsCQCACIDVPDQAgAS8AACACLwAARw0AIAFBAmohASACQQJqIQILIAIgHUkEfyACIAEtAAAgAi0AAEZqBSACCyAFawwBCyABaEEDdgsgJWohJQsCQCANIB5GBEBBACEBDAELIC0gJyAHayIBIAEgLUgbIgxBH3UgDHEhBUEAIQIDQCAMIAIiAU4EQCAFIQEMAgsgHiABQQFrIgJqLQAAIAIgB2otAABGDQALCyAlIAFrIgIgBEwNASABIB5qIQsgCiAkaiABaiEDIAIhBAwBCyACIAVrQQRqIgEgBEwNACAFIB5qIQsgBSAHaiEDIAEhBAsCQAJAAkACQAJAIDcgMyAKQf//A3FBAXRqLwEAIgdBAUdyDQAgG0UEQEEBIRsgQkUNAQJAAkAgISICIB9PDQADQCACKAAAIBJzIgFFBEAgHyACQQRqIgJLDQEMAgsLIAIgAWhBA3ZqIQIMAQsgAiAdTw0AIAIgHSACa2ohASASIQUDQCACLQAAIAVB/wFxRw0BIAVBCHYhBSACQQFqIgIgAUcNAAsgASECCyACICFrQQRqISpBAiEbCyAbQQJHDQAgCkEBayIMIDRJDQBBAiEbIAwgEWtBfEsNACAyICQgDCARSSJFGyAMaiIFKAAAIBJHDQAgBUEEaiIKIQIgGSAdIEUbIgdBA2siASAKTQ0BA0AgAigAACAScyIbRQRAIAEgAkEEaiICSw0BDAMLCyACIBtoQQN2aiECDAILIAogB2shCgwCCyACIAdPDQAgEiEBA0AgAi0AACABQf8BcUcNASABQQh2IQEgAkEBaiICIAdHDQALIAchAgsgAiAKayIBQQRqIRsCfyAMIBFPBEAgFCIHDAELIBkgBSAbakYEQCASIAFBA3R3IQECQAJAIBQiAiAfTw0AA0AgAigAACABcyIHRQRAIB8gAkEEaiICSw0BDAILCyACIAdoQQN2aiECDAELIAIgHU8NACACIB0gAmtqIQcDQCACLQAAIAFB/wFxRw0BIAFBCHYhASACQQFqIgIgB0cNAAsgByECCyAbIBRrIAJqIRsLICciBwshJSAvIBI2AgwgJUEEaiEKIAUhAQNAIAogASICTQRAIAFBBGsiASgAACASRg0BCwsCQCACICVNDQAgEyEBA0AgAkEBayIKLQAAIAEtAABHDQEgAUEBayEBIAoiAiAlSw0ACyAHIQILIAwgDCBFIAUgBSACayIHayAUR3IgESA7TXIEfyAHBSAvIBJBACAHa0EDdHciBTYCDCAZIQEDQCBJIAEiAk0EQCABQQRrIgEoAAAgBUYNAQsLIBMhAQJAIAIgJ00NAANAIAJBAWsiBS0AACABLQAARw0BIAFBAWshASAFIgIgJ0sNAAsgJyECCyAHIBlqIAJrC2siASA0IAEgNEsbIgprIBtqIgEgKkkgGyAqS3JFBEAgESAMICprIBtqIgEgASARa0F8SxshCkECIRsMAQtBAiEbIAogEWtBfEsEQCARIQoMAQsgDSAeRw0AAkAgASAqIAEgKkkbIgIgBE0EQCALIQEgAyEFIAQhAgwBCyANIQEgHiAKICRqIgVrQf//A0oNAgsgMyAKQf//A3FBAXRqLwEAIgMgCksEQCABIQsgBSEDIAIhBAwCCyAKIANrIQogAiEEIAUhAyABIQsLIAogNEkNACAYQQFrIhgNAQsLIAQgFkcNASADIQcgCyEMCyArRSAiIBBrIgEgFUEBaiICIAFB/wFuampBCGogLE1yRQRAQQAhAgwNCyANICJrIXgCQCABQQ9PBEAgFUHwAToAACABQQ9rIgpB/wFPBEAgAkH/ASABQY4CayIEQf8BbiICQQFqEBgaIAJBgX5sIARqIQogAiAVakECaiECCyACIAo6AAAgAkEBaiECDAELIBUgAUEEdDoAAAsgeCAOIA0gF0kbIQMgASACaiEBA0AgAiAQKQAANwAAIBBBCGohECACQQhqIgIgAUkNAAsgASAiIAlrOwAAICtFIAFBAmoiCiADQQRrIgJB/wFuakEGaiAsTXJFBEBBACECDA0LIBUtAAAhBAJAIAJBD08EQCAVIARBD2o6AAAgA0ETayICQf4DTwRAIApB/wEgDSAOICJqIgIgAiANSxsgImtBkQRrIgJB/gNuIgRBAXQiC0ECahAYGiABIAtqQQRqIQogBEGCfGwgAmohAgsgAkH/AU8EQCAKQf8BOgAAIApBAWohCiACQf8BayECCyAKIAI6AAAgCkEBaiEKDAELIBUgAiAEajoAAAsgK0UgDSADICJqIgNrIgIgCkEBaiIFIAJB/wFuampBCGogLE1yRQRAQQAhAgwNCwJAIAJBD08EQCAKQfABOgAAIAJBD2siAUH/AU8EQCAFQf8BIAJBjgJrIgRB/wFuIgFBAWoQGBogASAKakECaiEFIAFBgX5sIARqIQELIAUgAToAACAFQQFqIQUMAQsgCiACQQR0OgAACyACIAVqIQQgAyECIAUhAQNAIAEgAikAADcAACACQQhqIQIgAUEIaiIBIARJDQALIAQgDSAIazsAACArRSAEQQJqIg4gFkEEayIBQf8BbmpBBmogLE1yRQRAQQAhAgwNCyAKLQAAIQIgAUEPTwRAIAogAkEPajoAACAWQRNrIgJB/gNPBEAgDkH/ASAWQZEEayIBQf4DbiICQQF0IgRBAmoQGBogBSAEIA1qIANrakEEaiEOIAJBgnxsIAFqIQILIAJB/wFPBEAgDkH/AToAACAOQQFqIQ4gAkH/AWshAgsgDiACOgAAIA5BAWohDgwHCyAKIAEgAmo6AAAMBgsgCyBHTw0BIAMhByAXIAsiDEsNAAsCQCANIBdPDQAgFiAXIA1rIgFrIhZBA0oEQCABIAhqIQggFyENDAELIAshDSADIQggBCEWCyArRSAiIBBrIgIgFUEBaiIKIAJB/wFuampBCGogLE1yRQRAQQAhAgwLCwJAIAJBD08EQCAVQfABOgAAIAJBD2siAUH/AU8EQCAKQf8BIAJBjgJrIgVB/wFuIgFBAWoQGBogASAVakECaiEKIAFBgX5sIAVqIQELIAogAToAACAKQQFqIQoMAQsgFSACQQR0OgAACyACIApqIQUgECECIAohAQNAIAEgAikAADcAACACQQhqIQIgAUEIaiIBIAVJDQALIAUgIiAJazsAACArRSAFQQJqIgIgDkEEayIBQf8BbmpBBmogLE1yRQRAQQAhAgwLCyAVLQAAIQUCfyABQQ9PBEAgFSAFQQ9qOgAAIA5BE2siAUH+A08EQCACQf8BIA5BkQRrIgFB/gNuIgVBAXQiAkECahAYGiAKIAIgImogEGtqQQRqIQIgBUGCfGwgAWohAQsgAUH/AU8EQCACQf8BOgAAIAJBAWohAiABQf8BayEBCyACIAE6AAAgAkEBagwBCyAVIAEgBWo6AAAgAgshFSALIQwgAyEHIA0hDiAIIRQMAgsCfyANIBdPBEAgDiEFIBYMAQsgFiANICJrIgVBEUoNABogFiAFIBZqQQRrIC4gPCAPQQRrSxsiBSAiIA1raiIBQQBMDQAaIAEgCGohCCABIA1qIQ0gFiABawshDiArRSAiIBBrIgIgFUEBaiIKIAJB/wFuampBCGogLE1yRQRAQQAhAgwKCwJAIAJBD08EQCAVQfABOgAAIAJBD2siAUH/AU8EQCAKQf8BIAJBjgJrIgdB/wFuIgFBAWoQGBogASAVakECaiEKIAFBgX5sIAdqIQELIAogAToAACAKQQFqIQoMAQsgFSACQQR0OgAACyACIApqIQcgECECIAohAQNAIAEgAikAADcAACACQQhqIQIgAUEIaiIBIAdJDQALIAcgIiAJazsAACArRSAHQQJqIgIgBUEEayIBQf8BbmpBBmogLE1yBEAgFS0AACEHAn8gAUEPTwRAIBUgB0EPajoAACAFQRNrIgFB/gNPBEAgAkH/ASAFQZEEayIBQf4DbiIHQQF0IgJBAmoQGBogCiACICJqIBBrakEEaiECIAdBgnxsIAFqIQELIAFB/wFPBEAgAkH/AToAACACQQFqIQIgAUH/AWshAQsgAiABOgAAIAUgImohECANISIgAkEBagwBCyAVIAEgB2o6AAAgBSAiaiEQIA0hIiACCyEVIAghCSALIQwgAyEHDAEFQQAhAgwKCwALAAsACyAiQQFqISIgC0EBaiILIDZNDQEMAwsLIA8gNk0NAAsLIDkgD2shASArBEBBACECIA4gAUHwAWpB/wFuaiABakEBaiAsSw0DCyAOQQFqIQIgASAPaiELAkAgAUEPTwRAIA5B8AE6AAAgAUEPayIEQf8BTwRAIAJB/wEgAUGOAmsiBEH/AW4iA0EBaiIFEBgaIAMgDmpBAmohAiAFIA5qIQ4gA0GBfmwgBGohBAsgAiAEOgAAIA5BAmohAgwBCyAOIAFBBHQ6AAALIAIgDyABEBchAiAGIAsgPWs2AhAgASACaiAoawwBCyACKAIIIQEgA0EMRiFJIBwtAJqAEEEARyElIwBBwIAEayIRJAAgBigCECECIAZBADYCECAoIDBqITQgKCEOAn8gAiA9IghqIjJBDGsiPCAITwRAQf8fIAEgAUH/H08bIT8gMkEFayEVIDJBBmshOSAyQQhrIRkgHEGAgAhqIR0gEUG8gARqQQNyIRMgCCEQA0AgHCgCkIAQIjUgECAcKAKEgBAiIGsiLEH//wNrIDVBgIAEaiJFICxLGyESICAgHCgCjIAQIhZqIQ0gECgAACEXAkAgHCgClIAQIgMgLE8NACADQX9zIBBqIXkgECADICBqIgJrQQFxBEAgHSADQf//A3FBAXRqQf//AyADIBwgAigAAEGx893xeWxBD3ZB/P8HcWoiAigCAGsiBCAEQf//A08bOwEAIAIgAzYCACADQQFqIQMLIHkgIEYNAANAIB0gA0H//wNxQQF0akH//wMgAyAcIAMgIGooAABBsfPd8XlsQQ92Qfz/B3FqIgEoAgBrIgIgAkH//wNPGzsBACABIAM2AgAgHSADQQFqIgFB//8DcUEBdGpB//8DIAEgHCABICBqKAAAQbHz3fF5bEEPdkH8/wdxaiICKAIAayIEIARB//8DTxs7AQAgAiABNgIAIANBAmoiAyAsSQ0ACwsgHCgCiIAQITMgHCgCnIAQGiAcICw2ApSAECAWIDNqIQ8gDUEEaiEUIBBBCGohJyAQQQRqIQIgMyA1aiIhQQRqITtBACEMQQMhCwJAIBpFIBwgECgAAEGx893xeWxBD3ZB/P8HcWooAgAiBSASSXJFBEAgF0H//wNxIBdBEHZGIBdB/wFxIBdBGHZGcSEfIBBBAWshJCAaIQpBACEiQQAhHkEAIQkDQEEAIQcCQCAlICwgBWtBCElxDQACQAJ/AkACQCAFIBZPBEAgCyAkai8AACAFICBqIgQgC2pBAWsvAABHDQUgBCgAACAXRw0FIARBBGohAyAZIAIgGU8EfyACBSACKAAAIAMoAABzIgENAiAEQQhqIQMgJwsiAUsEQANAIAEoAAAgAygAAHMiBwRAIAEgB2hBA3ZqIAJrIQMMBwsgA0EEaiEDIAFBBGoiASAZSQ0ACwsCQCABIDlPDQAgAy8AACABLwAARw0AIANBAmohAyABQQJqIQELIAEgFUkEfyABIAMtAAAgAS0AAEZqBSABCyACayEDDAQLIAUgM2oiASgAACAXRw0EIAFBBGohAyACIBUgECAWIAVraiIEIAQgFUsbIgRBA2siB08EfyACBSACKAAAIAMoAABzIgMNAiABQQhqIQMgJwsiASAHSQRAA0AgASgAACADKAAAcyIYBEAgASAYaEEDdmogAmsMBQsgA0EEaiEDIAFBBGoiASAHSQ0ACwsCQCABIARBAWtPDQAgAy8AACABLwAARw0AIANBAmohAyABQQJqIQELIAEgBEkEfyABIAMtAAAgAS0AAEZqBSABCyACawwCCyABaEEDdiEDDAILIANoQQN2C0EEaiIHIBBqIARHIAQgFU9yRQRAIA0hAQJ/AkAgBCIDIBlJBEAgAygAACABKAAAcyIBDQEgA0EEaiEDIBQhAQsgAyAZSQRAA0AgAygAACABKAAAcyIYBEAgAyAYaEEDdmogBGsMBAsgAUEEaiEBIANBBGoiAyAZSQ0ACwsCQCADIDlPDQAgAS8AACADLwAARw0AIAFBAmohASADQQJqIQMLIAMgFUkEfyADIAEtAAAgAy0AAEZqBSADCyAEawwBCyABaEEDdgsgB2ohBwsgBSAgaiAJIAcgC0oiARshCSAHIAsgARshCwwBCyADQQRqIgcgCyAHIAtKIgEbIQsgBCAJIAEbIQkLIApBAWshCgJAAkACQAJAAkACQAJAAkAgByALRyAFIAtqICxLciAHQQRIckUEQCAHQQNrIRtBACEDQRAhBEEBIQEDQCADIAwgASAdIAMgBWpB//8DcUEBdGovAQAiGEkiKhshDCAEQQR1IS0gASAYIAEgGEsbIQFBECAEQQFqICobIQQgAyAtaiIDIBtIDQALIAFBAUsNAQsgHSAFQf//A3FBAXRqLwEAQQFHIAxyDQQgIg0DQQEhIiAfRQ0EIAIiAyAZTw0BA0AgAygAACAXcyIBRQRAIBkgA0EEaiIDSw0BDAMLCyADIAFoQQN2aiEDDAILIAEgBUsiAwRAIAchCwwKCyAFQQAgASADG2shBSAHIQsMBgsgAyAVTw0AIAMgFSADa2ohBCAXIQEDQCADLQAAIAFB/wFxRw0BIAFBCHYhASADQQFqIgMgBEcNAAsgBCEDCyADIAJrQQRqIR5BAiEiCyAiQQJHDQAgBUEBayIYIBJJDQBBAiEiIBggFmtBfEsNACAzICAgFiAYSyIbGyAYaiIHKAAAIBdHDQAgB0EEaiIFIQMgDyAVIBsbIgRBA2siASAFTQ0BA0AgAygAACAXcyIMRQRAIAEgA0EEaiIDSw0BDAMLCyADIAxoQQN2aiEDDAILIAUgHSAFIAxqQf//A3FBAXRqLwEAayEFDAILIAMgBE8NACAXIQEDQCADLQAAIAFB/wFxRw0BIAFBCHYhASADQQFqIgMgBEcNAAsgBCEDCyADIAVrIgFBBGohDCAWIBhNBH8gDQUgDyAHIAxqRgRAIBcgAUEDdHchAQJAAkAgDSIDIBlPDQADQCADKAAAIAFzIgRFBEAgGSADQQRqIgNLDQEMAgsLIAMgBGhBA3ZqIQMMAQsgAyAVTw0AIAMgFSADa2ohBANAIAMtAAAgAUH/AXFHDQEgAUEIdiEBIANBAWoiAyAERw0ACyAEIQMLIAwgDWsgA2ohDAsgIQshBCARIBc2AryABCAEQQRqIQUgByEBA0AgBSABIgNNBEAgAUEEayIBKAAAIBdGDQELCwJAIAMgBE0NACATIQEDQCADQQFrIgUtAAAgAS0AAEcNASABQQFrIQEgBSIDIARLDQALIAQhAwsgGCAYIBsgByAHIANrIgVrIA1HciAWIDVNcgR/IAUFIBEgF0EAIAVrQQN0dyIENgK8gAQgDyEBA0AgOyABIgNNBEAgAUEEayIBKAAAIARGDQELCyATIQECQCADICFNDQADQCADQQFrIgQtAAAgAS0AAEcNASABQQFrIQEgBCIDICFLDQALICEhAwsgBSAPaiADawtrIgEgEiABIBJLGyIDayAMaiIBIB5JIAwgHktyRQRAIBYgGCAeayAMaiIBIAEgFmtBfEsbIQVBACEMDAELQQAhDCADIBZrQXxLBEAgFiEFDAELAkAgASAeIAEgHkkbIgEgC00EQCAJIQQgCyEBDAELIBAgAyAgaiIEa0H//wNKDQQLIB0gA0H//wNxQQF0ai8BACILIANLBEAgBCEJIAEhCwwECyADIAtrIQUgBCEJIAEhCwsgBSASSQ0CIAoNAAsMAQtBACEJCwJAAn8CQAJAIAtBBE4EQCAQIAhrIQIgECAJayEEQRIgCyALQRNrQRJJGyALICUbIhggP0sNASACQQ5KIgsNAiACQQFqIQMgAgwDCyAQQQFqIRAMAwtBACArRSAOQQFqIgwgAkH/AW5qIAJqQQhqIDRNckUNBRoCQCACQQ9PBEAgDkHwAToAACACQQ9rIgNB/wFPBEAgDEH/ASAQIAhrQY4CayIDQf8BbiIBQQFqEBgaIAEgDmpBAmohDCABQYF+bCADaiEDCyAMIAM6AAAgDEEBaiEMDAELIA4gAkEEdDoAAAsgAiAMaiECIAghAyAMIQEDQCABIAMpAAA3AAAgA0EIaiEDIAFBCGoiASACSQ0ACyACIAQ7AABBACArRSACQQJqIgMgGEEEayIBQf8BbmpBBmogNE1yRQ0FGiAOLQAAIQIgAUEPTwRAIA4gAkEPajoAACAYQRNrIgFB/gNPBEAgA0H/ASAYQZEEayIBQf4DbiICQQF0IgNBAmoQGBogDCADIBBqIAhrakEEaiEDIAJBgnxsIAFqIQELIAFB/wFPBEAgA0H/AToAACADQQFqIQMgAUH/AWshAQsgAyABOgAAIANBAWohDiAQIBhqIhAhCAwDCyAOIAEgAmo6AAAgECAYaiIQIQggAyEODAILIAJBAWoiAyACQQ9rQf8BbmoLIQEgESACNgIMIBFCgICAgBA3AgQgESABNgIAIBEgAzYCHCARQoCAgIAQNwIUIBEgA0EPTgR/IAMgA0EPa0H/AW5qQQFqBSADCzYCECACQQJqIQECfwJAIAJBDU4EQCARIAE2AiwgEUKAgICAEDcCJCARIAJBA2oiASACQQ1rQf8Bbmo2AiAMAQsgESABNgIsIBFCgICAgBA3AiQgESABNgIgQQ8hASACQQxGDQAgAkEDaiIBDAELIAIgAkEMa0H/AW5qQQRqCyEFIBEgATYCPCARQoCAgIAQNwI0IBEgBTYCMCADIAJBD2tB/wFuaiACIAsbQQNqIQtBBCEDA0AgESADQQR0aiIBIAI2AgwgASAENgIEIAEgAzYCCCABIANBE08EfyADQRNrQf8BbiALakEBagUgCws2AgAgAyAYRyF6IANBAWohAyB6DQALQQEhFyARIBhBBHRqIgFBATYCHCABQoCAgIAQNwIUIAFCgICAgBA3AiQgAUECNgIsIAFBAzYCPCABQoCAgIAQNwI0IAEgASgCACICQQFqNgIQIAEgAkECajYCICABIAJBA2o2AjAgLEEBaiEkQQAhLgJAA0AgPCAQIBciImoiH08EQCAsIC5qIQIgESAXQQR0IgRqIkcoAgAhASARIBdBAWoiF0EEdGoiNygCACEDAkACfwJAAkACQAJAAkACQCBJBEAgASADTgRAIAQgEWpBQGsoAgAgAUEDakgNCQsgNSAfICBrIipB//8DayAqIEVJGyEtIB8oAAAhEgJAIBwoApSAECIBICpPDQAgJCABIgNrQQFxBEAgHSABQf//A3FBAXRqQf//AyABIBwgASAgaigAAEGx893xeWxBD3ZB/P8HcWoiBCgCAGsiCyALQf//A08bOwEAIAQgATYCACABQQFqIQMLIAEgAkYNAANAIB0gA0H//wNxQQF0akH//wMgAyAcIAMgIGooAABBsfPd8XlsQQ92Qfz/B3FqIgEoAgBrIgIgAkH//wNPGzsBACABIAM2AgAgHSADQQFqIgFB//8DcUEBdGpB//8DIAEgHCABICBqKAAAQbHz3fF5bEEPdkH8/wdxaiICKAIAayIEIARB//8DTxs7AQAgAiABNgIAIANBAmoiAyAkRw0ACwsgHCAqNgKUgBAgH0EIaiE2IB9BBGohCUEAIQxBAyELIBwgHygAAEGx893xeWxBD3ZB/P8HcWooAgAiBSAtTw0BDAULIAEgA04NByA1IB8gIGsiLUH//wNrIC0gRUkbITYgHygAACESAkAgHCgClIAQIgEgLU8NACAkIAEiA2tBAXEEQCAdIAFB//8DcUEBdGpB//8DIAEgHCABICBqKAAAQbHz3fF5bEEPdkH8/wdxaiIEKAIAayILIAtB//8DTxs7AQAgBCABNgIAIAFBAWohAwsgASACRg0AA0AgHSADQf//A3FBAXRqQf//AyADIBwgAyAgaigAAEGx893xeWxBD3ZB/P8HcWoiASgCAGsiAiACQf//A08bOwEAIAEgAzYCACAdIANBAWoiAUH//wNxQQF0akH//wMgASAcIAEgIGooAABBsfPd8XlsQQ92Qfz/B3FqIgIoAgBrIgQgBEH//wNPGzsBACACIAE2AgAgA0ECaiIDICRHDQALCyAYICJrIScgHCAtNgKUgBAgH0EIaiE+IB9BBGohCUEAIQwgHCAfKAAAQbHz3fF5bEEPdkH8/wdxaigCACIFIDZPDQEMAgsgGkUNAyASQf//A3EgEkEQdkYgEkH/AXEgEkEYdkZxIUIgH0EBayFKIBohCkEAIR5BACEbQQAhAgNAQQAhBwJAICUgKiAFa0EISXENAAJAAn8CQAJAIAUgFk8EQCALIEpqLwAAIAUgIGoiBCALakEBay8AAEcNBSAEKAAAIBJHDQUgBEEEaiEDIBkgCSAZTwR/IAkFIAkoAAAgAygAAHMiAQ0CIARBCGohAyA2CyIBSwRAA0AgASgAACADKAAAcyIHBEAgASAHaEEDdmogCWshAwwHCyADQQRqIQMgAUEEaiIBIBlJDQALCwJAIAEgOU8NACADLwAAIAEvAABHDQAgA0ECaiEDIAFBAmohAQsgASAVSQR/IAEgAy0AACABLQAARmoFIAELIAlrIQMMBAsgBSAzaiIBKAAAIBJHDQQgAUEEaiEDIAkgFSAfIBYgBWtqIgQgBCAVSxsiBEEDayIHTwR/IAkFIAkoAAAgAygAAHMiAw0CIAFBCGohAyA2CyIBIAdJBEADQCABKAAAIAMoAABzIicEQCABICdoQQN2aiAJawwFCyADQQRqIQMgAUEEaiIBIAdJDQALCwJAIAEgBEEBa08NACADLwAAIAEvAABHDQAgA0ECaiEDIAFBAmohAQsgASAESQR/IAEgAy0AACABLQAARmoFIAELIAlrDAILIAFoQQN2IQMMAgsgA2hBA3YLIQEgHyABQQRqIgdqIARHIAQgFU9yRQRAIA0hAQJ/AkAgBCIDIBlJBEAgAygAACABKAAAcyIBDQEgA0EEaiEDIBQhAQsgAyAZSQRAA0AgAygAACABKAAAcyInBEAgAyAnaEEDdmogBGsMBAsgAUEEaiEBIANBBGoiAyAZSQ0ACwsCQCADIDlPDQAgAS8AACADLwAARw0AIAFBAmohASADQQJqIQMLIAMgFUkEfyADIAEtAAAgAy0AAEZqBSADCyAEawwBCyABaEEDdgsgB2ohBwsgBSAgaiACIAcgC0oiARshAiAHIAsgARshCwwBCyADQQRqIgcgCyAHIAtKIgEbIQsgBCACIAEbIQILIApBAWshCgJAAkACQAJAAkACQAJAAkAgByALRyAFIAtqICpLciAHQQRIckUEQCAHQQNrIT5BACEDQRAhBEEBIQEDQCADIAwgASAdIAMgBWpB//8DcUEBdGovAQAiJ0kiSxshDCAEQQR1IUwgASAnIAEgJ0sbIQFBECAEQQFqIEsbIQQgAyBMaiIDID5IDQALIAFBAUsNAQsgHSAFQf//A3FBAXRqLwEAQQFHIAxyDQQgHg0DQQEhHiBCRQ0EIAkiAyAZTw0BA0AgAygAACAScyIBRQRAIBkgA0EEaiIDSw0BDAMLCyADIAFoQQN2aiEDDAILIAEgBUsiAwRAIAchCwwNCyAFQQAgASADG2shBSAHIQsMBgsgAyAVTw0AIAMgFSADa2ohBCASIQEDQCADLQAAIAFB/wFxRw0BIAFBCHYhASADQQFqIgMgBEcNAAsgBCEDCyADIAlrQQRqIRtBAiEeCyAeQQJHDQAgBUEBayInIC1JDQBBAiEeICcgFmtBfEsNACAzICAgFiAnSyI+GyAnaiIHKAAAIBJHDQAgB0EEaiIFIQMgDyAVID4bIgRBA2siASAFTQ0BA0AgAygAACAScyIMRQRAIAEgA0EEaiIDSw0BDAMLCyADIAxoQQN2aiEDDAILIAUgHSAFIAxqQf//A3FBAXRqLwEAayEFDAILIAMgBE8NACASIQEDQCADLQAAIAFB/wFxRw0BIAFBCHYhASADQQFqIgMgBEcNAAsgBCEDCyADIAVrIgFBBGohDCAWICdNBH8gDQUgDyAHIAxqRgRAIBIgAUEDdHchAQJAAkAgDSIDIBlPDQADQCADKAAAIAFzIgRFBEAgGSADQQRqIgNLDQEMAgsLIAMgBGhBA3ZqIQMMAQsgAyAVTw0AIAMgFSADa2ohBANAIAMtAAAgAUH/AXFHDQEgAUEIdiEBIANBAWoiAyAERw0ACyAEIQMLIAwgDWsgA2ohDAsgIQshBCARIBI2AryABCAEQQRqIQUgByEBA0AgBSABIgNNBEAgAUEEayIBKAAAIBJGDQELCwJAIAMgBE0NACATIQEDQCADQQFrIgUtAAAgAS0AAEcNASABQQFrIQEgBSIDIARLDQALIAQhAwsgJyAnID4gByAHIANrIgVrIA1HciAWIDVNcgR/IAUFIBEgEkEAIAVrQQN0dyIENgK8gAQgDyEBA0AgOyABIgNNBEAgAUEEayIBKAAAIARGDQELCyATIQECQCADICFNDQADQCADQQFrIgQtAAAgAS0AAEcNASABQQFrIQEgBCIDICFLDQALICEhAwsgBSAPaiADawtrIgEgLSABIC1LGyIDayAMaiIBIBtJIAwgG0tyRQRAIBYgJyAbayAMaiIBIAEgFmtBfEsbIQVBACEMDAELQQAhDCADIBZrQXxLBEAgFiEFDAELAkAgASAbIAEgG0kbIgEgC00EQCACIQQgCyEBDAELIB8gAyAgaiIEa0H//wNKDQcLIB0gA0H//wNxQQF0ai8BACICIANLBEAgBCECIAEhCwwHCyADIAJrIQUgBCECIAEhCwsgBSAtSQ0FIAoNAAsMBAsgGkUNACASQf//A3EgEkEQdkYgEkH/AXEgEkEYdkZxIUogH0EBayFLICchCyAaIQpBACEeQQAhG0EAIQIDQEEAIQcCQCAlIC0gBWtBCElxDQACQAJ/AkACQCAFIBZPBEAgCyBLai8AACAFICBqIgQgC2pBAWsvAABHDQUgBCgAACASRw0FIARBBGohAyAZIAkgGU8EfyAJBSAJKAAAIAMoAABzIgENAiAEQQhqIQMgPgsiAUsEQANAIAEoAAAgAygAAHMiBwRAIAEgB2hBA3ZqIAlrIQMMBwsgA0EEaiEDIAFBBGoiASAZSQ0ACwsCQCABIDlPDQAgAy8AACABLwAARw0AIANBAmohAyABQQJqIQELIAEgFUkEfyABIAMtAAAgAS0AAEZqBSABCyAJayEDDAQLIAUgM2oiASgAACASRw0EIAFBBGohAyAJIBUgHyAWIAVraiIEIAQgFUsbIgRBA2siB08EfyAJBSAJKAAAIAMoAABzIgMNAiABQQhqIQMgPgsiASAHSQRAA0AgASgAACADKAAAcyIqBEAgASAqaEEDdmogCWsMBQsgA0EEaiEDIAFBBGoiASAHSQ0ACwsCQCABIARBAWtPDQAgAy8AACABLwAARw0AIANBAmohAyABQQJqIQELIAEgBEkEfyABIAMtAAAgAS0AAEZqBSABCyAJawwCCyABaEEDdiEDDAILIANoQQN2CyEBIB8gAUEEaiIHaiAERyAEIBVPckUEQCANIQECfwJAIAQiAyAZSQRAIAMoAAAgASgAAHMiAQ0BIANBBGohAyAUIQELIAMgGUkEQANAIAMoAAAgASgAAHMiKgRAIAMgKmhBA3ZqIARrDAQLIAFBBGohASADQQRqIgMgGUkNAAsLAkAgAyA5Tw0AIAEvAAAgAy8AAEcNACABQQJqIQEgA0ECaiEDCyADIBVJBH8gAyABLQAAIAMtAABGagUgAwsgBGsMAQsgAWhBA3YLIAdqIQcLIAUgIGogAiAHIAtKIgEbIQIgByALIAEbIQsMAQsgA0EEaiIHIAsgByALSiIBGyELIAQgAiABGyECCyAKQQFrIQoCQAJAAkACQAJAAkACQAJAIAcgC0cgBSALaiAtS3IgB0EESHJFBEAgB0EDayFCQQAhA0EQIQRBASEBA0AgAyAMIAEgHSADIAVqQf//A3FBAXRqLwEAIipJIkwbIQwgBEEEdSFQIAEgKiABICpLGyEBQRAgBEEBaiBMGyEEIAMgUGoiAyBCSA0ACyABQQFLDQELIB0gBUH//wNxQQF0ai8BAEEBRyAMcg0EIB4NA0EBIR4gSkUNBCAJIgMgGU8NAQNAIAMoAAAgEnMiAUUEQCAZIANBBGoiA0sNAQwDCwsgAyABaEEDdmohAwwCCyABIAVLIgMEQCAHIQsMCgsgBUEAIAEgAxtrIQUgByELDAYLIAMgFU8NACADIBUgA2tqIQQgEiEBA0AgAy0AACABQf8BcUcNASABQQh2IQEgA0EBaiIDIARHDQALIAQhAwsgAyAJa0EEaiEbQQIhHgsgHkECRw0AIAVBAWsiKiA2SQ0AQQIhHiAqIBZrQXxLDQAgMyAgIBYgKksiQhsgKmoiBygAACASRw0AIAdBBGoiBSEDIA8gFSBCGyIEQQNrIgEgBU0NAQNAIAMoAAAgEnMiDEUEQCABIANBBGoiA0sNAQwDCwsgAyAMaEEDdmohAwwCCyAFIB0gBSAMakH//wNxQQF0ai8BAGshBQwCCyADIARPDQAgEiEBA0AgAy0AACABQf8BcUcNASABQQh2IQEgA0EBaiIDIARHDQALIAQhAwsgAyAFayIBQQRqIQwgFiAqTQR/IA0FIA8gByAMakYEQCASIAFBA3R3IQECQAJAIA0iAyAZTw0AA0AgAygAACABcyIERQRAIBkgA0EEaiIDSw0BDAILCyADIARoQQN2aiEDDAELIAMgFU8NACADIBUgA2tqIQQDQCADLQAAIAFB/wFxRw0BIAFBCHYhASADQQFqIgMgBEcNAAsgBCEDCyAMIA1rIANqIQwLICELIQQgESASNgK8gAQgBEEEaiEFIAchAQNAIAUgASIDTQRAIAFBBGsiASgAACASRg0BCwsCQCADIARNDQAgEyEBA0AgA0EBayIFLQAAIAEtAABHDQEgAUEBayEBIAUiAyAESw0ACyAEIQMLICogKiBCIAcgByADayIFayANR3IgFiA1TXIEfyAFBSARIBJBACAFa0EDdHciBDYCvIAEIA8hAQNAIDsgASIDTQRAIAFBBGsiASgAACAERg0BCwsgEyEBAkAgAyAhTQ0AA0AgA0EBayIELQAAIAEtAABHDQEgAUEBayEBIAQiAyAhSw0ACyAhIQMLIAUgD2ogA2sLayIBIDYgASA2SxsiA2sgDGoiASAbSSAMIBtLckUEQCAWICogG2sgDGoiASABIBZrQXxLGyEFQQAhDAwBC0EAIQwgAyAWa0F8SwRAIBYhBQwBCwJAIAEgGyABIBtJGyIBIAtNBEAgAiEEIAshAQwBCyAfIAMgIGoiBGtB//8DSg0ECyAdIANB//8DcUEBdGovAQAiAiADSwRAIAQhAiABIQsMBAsgAyACayEFIAQhAiABIQsLIAUgNkkNAiAKDQALDAELQQAhAiAnIQsLIAsgJ0wNA0ESIAsgC0ETa0ESSRsgCyAlGyIERQ0DIB8gAmsMAgtBACECCyALQQRIDQFBEiALIAtBE2tBEkkbIAsgJRshBCAfIAJrCyEFIAQgImpB/x9MIAQgP01xRQRAIBchGAwECyBHKAIAIgkgRygCDCIBQQFqIgIgAUEPa0H/AW5qIgcgASABQQ5KIgobayEDIAJBDkoEfyABIAFBDmtB/wFuakECagUgAgsgA2oiCyA3KAIASARAIDcgAjYCDCA3QoCAgIAQNwIEIDcgCzYCAAsgAUECaiILIQIgAUENTgR/IAEgAUENa0H/AW5qQQNqBSACCyADaiIMIBEgIkECakEEdGoiAigCAEgEQCACIAs2AgwgAkKAgICAEDcCBCACIAw2AgALIAFBA2oiCyECIAFBDE4EfyABIAFBDGtB/wFuakEEagUgAgsgA2oiAyARICJBA2pBBHRqIgIoAgBIBEAgAiALNgIMIAJCgICAgBA3AgQgAiADNgIACyAEQQNKBEAgB0EDaiALIAobIQdBBCEDIBEgIiABa0EEdGohCiARICJBBHRqKAIIQQFHIRIDQAJ/IBJFBEAgASAiSAR/IAooAgAFQQALIANBE08EfyADQRNrQf8BbiAHakEBagUgBwtqIQwgAQwBCyADQRNPBH8gA0ETa0H/AW5BBGoFQQMLIAlqIQxBAAshJwJAIAMgImoiAiAYQQNqTARAIAwgESACQQR0aigCACAla0oNAQsgESACQQR0aiILICc2AgwgCyAFNgIEIAsgAzYCCCALIAw2AgAgAiAYIAIgGEobIBggAyAERhshGAsgAyAERiF7IANBAWohAyB7RQ0ACwsgESAYQQR0aiIBQQE2AhwgAUKAgICAEDcCFCABQoCAgIAQNwIkIAFBAjYCLCABQQM2AjwgAUKAgICAEDcCNCABIAEoAgAiAkEBajYCECABIAJBAmo2AiAgASACQQNqNgIwCyAuQQFqIS4gJEEBaiEkIBcgGEgNAQsLIBggESAYQQR0aiIBKAIIIgRrISIgASgCBCEFCwNAIBEgIkEEdGoiAygCCCEBIAMgBDYCCCADKAIEIXwgAyAFNgIEIAEgIkwhAyAiIAFrISIgASEEIHwhBSADDQALQQAhByAYQQBMDQADQAJAIBEgB0EEdGoiASgCCCIEQQFGBEAgB0EBaiEHIBBBAWohEAwBCyABKAIEIQtBACArRSAQIAhrIgIgDkEBaiIMIAJB/wFuampBCGogNE1yRQ0FGgJAIAJBD08EQCAOQfABOgAAIAJBD2siAUH/AU8EQCAMQf8BIAJBjgJrIgNB/wFuIgFBAWoQGBogASAOakECaiEMIAFBgX5sIANqIQELIAwgAToAACAMQQFqIQwMAQsgDiACQQR0OgAACyAEIAdqIQcgAiAMaiECIAghAyAMIQEDQCABIAMpAAA3AAAgA0EIaiEDIAFBCGoiASACSQ0ACyACIAs7AABBACArRSACQQJqIgMgBEEEayIBQf8BbmpBBmogNE1yRQ0FGiAOLQAAIQICfyABQQ9PBEAgDiACQQ9qOgAAIARBE2siAUH+A08EQCADQf8BIARBkQRrIgFB/gNuIgJBAXQiA0ECahAYGiAMIAMgEGogCGtqQQRqIQMgAkGCfGwgAWohAQsgAUH/AU8EQCADQf8BOgAAIANBAWohAyABQf8BayEBCyADIAE6AAAgA0EBagwBCyAOIAEgAmo6AAAgAwshDiAEIBBqIhAhCAsgByAYSA0ACwsgECA8TQ0ACwsgMiAIayECICsEQEEAIA4gAkHwAWpB/wFuaiACakEBaiA0Sw0BGgsgDkEBaiEBIAIgCGohAwJAIAJBD08EQCAOQfABOgAAIAJBD2siB0H/AU8EQCABQf8BIAJBjgJrIgRB/wFuIgFBAWoiCxAYGiABQYF+bCAEaiEHIAEgDmpBAmohASALIA5qIQ4LIAEgBzoAACAOQQJqIQEMAQsgDiACQQR0OgAACyABIAggAhAXIX0gBiADID1rNgIQIH0gAmogKGsLIX4gEUHAgARqJAAgfgsiAkEASg0BCyAcQQE6AJuAEAsgL0EQaiQAIAIhDAsgQBAZDAILQX9BfiAwQX9IGyE6DAULIAZBEGpBAEGggAEQGBogIyApIEhsaiENAkACQCAwIFxOBEAgXkUEQEEAIQwgUg0EIA0gKWohEyAGQQM7AZaAASAGICk2ApCAASAGICk2AqCAASBfBEAgDSECICghCAwECyATQQVrIRYgE0ELayEYIAZBEGogDSgAAEGx893xeWxBEnZB/v8AcWpBADsBACATQQZrIQ8gE0EIayEQICghCCANIQIDQEEBIQUgAkEBaiEEIAIoAAEhAyBEIQcDQCAEIgEgBWoiBCAYSw0FIAZBEGogA0Gx893xeWxBEnZB/v8AcWoiCy8BACF/IAQoAAAhAyALIAEgDWs7AQAgB0EGdSEFIAdBAWohByB/IA1qIgsoAAAgASgAAEcNAAsgASACayIEQY4CayEFIARBD2shA0EAIQogBEHvAWoiISEJA0ACQCAKIQ4gCSEXIAMhDCAFIRogCyIEIA1NIAEiByACTXINACAFQQFrIQUgA0EBayEDIAlBAWshCSAKQQFqIQogAUEBayIBLQAAIARBAWsiCy0AAEYNAQsLIAhBAWohAQJAIAcgAmsiC0EPTwRAIAhB8AE6AAAgC0EPayIDQf8BTgRAIAFB/wEgISAOQf0DIAMgA0H9A04bamtB/wFuQQFqEBgaIBdB/QMgDCAMQf0DThtrQf8BbiIBQYF+bCAaaiEDIAEgCGpBAmohAQsgASADOgAAIAFBAWohAQwBCyAIIAtBBHQ6AAALIAEgC2ohBQNAIAEgAikAADcAACACQQhqIQIgAUEIaiIBIAVJDQALIAghAyAHIQIDQCAFIAIgBGs7AAAgBEEEaiEBIAVBAmohCAJAAkACQAJAIBACfyACQQRqIgsgEE8EQCALDAELIAsoAAAgASgAAHMiAQ0CIARBCGohASACQQhqCyIESwRAA0AgBCgAACABKAAAcyIHBEAgBCAHaEEDdmohBAwDCyABQQRqIQEgBEEEaiIEIBBJDQALCwJAIAQgD08NACABLwAAIAQvAABHDQAgAUECaiEBIARBAmohBAsgBCAWTw0AIAQgAS0AACAELQAARmohBAsgBCALayIBIAJqQQRqIQIgAUEPSQ0BIAMgAy0AAEEPajoAACAIQX82AAAgAUEPayIEQfwHTwRAIAFBiwhrIgFB/AduIgNBhHhsIAFqIQQgBUEGakH/ASADQQJ0IgFBBGoQGCABaiEICyAIIARB//8DcUH/AW4iAWoiAyABIARqOgAAIANBAWohCAwCCyACIAFoQQN2IgFBBHJqIQILIAMgAy0AACABajoAAAsgAiAYTw0FIAZBEGoiASACQQJrIgMoAABBsfPd8XlsQRJ2Qf7/AHFqIAMgDWs7AQAgAigAAEGx893xeWxBEnZB/v8AcSABaiIBLwEAIYABIAEgAiANazsBACCAASANaiIEKAAAIAIoAABHDQEgCEEAOgAAIAhBAWohBSAIIQMMAAsACwALQQAhDCBSDQMgDSApaiETIAYgKTYCkIABIAYgKTYCoIABIAZBAUECIA1B//8DSxs7AZaAASANKAAAQbHz3fF5bEEUdiEBAkAgDUGAgARJIhZFBEAgBkEQaiABQQJ0aiANNgIADAELIAZBEGogAUECdGpBADYCAAsgE0EFayEPIBNBC2shECATQQZrISEgE0EIayEYICghCSANIQIDQCACQQJqIQQgAkEBaiEBIAIoAAFBsfPd8XlsQRR2IQcCQCAWRQRAIEQhCyBPIQUgBCAQSw0EA0AgBkEQaiAHQQJ0aiIDKAIAIQcgBCgAACGBASADIAE2AgAgASAHQf//A2pNBEAgBygAACABKAAARg0DCyALQQZ1IQMggQFBsfPd8XlsQRR2IQcgBSILQQFqIQUgAyAEIgFqIgQgEE0NAAsMBAsgRCEMIE8hBSAEIBBLDQMDQCAGQRBqIAdBAnRqIgsoAgAhAyAEKAAAIYIBIAsgASANayILNgIAIAsgA0H//wNqTQRAIAMgDWoiBygAACABKAAARg0CCyAMQQZ1IQMgggFBsfPd8XlsQRR2IQcgBSIMQQFqIQUgECADIAQiAWoiBE8NAAsMAwsgASACayIDQY4CayEFIANBD2shC0EAIQwgA0HvAWoiFCEKA0ACQCAMIQ4gCiEXIAshCCAFIRogByIEIA1NIAEiAyACTXINACAFQQFrIQUgCEEBayELIApBAWshCiAMQQFqIQwgAUEBayIBLQAAIARBAWsiBy0AAEYNAQsLIAlBAWohAQJAIAMgAmsiC0EPTwRAIAlB8AE6AAAgC0EPayIFQf8BTgRAIAFB/wEgFCAOQf0DIAUgBUH9A04bamtB/wFuQQFqEBgaIBdB/QMgCCAIQf0DThtrQf8BbiIBQYF+bCAaaiEFIAEgCWpBAmohAQsgASAFOgAAIAFBAWohAQwBCyAJIAtBBHQ6AAALIAEgC2ohBQNAIAEgAikAADcAACACQQhqIQIgAUEIaiIBIAVJDQALIAkhCyADIQIDQCAFIAIgBGs7AAAgBEEEaiEBIAVBAmohCQJAAkACQAJAIBgCfyACQQRqIgMgGE8EQCADDAELIAMoAAAgASgAAHMiAQ0CIARBCGohASACQQhqCyIESwRAA0AgBCgAACABKAAAcyIIBEAgBCAIaEEDdmohBAwDCyABQQRqIQEgBEEEaiIEIBhJDQALCwJAIAQgIU8NACABLwAAIAQvAABHDQAgAUECaiEBIARBAmohBAsgBCAPTw0AIAQgAS0AACAELQAARmohBAsgBCADayIBIAJqQQRqIQIgAUEPSQ0BIAsgCy0AAEEPajoAACAJQX82AAAgAUEPayIEQfwHTwRAIAFBiwhrIgFB/AduIgNBhHhsIAFqIQQgBUEGakH/ASADQQJ0IgFBBGoQGCABaiEJCyAJIARB//8DcUH/AW4iAWoiAyABIARqOgAAIANBAWohCQwCCyACIAFoQQN2IgFBBHJqIQILIAsgCy0AACABajoAAAsgAiAQTw0DIAJBAmsiASgAAEGx893xeWxBFHYhAwJAIBZFBEAgBkEQaiIEIANBAnRqIAE2AgAgAigAAEGx893xeWxBEnZB/P8AcSAEaiIBKAIAIQQgASACNgIAIARB//8DaiACSQ0DIAQoAAAgAigAAEcNAwwBCyAGQRBqIgQgA0ECdGogASANazYCACACKAAAQbHz3fF5bEESdkH8/wBxIARqIgMoAgAhASADIAIgDWsiAzYCACABQf//A2ogA0kNAiABIA1qIgQoAAAgAigAAEcNAgsgCUEAOgAAIAlBAWohBSAJIQsMAAsACwALAkAgXkUEQEEAIQwgUg0EICggMGohGCANIClqIRAgBkEDOwGWgAEgBiApNgKQgAEgBiApNgKggAEgXwRAIA0hAiAoIQgMAgsgEEEFayEhIBBBC2shDyAGQRBqIA0oAABBsfPd8XlsQRJ2Qf7/AHFqQQA7AQAgEEEGayEUIBBBCGshFiAoIQggDSECA0BBASEFIAJBAWohBCACKAABIQMgRCEHA0AgBCIBIAVqIgQgD0sNAyAGQRBqIANBsfPd8XlsQRJ2Qf7/AHFqIgsvAQAhgwEgBCgAACEDIAsgASANazsBACAHQQZ1IQUgB0EBaiEHIIMBIA1qIgsoAAAgASgAAEcNAAsgASACayIEQY4CayEFIARBD2shA0EAIQkgBEHvAWoiIiEOA0ACQCAJIRcgDiEaIAMhCiAFIRMgCyIEIA1NIAEiByACTXINACAFQQFrIQUgA0EBayEDIA5BAWshDiAJQQFqIQkgAUEBayIBLQAAIARBAWsiCy0AAEYNAQsLIBggCEEBaiIBIAcgAmsiC2ogC0H/AW5qQQhqSQ0FAkAgC0EPTwRAIAhB8AE6AAAgC0EPayIDQf8BTgRAIAFB/wEgIiAXQf0DIAMgA0H9A04bamtB/wFuQQFqEBgaIBpB/QMgCiAKQf0DThtrQf8BbiIBQYF+bCATaiEDIAEgCGpBAmohAQsgASADOgAAIAFBAWohAQwBCyAIIAtBBHQ6AAALIAEgC2ohBQNAIAEgAikAADcAACACQQhqIQIgAUEIaiIBIAVJDQALIAghAyAHIQIDQCAFIAIgBGs7AAAgBEEEaiEBIBggBQJ/AkAgFgJ/IAJBBGoiCyAWTwRAIAsMAQsgCygAACABKAAAcyIBDQEgBEEIaiEBIAJBCGoLIgRLBEADQCAEKAAAIAEoAABzIggEQCAEIAhoQQN2aiALawwECyABQQRqIQEgBEEEaiIEIBZJDQALCwJAIAQgFE8NACABLwAAIAQvAABHDQAgAUECaiEBIARBAmohBAsgBCAhSQR/IAQgAS0AACAELQAARmoFIAQLIAtrDAELIAFoQQN2CyIBQfABakH/AW5qQQhqSQ0GIAVBAmohCCABIAJqQQRqIQIgAy0AACEEAkAgAUEPTwRAIAMgBEEPajoAACAIQX82AAAgAUEPayIEQfwHTwRAIAFBiwhrIgFB/AduIgNBhHhsIAFqIQQgBUEGakH/ASADQQJ0IgFBBGoQGCABaiEICyAIIARB//8DcUH/AW4iAWoiAyABIARqOgAAIANBAWohCAwBCyADIAEgBGo6AAALIAIgD08NAyAGQRBqIgEgAkECayIDKAAAQbHz3fF5bEESdkH+/wBxaiADIA1rOwEAIAIoAABBsfPd8XlsQRJ2Qf7/AHEgAWoiAS8BACGEASABIAIgDWs7AQAghAEgDWoiBCgAACACKAAARw0BIAhBADoAACAIQQFqIQUgCCEDDAALAAsAC0EAIQwgUg0DIA0gKWohECAGICk2ApCAASAGICk2AqCAASAGQQFBAiANQf//A0sbOwGWgAEgDSgAAEGx893xeWxBFHYhAQJAIA1BgIAESSIhRQRAIAZBEGogAUECdGogDTYCAAwBCyAGQRBqIAFBAnRqQQA2AgALICggMGohFiAQQQVrIRQgEEELayEYIBBBBmshIiAQQQhrIQ8gKCEOIA0hAgNAAkAgAkECaiEEIAJBAWohASACKAABQbHz3fF5bEEUdiEHAkAgIUUEQCBEIQsgTyEFIAQgGEsNAgNAIAZBEGogB0ECdGoiAygCACEHIAQoAAAhhQEgAyABNgIAIAEgB0H//wNqTQRAIAcoAAAgASgAAEYNAwsgC0EGdSEDIIUBQbHz3fF5bEEUdiEHIAUiC0EBaiEFIAMgBCIBaiIEIBhNDQALDAILIEQhCiBPIQUgBCAYSw0BA0AgBkEQaiAHQQJ0aiILKAIAIQMgBCgAACGGASALIAEgDWsiCzYCACALIANB//8Dak0EQCADIA1qIgcoAAAgASgAAEYNAgsgCkEGdSEDIIYBQbHz3fF5bEEUdiEHIAUiCkEBaiEFIBggAyAEIgFqIgRPDQALDAELIAEgAmsiA0GOAmshBSADQQ9rIQtBACEKIANB7wFqIhIhCQNAAkAgCiEXIAkhGiALIQggBSETIAciBCANTSABIgMgAk1yDQAgBUEBayEFIAhBAWshCyAJQQFrIQkgCkEBaiEKIAFBAWsiAS0AACAEQQFrIgctAABGDQELCyAWIA5BAWoiASADIAJrIgtqIAtB/wFuakEIakkNBQJAIAtBD08EQCAOQfABOgAAIAtBD2siBUH/AU4EQCABQf8BIBIgF0H9AyAFIAVB/QNOG2prQf8BbkEBahAYGiAaQf0DIAggCEH9A04ba0H/AW4iAUGBfmwgE2ohBSABIA5qQQJqIQELIAEgBToAACABQQFqIQEMAQsgDiALQQR0OgAACyABIAtqIQUDQCABIAIpAAA3AAAgAkEIaiECIAFBCGoiASAFSQ0ACyADIQIDQCAFIAIgBGs7AAAgBEEEaiEBIBYgBQJ/AkAgDwJ/IAJBBGoiAyAPTwRAIAMMAQsgAygAACABKAAAcyIBDQEgBEEIaiEBIAJBCGoLIgRLBEADQCAEKAAAIAEoAABzIgsEQCAEIAtoQQN2aiADawwECyABQQRqIQEgBEEEaiIEIA9JDQALCwJAIAQgIk8NACABLwAAIAQvAABHDQAgAUECaiEBIARBAmohBAsgBCAUSQR/IAQgAS0AACAELQAARmoFIAQLIANrDAELIAFoQQN2CyIBQfABakH/AW5qQQhqSQ0GIAVBAmohBCABIAJqQQRqIQIgDi0AACEDAn8gAUEPTwRAIA4gA0EPajoAACAEQX82AAAgAUEPayIHQfwHTwRAIAFBiwhrIgFB/AduIgNBhHhsIAFqIQcgBUEGakH/ASADQQJ0IgFBBGoQGCABaiEECyAEIAdB//8DcUH/AW4iAWoiAyABIAdqOgAAIANBAWoMAQsgDiABIANqOgAAIAQLIQ4gAiAYTw0BIAJBAmsiASgAAEGx893xeWxBFHYhAwJAICFFBEAgBkEQaiIEIANBAnRqIAE2AgAgAigAAEGx893xeWxBEnZB/P8AcSAEaiIBKAIAIQQgASACNgIAIARB//8DaiACSQ0EIAQoAAAgAigAAEcNBAwBCyAGQRBqIgQgA0ECdGogASANazYCACACKAAAQbHz3fF5bEESdkH8/wBxIARqIgMoAgAhASADIAIgDWsiAzYCACABQf//A2ogA0kNAyABIA1qIgQoAAAgAigAAEcNAwsgDkEAOgAAIA5BAWohBQwACwALCyAOIBAgAmsiAWogAUHwAWpB/wFuakEBaiAWSw0DIA5BAWohBAJAIAFBD08EQCAOQfABOgAAIAFBD2siDUH/AU8EQCAEQf8BIAFBjgJrIgRB/wFuIgNBAWoiCxAYGiADQYF+bCAEaiENIAMgDmpBAmohBCALIA5qIQ4LIAQgDToAACAOQQJqIQQMAQsgDiABQQR0OgAACyAEIAIgARAXIAFqIChrIQwMAwsgCCAQIAJrIgFqIAFB8AFqQf8BbmpBAWogGEsNAiAIQQFqIQQCQCABQQ9PBEAgCEHwAToAACABQQ9rIg1B/wFPBEAgBEH/ASABQY4CayILQf8BbiIDQQFqIgUQGBogAyAIakECaiEEIANBgX5sIAtqIQ0gBSAIaiEICyAEIA06AAAgCEECaiEEDAELIAggAUEEdDoAAAsgBCACIAEQFyABaiAoayEMDAILIAlBAWohBAJAIBMgAmsiAUEPTwRAIAlB8AE6AAAgAUEPayINQf8BTwRAIARB/wEgAUGOAmsiC0H/AW4iA0EBaiIFEBgaIAMgCWpBAmohBCAFIAlqIQkgA0GBfmwgC2ohDQsgBCANOgAAIAlBAmohBAwBCyAJIAFBBHQ6AAALIAQgAiABEBcgAWogKGshDAwBCyAIQQFqIQQCQCATIAJrIgFBD08EQCAIQfABOgAAIAFBD2siDUH/AU8EQCAEQf8BIAFBjgJrIgtB/wFuIgNBAWoiBRAYGiADIAhqQQJqIQQgA0GBfmwgC2ohDSAFIAhqIQgLIAQgDToAACAIQQJqIQQMAQsgCCABQQR0OgAACyAEIAIgARAXIAFqIChrIQwLIAwgMEoEQEF/IToMBAsgDEEASARAQX4hOgwECyAMRSAMIClGcg0AIAwgWWohCwwBCyBVICkgWWoiC0gEQEEAIToMAwsgKCAjICkgSGxqICkQJxogKSEMCyBOIAw2AAAgOkEEaiAMaiE6IAwgKGohTiBIQQFqIkggWkcNAAsLIAZBgIICaiQAIDoiAg0BQQAhQyBBEBkMBQsgAwRAIAEgRmwiASAAKAIIaiAAKAIEIAFqQRBqIAIQJxoMAQsCfyAAKAIEIQkgACgCNCBGQQJ0aigAACEjIAAoAgggASBGbGohCkEAIQEgACgCDC0AACIIQQJ2IAIiBCAAKAIoIgNOcSEMIAggA0EBSnEhDiAAKAIYIQ1BASELAkACQAJAIAhBEHEgA0EQSnINACAFIAIgA20iCEGAAUhyDQAgCCECIAMiC0EASg0ADAELIEEgQSAKIAwbIA4bIQUgAiALbCEBIA1BBGshF0EAIQcDQEF/IQggI0EASCAXICNJcg0CIAkgI2ooAAAiDUEASA0CIA0gACgCGCAjQQRqIihrSg0CIAkgKGohCAJAIAIgDUYEQCAFIAggAhAnGgwBCyAIIA0gBSACIAAoAkARBgAgAkYNAEF+DAQLIAIgBWohBSANIChqISMgB0EBaiIHIAtHDQALCwJAIA4EQBAwIAQgA24hAiADIARNBEBBASADIANBAU0bIgtBfHEhCSALQQNxIQ1BACEHIANBBEkhDANAIAcgQWohCyAKIAMgB2xqIQVBACEjIAxFBEADQCAFICNqIAsgAiAjbGotAAA6AAAgBSAjQQFyIghqIAsgAiAIbGotAAA6AAAgBSAjQQJyIghqIAsgAiAIbGotAAA6AAAgBSAjQQNyIghqIAsgAiAIbGotAAA6AAAgI0EEaiIjIAlHDQALC0EAIQggDQRAA0AgBSAjaiALIAIgI2xqLQAAOgAAICNBAWohIyAIQQFqIgggDUcNAAsLIAdBAWoiByACSQ0ACwsgCiACIANsIgJqIAIgQWogBCACaxAXGgwBCyAMRQ0AEDACQCAEIANuIghBB3FFBEAgA0EDdCENIAhBCE8EQCAIQQN2IQUgMUEHaiEMIDFBBmohDiAxQQVqISggMUEEaiEXIDFBA2ohGiAxQQJqIUQgMUEBaiETQQAhCwNAIAwgC0EDdCICaiEQIAIgDmohGCACIChqIRYgAiAXaiEPIAIgGmohTyACIERqISMgAiATaiEpIAIgMWohISACIAVsIRQgAkEHciAFbCEiIAJBBnIgBWwhMCACQQVyIAVsIRIgAkEEciAFbCEnIAJBA3IgBWwhPSACQQJyIAVsIREgAkEBciAFbCEVQQAhAgNAICEgAiANbCIHaiACIEFqIgkgFGotAAA6AAAgByApaiAJIBVqLQAAOgAAIAcgI2ogCSARai0AADoAACAHIE9qIAkgPWotAAA6AAAgByAPaiAJICdqLQAAOgAAIAcgFmogCSASai0AADoAACAHIBhqIAkgMGotAAA6AAAgByAQaiAJICJqLQAAOgAAIAJBAWoiAiAFRw0ACyALQQFqIgsgA0cNAAsLIAMgCGwiCCANQQFrSwRAIANBB2whByADQQZsIQkgA0EFbCEMIANBAnQhDiADQQNsISggA0EBdCEXQQAhIwNAICMgMWohGiAKICNBA3ZqIUQgDSECQQAhBQNAIAUgRGoiCyAFIBpqKQMAIooBQgeIIIoBhUKqgaiFoJWA1QCDQoEBfiCKAYUiigFCDoggigGFQsyZg4DAmTODQoGAAX4gigGFIooBQhyIIIoBhULw4cOHD4NCgYCAgAF+IIoBhSKKATwAACADIAtqIIoBQgiIPAAAIAsgF2ogigFCEIg8AAAgCyAoaiCKAUIYiDwAACALIA5qIIoBQiCIPAAAIAsgDGogigFCKIg8AAAgCSALaiCKAUIwiDwAACAHIAtqIIoBQjiIPAAAIAIiBSANaiICQQFrIAhJDQALICNBCGoiIyANSQ0ACwsgCCAKaiAIIEFqIAQgCGsQFxoMAQsgCiBBIAQQFxoLIAhBAEgNAQsgASEICyAICyECCyACQQBIBEAgAiFDIEEQGQwECyACIENqIUMgRkEBaiJGIAAoAhwiA0gNAAsLIEEQGQwBCwJAIAJBgQJOBEAgOEGAAjYCAEGHFiA4ECAMAQsgAkEATARAQd0OQSsQLgwBCwJAIAIgACgCSCIBRg0AIAFBAEoEQCAAQQE2AkxBACECA0AgOEEcNgJAQcIXIDhBQGsQICA4QRwQazYCMEGvFyA4QTBqECAgAkEBaiICIAAoAkhIDQALCyAAQoGAgIBwNwK8ESAAQQA2AkgjAEEwayIBJAAgAUEEaiICQQBBLBAYGiAAQZARaiIDIAJBLBAXQoCAhICAgAg3AgAgAUEwaiQAIANBADYCDCAAKAJEIgJBAEwNACAAQdAIakEANgIAIDhBADYCTCA4QcwAakEYEEUhAUEAIDgoAkwiAiABG0UEQBBHQQAhAgsgAkEANgIEIAIgADYCACAAKAIoIQMgACgCJCEBIDhBADYCTCA4QcwAaiABIANBAnRqIgMgAUEBdGoQRSEBQQAgOCgCTCJDIAEbRQRAEEdBACFDCyACIEM2AgggAiAAKAIkIgE2AhQgAiABIENqIgE2AgwgAiABIANqNgIQIDhBBjYCIEHwFyA4QSBqECAgOEEGEGs2AhBBrxcgOEEQahAgIAAoAkQhAgsgACACNgJICyAAQoGAgIBwNwK8ESAAKAIsIUMLIDhB0ABqJAAgQwvYAQECfyACQfD///8HSQRAAkACQCACQQtPBEAgAkEPckEBaiIEEC0hAyAAIARBgICAgHhyNgIIIAAgAzYCACAAIAI2AgQMAQsgACACOgALIAAhAyACRQ0BCyADIAEgAhAeGgsgAiADakEAOgAAIAAPC0HYABAdQdAAaiIAQaTfATYCACAAQdDdATYCAEEZEC0iAUEANgIIIAFCjICAgMABNwIAIAFBDGoiAkHbDykAADcABSABQdYPKQAANwAMIAAgAjYCBCAAQYDeATYCACAAQaDeAUEWEA8ACxYAIABBICABEF4iADYCAEEAQQwgABsLmwMBBH8gASAAQQRqIgRqQQFrQQAgAWtxIgUgAmogACAAKAIAIgFqQQRrTQR/IAAoAgQiAyAAKAIIIgY2AgggBiADNgIEIAQgBUcEQCAAIABBBGsoAgBBfnFrIgMgBSAEayIEIAMoAgBqIgU2AgAgAyAFQXxxakEEayAFNgIAIAAgBGoiACABIARrIgE2AgALAn8gASACQRhqTwRAIAAgAmpBCGoiAyABIAJrQQhrIgE2AgAgAyABQXxxakEEayABQQFyNgIAIAMCfyADKAIAQQhrIgFB/wBNBEAgAUEDdkEBawwBCyABZyEEIAFBHSAEa3ZBBHMgBEECdGtB7gBqIAFB/x9NDQAaQT8gAUEeIARrdkECcyAEQQF0a0HHAGoiASABQT9PGwsiAUEEdCIEQbDiAWo2AgQgAyAEQbjiAWoiBCgCADYCCCAEIAM2AgAgAygCCCADNgIEQbjqAUG46gEpAwBCASABrYaENwMAIAAgAkEIaiIBNgIAIAAgAUF8cWoMAQsgACABagtBBGsgATYCACAAQQRqBSADCwsmAQF/IwBBEGsiACQAIABBADYCDEGA4QFBxRZBABBuIABBEGokAAvBAQEDfwJAIAEgAigCECIDBH8gAwUgAhBoDQEgAigCEAsgAigCFCIEa0sEQCACIAAgASACKAIkEQQADwsCQAJAIAFFIAIoAlBBAEhyDQAgASEDA0AgACADaiIFQQFrLQAAQQpHBEAgA0EBayIDDQEMAgsLIAIgACADIAIoAiQRBAAiBCADSQ0CIAEgA2shASACKAIUIQQMAQsgACEFQQAhAwsgBCAFIAEQFxogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAuICQEJf0G6fyELAkAgACACKAIEIgogAigCACIJaiINaiABSw0AQWwhCyADKAIAIgggCWoiDiAESw0AIAFBIGshBCAAIAlqIQEgAigCCCEMAkAgCUEHTARAIAlBAEwNAQNAIAAgCC0AADoAACAIQQFqIQggAEEBaiIAIAFJDQALDAELIAEgBE0EQCAAIAgpAAA3AAAgACAIKQAINwAIIAAgCCkAEDcAECAAIAgpABg3ABggCUEhSQ0BIABBIGohAANAIAAgCCkAIDcAACAAIAgpACg3AAggACAIKQAwNwAQIAAgCCkAODcAGCAIQSBqIQggAEEgaiIAIAFJDQALDAELIAAgBE0EQCAAIAgpAAA3AAAgACAIKQAINwAIIAAgCCkAEDcAECAAIAgpABg3ABggBCAAayIPQSFOBEAgAEEgaiEAIAghCQNAIAAgCSkAIDcAACAAIAkpACg3AAggACAJKQAwNwAQIAAgCSkAODcAGCAJQSBqIQkgAEEgaiIAIARJDQALCyAIIA9qIQggBCEACyAAIAFPDQADQCAAIAgtAAA6AAAgCEEBaiEIIABBAWoiACABSQ0ACwsgASAMayEAIAMgDjYCAAJAAkAgASAFayAMSQRAIAwgASAGa0sNAyAHIAcgACAFayIAaiIDIApqTwRAIAEgAyAKEB4aDAMLIAEgA0EAIABrEB4hECACIAAgCmoiCjYCBCAQIABrIQEMAQsgACEFCyABIApqIQIgCkEHTARAIApBAEwNAQNAIAEgBS0AADoAACAFQQFqIQUgAUEBaiIBIAJJDQALDAELAkAgASAFayIAQQdNBEAgASAFLQAAOgAAIAEgBS0AAToAASABIAUtAAI6AAIgASAFLQADOgADIAEgBSAAQQJ0IgBB0LwBaigCAGoiAygAADYABCADIABB8LwBaigCAGshBQwBCyABIAUpAAA3AAALIAFBCGohACAFQQhqIQggAiAETQRAIAAgCmohAiAAIAhrQQ9MBEADQCAAIAgpAAA3AAAgCEEIaiEIIABBCGoiACACSQ0ADAMLAAsgACAIKQAANwAAIAAgCCkACDcACCABIAUpACA3ACAgASAFKQAYNwAYIApBIUkNASABQShqIQADQCAAIAgpACA3AAAgACAIKQAoNwAIIAAgCCkAMDcAECAAIAgpADg3ABggCEEgaiEIIABBIGoiACACSQ0ACwwBCwJAIAAgBEsEQCAAIQQMAQsgBCAAayEDAkAgACAIa0EPTARAIAghAQNAIAAgASkAADcAACABQQhqIQEgAEEIaiIAIARJDQALDAELIAAgCCkAADcAACAAIAgpAAg3AAggASAFKQAgNwAgIAEgBSkAGDcAGCADQSFIDQAgAUEoaiEAIAghAQNAIAAgASkAIDcAACAAIAEpACg3AAggACABKQAwNwAQIAAgASkAODcAGCABQSBqIQEgAEEgaiIAIARJDQALCyADIAhqIQgLIAIgBE0NAANAIAQgCC0AADoAACAIQQFqIQggBEEBaiIEIAJJDQALCyANIQsLIAsLpQgBBn8jAEHwAWsiDiQAIA4gAzYCfEF/IQ0CQAJAAkACQAJAIAIOBAEAAwIECyAGRQRAQbh/IQ0MBAtBbCENIAUtAAAiAiADSw0DIAggAkECdCICaigCACEDIAIgB2ooAgAhAiAAQQA6AAsgAEIANwIAIAAgAjYCDCAAIAM6AAogAEEAOwEI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ACgCFCIEQQFqNgIUIAQgACgCCGogAjoAACABQQJqIQEgA0ECayIDDQALCwvJBQEEfyAAQZQBaiEBA0AgASADQQJ0IgJqQQA7AQAgASACQQRyakEAOwEAIAEgAkEIcmpBADsBACABIAJBDHJqQQA7AQAgASACQRByakEAOwEAIAEgAkEUcmpBADsBACADQQZyIgRBngJGRQRAIAEgBEECdGpBADsBACABIAJBHHJqQQA7AQAgA0EIaiEDDAELCyAAQQA7AfwUIABBADsBiBMgAEHEFWpBADsBACAAQcAVakEAOwEAIABBvBVqQQA7AQAgAEG4FWpBADsBACAAQbQVakEAOwEAIABBsBVqQQA7AQAgAEGsFWpBADsBACAAQagVakEAOwEAIABBpBVqQQA7AQAgAEGgFWpBADsBACAAQZwVakEAOwEAIABBmBVqQQA7AQAgAEGUFWpBADsBACAAQZAVakEAOwEAIABBjBVqQQA7AQAgAEGIFWpBADsBACAAQYQVakEAOwEAIABBgBVqQQA7AQAgAEH8E2pBADsBACAAQfgTakEAOwEAIABB9BNqQQA7AQAgAEHwE2pBADsBACAAQewTakEAOwEAIABB6BNqQQA7AQAgAEHkE2pBADsBACAAQeATakEAOwEAIABB3BNqQQA7AQAgAEHYE2pBADsBACAAQdQTakEAOwEAIABB0BNqQQA7AQAgAEHME2pBADsBACAAQcgTakEAOwEAIABBxBNqQQA7AQAgAEHAE2pBADsBACAAQbwTakEAOwEAIABBuBNqQQA7AQAgAEG0E2pBADsBACAAQbATakEAOwEAIABBrBNqQQA7AQAgAEGoE2pBADsBACAAQaQTakEAOwEAIABBoBNqQQA7AQAgAEGcE2pBADsBACAAQZgTakEAOwEAIABBlBNqQQA7AQAgAEGQE2pBADsBACAAQYwTakEAOwEAIABCADcCrC0gAEGUCWpBATsBACAAQQA2AqgtIABBADYCoC0LvwUCBX4EfyAAQShqIgcgACgCSCIJaiEIAn4gACkDACICQiBaBEAgACkDECIDQgeJIAApAwgiBEIBiXwgACkDGCIFQgyJfCAAKQMgIgFCEol8IARCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+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IAw7AQYgASADQQhqIgA2AgQgEyAGIAhqIgNJBEAgAyEFDAELIBQgESAgaikAAEKAxpX9y5vvjU9+ICeIp0ECdGogEUECajYCACAUIANBAmsiBikAAEKAxpX9y5vvjU9+ICeIp0ECdGogBiAOazYCACAEIQggByEGA0ACQCAGIQQgCCEGIBkgAyAOayIHIARrIgVrQQNJDQAgBSAcIA4gBSAQSSIFG2oiCCgAACADKAAARw0AIANBBGogCEEEaiANIBUgDSAFGyASEBYiCUEBaiEFIAMgC00EQCABKAIMIgAgAykAADcAACAAIAMpAAg3AAggASgCBCEACyAAQQE2AgAgAEEAOwEEIAVBgIAETwRAIAFBAjYCJCABIAAgASgCAGtBA3U2AigLIAAgBTsBBiABIABBCGoiADYCBCAUIAMpAABCgMaV/cub741PfiAniKdBAnRqIAc2AgAgBCEIIAYhByAJQQRqIANqIgMhBSADIBNNDQEMAgsLIAQhByAGIQQgAyEFCyAFIBNJDQALDAILIAUgE08NASAWIBhrIRwgDUEBayEdIA1BA2shFyANQSBrIQsgEEEBayEZQcAAIAYoAnxrrSEoQcAAIAAoAnxrrSEnA0AgFCAFKQAAIilCgIDs/Mub741PfiIqICeIp0ECdGoiACgCACEMIAAgBSAOayIRNgIAAkACQAJAAkAgGSARIARrQQFqIgBrQQNJDQAgFiAAIBhraiAAIA5qIAAgEEkiABsiBigAACAFKAABRw0AIAVBBWogBkEEaiANIBUgDSAAGyASEBYiCkEBaiEMIAVBAWoiBiADayEJIAEoAgwhAAJAAkAgBiALTQRAIAAgAykAADcAACAAIAMpAAg3AAggASgCDCEAIAlBEE0EQCABIAAgCWo2AgwgASgCBCEDDAMLIAAgAykAEDcAECAAIAMpABg3ABggACADKQAgNwAgIAAgAykAKDcAKCAJQTFIDQEgACAJaiEIIANBEGohAyAAQTBqIQUDQCAFIAMpACA3AAAgBSADKQAoNwAIIAUgAykAMDcAECAFIAMpADg3ABggA0EgaiEDIAVBIGoiBSAISQ0ACwwBCyADIAtNBEAgACADKQAANwAAIAAgAykACDcACCAAIAMpABA3ABAgACADKQAYNwAYIAAgCyADayIPaiEIIA9BIU4EQCAAQSBqIQAD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IAAgDmogACAQSSIAGyIGKAAAIAUoAAFHDQAgBUEFaiAGQQRqIA0gFSANIAAbIBIQFiIKQQFqIQwgBUEBaiIGIANrIQkgASgCDCEAAkACQCAGIAtNBEAgACADKQAANwAAIAAgAykACDcACCABKAIMIQAgCUEQTQRAIAEgACAJajYCDCABKAIEIQMMAwsgACADKQAQNwAQIAAgAykAGDcAGCAAIAMpACA3ACAgACADKQAoNwAoIAlBMUgNASAAIAlqIQggA0EQaiEDIABBMGohBQNAIAUgAykAIDcAACAFIAMpACg3AAggBSADKQAwNwAQIAUgAykAODcAGCADQSBqIQMgBUEgaiIFIAhJDQALDAELIAMgC00EQCAAIAMpAAA3AAAgACADKQAINwAIIAAgAykAEDcAECAAIAMpABg3ABggACALIANrIg9qIQggD0EhTgRAIABBIGohAANAIAAgAykAIDcAACAAIAMpACg3AAggACADKQAwNwAQIAAgAykAODcAGCADQSBqIQMgAEEgaiIAIAhJDQALCyALIQMgCCEACyADIAZPDQAgBSADayEmQQAhBSAGIANrQQdxIg8EQANAIAAgAy0AADoAACAAQQFqIQAgA0EBaiEDIAVBAWoiBSAPRw0ACwsgJkEHSQ0AA0AgACADLQAAOgAAIAAgAy0AAToAASAAIAMtAAI6AAIgACADLQADOgADIAAgAy0ABDoABCAAIAMtAAU6AAUgACADLQAGOgAGIAAgAy0ABzoAByAAQQhqIQAgA0EIaiIDIAZHDQALCyABIAEoAgwgCWo2AgwgASgCBCEDIAlBgIAESQ0AIAFBATYCJCABIAMgASgCAGtBA3U2AigLIApBBGohCCADQQE2AgAgAyAJOwEEIAQhCSAMQf//A0sNAQwCCyAMIBBNBEACQCAhICogKIinQQJ0aigCACIGIBtNDQAgBiAWaiIAKAAAIAUoAABHDQAgBUEEaiAAQQRqIA0gFSASEBZBBGohCCAGIBhqIQcCQCAGIBtMBEAgBSEGDAELIAUhBiADIAVPDQADQCAFQQFrIgYtAAAgAEEBayIALQAARwRAIAUhBgwCCyAIQQFqIQggACAfTQ0BIAYiBSADSw0ACwsgESAHayEJIAhBA2shDCAGIANrIQogASgCDCEFAkACQCAGIAtNBEAgBSADKQAANwAA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AQsCQCAFIBJPDQAgAC8AACAFLwAARw0AIABBAmohACAFQQJqIQULIAUgDUkEfyAFIAAtAAAgBS0AAEZqBSAFCyAEawshISAGIANrIQQgISAIaiIYQQFqIQcgASgCDCEFAkACQCAGIAxNBEAgBSADKQAANwAAIAUgAykACDcACCABKAIMIQAgBEEQTQRAIAEgACAEajYCDCABKAIEIQMMAwsgACADKQAQNwAQIAAgAykAGDcAGCAAIAMpACA3ACAgACADKQAoNwAoIARBMUgNASAAIARqIQggA0EQaiEDIABBMGohBQNAIAUgAykAIDcAACAFIAMpACg3AAggBSADKQAwNwAQIAUgAykAODcAGCADQSBqIQMgBUEgaiIFIAhJDQALDAELIAMgDE0EQCAFIAMpAAA3AAAgBSADKQAINwAIIAUgAykAEDcAECAFIAMpABg3ABggBSAMIANrIghqIQAgCEEhTgRAIAVBIGohBQNAIAUgAykAIDcAACAFIAMpACg3AAggBSADKQAwNwAQIAUgAykAODcAGCADQSBqIQMgBUEgaiIFIABJDQALCyAAIQUgDCEDCyADIAZPDQBBACEIIAMhACAGIANrQQdxIhMEQANAIAUgAC0AADoAACAFQQFqIQUgAEEBaiEAIAhBAWoiCCATRw0ACwsgAyAGa0F4Sw0AA0AgBSAALQAAOgAAIAUgAC0AAToAASAFIAAtAAI6AAIgBSAALQADOgADIAUgAC0ABDoABCAFIAAtAAU6AAUgBSAALQAGOgAGIAUgAC0ABzoAByAFQQhqIQUgAEEIaiIAIAZHDQALCyABIAEoAgwgBGo2AgwgASgCBCEDIARBgIAESQ0AIAFBATYCJCABIAMgASgCAGtBA3U2AigLIAMgBDsBBCADIA9BAWo2AgAgB0GAgARPBEAgAUECNgIkIAEgAyABKAIAa0EDdTYCKAsgAyAHOwEGIAEgA0EIaiIANgIEIBhBBGogBmoiA0EBaiEFAkAgAyARSw0AIA4gFCAZaikAAEKAgOz8y5vvjU9+ICOIp0ECdGogFEECajYCACAOIANBAmsiBCkAAEKAgOz8y5vvjU9+ICOIp0ECdGogBCALazYCACAJRQRAQQAhCQwBCyADKAAAIAMgCWsoAABHDQBBACAJayEGIAkhBQNAIAohCSAFIQogA0EEaiIEIAZq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IAAgA08EQCADIQUMAQsDQCADQQFrIgUtAAAgBEEBayIELQAARwRAIAMhBQwCCyAJQQFqIQkgBCAHTQ0BIAUiAyAASw0ACwsgCUEDayETIAUgAGshCCABKAIMIQMCQAJAIAUgC00EQCADIAApAAA3AAAgAyAAKQAINwAIIAEoAgwhBCAIQRBNBEAgASAEIAhqNgIMIAEoAgQhAwwDCyAEIAApABA3ABAgBCAAKQAYNwAYIAQgACkAIDcAICAEIAApACg3ACggCEExSA0BIAQgCGohByAAQRBqIQMgBEEwaiEAA0AgACADKQAgNwAAIAAgAykAKDcACCAAIAMpADA3ABAgACADKQA4NwAYIANBIGohAyAAQSBqIgAgB0kNAAsMAQsgACALTQRAIAMgACkAADcAACADIAApAAg3AAggAyAAKQAQNwAQIAMgACkAGDcAGCADIAsgAGsiB2ohBCAHQSFOBEAgA0EgaiEDA0AgAyAAKQAgNwAAIAMgACkAKDcACCADIAApADA3ABAgAyAAKQA4NwAYIABBIGohACADQSBqIgMgBEkNAAsLIAQhAyALIQALIAAgBU8NAEEAIQcgACEEIAUgAGtBB3EiFwRAA0AgAyAELQAAOgAAIANBAWohAyAEQQFqIQQgB0EBaiIHIBdHDQALCyAAIAVrQXhLDQADQCADIAQtAAA6AAAgAyAELQABOgABIAMgBC0AAjoAAiADIAQtAAM6AAMgAyAELQAEOgAEIAMgBC0ABToABSADIAQtAAY6AAYgAyAELQAHOgAHIANBCGohAyAEQQhqIgQgBUcNAAsLIAEgASgCDCAIajYCDCABKAIEIQMgCEGAgARJDQAgAUEBNgIkIAEgAyABKAIAa0EDdTYCKAsgAyAIOwEEIAMgBkEDajYCACAKIgghByATQf//A00NAQsgAUECNgIkIAEgAyABKAIAa0EDdTYCKCAIIQcLIAMgEzsBBiABIANBCGoiBDYCBCAYIAUgCWoiAEkEQCAHIQggBiEKIAAhAwwDCyAVIA8gEkECaiIDaiIKKQAAIiJC48iVvcub741PfiIlICSIp0ECdGogAzYCACAVIABBAmsiBSkAAELjyJW9y5vvjU9+ICSIp0ECdGogBSAPazYCACAQAn8CQAJAAkACQAJAIBsOBAABAgMECyAQICJCgICA2Mub741PfiAj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AWohDSAAIBNNDQUgBiIEIANLDQALDAQLAkAgACAUTw0AIAkvAAAgAC8AAEcNACAJQQJqIQkgAEECaiEACyAAIA5JBH8gACAJLQAAIAAtAABGagUgAAsgBGsLIR8gBiAFayEIIB9BCGohDSAHIBFMIAMgBk9yDQIDQCAGQQFrIgAtAAAgBUEBayIFLQAARw0DIA1BAWohDSAFIBNNBEAgACEGDAQLIAAiBiADSw0ACwwCCwJAIAUgFE8NACAGLwAAIAUvAABHDQAgBkECaiEGIAVBAmohBQsgBSAOSQR/IAUgBi0AACAFLQAARmoFIAULIAdrCyEgIAQgAGshCCAgQQhqIQ0gCSARTARAIAQhBgwBCyADIARPBEAgBCEGDAELA0AgBEEBayIGLQAAIABBAWsiAC0AAEcEQCAEIQYMAgsgDUEBaiENIAAgE00NASAGIgQgA0sNAAsLIA1BA2shEiAGIANrIQcgASgCDCEAAkACQCAGIAtNBEAgACADKQAANwAAIAAgAykACDcACCABKAIMIQAgB0EQTQRAIAEgACAHajYCDCABKAIEIQMMAwsgACADKQAQNwAQIAAgAykAGDcAGCAAIAMpACA3ACAgACADKQAoNwAoIAdBMUgNASAAIAdqIQQgA0EQaiEDIABBMGohAANAIAAgAykAIDcAACAAIAMpACg3AAggACADKQAwNwAQIAAgAykAODcAGCADQSBqIQMgAEEgaiIAIARJDQALDAELIAMgC00EQCAAIAMpAAA3AAAgACADKQAINwAIIAAgAykAEDcAECAAIAMpABg3ABggACALIANrIgVqIQQgBUEhTgRAIABBIGohAANAIAAgAykAIDcAACAAIAMpACg3AAggACADKQAwNwAQIAAgAykAODcAGCADQSBqIQMgAEEgaiIAIARJDQALCyALIQMgBCEACyADIAZPDQBBACEFIAMhBCAGIANrQQdxIgkEQANAIAAgBC0AADoAACAAQQFqIQAgBEEBaiEEIAVBAWoiBSAJRw0ACwsgAyAGa0F4Sw0AA0AgACAELQAAOgAAIAAgBC0AAToAASAAIAQtAAI6AAIgACAELQADOgADIAAgBC0ABDoABCAAIAQtAAU6AAUgACAELQAGOgAGIAAgBC0ABzoAByAAQQhqIQAgBEEIaiIEIAZHDQALCyABIAEoAgwgB2o2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CiAbIAobNgIAIAcgGyAHGyEICyACIAg2AgQgDiADawufbgItfwd+IAMgACgCBCINayAEaiIGQQEgACgCdHQiBWsgACgCDCIHIAYgB2sgBUsbIg4gACgCcCIGKAIEIhQgBigCACIVa2ohFiADIBQgBigCDCIcaiIZIBUgAyANIA5qIhBrakZqIQUgAyAEaiILQQhrIRogAigCBCEHIAIoAgAhBCAAKAIoIRsgACgCICEXIAYoAighICAGKAIgIR4CQAJAAkACQAJAIAAoAoQBQQVrDgMDAgEACyAFIBpPDQMgFCAWayEYIAtBIGshDyALQQFrIR0gC0EDayEMQSAgBigCeGshIUEgIAAoAnhrIRNBwAAgBigCfGutITJBwAAgACgCfGutITMDQCAXIAUpAAAiNELjyJW9y5vvjU9+IjUgM4inQQJ0aiIAKAIAIREgGyA0p0Gx893xeWwiCCATdkECdGoiBigCACEKIAYgBSANayISNgIAIAAgEjYCAAJAAkACQAJAIBJBAWoiCSAEayIAIA5rQXxLDQAgFCAAIBZraiAAIA1qIAAgDkkiABsiBigAACAFKAABRw0AIAVBBWogBkEEaiALIBUgCyAAGyAQEBYiCkEBaiERIAVBAWoiBiADayEJIAEoAgwhAAJAAkAgBiAPTQRAIAAgAykAADcAACAAIAMpAAg3AAggASgCDCEAIAlBEE0EQCABIAAgCWo2AgwgASgCBCEDDAMLIAAgAykAEDcAECAAIAMpABg3ABggACADKQAgNwAgIAAgAykAKDcAKCAJQTFIDQEgACAJaiEIIANBEGohAyAAQTBqIQUDQCAFIAMpACA3AAAgBSADKQAoNwAIIAUgAykAMDcAECAFIAMpADg3ABggA0EgaiEDIAVBIGoiBSAISQ0ACwwBCyADIA9NBEAgACADKQAANwAAIAAgAykACDcACCAAIAMpABA3ABAgACADKQAYNwAYIAAgDyADayIfaiEIIB9BIU4EQCAAQSBqIQADQCAAIAMpACA3AAAgACADKQAoNwAIIAAgAykAMDcAECAAIAMpADg3ABggA0EgaiEDIABBIGoiACAISQ0ACwsgDyEDIAghAAsgAyAGTw0AIAUgA2shIkEAIQUgBiADa0EHcSIfBEADQCAAIAMtAAA6AAAgAEEBaiEAIANBAWohAyAFQQFqIgUg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IAMpAABC48iVvcub741PfiAziKdBAnRqIAU2AgAgBCEIIAYhByAJQQRqIANqIgMhBSADIBpNDQEMAgsLIAQhByAGIQQgAyEFCyAFIBpJDQALDAMLIAUgGk8NAiAUIBZrIR0gC0EgayEPIAtBAWshESALQQNrIRJBwAAgBigCeGutITdBwAAgBigCfGutITVBwAAgACgCeGutITRBwAAgACgCfGutITMDQCAXIAUpAAAiMkLjyJW9y5vvjU9+IjYgM4inQQJ0aiIAKAIAIQogGyAyQoDGlf3Lm++NT34iOCA0iKdBAnRqIgYoAgAhCSAGIAUgDWsiEzYCACAAIBM2AgACQAJAAkACQCATQQFqIgwgBGsiACAOa0F8Sw0AIBQgACAWa2ogACANaiAAIA5JIgAbIgYoAAAgBSgAAUcNACAFQQVqIAZBBGogCyAVIAsgABsgEBAWIgxBAWohCiAFQQFqIgYgA2shCSABKAIMIQACQAJAIAYgD00EQCAAIAMpAAA3AAAgACADKQAINwAIIAEoAgwhACAJQRBNBEAgASAAIAlqNgIMIAEoAgQhAwwDCyAAIAMpABA3ABAgACADKQAYNwAYIAAgAykAIDcAICAAIAMpACg3ACggCUExSA0BIAAgCWohCCADQRBqIQMgAEEwaiEFA0AgBSADKQAgNwAAIAUgAykAKDcACCAFIAMpADA3ABAgBSADKQA4NwAYIANBIGohAyAFQSBqIgUgCEkNAAsMAQsgAyAPTQRAIAAgAykAADcAACAAIAMpAAg3AAggACADKQAQNwAQIAAgAykAGDcAGCAAIA8gA2siGGohCCAYQSFOBEAgAEEgaiEAA0AgACADKQAgNwAAIAAgAykAKDcACCAAIAMpADA3ABAgACADKQA4NwAYIANBIGohAyAAQSBqIgAgCEkNAAsLIA8hAyAIIQALIAMgBk8NACAFIANrISZBACEFIAYgA2tBB3EiGARAA0AgACADLQAAOgAAIABBAWohACADQQFqIQMgBUEBaiIFIBhHDQALCyAmQQdJDQADQCAAIAMtAAA6AAAgACADLQABOgABIAAgAy0AAjoAAiAAIAMtAAM6AAMgACADLQAEOgAEIAAgAy0ABToABSAAIAMtAAY6AAYgACADLQAHOgAHIABBCGohACADQQhqIgMgBkcNAAsLIAEgASgCDCAJ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ASAEIAlqIQAgA0EQaiEDIARBMGohBQNAIAUgAykAIDcAACAFIAMpACg3AAggBSADKQAwNwAQIAUgAykAODcAGCADQSBqIQMgBUEgaiIFIABJDQALDAELIAMgDE0EQCAFIAMpAAA3AAAgBSADKQAINwAIIAUgAykAEDcAECAFIAMpABg3ABggBSAMIANrIgRqIQAgBEEhTgRAIAVBIGohBQNAIAUgAykAIDcAACAFIAMpACg3AAggBSADKQAwNwAQIAUgAykAODcAGCADQSBqIQMgBUEgaiIFIABJDQALCyAAIQUgDCEDCyADIAZPDQBBACEEIAMhACAGIANrQQdxIgcEQANAIAUgAC0AADoAACAFQQFqIQUgAEEBaiEAIARBAWoiBCAHRw0ACwsgAyAGa0F4Sw0AA0AgBSAALQAAOgAAIAUgAC0AAToAASAFIAAtAAI6AAIgBSAALQADOgADIAUgAC0ABDoABCAFIAAtAAU6AAUgBSAALQAGOgAGIAUgAC0ABzoAByAFQQhqIQUgAEEIaiIAIAZHDQALCyABIAEoAgwgCWo2AgwgASgCBCEDIAlBgIAESQ0AIAFBATYCJCABIAMgASgCAGtBA3U2AigLIAMgCTsBBCADIAhBA2o2AgAgCiEHIAghCiARQYCABEkNAwwCCwJAIAAgE08NACAELwAAIAAvAABHDQAgBEECaiEEIABBAmohAAsgACAQSQR/IAAgBC0AACAALQAARmoFIAALIAhrCyILQQFqIREgBiADayEJIAEoAgwhAAJAAkAgBiAMTQRAIAAgAykAADcAACAAIAMpAAg3AAggASgCDCEEIAlBEE0EQCABIAQgCWo2AgwgASgCBCEDDAMLIAQgAykAEDcAECAEIAMpABg3ABggBCADKQAgNwAgIAQgAykAKDcAKCAJQTFIDQEgBCAJaiEAIANBEGohAyAEQTBqIQUDQCAFIAMpACA3AAAgBSADKQAoNwAIIAUgAykAMDcAECAFIAMpADg3ABggA0EgaiEDIAVBIGoiBSAASQ0ACwwBCyADIAxNBEAgACADKQAANwAAIAAgAykACDcACCAAIAMpABA3ABAgACADKQAYNwAYIAAgDCADayIIaiEEIAhBIU4EQCAAQSBqIQADQCAAIAMpACA3AAAgACADKQAoNwAIIAAgAykAMDcAECAAIAMpADg3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LQAAIABBAWsiAC0AAEcEQCAFIQYMAgsgC0EBaiELIAAgF00NASAGIgUgA0sNAAsLIAtBA2shESAGIANrIQkgASgCDCEFAkACQCAGIAxNBEAgBSADKQAANwAAIAUgAykACDcACCABKAIMIQQgCUEQTQRAIAEgBCAJajYCDCABKAIEIQMMAwsgBCADKQAQNwAQIAQgAykAGDcAGCAEIAMpACA3ACAgBCADKQAoNwAoIAlBMUgNASAEIAlqIQAgA0EQaiEDIARBMGohBQNAIAUgAykAIDcAACAFIAMpACg3AAggBSADKQAwNwAQIAUgAykAODcAGCADQSBqIQMgBUEgaiIFIABJDQALDAELIAMgDE0EQCAFIAMpAAA3AAAgBSADKQAINwAIIAUgAykAEDcAECAFIAMpABg3ABggBSAMIANrIgRqIQAgBEEhTgRAIAVBIGohBQNAIAUgAykAIDcAACAFIAMpACg3AAggBSADKQAwNwAQIAUgAykAODcAGCADQSBqIQMgBUEgaiIFIABJDQALCyAAIQUgDCEDCyADIAZPDQBBACEEIAMhACAGIANrQQdxIgcEQANAIAUgAC0AADoAACAFQQFqIQUgAEEBaiEAIARBAWoiBCAHRw0ACwsgAyAGa0F4Sw0AA0AgBSAALQAAOgAAIAUgAC0AAToAASAFIAAtAAI6AAIgBSAALQADOgADIAUgAC0ABDoABCAFIAAtAAU6AAUgBSAALQAGOgAGIAUgAC0ABzoAByAFQQhqIQUgAEEIaiIAIAZHDQALCyABIAEoAgwgCWo2AgwgASgCBCEDIAlBgIAESQ0AIAFBATYCJCABIAMgASgCAGtBA3U2AigLIAMgCTsBBCADIAhBA2o2AgAgCiEHIAghCiARQYCABEkNAwwCCwJAIAAgE08NACAELwAAIAAvAABHDQAgBEECaiEEIABBAmohAAsgACAQSQR/IAAgBC0AACAALQAARmoFIAALIAhrCyILQQFqIREgBiADayEJIAEoAgwhAAJAAkAgBiAMTQRAIAAgAykAADcAACAAIAMpAAg3AAggASgCDCEEIAlBEE0EQCABIAQgCWo2AgwgASgCBCEDDAMLIAQgAykAEDcAECAEIAMpABg3ABggBCADKQAgNwAgIAQgAykAKDcAKCAJQTFIDQEgBCAJaiEAIANBEGohAyAEQTBq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ACgCmC1qIAI6AAAgACACQQJ0aiICQZQBaiACLwGUAUEBajsBACAAIAAoAnRBAWs2AnQgACAAKAJsQQFqIgI2AmwgACgCoC0gACgCnC1BAWtHDQELQQAhBCAAIAAoAlwiA0EATgR/IAAoAjggA2oFIAQLIAIgA2tBABAcIAAgACgCbDYCXAJAAn8gACgCACIDKAIcIgIoArwtIgRBEEYEQCACIAIoAhQiBEEBajYCFCAEIAIoAghqIAItALgtOgAAIAIgAigCFCIEQQFqNgIUIAQgAigCCGogAkG5LWotAAA6AAAgAkEAOwG4LUEADAELIARBCEgNASACIAIoAhQiBEEBajYCFCAEIAIoAghqIAItALgtOgAAIAIgAkG5LWotAAA7AbgtIAIoArwtQQhrCyEEIAIgBDYCvC0LAkAgAigCFCIEIAMoAhAiBSAEIAVJGyIERQ0AIAMoAgwgAigCECAEEBcaIAMgAygCDCAEajYCDCACIAIoAhAgBGo2AhAgAyADKAIUIARqNgIUIAMgAygCECAEazYCECACIAIoAhQiAyAEazYCFCADIARHDQAgAiACKAIINgIQCyAAKAIAKAIQDQALQQAPCyAAQQIgACgCbCICIAJBAk8bNgK0LSABQQRGBEBBACEFIAAgACgCXCIBQQBOBH8gACgCOCABagUgBQsgAiABa0EBEBwgACAAKAJsNgJcAkACfyAAKAIAIgIoAhwiASgCvC0iA0EQRgRAIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAS0AuC06AAAgASABKAIUIgNBAWo2AhQgAyABKAIIaiABQbktai0AADoAACABQQA7AbgtQQAMAQsgA0EISA0BIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAS0AuC06AAAgASABQbktai0AADsBuC0gASgCvC1BCGsLIQQgASAENgK8LQsCQCABKAIUIgMgAigCECIEIAMgBEkbIgNFDQAgAigCDCABKAIQIAMQFxogAiACKAIMIANqNgIMIAEgASgCECADajYCECACIAIoAhQgA2o2AhQgAiACKAIQIANrNgIQIAEgASgCFCICIANrNgIUIAIgA0cNACABIAEoAgg2AhALQQNBAiAAKAIAKAIQGw8LAkAgACgCoC1FDQBBACEFIAAgACgCXCIBQQBOBH8gACgCOCABagUgBQsgAiABa0EAEBwgACAAKAJsNgJcAkACfyAAKAIAIgIoAhwiASgCvC0iA0EQRgRAIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAS0AuC06AAAgASABKAIUIgNBAWo2AhQgAyABKAIIaiABQbktai0AADoAACABQQA7AbgtQQAMAQsgA0EISA0BIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAS0AuC06AAAgASABQbktai0AADsBuC0gASgCvC1BCGsLIQQgASAENgK8LQsCQCABKAIUIgMgAigCECIEIAMgBEkbIgNFDQAgAigCDCABKAIQIAMQFxogAiACKAIMIANqNgIMIAEgASgCECADajYCECACIAIoAhQgA2o2AhQgAiACKAIQIANrNgIQIAEgASgCFCICIANrNgIUIAIgA0cNACABIAEoAgg2AhALIAAoAgAoAhANAEEADwtBAQuKDQEFf0H//wMgACgCDEEFayICIAJB//8DTxshBgJAA0AgACgCdCICQQFNBEAgABArIAAoAnQiAiABckUEQEEADwsgAkUNAgsgAEEANgJ0IAAgACgCbCACaiICNgJsIAJBACAAKAJcIgQgBmoiAyACSxsEfyACBSAAIAM2AmwgACACIANrNgJ0QQAhAiAAIARBAE4EfyAAKAI4IARqBSACCyAGQQAQHCAAIAAoAmw2AlwCQAJ/IAAoAgAiBCgCHCICKAK8LSIDQRBGBEAgAiACKAIUIgNBAWo2AhQgAyACKAIIaiACLQC4LToAACACIAIoAhQiA0EBajYCFCADIAIoAghqIAJBuS1qLQAAOgAAIAJBADsBuC1BAAwBCyADQQhIDQEgAiACKAIUIgNBAWo2AhQgAyACKAIIaiACLQC4LToAACACIAJBuS1qLQAAOwG4LSACKAK8LUEIawshAyACIAM2ArwtCwJAIAIoAhQiAyAEKAIQIgUgAyAFSRsiA0UNACAEKAIMIAIoAhAgAxAXGiAEIAQoAgwgA2o2AgwgAiACKAIQIANqNgIQIAQgBCgCFCADajYCFCAEIAQoAhAgA2s2AhAgAiACKAIUIgQgA2s2AhQgAyAERw0AIAIgAigCCDYCEAsgACgCACgCEEUEQEEADwsgACgCXCEEIAAoAmwLIARrIgIgACgCLEGGAmtJDQBBACEDIAAgBEEATgR/IAAoAjggBGoFIAML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IAYhACAIDAELIAgtAAEgBnQgB2ohByAIQQFqIAIgBkEIaiIATQ0AGiAILQACIAB0IAdqIQcgBkEQaiEAIAhBAmoLIQogB0F/IAJ0QX9zcSEIIAAgAmshBiAHIAJ2IQcgCCAMaiINIAQgH2siAEsEQAJAIA0gAGsiAyAmTQ0AIAUoAsA3RQ0AQR0hCwwCCyALRQRAIAkgIiADa2ohAiABIANNDQogCCATaiAMaiAEayEMQQAhCCADQQdxIhRFDQMgAyEAA0AgBCACLQABOgABIABBAWshACAEQQFqIQQgAkEBaiECIAhBAWoiCCAURw0ACwwICyADIAtLBEAgCSAjIANraiECIAEgAyALayIDTQ0KIAggIGogDGogBGshDEEAIQggA0EHcSIURQ0EIAMhAANAIAQgAi0AAToAASAAQQFrIQAgBEEBaiEEIAJBAWohAiAIQQFqIgggFEcNAAsMBwsgCSALIANraiECIAEgA00NCSAIIBNqIAxqIARrIQxBACEIIANBB3EiFEUNBCADIQADQCAEIAItAAE6AAEgAEEBayEAIARBAWohBCACQQFqIQIgCEEBaiIIIBRHDQALDAULIAQgDWshCANAIAQiACAIIgItAAE6AAEgBCAILQACOgACIAQgCC0AAzoAAyAEQQNqIQQgCEEDaiEIIAFBA2siAUECSw0ACyABRQ0KIAAgAi0ABDoABCABQQFGBEAgAEEEaiEEDAsLIAAgAi0ABToABSAAQQVqIQQMCgsgBSALNgIADAsLIAMhAAwECyADIQAMAgsgAyEACyAMQQdJDQIDQCAEIAItAAE6AAEgBCACLQACOgACIAQgAi0AAzoAAyAEIAItAAQ6AAQgBCACLQAFOgAFIAQgAi0ABjoABiAEIAItAAc6AAcgBCACLQAIOgAIIARBCGohBCACQQhqIQIgAEEIayIADQALDAILIAxBB08EQANAIAQgAi0AAToAASAEIAItAAI6AAIgBCACLQADOgADIAQgAi0ABDoABCAEIAItAAU6AAUgBCACLQAGOgAGIAQgAi0ABzoAByAEIAItAAg6AAggBEEIaiEEIAJBCGohAiAAQQhrIgANAAsLIAsgASADayIBTwRAIAkhAgwDC0EAIQACfyAQBEAgCSECA0AgBCACLQABOgABIARBAWohBCACQQFqIQIgAEEBaiIAIBBH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QR5JDQoDQCAAIAMtAAA6AAAgACABLQAAOgABIAAgAS0AAToAAiAAIAEtAAI6AAMgACABLQADOgAEIAAgAS0ABDoABSAAIAEtAAU6AAYgACABLQAGOgAHIAAgAS0ABzoACCAAIAEtAAg6AAkgACABLQAJOgAKIAAgAS0ACjoACyAAIAEtAAs6AAwgACABLQAMOgANIAAgAS0ADToADiAAIAEtAA46AA8gACABKQAPNwAQIAAgASgAFzYAGCAAIAEvABs7ABwgAEEeaiEAIARBHmsiBEEdSw0ACwwKCyAEQRxJDQkDQCAAIAMtAAA6AAAgACABLQAAOgABIAAgAS0AAToAAiAAIAEtAAI6AAMgACABLQADOgAEIAAgAS0ABDoABSAAIAEtAAU6AAYgACABLQAGOgAHIAAgAS0ABzoACCAAIAEtAAg6AAkgACABLQAJOgAKIAAgAS0ACjoACyAAIAEtAAs6AAwgACABLQAMOgANIAAgAS0ADToADiAAIAEtAA46AA8gACABKQAPNwAQIAAgASgAFzYAGCAAQRxqIQAgBEEcayIEQRtLDQALDAkLIARBGkkNCANAIAAgAy0AADoAACAAIAEtAAA6AAEgACABLQABOgACIAAgAS0AAjoAAyAAIAEtAAM6AAQgACABLQAEOgAFIAAgAS0ABToABiAAIAEtAAY6AAcgACABLQAHOgAIIAAgAS0ACDoACSAAIAEtAAk6AAogACABLQAKOgALIAAgAS0ACzoADCAAIAEtAAw6AA0gACABLQANOgAOIAAgAS0ADjoADyAAIAEpAA83ABAgACABLwAXOwAYIABBGmohACAEQRprIgRBGUsNAAsMCAsgBEEYSQ0HA0AgACADLQAAOgAAIAAgAS0AADoAASAAIAEtAAE6AAIgACABLQACOgADIAAgAS0AAzoABCAAIAEtAAQ6AAUgACABLQAFOgAGIAAgAS0ABjoAByAAIAEtAAc6AAggACABLQAIOgAJIAAgAS0ACToACiAAIAEtAAo6AAsgACABLQALOgAMIAAgAS0ADDoADSAAIAEtAA06AA4gACABLQAOOgAPIAAgASkADzcAECAAQRhqIQAgBEEYayIEQRdLDQALDAcLIARBFkkNBgNAIAAgAy0AADoAACAAIAEtAAA6AAEgACABLQABOgACIAAgAS0AAjoAAyAAIAEtAAM6AAQgACABLQAEOgAFIAAgAS0ABToABiAAIAEtAAY6AAcgACABLQAHOgAIIAAgAS0ACDoACSAAIAEtAAk6AAogACABLQAKOgALIAAgAS0ACzoADCAAIAEtAAw6AA0gACABLQANOgAOIAAgAS0ADjoADyAAIAEoAA82ABAgACABLwATOwAUIABBFmohACAEQRZrIgRBFUsNAAsMBgsgBEEUSQ0FA0AgACADLQAAOgAAIAAgAS0AADoAASAAIAEtAAE6AAIgACABLQACOgADIAAgAS0AAzoABCAAIAEtAAQ6AAUgACABLQAFOgAGIAAgAS0ABjoAByAAIAEtAAc6AAggACABLQAIOgAJIAAgAS0ACToACiAAIAEtAAo6AAsgACABLQALOgAMIAAgAS0ADDoADSAAIAEtAA06AA4gACABLQAOOgAPIAAgASgADzYAECAAQRRqIQAgBEEUayIEQRNLDQALDAULIARBEkkNBANAIAAgAy0AADoAACAAIAEtAAA6AAEgACABLQABOgACIAAgAS0AAjoAAyAAIAEtAAM6AAQgACABLQAEOgAFIAAgAS0ABToABiAAIAEtAAY6AAcgACABLQAHOgAIIAAgAS0ACDoACSAAIAEtAAk6AAogACABLQAKOgALIAAgAS0ACzoADCAAIAEtAAw6AA0gACABLQANOgAOIAAgAS0ADjoADyAAIAEvAA87ABAgAEESaiEAIARBEmsiBEERSw0ACwwECwNAIAAgAy0AADoAACAAIAMtAAE6AAEgACADLQACOgACIAAgAy0AAzoAAyAAIAMtAAQ6AAQgACADLQAFOgAFIAAgAy0ABjoABiAAIAMtAAc6AAcgAEEIaiEAIANBCGohAyAEQQhrIgQNAAsgBgwECyAEQRBPDQEMAgsgACAJQQFqIgZqIA1LDQUgAyAGaiIBIAhLDQUgACADIAYQJyEAIAEgCE8NA0EBIQsgAS0AACEJIAFBAWoMAgsDQCAAIAMtAAA6AAAgACABLQAAOgABIAAgAS0AAToAAiAAIAEtAAI6AAMgACABLQADOgAEIAAgAS0ABDoABSAAIAEtAAU6AAYgACABLQAGOgAHIAAgAS0ABzoACCAAIAEtAAg6AAkgACABLQAJOgAKIAAgAS0ACjoACyAAIAEtAAs6AAwgACABLQAMOgANIAAgAS0ADToADiAA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FBEKACABLQA1BEAgAUEDNgIsIAEtADRFDQEMAwsgAUEENgIsCyABIAI2AhQgASABKAIoQQFqNgIoIAEoAiRBAUcNASABKAIYQQJHDQEgAUEBOgA2DwsgACgCCCIAIAEgAiADIAQgACgCACgCGBELAAsLNwAgACABKAIIIAUQHwRAIAEgAiADIAQQZA8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEKAAudAQECfyMAQUBqIgMkAAJ/QQEgACABQQAQHw0AGkEAIAFFDQAaQQAgAUGU2gEQZSIBRQ0AGiADQQxqQQBBNBAYGiADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQkAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshBCADQUBrJAAgBAsKACAAIAFBABAfCwYAEKEBAAsFABAHAAsEAEIACwQAQQALRQECfyAAKAI8IQQjAEEQayIAJAAgBCABpyABQiCIpyACQf8BcSAAQQhqEA0QbCECIAApAwghASAAQRBqJABCfyABIAIbC70CAQh/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQYgA0EQaiEBAn8DQAJAAkACQCAAKAI8IAEgBiADQQxqEBEQbEUEQCAFIAMoAgwiB0YNASAHQQBODQIMAwsgBUF/Rw0CCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAwsgASAHIAEoAgQiCEsiCUEDdGoiBCAHIAhBACAJG2siCCAEKAIAajYCACABQQxBBCAJG2oiASABKAIAIAhrNgIAIAUgB2shBSAGIAlrIQYgBCEBDAELCyAAQQA2AhwgAEIANwMQIAAgACgCAEEgcjYCAEEAIAZBAkYNABogAiABKAIEawshCiADQSBqJAAgCgsJACAAKAI8EBILmAEBA38CfwJAAkAgACgCBCICIgBBA3FFDQBBACAALQAARQ0CGgNAIABBAWoiAEEDcUUNASAALQAADQALDAELA0AgACIBQQRqIQAgASgCACIDQX9zIANBgYKECGtxQYCBgoR4cUUNAAsDQCABIgBBAWohASAALQAADQALCyAAIAJrC0EBaiIAEB0i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dzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AGx6NABjb21wcmVzc2lvbiBzdXBwb3J0LiAgUGxlYXNlIHVzZSBvbmUgaGF2aW5nIGl0LgAobnVsbCkARXJyb3IuICBudGhyZWFkcyBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gQkxPU0NfTUFYX1RIUkVBRFMgKCVkKQBFcnJvciBhbGxvY2F0aW5nIG1lbW9yeSEAQmxvc2MgaGFzIG5vdCBiZWVuIGNvbXBpbGVkIHdpdGggJyVzJyAASW5wdXQgYnVmZmVyIHNpemUgY2Fubm90IGV4Y2VlZCAlZCBieXRlcwoACUVycm9yIGRldGFpbDogJXMKAEVSUk9SOyByZXR1cm4gY29kZSBmcm9tIHB0aHJlYWRf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AAUAAAAFAAAAMAAAAAcAAAAXAAAAFwAAABYAAAAFAAAABAAAAEAAAAAHAAAAFwAAABcAAAAWAAAABgAAAAMAAABAAAAACAAAABcAAAAYAAAAFgAAAAcAAAADAAAAAAEAAAkAAAAZAAAAGQAAABcAAAAHAAAAAwAAAAABAAAJAAAAGgAAABoAAAAYAAAABwAAAAMAAAAAAgAACQAAABsAAAAbAAAAGQAAAAkAAAADAAAA5wMAAAkAAAASAAAADAAAAA0AAAABAAAABQAAAAEAAAABAAAAEgAAAA0AAAAOAAAAAQAAAAYAAAAAAAAAAQAAABIAAAAOAAAADgAAAAEAAAAFAAAAAAAAAAIAAAASAAAAEAAAABAAAAABAAAABAAAAAAAAAACAAAAEgAAABAAAAARAAAAAgAAAAUAAAACAAAAAwAAABIAAAASAAAAEgAAAAMAAAAFAAAAAgAAAAMAAAASAAAAEgAAABMAAAADAAAABQAAAAQAAAAEAAAAEgAAABIAAAATAAAABAAAAAQAAAAEAAAABAAAABIAAAASAAAAEwAAAAQAAAAEAAAACAAAAAUAAAASAAAAEgAAABMAAAAFAAAABAAAAAgAAAAFAAAAEgAAABIAAAATAAAABgAAAAQAAAAIAAAABQAAABIAAAASAAAAEwAAAAUAAAAEAAAADAAAAAYAAAASAAAAEwAAABMAAAAHAAAABAAAAAwAAAAGAAAAEgAAABIAAAATAAAABAAAAAQAAAAQAAAABwAAABIAAAASAAAAEwAAAAQAAAADAAAAIAAAAAcAAAASAAAAEgAAABMAAAAGAAAAAwAAAIAAAAAHAAAAEgAAABMAAAATAAAABgAAAAMAAACAAAAACAAAABIAAAATAAAAEwAAAAgAAAADAAAAAAEAAAgAAAASAAAAEwAAABMAAAAGAAAAAwAAAIAAAAAJAAAAEgAAABMAAAATAAAACAAAAAMAAAAAAQAACQAAABIAAAATAAAAEwAAAAoAAAADAAAAAAIAAAkAAAASAAAAEwAAABMAAAAMAAAAAwAAAAACAAAJAAAAEgAAABMAAAATAAAADQAAAAMAAADnAwAACQAAABEAAAAMAAAADAAAAAEAAAAFAAAAAQAAAAEAAAARAAAADAAAAA0AAAABAAAABgAAAAAAAAABAAAAEQAAAA0AAAAPAAAAAQAAAAUAAAAAAAAAAQAAABEAAAAPAAAAEAAAAAIAAAAFAAAAAAAAAAIAAAARAAAAEQAAABEAAAACAAAABAAAAAAAAAACAAAAEQAAABAAAAARAAAAAwAAAAQAAAACAAAAAwAAABEAAAARAAAAEQAAAAMAAAAEAAAABAAAAAQAAAARAAAAEQAAABEAAAADAAAABAAAAAgAAAAFAAAAEQAAABEAAAARAAAABAAAAAQAAAAIAAAABQAAABEAAAARAAAAEQAAAAUAAAAEAAAACAAAAAUAAAARAAAAEQAAABEAAAAGAAAABAAAAAgAAAAFAAAAEQAAABEAAAARAAAABQAAAAQAAAAIAAAABgAAABEAAAASAAAAEQAAAAcAAAAEAAAADAAAAAYAAAARAAAAEgAAABEAAAADAAAABAAAAAwAAAAHAAAAEQAAABIAAAARAAAABAAAAAMAAAAgAAAABwAAABEAAAASAAAAEQAAAAYAAAADAAAAAAEAAAcAAAARAAAAEgAAABEAAAAGAAAAAwAAAIAAAAAIAAAAEQAAABIAAAARAAAACAAAAAMAAAAAAQAACAAAABEAAAASAAAAEQAAAAoAAAADAAAAAAIAAAgAAAARAAAAEgAAABEAAAAFAAAAAwAAAAABAAAJAAAAEQAAABIAAAARAAAABwAAAAMAAAAAAgAACQAAABEAAAASAAAAEQAAAAkAAAADAAAAAAIAAAkAAAARAAAAEgAAABEAAAALAAAAAwAAAOcDAAAJAAAADgAAAAwAAAANAAAAAQAAAAUAAAABAAAAAQAAAA4AAAAOAAAADwAAAAEAAAAFAAAAAAAAAAEAAAAOAAAADgAAAA8AAAABAAAABAAAAAAAAAABAAAADgAAAA4AAAAPAAAAAgAAAAQAAAAAAAAAAgAAAA4AAAAOAAAADgAAAAQAAAAEAAAAAgAAAAMAAAAOAAAADgAAAA4AAAADAAAABAAAAAQAAAAEAAAADgAAAA4AAAAOAAAABAAAAAQAAAAIAAAABQAAAA4AAAAOAAAADgAAAAYAAAAEAAAACAAAAAUAAAAOAAAADgAAAA4AAAAIAAAABAAAAAgAAAAFAAAADgAAAA8AAAAOAAAABQAAAAQAAAAIAAAABgAAAA4AAAAPAAAADgAAAAkAAAAEAAAACAAAAAYAAAAOAAAADwAAAA4AAAADAAAABAAAAAwAAAAHAAAADgAAAA8AAAAOAAAABAAAAAMAAAAYAAAABwAAAA4AAAAPAAAADgAAAAUAAAADAAAAIAAAAAgAAAAOAAAADwAAAA8AAAAGAAAAAwAAAEAAAAAIAAAADgAAAA8AAAAPAAAABwAAAAMAAAAAAQAACAAAAA4AAAAPAAAADwAAAAUAAAADAAAAMAAAAAkAAAAOAAAADwAAAA8AAAAGAAAAAwAAAIAAAAAJAAAADgAAAA8AAAAPAAAABwAAAAMAAAAAAQAACQAAAA4AAAAPAAAADwAAAAgAAAADAAAAAAEAAAkAAAAOAAAADwAAAA8AAAAIAAAAAwAAAAACAAAJAAAADgAAAA8AAAAPAAAACQAAAAMAAAAAAgAACQAAAA4AAAAPAAAADwAAAAoAAAADAAAA5wMAAAkAAAAEAAMAAgACAAIAAgACAAIAAgACAAIAAgACAAEAAQABAAIAAgACAAIAAgACAAIAAgACAAMAAgABAAEAAQABAAEA//////////8AAAAAAAAAAAEAAQABAAEAAQABAAIAAgACAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAP////////////8AAAAAAAABAAQAAwACAAIAAgACAAIAAgABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAP//////////////////AEG0nAELmQhrOAcADbIHAJzyBwBwZAgAYK4KALBxCwAwqgwAAAAAAAAIAAAABwAAagYAAAAGAACtBQAAagUAADEFAAAABQAA1AQAAK0EAACKBAAAagQAAEwEAAAxBAAAFwQAAAAEAADpAwAA1AMAAMADAACtAwAAmwMAAIoDAAB5AwAAagMAAFsDAABMAwAAPgMAADEDAAAkAwAAFwMAAAsDAAAAAwAA9AIAAOkCAADeAgAA1AIAAMoCAADAAgAAtgIAAK0CAACkAgAAmwIAAJICAACKAgAAggIAAHkCAAByAgAAagIAAGICAABbAgAAUwIAAEwCAABFAgAAPgIAADcCAAAxAgAAKgIAACQCAAAeAgAAFwIAABECAAALAgAABQIAAAACAAD6AQAA9AEAAO8BAADpAQAA5AEAAN4BAADZAQAA1AEAAM8BAADK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AAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAHAAAACAAAAAkAAAAKAAAACwAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAA0bwAAkF4AAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAAA0bwAA2F4AAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAAA0bwAAIF8AAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAANG8AAGhfAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAADRvAAC0XwAATjEwZW1zY3JpcHRlbjN2YWxFAAA0bwAAAGAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAANG8AABxgAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAADRvAABEYAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAAA0bwAAbGAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQAANG8AAJRgAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAADRvAAC8YAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAAA0bwAA5GAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQAANG8AAAxhAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAADRvAAA0YQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAAA0bwAAXGEAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXhFRQAANG8AAIRhAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l5RUUAADRvAACsYQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAA0bwAA1GEAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAANG8AAPxhAABObyBlcnJvciBpbmZvcm1hdGlvbgBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBS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");
    COMPRESSORS = /* @__PURE__ */ new Set(["blosclz", "lz4", "lz4hc", "snappy", "zlib", "zstd"]);
    init2 = () => blosc_codec_default({ noInitialRun: true, wasmBinary: blosc_codec_default2 });
    Blosc = (_a = class {
      constructor(clevel = 5, cname = "lz4", shuffle = 1, blocksize = 0) {
        __publicField(this, "clevel");
        __publicField(this, "cname");
        __publicField(this, "shuffle");
        __publicField(this, "blocksize");
        if (clevel < 0 || clevel > 9) {
          throw new Error(`Invalid compression level: '${clevel}'. It should be between 0 and 9`);
        }
        if (!COMPRESSORS.has(cname)) {
          throw new Error(
            `Invalid compressor '${cname}'. Valid compressors include
        'blosclz', 'lz4', 'lz4hc','snappy', 'zlib', 'zstd'.`
          );
        }
        if (shuffle < -1 || shuffle > 2) {
          throw new Error(
            `Invalid shuffle ${shuffle}. Must be one of 0 (NOSHUFFLE),
        1 (SHUFFLE), 2 (BITSHUFFLE), -1 (AUTOSHUFFLE).`
          );
        }
        this.blocksize = blocksize;
        this.clevel = clevel;
        this.cname = cname;
        this.shuffle = shuffle;
      }
      static fromConfig({ blocksize, clevel, cname, shuffle }) {
        return new _a(clevel, cname, shuffle, blocksize);
      }
      async encode(data) {
        if (!emscriptenModule) {
          emscriptenModule = init2();
        }
        const module = await emscriptenModule;
        const view = module.compress(data, this.cname, this.clevel, this.shuffle, this.blocksize);
        const result = new Uint8Array(view);
        module.free_result();
        return result;
      }
      async decode(data, out) {
        if (!emscriptenModule) {
          emscriptenModule = init2();
        }
        const module = await emscriptenModule;
        const view = module.decompress(data);
        const result = new Uint8Array(view);
        module.free_result();
        if (out !== void 0) {
          out.set(result);
          return out;
        }
        return result;
      }
    }, __publicField(_a, "codecId", "blosc"), __publicField(_a, "COMPRESSORS", [...COMPRESSORS]), __publicField(_a, "NOSHUFFLE", 0), __publicField(_a, "SHUFFLE", 1), __publicField(_a, "BITSHUFFLE", 2), __publicField(_a, "AUTOSHUFFLE", -1), _a);
    blosc_default = Blosc;
  }
});

// node_modules/numcodecs/dist/lz4.js
var lz4_exports = {};
__export(lz4_exports, {
  default: () => lz4_default
});
var lz4_codec, lz4_codec_default, lz4_codec_default2, DEFAULT_ACCELERATION, MAX_BUFFER_SIZE, emscriptenModule2, init3, _a2, LZ4, lz4_default;
var init_lz4 = __esm({
  "node_modules/numcodecs/dist/lz4.js"() {
    init_chunk_INHXZS53();
    lz4_codec = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      return function(moduleArg = {}) {
        var f2 = moduleArg, aa, t2;
        f2.ready = new Promise((a2, b2) => {
          aa = a2;
          t2 = b2;
        });
        var ba = Object.assign({}, f2), u2 = f2.printErr || console.error.bind(console);
        Object.assign(f2, ba);
        ba = null;
        var v2;
        f2.wasmBinary && (v2 = f2.wasmBinary);
        "object" != typeof WebAssembly && x2("no native wasm support detected");
        var z2, da = false, C3, D3, E3, F2, G3, H2, ea, fa;
        function ha() {
          var a2 = z2.buffer;
          f2.HEAP8 = C3 = new Int8Array(a2);
          f2.HEAP16 = E3 = new Int16Array(a2);
          f2.HEAPU8 = D3 = new Uint8Array(a2);
          f2.HEAPU16 = F2 = new Uint16Array(a2);
          f2.HEAP32 = G3 = new Int32Array(a2);
          f2.HEAPU32 = H2 = new Uint32Array(a2);
          f2.HEAPF32 = ea = new Float32Array(a2);
          f2.HEAPF64 = fa = new Float64Array(a2);
        }
        var ia = [], ja = [], ka = [];
        function la() {
          var a2 = f2.preRun.shift();
          ia.unshift(a2);
        }
        var I3 = 0, J2 = null, L2 = null;
        function x2(a2) {
          f2.onAbort?.(a2);
          a2 = "Aborted(" + a2 + ")";
          u2(a2);
          da = true;
          a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
          t2(a2);
          throw a2;
        }
        var ma = (a2) => a2.startsWith("data:application/octet-stream;base64,"), na = (a2) => a2.startsWith("file://"), M2;
        M2 = "lz4_codec.wasm";
        if (!ma(M2)) {
          var oa = M2;
          M2 = f2.locateFile ? f2.locateFile(oa, "") : "" + oa;
        }
        function pa(a2) {
          return Promise.resolve().then(() => {
            if (a2 == M2 && v2)
              var b2 = new Uint8Array(v2);
            else
              throw "both async and sync fetching of the wasm failed";
            return b2;
          });
        }
        function qa(a2, b2, c2) {
          return pa(a2).then((d2) => WebAssembly.instantiate(d2, b2)).then((d2) => d2).then(c2, (d2) => {
            u2(`failed to asynchronously prepare wasm: ${d2}`);
            x2(d2);
          });
        }
        function ra(a2, b2) {
          var c2 = M2;
          return v2 || "function" != typeof WebAssembly.instantiateStreaming || ma(c2) || na(c2) || "function" != typeof fetch ? qa(c2, a2, b2) : fetch(c2, { credentials: "same-origin" }).then((d2) => WebAssembly.instantiateStreaming(d2, a2).then(b2, function(e2) {
            u2(`wasm streaming compile failed: ${e2}`);
            u2("falling back to ArrayBuffer instantiation");
            return qa(c2, a2, b2);
          }));
        }
        var N3 = (a2) => {
          for (; 0 < a2.length; )
            a2.shift()(f2);
        };
        function sa(a2) {
          this.D = a2 - 24;
          this.K = function(b2) {
            H2[this.D + 4 >> 2] = b2;
          };
          this.J = function(b2) {
            H2[this.D + 8 >> 2] = b2;
          };
          this.F = function(b2, c2) {
            this.G();
            this.K(b2);
            this.J(c2);
          };
          this.G = function() {
            H2[this.D + 16 >> 2] = 0;
          };
        }
        var ta = 0, ua = 0, va, O2 = (a2) => {
          for (var b2 = ""; D3[a2]; )
            b2 += va[D3[a2++]];
          return b2;
        }, P2 = {}, Q3 = {}, R2 = {}, S2, wa = (a2) => {
          throw new S2(a2);
        }, T2, xa = (a2, b2) => {
          function c2(l2) {
            l2 = b2(l2);
            if (l2.length !== d2.length)
              throw new T2("Mismatched type converter count");
            for (var g3 = 0; g3 < d2.length; ++g3)
              U2(d2[g3], l2[g3]);
          }
          var d2 = [];
          d2.forEach(function(l2) {
            R2[l2] = a2;
          });
          var e2 = Array(a2.length), h2 = [], k2 = 0;
          a2.forEach((l2, g3) => {
            Q3.hasOwnProperty(l2) ? e2[g3] = Q3[l2] : (h2.push(l2), P2.hasOwnProperty(l2) || (P2[l2] = []), P2[l2].push(() => {
              e2[g3] = Q3[l2];
              ++k2;
              k2 === h2.length && c2(e2);
            }));
          });
          0 === h2.length && c2(e2);
        };
        function ya(a2, b2, c2 = {}) {
          var d2 = b2.name;
          if (!a2)
            throw new S2(`type "${d2}" must have a positive integer typeid pointer`);
          if (Q3.hasOwnProperty(a2)) {
            if (c2.M)
              return;
            throw new S2(`Cannot register type '${d2}' twice`);
          }
          Q3[a2] = b2;
          delete R2[a2];
          P2.hasOwnProperty(a2) && (b2 = P2[a2], delete P2[a2], b2.forEach((e2) => e2()));
        }
        function U2(a2, b2, c2 = {}) {
          if (!("argPackAdvance" in b2))
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          ya(a2, b2, c2);
        }
        function za() {
          this.B = [void 0];
          this.H = [];
        }
        var V2 = new za(), Aa = (a2) => {
          a2 >= V2.D && 0 === --V2.get(a2).I && V2.G(a2);
        }, Ba = (a2) => {
          switch (a2) {
            case void 0:
              return 1;
            case null:
              return 2;
            case true:
              return 3;
            case false:
              return 4;
            default:
              return V2.F({ I: 1, value: a2 });
          }
        };
        function Ca(a2) {
          return this.fromWireType(G3[a2 >> 2]);
        }
        var Da = (a2, b2) => {
          switch (b2) {
            case 4:
              return function(c2) {
                return this.fromWireType(ea[c2 >> 2]);
              };
            case 8:
              return function(c2) {
                return this.fromWireType(fa[c2 >> 3]);
              };
            default:
              throw new TypeError(`invalid float width (${b2}): ${a2}`);
          }
        }, Ga = (a2, b2) => Object.defineProperty(b2, "name", { value: a2 }), Ha = (a2) => {
          for (; a2.length; ) {
            var b2 = a2.pop();
            a2.pop()(b2);
          }
        };
        function Ia(a2) {
          for (var b2 = 1; b2 < a2.length; ++b2)
            if (null !== a2[b2] && void 0 === a2[b2].C)
              return true;
          return false;
        }
        function Ja(a2) {
          var b2 = Function;
          if (!(b2 instanceof Function))
            throw new TypeError(`new_ called with constructor type ${typeof b2} which is not a function`);
          var c2 = Ga(b2.name || "unknownFunctionName", function() {
          });
          c2.prototype = b2.prototype;
          c2 = new c2();
          a2 = b2.apply(c2, a2);
          return a2 instanceof Object ? a2 : c2;
        }
        var Ka = (a2, b2) => {
          if (void 0 === f2[a2].A) {
            var c2 = f2[a2];
            f2[a2] = function() {
              if (!f2[a2].A.hasOwnProperty(arguments.length))
                throw new S2(`Function '${b2}' called with an invalid number of arguments (${arguments.length}) - expects one of (${f2[a2].A})!`);
              return f2[a2].A[arguments.length].apply(this, arguments);
            };
            f2[a2].A = [];
            f2[a2].A[c2.L] = c2;
          }
        }, La = (a2, b2, c2) => {
          if (f2.hasOwnProperty(a2)) {
            if (void 0 === c2 || void 0 !== f2[a2].A && void 0 !== f2[a2].A[c2])
              throw new S2(`Cannot register public name '${a2}' twice`);
            Ka(a2, a2);
            if (f2.hasOwnProperty(c2))
              throw new S2(`Cannot register multiple overloads of a function with the same number of arguments (${c2})!`);
            f2[a2].A[c2] = b2;
          } else
            f2[a2] = b2, void 0 !== c2 && (f2[a2].O = c2);
        }, Ma = (a2, b2) => {
          for (var c2 = [], d2 = 0; d2 < a2; d2++)
            c2.push(H2[b2 + 4 * d2 >> 2]);
          return c2;
        }, Na, Oa = (a2, b2) => {
          var c2 = [];
          return function() {
            c2.length = 0;
            Object.assign(c2, arguments);
            if (a2.includes("j")) {
              var d2 = f2["dynCall_" + a2];
              d2 = c2 && c2.length ? d2.apply(null, [b2].concat(c2)) : d2.call(null, b2);
            } else
              d2 = Na.get(b2).apply(null, c2);
            return d2;
          };
        }, Pa = (a2, b2) => {
          a2 = O2(a2);
          var c2 = a2.includes("j") ? Oa(a2, b2) : Na.get(b2);
          if ("function" != typeof c2)
            throw new S2(`unknown function pointer with signature ${a2}: ${b2}`);
          return c2;
        }, Qa, Sa = (a2) => {
          a2 = Ra(a2);
          var b2 = O2(a2);
          W2(a2);
          return b2;
        }, Ta = (a2, b2) => {
          function c2(h2) {
            e2[h2] || Q3[h2] || (R2[h2] ? R2[h2].forEach(c2) : (d2.push(h2), e2[h2] = true));
          }
          var d2 = [], e2 = {};
          b2.forEach(c2);
          throw new Qa(`${a2}: ` + d2.map(Sa).join([", "]));
        }, Ua = (a2) => {
          a2 = a2.trim();
          const b2 = a2.indexOf("(");
          return -1 !== b2 ? a2.substr(0, b2) : a2;
        }, Va = (a2, b2, c2) => {
          switch (b2) {
            case 1:
              return c2 ? (d2) => C3[d2 >> 0] : (d2) => D3[d2 >> 0];
            case 2:
              return c2 ? (d2) => E3[d2 >> 1] : (d2) => F2[d2 >> 1];
            case 4:
              return c2 ? (d2) => G3[d2 >> 2] : (d2) => H2[d2 >> 2];
            default:
              throw new TypeError(`invalid integer width (${b2}): ${a2}`);
          }
        };
        function Wa(a2) {
          return this.fromWireType(H2[a2 >> 2]);
        }
        for (var Xa = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, Ya = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, Za = (a2, b2) => {
          var c2 = a2 >> 1;
          for (var d2 = c2 + b2 / 2; !(c2 >= d2) && F2[c2]; )
            ++c2;
          c2 <<= 1;
          if (32 < c2 - a2 && Ya)
            return Ya.decode(D3.subarray(a2, c2));
          c2 = "";
          for (d2 = 0; !(d2 >= b2 / 2); ++d2) {
            var e2 = E3[a2 + 2 * d2 >> 1];
            if (0 == e2)
              break;
            c2 += String.fromCharCode(e2);
          }
          return c2;
        }, $a = (a2, b2, c2) => {
          c2 ?? (c2 = 2147483647);
          if (2 > c2)
            return 0;
          c2 -= 2;
          var d2 = b2;
          c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
          for (var e2 = 0; e2 < c2; ++e2)
            E3[b2 >> 1] = a2.charCodeAt(e2), b2 += 2;
          E3[b2 >> 1] = 0;
          return b2 - d2;
        }, ab = (a2) => 2 * a2.length, bb = (a2, b2) => {
          for (var c2 = 0, d2 = ""; !(c2 >= b2 / 4); ) {
            var e2 = G3[a2 + 4 * c2 >> 2];
            if (0 == e2)
              break;
            ++c2;
            65536 <= e2 ? (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023)) : d2 += String.fromCharCode(e2);
          }
          return d2;
        }, cb = (a2, b2, c2) => {
          c2 ?? (c2 = 2147483647);
          if (4 > c2)
            return 0;
          var d2 = b2;
          c2 = d2 + c2 - 4;
          for (var e2 = 0; e2 < a2.length; ++e2) {
            var h2 = a2.charCodeAt(e2);
            if (55296 <= h2 && 57343 >= h2) {
              var k2 = a2.charCodeAt(++e2);
              h2 = 65536 + ((h2 & 1023) << 10) | k2 & 1023;
            }
            G3[b2 >> 2] = h2;
            b2 += 4;
            if (b2 + 4 > c2)
              break;
          }
          G3[b2 >> 2] = 0;
          return b2 - d2;
        }, db = (a2) => {
          for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
            var d2 = a2.charCodeAt(c2);
            55296 <= d2 && 57343 >= d2 && ++c2;
            b2 += 4;
          }
          return b2;
        }, eb = Array(256), X2 = 0; 256 > X2; ++X2)
          eb[X2] = String.fromCharCode(X2);
        va = eb;
        S2 = f2.BindingError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "BindingError";
          }
        };
        T2 = f2.InternalError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "InternalError";
          }
        };
        Object.assign(za.prototype, { get(a2) {
          return this.B[a2];
        }, has(a2) {
          return void 0 !== this.B[a2];
        }, F(a2) {
          var b2 = this.H.pop() || this.B.length;
          this.B[b2] = a2;
          return b2;
        }, G(a2) {
          this.B[a2] = void 0;
          this.H.push(a2);
        } });
        V2.B.push({ value: void 0 }, { value: null }, { value: true }, { value: false });
        V2.D = V2.B.length;
        f2.count_emval_handles = () => {
          for (var a2 = 0, b2 = V2.D; b2 < V2.B.length; ++b2)
            void 0 !== V2.B[b2] && ++a2;
          return a2;
        };
        Qa = f2.UnboundTypeError = ((a2, b2) => {
          var c2 = Ga(b2, function(d2) {
            this.name = b2;
            this.message = d2;
            d2 = Error(d2).stack;
            void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
          });
          c2.prototype = Object.create(a2.prototype);
          c2.prototype.constructor = c2;
          c2.prototype.toString = function() {
            return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;
          };
          return c2;
        })(Error, "UnboundTypeError");
        var gb = { n: (a2, b2, c2) => {
          new sa(a2).F(b2, c2);
          ta = a2;
          ua++;
          throw ta;
        }, o: () => {
        }, l: (a2, b2, c2, d2) => {
          b2 = O2(b2);
          U2(a2, { name: b2, fromWireType: function(e2) {
            return !!e2;
          }, toWireType: function(e2, h2) {
            return h2 ? c2 : d2;
          }, argPackAdvance: 8, readValueFromPointer: function(e2) {
            return this.fromWireType(D3[e2]);
          }, C: null });
        }, k: (a2, b2) => {
          b2 = O2(b2);
          U2(a2, { name: b2, fromWireType: (c2) => {
            if (!c2)
              throw new S2("Cannot use deleted val. handle = " + c2);
            var d2 = V2.get(c2).value;
            Aa(c2);
            return d2;
          }, toWireType: (c2, d2) => Ba(d2), argPackAdvance: 8, readValueFromPointer: Ca, C: null });
        }, i: (a2, b2, c2) => {
          b2 = O2(b2);
          U2(a2, { name: b2, fromWireType: (d2) => d2, toWireType: (d2, e2) => e2, argPackAdvance: 8, readValueFromPointer: Da(b2, c2), C: null });
        }, d: (a2, b2, c2, d2, e2, h2, k2) => {
          var l2 = Ma(b2, c2);
          a2 = O2(a2);
          a2 = Ua(a2);
          e2 = Pa(d2, e2);
          La(a2, function() {
            Ta(`Cannot call ${a2} due to unbound types`, l2);
          }, b2 - 1);
          xa(l2, function(g3) {
            var n2 = a2;
            var p2 = a2;
            g3 = [g3[0], null].concat(g3.slice(1));
            var q2 = e2, m2 = g3.length;
            if (2 > m2)
              throw new S2("argTypes array size mismatch! Must at least get return value and 'this' types!");
            var r2 = null !== g3[1] && false, y2 = Ia(g3), A3 = "void" !== g3[0].name;
            q2 = [wa, q2, h2, Ha, g3[0], g3[1]];
            for (var w3 = 0; w3 < m2 - 2; ++w3)
              q2.push(g3[w3 + 2]);
            if (!y2)
              for (w3 = r2 ? 1 : 2; w3 < g3.length; ++w3)
                null !== g3[w3].C && q2.push(g3[w3].C);
            y2 = Ia(g3);
            w3 = g3.length;
            var B3 = "", K2 = "";
            for (m2 = 0; m2 < w3 - 2; ++m2)
              B3 += (0 !== m2 ? ", " : "") + "arg" + m2, K2 += (0 !== m2 ? ", " : "") + "arg" + m2 + "Wired";
            B3 = `
        return function (${B3}) {
        if (arguments.length !== ${w3 - 2}) {
          throwBindingError('function ${p2} called with ' + arguments.length + ' arguments, expected ${w3 - 2}');
        }`;
            y2 && (B3 += "var destructors = [];\n");
            var Ea = y2 ? "destructors" : "null", ca = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
            r2 && (B3 += "var thisWired = classParam['toWireType'](" + Ea + ", this);\n");
            for (m2 = 0; m2 < w3 - 2; ++m2)
              B3 += "var arg" + m2 + "Wired = argType" + m2 + "['toWireType'](" + Ea + ", arg" + m2 + "); // " + g3[m2 + 2].name + "\n", ca.push("argType" + m2);
            r2 && (K2 = "thisWired" + (0 < K2.length ? ", " : "") + K2);
            B3 += (A3 || k2 ? "var rv = " : "") + "invoker(fn" + (0 < K2.length ? ", " : "") + K2 + ");\n";
            if (y2)
              B3 += "runDestructors(destructors);\n";
            else
              for (m2 = r2 ? 1 : 2; m2 < g3.length; ++m2)
                r2 = 1 === m2 ? "thisWired" : "arg" + (m2 - 2) + "Wired", null !== g3[m2].C && (B3 += r2 + "_dtor(" + r2 + "); // " + g3[m2].name + "\n", ca.push(r2 + "_dtor"));
            A3 && (B3 += "var ret = retType['fromWireType'](rv);\nreturn ret;\n");
            let [Fa, hb] = [ca, B3 + "}\n"];
            Fa.push(hb);
            g3 = Ja(Fa).apply(null, q2);
            p2 = Ga(p2, g3);
            g3 = b2 - 1;
            if (!f2.hasOwnProperty(n2))
              throw new T2("Replacing nonexistant public symbol");
            void 0 !== f2[n2].A && void 0 !== g3 ? f2[n2].A[g3] = p2 : (f2[n2] = p2, f2[n2].L = g3);
            return [];
          });
        }, b: (a2, b2, c2, d2, e2) => {
          b2 = O2(b2);
          -1 === e2 && (e2 = 4294967295);
          e2 = (l2) => l2;
          if (0 === d2) {
            var h2 = 32 - 8 * c2;
            e2 = (l2) => l2 << h2 >>> h2;
          }
          var k2 = b2.includes("unsigned") ? function(l2, g3) {
            return g3 >>> 0;
          } : function(l2, g3) {
            return g3;
          };
          U2(a2, {
            name: b2,
            fromWireType: e2,
            toWireType: k2,
            argPackAdvance: 8,
            readValueFromPointer: Va(b2, c2, 0 !== d2),
            C: null
          });
        }, a: (a2, b2, c2) => {
          function d2(h2) {
            return new e2(C3.buffer, H2[h2 + 4 >> 2], H2[h2 >> 2]);
          }
          var e2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b2];
          c2 = O2(c2);
          U2(a2, { name: c2, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { M: true });
        }, e: (a2, b2) => {
          b2 = O2(b2);
          var c2 = "std::string" === b2;
          U2(a2, { name: b2, fromWireType: function(d2) {
            var e2 = H2[d2 >> 2], h2 = d2 + 4;
            if (c2)
              for (var k2 = h2, l2 = 0; l2 <= e2; ++l2) {
                var g3 = h2 + l2;
                if (l2 == e2 || 0 == D3[g3]) {
                  if (k2) {
                    var n2 = k2;
                    var p2 = D3, q2 = n2 + (g3 - k2);
                    for (k2 = n2; p2[k2] && !(k2 >= q2); )
                      ++k2;
                    if (16 < k2 - n2 && p2.buffer && Xa)
                      n2 = Xa.decode(p2.subarray(n2, k2));
                    else {
                      for (q2 = ""; n2 < k2; ) {
                        var m2 = p2[n2++];
                        if (m2 & 128) {
                          var r2 = p2[n2++] & 63;
                          if (192 == (m2 & 224))
                            q2 += String.fromCharCode((m2 & 31) << 6 | r2);
                          else {
                            var y2 = p2[n2++] & 63;
                            m2 = 224 == (m2 & 240) ? (m2 & 15) << 12 | r2 << 6 | y2 : (m2 & 7) << 18 | r2 << 12 | y2 << 6 | p2[n2++] & 63;
                            65536 > m2 ? q2 += String.fromCharCode(m2) : (m2 -= 65536, q2 += String.fromCharCode(55296 | m2 >> 10, 56320 | m2 & 1023));
                          }
                        } else
                          q2 += String.fromCharCode(m2);
                      }
                      n2 = q2;
                    }
                  } else
                    n2 = "";
                  if (void 0 === A3)
                    var A3 = n2;
                  else
                    A3 += String.fromCharCode(0), A3 += n2;
                  k2 = g3 + 1;
                }
              }
            else {
              A3 = Array(e2);
              for (l2 = 0; l2 < e2; ++l2)
                A3[l2] = String.fromCharCode(D3[h2 + l2]);
              A3 = A3.join("");
            }
            W2(d2);
            return A3;
          }, toWireType: function(d2, e2) {
            e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2));
            var h2, k2 = "string" == typeof e2;
            if (!(k2 || e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray || e2 instanceof Int8Array))
              throw new S2("Cannot pass non-string to std::string");
            var l2;
            if (c2 && k2)
              for (h2 = l2 = 0; h2 < e2.length; ++h2) {
                var g3 = e2.charCodeAt(h2);
                127 >= g3 ? l2++ : 2047 >= g3 ? l2 += 2 : 55296 <= g3 && 57343 >= g3 ? (l2 += 4, ++h2) : l2 += 3;
              }
            else
              l2 = e2.length;
            h2 = l2;
            l2 = fb(4 + h2 + 1);
            g3 = l2 + 4;
            H2[l2 >> 2] = h2;
            if (c2 && k2) {
              if (k2 = g3, g3 = h2 + 1, h2 = D3, 0 < g3) {
                g3 = k2 + g3 - 1;
                for (var n2 = 0; n2 < e2.length; ++n2) {
                  var p2 = e2.charCodeAt(n2);
                  if (55296 <= p2 && 57343 >= p2) {
                    var q2 = e2.charCodeAt(++n2);
                    p2 = 65536 + ((p2 & 1023) << 10) | q2 & 1023;
                  }
                  if (127 >= p2) {
                    if (k2 >= g3)
                      break;
                    h2[k2++] = p2;
                  } else {
                    if (2047 >= p2) {
                      if (k2 + 1 >= g3)
                        break;
                      h2[k2++] = 192 | p2 >> 6;
                    } else {
                      if (65535 >= p2) {
                        if (k2 + 2 >= g3)
                          break;
                        h2[k2++] = 224 | p2 >> 12;
                      } else {
                        if (k2 + 3 >= g3)
                          break;
                        h2[k2++] = 240 | p2 >> 18;
                        h2[k2++] = 128 | p2 >> 12 & 63;
                      }
                      h2[k2++] = 128 | p2 >> 6 & 63;
                    }
                    h2[k2++] = 128 | p2 & 63;
                  }
                }
                h2[k2] = 0;
              }
            } else if (k2)
              for (k2 = 0; k2 < h2; ++k2) {
                n2 = e2.charCodeAt(k2);
                if (255 < n2)
                  throw W2(g3), new S2("String has UTF-16 code units that do not fit in 8 bits");
                D3[g3 + k2] = n2;
              }
            else
              for (k2 = 0; k2 < h2; ++k2)
                D3[g3 + k2] = e2[k2];
            null !== d2 && d2.push(W2, l2);
            return l2;
          }, argPackAdvance: 8, readValueFromPointer: Wa, C(d2) {
            W2(d2);
          } });
        }, c: (a2, b2, c2) => {
          c2 = O2(c2);
          if (2 === b2) {
            var d2 = Za;
            var e2 = $a;
            var h2 = ab;
            var k2 = () => F2;
            var l2 = 1;
          } else
            4 === b2 && (d2 = bb, e2 = cb, h2 = db, k2 = () => H2, l2 = 2);
          U2(a2, { name: c2, fromWireType: (g3) => {
            for (var n2 = H2[g3 >> 2], p2 = k2(), q2, m2 = g3 + 4, r2 = 0; r2 <= n2; ++r2) {
              var y2 = g3 + 4 + r2 * b2;
              if (r2 == n2 || 0 == p2[y2 >> l2])
                m2 = d2(m2, y2 - m2), void 0 === q2 ? q2 = m2 : (q2 += String.fromCharCode(0), q2 += m2), m2 = y2 + b2;
            }
            W2(g3);
            return q2;
          }, toWireType: (g3, n2) => {
            if ("string" != typeof n2)
              throw new S2(`Cannot pass non-string to C++ string type ${c2}`);
            var p2 = h2(n2), q2 = fb(4 + p2 + b2);
            H2[q2 >> 2] = p2 >> l2;
            e2(n2, q2 + 4, p2 + b2);
            null !== g3 && g3.push(W2, q2);
            return q2;
          }, argPackAdvance: 8, readValueFromPointer: Ca, C(g3) {
            W2(g3);
          } });
        }, m: (a2, b2) => {
          b2 = O2(b2);
          U2(a2, { N: true, name: b2, argPackAdvance: 0, fromWireType: () => {
          }, toWireType: () => {
          } });
        }, g: Aa, j: (a2) => {
          4 < a2 && (V2.get(a2).I += 1);
        }, f: (a2, b2) => {
          var c2 = Q3[a2];
          if (void 0 === c2)
            throw a2 = "_emval_take_value has unknown type " + Sa(a2), new S2(a2);
          a2 = c2;
          a2 = a2.readValueFromPointer(b2);
          return Ba(a2);
        }, h: () => {
          x2("");
        }, q: (a2, b2, c2) => D3.copyWithin(a2, b2, b2 + c2), p: (a2) => {
          var b2 = D3.length;
          a2 >>>= 0;
          if (2147483648 < a2)
            return false;
          for (var c2 = 1; 4 >= c2; c2 *= 2) {
            var d2 = b2 * (1 + 0.2 / c2);
            d2 = Math.min(d2, a2 + 100663296);
            var e2 = Math;
            d2 = Math.max(a2, d2);
            a: {
              e2 = (e2.min.call(e2, 2147483648, d2 + (65536 - d2 % 65536) % 65536) - z2.buffer.byteLength + 65535) / 65536;
              try {
                z2.grow(e2);
                ha();
                var h2 = 1;
                break a;
              } catch (k2) {
              }
              h2 = void 0;
            }
            if (h2)
              return true;
          }
          return false;
        } }, Y2 = function() {
          function a2(c2) {
            Y2 = c2.exports;
            z2 = Y2.r;
            ha();
            Na = Y2.w;
            ja.unshift(Y2.s);
            I3--;
            f2.monitorRunDependencies?.(I3);
            0 == I3 && (null !== J2 && (clearInterval(J2), J2 = null), L2 && (c2 = L2, L2 = null, c2()));
            return Y2;
          }
          var b2 = { a: gb };
          I3++;
          f2.monitorRunDependencies?.(I3);
          if (f2.instantiateWasm)
            try {
              return f2.instantiateWasm(
                b2,
                a2
              );
            } catch (c2) {
              u2(`Module.instantiateWasm callback failed with error: ${c2}`), t2(c2);
            }
          ra(b2, function(c2) {
            a2(c2.instance);
          }).catch(t2);
          return {};
        }(), fb = (a2) => (fb = Y2.t)(a2), W2 = (a2) => (W2 = Y2.u)(a2), Ra = (a2) => (Ra = Y2.v)(a2), Z2;
        L2 = function ib() {
          Z2 || jb();
          Z2 || (L2 = ib);
        };
        function jb() {
          function a2() {
            if (!Z2 && (Z2 = true, f2.calledRun = true, !da)) {
              N3(ja);
              aa(f2);
              if (f2.onRuntimeInitialized)
                f2.onRuntimeInitialized();
              if (f2.postRun)
                for ("function" == typeof f2.postRun && (f2.postRun = [f2.postRun]); f2.postRun.length; ) {
                  var b2 = f2.postRun.shift();
                  ka.unshift(b2);
                }
              N3(ka);
            }
          }
          if (!(0 < I3)) {
            if (f2.preRun)
              for ("function" == typeof f2.preRun && (f2.preRun = [f2.preRun]); f2.preRun.length; )
                la();
            N3(ia);
            0 < I3 || (f2.setStatus ? (f2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                f2.setStatus("");
              }, 1);
              a2();
            }, 1)) : a2());
          }
        }
        if (f2.preInit)
          for ("function" == typeof f2.preInit && (f2.preInit = [f2.preInit]); 0 < f2.preInit.length; )
            f2.preInit.pop()();
        jb();
        return moduleArg.ready;
      };
    })();
    lz4_codec_default = lz4_codec;
    lz4_codec_default2 = __toBinary("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ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgAAAABkCQAAIAgAAGlpaQBkCQAAIAgAANwMAABpaWlpAAAAAIgMAAB2aQAAAAAAAAEAAAACAAAAAQAAAAAAAAAEAAAABAAAAAQAQcwPC5UN//////z///8BAAAAAgAAAAMAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAA6A0AAOAHAABOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAA6A0AACgIAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAA6A0AAHAIAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRHNOU18xMWNoYXJfdHJhaXRzSURzRUVOU185YWxsb2NhdG9ySURzRUVFRQAAAOgNAAC4CAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURpTlNfMTFjaGFyX3RyYWl0c0lEaUVFTlNfOWFsbG9jYXRvcklEaUVFRUUAAADoDQAABAkAAE4xMGVtc2NyaXB0ZW4zdmFsRQAA6A0AAFAJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAOgNAABsCQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAADoDQAAlAkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAA6A0AALwJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAOgNAADkCQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAADoDQAADAoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAA6A0AADQKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAOgNAABcCgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAADoDQAAhAoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAA6A0AAKwKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAOgNAADUCgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAADoDQAA/AoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAA6A0AACQLAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAAOgNAABMCwAATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAAAAAKA4AAHQLAAAYDgAATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAAAAKA4AAKQLAACYCwAATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAAAAKA4AANQLAACYCwAATjEwX19jeHhhYml2MTE5X19wb2ludGVyX3R5cGVfaW5mb0UAKA4AAAQMAAD4CwAAAAAAAHgMAAALAAAADAAAAA0AAAAOAAAADwAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQAoDgAAUAwAAJgLAAB2AAAAPAwAAIQMAABiAAAAPAwAAJAMAABjAAAAPAwAAJwMAABoAAAAPAwAAKgMAABhAAAAPAwAALQMAABzAAAAPAwAAMAMAAB0AAAAPAwAAMwMAABpAAAAPAwAANgMAABqAAAAPAwAAOQMAABsAAAAPAwAAPAMAABtAAAAPAwAAPwMAAB4AAAAPAwAAAgNAAB5AAAAPAwAABQNAABmAAAAPAwAACANAABkAAAAPAwAACwNAABOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UAAAAAKA4AADgNAADICwAAU3Q5ZXhjZXB0aW9uAAAAAAAAAACgDQAACAAAABAAAAARAAAAU3QxMWxvZ2ljX2Vycm9yACgOAACQDQAASA4AAAAAAADUDQAACAAAABIAAAARAAAAU3QxMmxlbmd0aF9lcnJvcgAAAAAoDgAAwA0AAKANAAAAAAAAyAsAAAsAAAATAAAADQAAAA4AAAAUAAAAFQAAABYAAAAXAAAAU3Q5dHlwZV9pbmZvAAAAAOgNAAAIDgAAAAAAAGANAAALAAAAGAAAAA0AAAAOAAAAFAAAABkAAAAaAAAAGwAAAOgNAABsDQAAAAAAAEgOAAAcAAAAHQAAAB4AQeQcCwNwEwEAQYAdCwEqAEHIHQsCSBMAQewdCwEK");
    DEFAULT_ACCELERATION = 1;
    MAX_BUFFER_SIZE = 2113929216;
    init3 = () => lz4_codec_default({ noInitialRun: true, wasmBinary: lz4_codec_default2 });
    LZ4 = (_a2 = class {
      constructor(acceleration = DEFAULT_ACCELERATION) {
        __publicField(this, "max_buffer_size", MAX_BUFFER_SIZE);
        __publicField(this, "acceleration");
        if (!Number.isInteger(acceleration)) {
          throw Error(`Invalid acceleration "${acceleration}". Must be a positive integer.`);
        }
        this.acceleration = acceleration <= 0 ? DEFAULT_ACCELERATION : acceleration;
      }
      static fromConfig({ acceleration }) {
        return new _a2(acceleration);
      }
      async encode(data) {
        if (!emscriptenModule2) {
          emscriptenModule2 = init3();
        }
        if (data.length > MAX_BUFFER_SIZE) {
          throw Error(`Codec does not support buffers of > ${MAX_BUFFER_SIZE} bytes.`);
        }
        const module = await emscriptenModule2;
        const view = module.compress(data, this.acceleration);
        const result = new Uint8Array(view);
        module.free_result();
        return result;
      }
      async decode(data, out) {
        if (!emscriptenModule2) {
          emscriptenModule2 = init3();
        }
        if (data.length > MAX_BUFFER_SIZE) {
          throw Error(`Codec does not support buffers of > ${MAX_BUFFER_SIZE} bytes.`);
        }
        const module = await emscriptenModule2;
        const view = module.decompress(data);
        const result = new Uint8Array(view);
        module.free_result();
        if (out !== void 0) {
          out.set(result);
          return out;
        }
        return result;
      }
    }, __publicField(_a2, "codecId", "lz4"), __publicField(_a2, "DEFAULT_ACCELERATION", DEFAULT_ACCELERATION), __publicField(_a2, "max_buffer_size", MAX_BUFFER_SIZE), _a2);
    lz4_default = LZ4;
  }
});

// node_modules/numcodecs/dist/zstd.js
var zstd_exports = {};
__export(zstd_exports, {
  default: () => zstd_default
});
var zstd_codec, zstd_codec_default, zstd_codec_default2, DEFAULT_CLEVEL, MAX_CLEVEL, emscriptenModule3, init4, _a3, Zstd, zstd_default;
var init_zstd = __esm({
  "node_modules/numcodecs/dist/zstd.js"() {
    init_chunk_INHXZS53();
    zstd_codec = (() => {
      var _scriptName = typeof document != "undefined" ? document.currentScript?.src : void 0;
      return function(moduleArg = {}) {
        var moduleRtn;
        var f2 = moduleArg, aa, q2, ba = new Promise((a2, b2) => {
          aa = a2;
          q2 = b2;
        }), ca = Object.assign({}, f2), r2 = f2.printErr || console.error.bind(console);
        Object.assign(f2, ca);
        ca = null;
        var t2;
        f2.wasmBinary && (t2 = f2.wasmBinary);
        var u2, da = false, x2, z2, A3, B3, D3, E3, ea, ha;
        function ia() {
          var a2 = u2.buffer;
          f2.HEAP8 = x2 = new Int8Array(a2);
          f2.HEAP16 = A3 = new Int16Array(a2);
          f2.HEAPU8 = z2 = new Uint8Array(a2);
          f2.HEAPU16 = B3 = new Uint16Array(a2);
          f2.HEAP32 = D3 = new Int32Array(a2);
          f2.HEAPU32 = E3 = new Uint32Array(a2);
          f2.HEAPF32 = ea = new Float32Array(a2);
          f2.HEAPF64 = ha = new Float64Array(a2);
        }
        var ja = [], ka = [], la = [], ma = false;
        function na() {
          var a2 = f2.preRun.shift();
          ja.unshift(a2);
        }
        var F2 = 0, H2 = null, I3 = null;
        function oa(a2) {
          f2.onAbort?.(a2);
          a2 = "Aborted(" + a2 + ")";
          r2(a2);
          da = true;
          a2 += ". Build with -sASSERTIONS for more info.";
          ma && pa();
          a2 = new WebAssembly.RuntimeError(a2);
          q2(a2);
          throw a2;
        }
        var qa = (a2) => a2.startsWith("data:application/octet-stream;base64,"), ra = (a2) => a2.startsWith("file://"), J2;
        function sa(a2) {
          if (a2 == J2 && t2)
            return new Uint8Array(t2);
          throw "both async and sync fetching of the wasm failed";
        }
        function ta(a2) {
          return t2 ? Promise.resolve().then(() => sa(a2)) : (void 0)(a2).then((b2) => new Uint8Array(b2), () => sa(a2));
        }
        function ua(a2, b2, c2) {
          return ta(a2).then((d2) => WebAssembly.instantiate(d2, b2)).then(c2, (d2) => {
            r2(`failed to asynchronously prepare wasm: ${d2}`);
            oa(d2);
          });
        }
        function va(a2, b2) {
          var c2 = J2;
          return t2 || "function" != typeof WebAssembly.instantiateStreaming || qa(c2) || ra(c2) || "function" != typeof fetch ? ua(c2, a2, b2) : fetch(c2, { credentials: "same-origin" }).then((d2) => WebAssembly.instantiateStreaming(d2, a2).then(b2, function(e2) {
            r2(`wasm streaming compile failed: ${e2}`);
            r2("falling back to ArrayBuffer instantiation");
            return ua(c2, a2, b2);
          }));
        }
        var K2 = (a2) => {
          for (; 0 < a2.length; )
            a2.shift()(f2);
        }, wa, L2 = (a2) => {
          for (var b2 = ""; z2[a2]; )
            b2 += wa[z2[a2++]];
          return b2;
        }, N3 = {}, O2 = {}, P2 = {}, Q3, xa = (a2) => {
          throw new Q3(a2);
        }, R2, ya = (a2, b2) => {
          function c2(k2) {
            k2 = b2(k2);
            if (k2.length !== d2.length)
              throw new R2("Mismatched type converter count");
            for (var g3 = 0; g3 < d2.length; ++g3)
              S2(d2[g3], k2[g3]);
          }
          var d2 = [];
          d2.forEach(function(k2) {
            P2[k2] = a2;
          });
          var e2 = Array(a2.length), h2 = [], l2 = 0;
          a2.forEach((k2, g3) => {
            O2.hasOwnProperty(k2) ? e2[g3] = O2[k2] : (h2.push(k2), N3.hasOwnProperty(k2) || (N3[k2] = []), N3[k2].push(() => {
              e2[g3] = O2[k2];
              ++l2;
              l2 === h2.length && c2(e2);
            }));
          });
          0 === h2.length && c2(e2);
        };
        function za(a2, b2, c2 = {}) {
          var d2 = b2.name;
          if (!a2)
            throw new Q3(`type "${d2}" must have a positive integer typeid pointer`);
          if (O2.hasOwnProperty(a2)) {
            if (c2.H)
              return;
            throw new Q3(`Cannot register type '${d2}' twice`);
          }
          O2[a2] = b2;
          delete P2[a2];
          N3.hasOwnProperty(a2) && (b2 = N3[a2], delete N3[a2], b2.forEach((e2) => e2()));
        }
        function S2(a2, b2, c2 = {}) {
          if (!("argPackAdvance" in b2))
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          return za(a2, b2, c2);
        }
        var T2 = [], U2 = [], Aa = (a2) => {
          switch (a2) {
            case void 0:
              return 2;
            case null:
              return 4;
            case true:
              return 6;
            case false:
              return 8;
            default:
              const b2 = T2.pop() || U2.length;
              U2[b2] = a2;
              U2[b2 + 1] = 1;
              return b2;
          }
        };
        function V2(a2) {
          return this.fromWireType(E3[a2 >> 2]);
        }
        var Ba = { name: "emscripten::val", fromWireType: (a2) => {
          if (!a2)
            throw new Q3("Cannot use deleted val. handle = " + a2);
          var b2 = U2[a2];
          9 < a2 && 0 === --U2[a2 + 1] && (U2[a2] = void 0, T2.push(a2));
          return b2;
        }, toWireType: (a2, b2) => Aa(b2), argPackAdvance: 8, readValueFromPointer: V2, F: null }, Ca = (a2, b2) => {
          switch (b2) {
            case 4:
              return function(c2) {
                return this.fromWireType(ea[c2 >> 2]);
              };
            case 8:
              return function(c2) {
                return this.fromWireType(ha[c2 >> 3]);
              };
            default:
              throw new TypeError(`invalid float width (${b2}): ${a2}`);
          }
        }, Da = (a2, b2) => Object.defineProperty(b2, "name", { value: a2 }), Ea = (a2) => {
          for (; a2.length; ) {
            var b2 = a2.pop();
            a2.pop()(b2);
          }
        };
        function Fa(a2) {
          for (var b2 = 1; b2 < a2.length; ++b2)
            if (null !== a2[b2] && void 0 === a2[b2].F)
              return true;
          return false;
        }
        function Ga(a2) {
          var b2 = Function;
          if (!(b2 instanceof Function))
            throw new TypeError(`new_ called with constructor type ${typeof b2} which is not a function`);
          var c2 = Da(b2.name || "unknownFunctionName", function() {
          });
          c2.prototype = b2.prototype;
          c2 = new c2();
          a2 = b2.apply(c2, a2);
          return a2 instanceof Object ? a2 : c2;
        }
        var Ha = (a2, b2) => {
          if (void 0 === f2[a2].D) {
            var c2 = f2[a2];
            f2[a2] = function(...d2) {
              if (!f2[a2].D.hasOwnProperty(d2.length))
                throw new Q3(`Function '${b2}' called with an invalid number of arguments (${d2.length}) - expects one of (${f2[a2].D})!`);
              return f2[a2].D[d2.length].apply(this, d2);
            };
            f2[a2].D = [];
            f2[a2].D[c2.G] = c2;
          }
        }, Ia = (a2, b2, c2) => {
          if (f2.hasOwnProperty(a2)) {
            if (void 0 === c2 || void 0 !== f2[a2].D && void 0 !== f2[a2].D[c2])
              throw new Q3(`Cannot register public name '${a2}' twice`);
            Ha(a2, a2);
            if (f2.hasOwnProperty(c2))
              throw new Q3(`Cannot register multiple overloads of a function with the same number of arguments (${c2})!`);
            f2[a2].D[c2] = b2;
          } else
            f2[a2] = b2, void 0 !== c2 && (f2[a2].J = c2);
        }, Ja = (a2, b2) => {
          for (var c2 = [], d2 = 0; d2 < a2; d2++)
            c2.push(E3[b2 + 4 * d2 >> 2]);
          return c2;
        }, Ka, La = (a2, b2, c2 = []) => {
          a2.includes("j") ? (a2 = a2.replace(/p/g, "i"), b2 = (0, f2["dynCall_" + a2])(b2, ...c2)) : b2 = Ka.get(b2)(...c2);
          return b2;
        }, Pa = (a2, b2) => (...c2) => La(a2, b2, c2), Qa = (a2, b2) => {
          a2 = L2(a2);
          var c2 = a2.includes("j") ? Pa(a2, b2) : Ka.get(b2);
          if ("function" != typeof c2)
            throw new Q3(`unknown function pointer with signature ${a2}: ${b2}`);
          return c2;
        }, Ra, Ta = (a2) => {
          a2 = Sa(a2);
          var b2 = L2(a2);
          W2(a2);
          return b2;
        }, Ua = (a2, b2) => {
          function c2(h2) {
            e2[h2] || O2[h2] || (P2[h2] ? P2[h2].forEach(c2) : (d2.push(h2), e2[h2] = true));
          }
          var d2 = [], e2 = {};
          b2.forEach(c2);
          throw new Ra(`${a2}: ` + d2.map(Ta).join([", "]));
        }, Va = (a2) => {
          a2 = a2.trim();
          const b2 = a2.indexOf("(");
          return -1 !== b2 ? a2.substr(0, b2) : a2;
        }, Wa = (a2, b2, c2) => {
          switch (b2) {
            case 1:
              return c2 ? (d2) => x2[d2] : (d2) => z2[d2];
            case 2:
              return c2 ? (d2) => A3[d2 >> 1] : (d2) => B3[d2 >> 1];
            case 4:
              return c2 ? (d2) => D3[d2 >> 2] : (d2) => E3[d2 >> 2];
            default:
              throw new TypeError(`invalid integer width (${b2}): ${a2}`);
          }
        }, Xa = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, Ya = (a2, b2) => {
          var c2 = z2, d2 = a2 + b2;
          for (b2 = a2; c2[b2] && !(b2 >= d2); )
            ++b2;
          if (16 < b2 - a2 && c2.buffer && Xa)
            return Xa.decode(c2.subarray(a2, b2));
          for (d2 = ""; a2 < b2; ) {
            var e2 = c2[a2++];
            if (e2 & 128) {
              var h2 = c2[a2++] & 63;
              if (192 == (e2 & 224))
                d2 += String.fromCharCode((e2 & 31) << 6 | h2);
              else {
                var l2 = c2[a2++] & 63;
                e2 = 224 == (e2 & 240) ? (e2 & 15) << 12 | h2 << 6 | l2 : (e2 & 7) << 18 | h2 << 12 | l2 << 6 | c2[a2++] & 63;
                65536 > e2 ? d2 += String.fromCharCode(e2) : (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023));
              }
            } else
              d2 += String.fromCharCode(e2);
          }
          return d2;
        }, Za = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, $a = (a2, b2) => {
          var c2 = a2 >> 1;
          for (var d2 = c2 + b2 / 2; !(c2 >= d2) && B3[c2]; )
            ++c2;
          c2 <<= 1;
          if (32 < c2 - a2 && Za)
            return Za.decode(z2.subarray(a2, c2));
          c2 = "";
          for (d2 = 0; !(d2 >= b2 / 2); ++d2) {
            var e2 = A3[a2 + 2 * d2 >> 1];
            if (0 == e2)
              break;
            c2 += String.fromCharCode(e2);
          }
          return c2;
        }, ab = (a2, b2, c2) => {
          c2 ?? (c2 = 2147483647);
          if (2 > c2)
            return 0;
          c2 -= 2;
          var d2 = b2;
          c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
          for (var e2 = 0; e2 < c2; ++e2)
            A3[b2 >> 1] = a2.charCodeAt(e2), b2 += 2;
          A3[b2 >> 1] = 0;
          return b2 - d2;
        }, bb = (a2) => 2 * a2.length, cb = (a2, b2) => {
          for (var c2 = 0, d2 = ""; !(c2 >= b2 / 4); ) {
            var e2 = D3[a2 + 4 * c2 >> 2];
            if (0 == e2)
              break;
            ++c2;
            65536 <= e2 ? (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023)) : d2 += String.fromCharCode(e2);
          }
          return d2;
        }, db = (a2, b2, c2) => {
          c2 ?? (c2 = 2147483647);
          if (4 > c2)
            return 0;
          var d2 = b2;
          c2 = d2 + c2 - 4;
          for (var e2 = 0; e2 < a2.length; ++e2) {
            var h2 = a2.charCodeAt(e2);
            if (55296 <= h2 && 57343 >= h2) {
              var l2 = a2.charCodeAt(++e2);
              h2 = 65536 + ((h2 & 1023) << 10) | l2 & 1023;
            }
            D3[b2 >> 2] = h2;
            b2 += 4;
            if (b2 + 4 > c2)
              break;
          }
          D3[b2 >> 2] = 0;
          return b2 - d2;
        }, eb = (a2) => {
          for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
            var d2 = a2.charCodeAt(c2);
            55296 <= d2 && 57343 >= d2 && ++c2;
            b2 += 4;
          }
          return b2;
        }, gb = (a2) => {
          a2 = a2.getArg(X2.C, 0);
          return fb(a2);
        };
        f2.incrementExceptionRefcount = (a2) => {
          a2 = gb(a2);
          hb(a2);
        };
        f2.decrementExceptionRefcount = (a2) => {
          a2 = gb(a2);
          ib(a2);
        };
        f2.getExceptionMessage = (a2) => {
          var b2 = gb(a2);
          a2 = jb();
          var c2 = kb(4), d2 = kb(4);
          lb(b2, c2, d2);
          b2 = E3[c2 >> 2];
          d2 = E3[d2 >> 2];
          c2 = b2 ? Ya(b2) : "";
          W2(b2);
          if (d2) {
            var e2 = d2 ? Ya(d2) : "";
            W2(d2);
          }
          mb(a2);
          return [c2, e2];
        };
        for (var nb = Array(256), Y2 = 0; 256 > Y2; ++Y2)
          nb[Y2] = String.fromCharCode(Y2);
        wa = nb;
        Q3 = f2.BindingError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "BindingError";
          }
        };
        R2 = f2.InternalError = class extends Error {
          constructor(a2) {
            super(a2);
            this.name = "InternalError";
          }
        };
        U2.push(0, 1, void 0, 1, null, 1, true, 1, false, 1);
        f2.count_emval_handles = () => U2.length / 2 - 5 - T2.length;
        Ra = f2.UnboundTypeError = ((a2, b2) => {
          var c2 = Da(b2, function(d2) {
            this.name = b2;
            this.message = d2;
            d2 = Error(d2).stack;
            void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
          });
          c2.prototype = Object.create(a2.prototype);
          c2.prototype.constructor = c2;
          c2.prototype.toString = function() {
            return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;
          };
          return c2;
        })(Error, "UnboundTypeError");
        var pb = { l: () => {
          oa("");
        }, k: () => {
        }, i: (a2, b2, c2, d2) => {
          b2 = L2(b2);
          S2(a2, { name: b2, fromWireType: function(e2) {
            return !!e2;
          }, toWireType: function(e2, h2) {
            return h2 ? c2 : d2;
          }, argPackAdvance: 8, readValueFromPointer: function(e2) {
            return this.fromWireType(z2[e2]);
          }, F: null });
        }, h: (a2) => S2(a2, Ba), e: (a2, b2, c2) => {
          b2 = L2(b2);
          S2(a2, { name: b2, fromWireType: (d2) => d2, toWireType: (d2, e2) => e2, argPackAdvance: 8, readValueFromPointer: Ca(b2, c2), F: null });
        }, d: (a2, b2, c2, d2, e2, h2, l2) => {
          var k2 = Ja(b2, c2);
          a2 = L2(a2);
          a2 = Va(a2);
          e2 = Qa(d2, e2);
          Ia(a2, function() {
            Ua(`Cannot call ${a2} due to unbound types`, k2);
          }, b2 - 1);
          ya(
            k2,
            (g3) => {
              var m2 = a2;
              var n2 = a2;
              g3 = [g3[0], null].concat(g3.slice(1));
              var w3 = e2, p2 = g3.length;
              if (2 > p2)
                throw new Q3("argTypes array size mismatch! Must at least get return value and 'this' types!");
              var C3 = null !== g3[1] && false, M2 = Fa(g3), Ma = "void" !== g3[0].name;
              w3 = [n2, xa, w3, h2, Ea, g3[0], g3[1]];
              for (var v2 = 0; v2 < p2 - 2; ++v2)
                w3.push(g3[v2 + 2]);
              if (!M2)
                for (v2 = C3 ? 1 : 2; v2 < g3.length; ++v2)
                  null !== g3[v2].F && w3.push(g3[v2].F);
              M2 = Fa(g3);
              v2 = g3.length;
              var y2 = "", G3 = "";
              for (p2 = 0; p2 < v2 - 2; ++p2)
                y2 += (0 !== p2 ? ", " : "") + "arg" + p2, G3 += (0 !== p2 ? ", " : "") + "arg" + p2 + "Wired";
              y2 = `
        return function (${y2}) {
        if (arguments.length !== ${v2 - 2}) {
          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${v2 - 2}');
        }`;
              M2 && (y2 += "var destructors = [];\n");
              var Na = M2 ? "destructors" : "null", fa = "humanName throwBindingError invoker fn runDestructors retType classParam".split(" ");
              C3 && (y2 += "var thisWired = classParam['toWireType'](" + Na + ", this);\n");
              for (p2 = 0; p2 < v2 - 2; ++p2)
                y2 += "var arg" + p2 + "Wired = argType" + p2 + "['toWireType'](" + Na + ", arg" + p2 + ");\n", fa.push("argType" + p2);
              C3 && (G3 = "thisWired" + (0 < G3.length ? ", " : "") + G3);
              y2 += (Ma || l2 ? "var rv = " : "") + "invoker(fn" + (0 < G3.length ? ", " : "") + G3 + ");\n";
              if (M2)
                y2 += "runDestructors(destructors);\n";
              else
                for (p2 = C3 ? 1 : 2; p2 < g3.length; ++p2)
                  C3 = 1 === p2 ? "thisWired" : "arg" + (p2 - 2) + "Wired", null !== g3[p2].F && (y2 += `${C3}_dtor(${C3});
`, fa.push(`${C3}_dtor`));
              Ma && (y2 += "var ret = retType['fromWireType'](rv);\nreturn ret;\n");
              let [Oa, qb] = [fa, y2 + "}\n"];
              Oa.push(qb);
              g3 = Ga(Oa)(...w3);
              n2 = Da(n2, g3);
              g3 = b2 - 1;
              if (!f2.hasOwnProperty(m2))
                throw new R2("Replacing nonexistent public symbol");
              void 0 !== f2[m2].D && void 0 !== g3 ? f2[m2].D[g3] = n2 : (f2[m2] = n2, f2[m2].G = g3);
              return [];
            }
          );
        }, b: (a2, b2, c2, d2, e2) => {
          b2 = L2(b2);
          -1 === e2 && (e2 = 4294967295);
          e2 = (k2) => k2;
          if (0 === d2) {
            var h2 = 32 - 8 * c2;
            e2 = (k2) => k2 << h2 >>> h2;
          }
          var l2 = b2.includes("unsigned") ? function(k2, g3) {
            return g3 >>> 0;
          } : function(k2, g3) {
            return g3;
          };
          S2(a2, { name: b2, fromWireType: e2, toWireType: l2, argPackAdvance: 8, readValueFromPointer: Wa(b2, c2, 0 !== d2), F: null });
        }, a: (a2, b2, c2) => {
          function d2(h2) {
            return new e2(x2.buffer, E3[h2 + 4 >> 2], E3[h2 >> 2]);
          }
          var e2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b2];
          c2 = L2(c2);
          S2(a2, {
            name: c2,
            fromWireType: d2,
            argPackAdvance: 8,
            readValueFromPointer: d2
          }, { H: true });
        }, f: (a2, b2) => {
          b2 = L2(b2);
          var c2 = "std::string" === b2;
          S2(a2, { name: b2, fromWireType: function(d2) {
            var e2 = E3[d2 >> 2], h2 = d2 + 4;
            if (c2)
              for (var l2 = h2, k2 = 0; k2 <= e2; ++k2) {
                var g3 = h2 + k2;
                if (k2 == e2 || 0 == z2[g3]) {
                  l2 = l2 ? Ya(l2, g3 - l2) : "";
                  if (void 0 === m2)
                    var m2 = l2;
                  else
                    m2 += String.fromCharCode(0), m2 += l2;
                  l2 = g3 + 1;
                }
              }
            else {
              m2 = Array(e2);
              for (k2 = 0; k2 < e2; ++k2)
                m2[k2] = String.fromCharCode(z2[h2 + k2]);
              m2 = m2.join("");
            }
            W2(d2);
            return m2;
          }, toWireType: function(d2, e2) {
            e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2));
            var h2, l2 = "string" == typeof e2;
            if (!(l2 || e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray || e2 instanceof Int8Array))
              throw new Q3("Cannot pass non-string to std::string");
            var k2;
            if (c2 && l2)
              for (h2 = k2 = 0; h2 < e2.length; ++h2) {
                var g3 = e2.charCodeAt(h2);
                127 >= g3 ? k2++ : 2047 >= g3 ? k2 += 2 : 55296 <= g3 && 57343 >= g3 ? (k2 += 4, ++h2) : k2 += 3;
              }
            else
              k2 = e2.length;
            h2 = k2;
            k2 = ob(4 + h2 + 1);
            g3 = k2 + 4;
            E3[k2 >> 2] = h2;
            if (c2 && l2) {
              if (l2 = g3, g3 = h2 + 1, h2 = z2, 0 < g3) {
                g3 = l2 + g3 - 1;
                for (var m2 = 0; m2 < e2.length; ++m2) {
                  var n2 = e2.charCodeAt(m2);
                  if (55296 <= n2 && 57343 >= n2) {
                    var w3 = e2.charCodeAt(++m2);
                    n2 = 65536 + ((n2 & 1023) << 10) | w3 & 1023;
                  }
                  if (127 >= n2) {
                    if (l2 >= g3)
                      break;
                    h2[l2++] = n2;
                  } else {
                    if (2047 >= n2) {
                      if (l2 + 1 >= g3)
                        break;
                      h2[l2++] = 192 | n2 >> 6;
                    } else {
                      if (65535 >= n2) {
                        if (l2 + 2 >= g3)
                          break;
                        h2[l2++] = 224 | n2 >> 12;
                      } else {
                        if (l2 + 3 >= g3)
                          break;
                        h2[l2++] = 240 | n2 >> 18;
                        h2[l2++] = 128 | n2 >> 12 & 63;
                      }
                      h2[l2++] = 128 | n2 >> 6 & 63;
                    }
                    h2[l2++] = 128 | n2 & 63;
                  }
                }
                h2[l2] = 0;
              }
            } else if (l2)
              for (l2 = 0; l2 < h2; ++l2) {
                m2 = e2.charCodeAt(l2);
                if (255 < m2)
                  throw W2(g3), new Q3("String has UTF-16 code units that do not fit in 8 bits");
                z2[g3 + l2] = m2;
              }
            else
              for (l2 = 0; l2 < h2; ++l2)
                z2[g3 + l2] = e2[l2];
            null !== d2 && d2.push(W2, k2);
            return k2;
          }, argPackAdvance: 8, readValueFromPointer: V2, F(d2) {
            W2(d2);
          } });
        }, c: (a2, b2, c2) => {
          c2 = L2(c2);
          if (2 === b2) {
            var d2 = $a;
            var e2 = ab;
            var h2 = bb;
            var l2 = (k2) => B3[k2 >> 1];
          } else
            4 === b2 && (d2 = cb, e2 = db, h2 = eb, l2 = (k2) => E3[k2 >> 2]);
          S2(a2, { name: c2, fromWireType: (k2) => {
            for (var g3 = E3[k2 >> 2], m2, n2 = k2 + 4, w3 = 0; w3 <= g3; ++w3) {
              var p2 = k2 + 4 + w3 * b2;
              if (w3 == g3 || 0 == l2(p2))
                n2 = d2(n2, p2 - n2), void 0 === m2 ? m2 = n2 : (m2 += String.fromCharCode(0), m2 += n2), n2 = p2 + b2;
            }
            W2(k2);
            return m2;
          }, toWireType: (k2, g3) => {
            if ("string" != typeof g3)
              throw new Q3(`Cannot pass non-string to C++ string type ${c2}`);
            var m2 = h2(g3), n2 = ob(4 + m2 + b2);
            E3[n2 >> 2] = m2 / b2;
            e2(g3, n2 + 4, m2 + b2);
            null !== k2 && k2.push(W2, n2);
            return n2;
          }, argPackAdvance: 8, readValueFromPointer: V2, F(k2) {
            W2(k2);
          } });
        }, j: (a2, b2) => {
          b2 = L2(b2);
          S2(a2, {
            I: true,
            name: b2,
            argPackAdvance: 0,
            fromWireType: () => {
            },
            toWireType: () => {
            }
          });
        }, n: (a2, b2, c2) => z2.copyWithin(a2, b2, b2 + c2), g: (a2, b2) => {
          var c2 = O2[a2];
          if (void 0 === c2)
            throw a2 = `${"_emval_take_value"} has unknown type ${Ta(a2)}`, new Q3(a2);
          a2 = c2;
          a2 = a2.readValueFromPointer(b2);
          return Aa(a2);
        }, m: (a2) => {
          var b2 = z2.length;
          a2 >>>= 0;
          if (2147483648 < a2)
            return false;
          for (var c2 = 1; 4 >= c2; c2 *= 2) {
            var d2 = b2 * (1 + 0.2 / c2);
            d2 = Math.min(d2, a2 + 100663296);
            var e2 = Math;
            d2 = Math.max(a2, d2);
            a: {
              e2 = (e2.min.call(e2, 2147483648, d2 + (65536 - d2 % 65536) % 65536) - u2.buffer.byteLength + 65535) / 65536;
              try {
                u2.grow(e2);
                ia();
                var h2 = 1;
                break a;
              } catch (l2) {
              }
              h2 = void 0;
            }
            if (h2)
              return true;
          }
          return false;
        } }, X2 = function() {
          function a2(c2) {
            X2 = c2.exports;
            u2 = X2.o;
            ia();
            Ka = X2.t;
            ka.unshift(X2.p);
            F2--;
            f2.monitorRunDependencies?.(F2);
            0 == F2 && (null !== H2 && (clearInterval(H2), H2 = null), I3 && (c2 = I3, I3 = null, c2()));
            return X2;
          }
          var b2 = { a: pb };
          F2++;
          f2.monitorRunDependencies?.(F2);
          if (f2.instantiateWasm)
            try {
              return f2.instantiateWasm(b2, a2);
            } catch (c2) {
              r2(`Module.instantiateWasm callback failed with error: ${c2}`), q2(c2);
            }
          J2 || (J2 = qa("zstd_codec.wasm") ? "zstd_codec.wasm" : f2.locateFile ? f2.locateFile("zstd_codec.wasm", "") : "zstd_codec.wasm");
          va(b2, function(c2) {
            a2(c2.instance);
          }).catch(q2);
          return {};
        }(), ob = (a2) => (ob = X2.q)(a2), W2 = (a2) => (W2 = X2.r)(a2), Sa = (a2) => (Sa = X2.s)(a2), pa = () => (pa = X2.u)(), mb = (a2) => (mb = X2.v)(a2), kb = (a2) => (kb = X2.w)(a2), jb = () => (jb = X2.x)(), ib = (a2) => (ib = X2.y)(a2), hb = (a2) => (hb = X2.z)(a2), fb = (a2) => (fb = X2.A)(a2), lb = (a2, b2, c2) => (lb = X2.B)(a2, b2, c2), Z2;
        I3 = function rb() {
          Z2 || sb();
          Z2 || (I3 = rb);
        };
        function sb() {
          function a2() {
            if (!Z2 && (Z2 = true, f2.calledRun = true, !da)) {
              ma = true;
              K2(ka);
              aa(f2);
              f2.onRuntimeInitialized?.();
              if (f2.postRun)
                for ("function" == typeof f2.postRun && (f2.postRun = [f2.postRun]); f2.postRun.length; ) {
                  var b2 = f2.postRun.shift();
                  la.unshift(b2);
                }
              K2(la);
            }
          }
          if (!(0 < F2)) {
            if (f2.preRun)
              for ("function" == typeof f2.preRun && (f2.preRun = [f2.preRun]); f2.preRun.length; )
                na();
            K2(ja);
            0 < F2 || (f2.setStatus ? (f2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                f2.setStatus("");
              }, 1);
              a2();
            }, 1)) : a2());
          }
        }
        if (f2.preInit)
          for ("function" == typeof f2.preInit && (f2.preInit = [f2.preInit]); 0 < f2.preInit.length; )
            f2.preInit.pop()();
        sb();
        moduleRtn = ba;
        return moduleRtn;
      };
    })();
    zstd_codec_default = zstd_codec;
    zstd_codec_default2 = __toBinary("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IAdBgBNyIgg7AAULIAIhBANAIAQgBUYiB0UEQCAEKAIAIARBBGohBC8ABUGAGHFBgAhGDQELCyAHBEAgBiAIQf9ncUGACHIiCDsABQsDQCACIAVGIgRFBEAgAigCACACQQRqIQIvAAVBwAFxQcAARg0BCwsgBARAIAYgCEG//gNxQcAAcjsABQsgAyAGNgIUCyAMIANBFGoQHwwBCyADIAAQTCICNgIMIAJFDQMgCiADQQxqEB8LIABB0QAQEUUNAAsgAyAAEJkBIgE2AhxBACECIAFFDQIgAEHFABARRQ0CCyADQQxqIAAgCxAnIABBmANqQRQQEiADKQIMIQ4gAygCHCEBQStBAEEBQQFBARAWIgIgATYCECACIA43AgggAkGs0AE2AgAMAQtBACECCyADQSBqJAAgAgsTACAAQZgDakEQEBIgASkCABBICyIAIABBCEEAQQFBAUEBEBYiACABNwIIIABBqJgBNgIAIAALzQEBBH8jAEEwayIBJAAgAUEANgIsAkAgACABQSxqEK8BDQAgASgCLCICQQFrIAAoAgAiBCAAKAIEEDpPDQAgAUEgaiAEIAIQKiEDIAAgACgCACACajYCACABIAMpAwA3AxggAUEQakHbGhAOIQIgASABKQMYNwMIIAEgAikCADcDACABQQhqIAEQmgEEQCMAQRBrIgIkACAAQZgDakEQEBIgAkEIakHfJBAOKQMAEEggAkEQaiQAIQMMAQsgACADEEchAwsgAUEwaiQAIAMLPwAgAEGYA2pBEBASIAEoAgAhASACKAIAIQJBLUEAQQFBAUEBEBYiACACNgIMIAAgATYCCCAAQZjRATYCACAACwsAIABCADcCACAAC60DAgV/AX4jAEEQayIDJAACQAJAAkACQAJAAkAgACgCACIBIAAoAgQiBEEAEBlBygBrQR93DggBAgQEBAMEAAQLIAAgAUEBajYCACAAEB0iAUUNBCABQQAgAEHFABARGyECDAQLIAAgAUEBajYCACAAQQhqIQEgACgCCCAAKAIMEB4hBANAIABBxQAQEUUEQCADIAAQTCIFNgIIIAVFDQUgASADQQhqEB8MAQsLIANBCGoiAiAAIAQQJyAAQZgDakEQEBIgAikCACEGQSlBAEEBQQFBARAWIgAgBjcCCCAAQYzSATYCACAAIQIMAwsgASAEQQEQGUHa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IgRB/wFxIgJrdjYAACABIAJBA3ZqIgUgByADIAtqLQAAQQJ0aigCACIGIAcgAyAKai0AAEECdGooAgAiAXYgAXIgByADIAhqLQAAQQJ0aigCACICdiAQIAIgASAGamoiAXZyIAJyIgZBICABIARBB3FqIgFB/wFxIgJrdjYAACABQQdxIQQgBSACQQN2aiEBIANBBksgA0EGayEDDQALCyABIAZBAXZBgICAgHhyQSAgBEH/////B2siAkEPcSIDa3Y2AAAgCSABIANBA3ZqIgEgASAJSxsiASAJTw0AIAJBB3FBAEcgAGsgAWohDAsgDAsEAEEBCw0AIAAgAUECdGooAgALGwAgASgCEEF/RgRAIAFBADYCDCABIAA2AhALCzABAX8gAC8ABSICQcABcUGAAUcEQCACQf8BcUHAAEkPCyAAIAEgACgCACgCABEBAAv6AQEFfyABIAIoAgQiBUYEfyACKAIAIQIjAEEQayIEJAAgBCABNgIMIAQgBTYCCAJAAn8CQAJAIARBCGoiAyAEQQxqIgYgAygCACAGKAIAELYBGygCACIDQQRPBEAgACACckEDcQ0BA0AgACgCACACKAIARw0CIAJBBGohAiAAQQRqIQAgA0EEayIDQQNLDQALCyADRQ0BCwNAIAAtAAAiBiACLQAAIgdGBEAgAkEBaiECIABBAWohACADQQFrIgMNAQwCCwsgBiAHawwBC0EACyIADQBBACEAIAEgBUYNAEF/QQEgASAFSRshAAsgBEEQaiQAIAAFQQELRQsNACAAKAIAIABBDGpGC+8DAQZ/AkAgAEUNACAAKAKQ6wENACAAKAKE6wEhBCAAKAKA6wEhAwJAIAAoApTrASIBRQ0AIAEoArjVASEFIAEoArTVASECAkACQCABKAIAIgYEQCACRQ0BIAUgBiACEQAAIAUgASACEQAADAMLIAJFDQEgBSABIAIRAAAMAgsgBhAVCyABEBULIABBADYCpOsBIABCADcClOsBAkAgACgCuOsBIgFFDQAgAwRAIAQgASADEQAADAELIAEQFQsgAEEANgK46wECQCAAKALc6wEiAUUNAAJAAkACQCAAKALg6wFBBWsOAwABAgMLIAEoAgAQFSABKAIwEBUgASgCPBAVIAEQFQwCCyABKAIAEBUgASgCHBAVIAEoAigQFSABEBUMAQsgASgC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NwMIIAAgAUEIahAaGiABIABBABC6AiIDNgIcIANFDQAgAyECIAAoAgAgACgCBEEAEBlByQBHDQAgASAAQQAQRiICNgIYIAIEfyAAIAFBHGogAUEYahBKBUEACyECCyABQTBqJAAgAguGAQECfyMAQRBrIgIkAAJAAkAgACgCACAAKAIEQQAQGSIBQcQARwRAIAFB/wFxQdQARw0BIAIgABCYASIBNgIMIAFFDQIgAEGUAWogAkEMahAfDAILIAIgABDmASIBNgIIIAFFDQEgAEGUAWogAkEIahAfDAELIAAQ4gEhAQsgAkEQaiQAIAELDwAgACAAKAIAIAFyNgIACzEBAX8gAEIANwIMIAAgAEEcajYCCCAAIABBDGoiATYCBCAAIAE2AgAgAEIANwIUIAALPwAgAEGYA2pBEBASIAEoAgAhASACKAIAIQJBGkEAQQFBAUEBEBYiACACNgIMIAAgATYCCCAAQdjOATYCACAACyIAIABBKkEAQQFBAUEBEBYiACABNgIIIABBrLgBNgIAIAALPwEBfwJAIAAgAUYNAANAIAAgAUEBayIBTw0BIAAtAAAhAiAAIAEtAAA6AAAgASACOgAAIABBAWohAAwACwALCxcAIABBMGtBCkkgAEEgckHhAGtBBklyCwkAIAAgARCjAgsEACAACykAIABBBUEAQQFBAUEBEBYiACACNwIMIAAgATYCCCAAQfzeATYCACAACxwAIAAgACgCACABajYCACAAIAAoAgQgAWs2AgQLRQEDfyMAIQEGQBBTIgIQuQEiAEHUkwE2AgAgAEEEakGKFBDwASAAQZiUATYCABkgASQAIAIQUgkACyAAQbiUAUELEFAACxYAIAAgASgCCCIAIAAoAgAoAhgRAAAL9wMBBn8jAEEQayIGJAACQCAAQcDpAWogASACIAAoAuzqARCbASIBQYh/Sw0AIAEEQEG4fyEBDAELAkAgACgCrOsBQQFHDQAgACgCqOsBIgNFDQAgACgCmOsBRQ0AIAYgACgC3OkBIgQ2AgwgAygCBEEBayIFIAZBDGpBBBDlAadxIQEgAygCACEDA0AgAyABQQJ0aigCACIHRQ0BIAQgBygCqNUBIghHBEAgASAFcUEBaiEBIAgNAQsLAkAgACgClOsBIgFFDQAgASgCuNUBIQQgASgCtNUBIQMCQAJAIAEoAgAi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ASABKAIMIA1qNgIMIAEoAgQhAyANQYCABEkNACABQQE2AiQgASADIAEoAgBrQQN1NgIoCyADIAk2AgAgAyANOwEEIAwhByAIIQwgCkEDayIFQYCABEkNAwwCCwJAIAUgGE8NACAALwAAIAUvAABHDQAgAEECaiEAIAVBAmohBQsgBSAUSQR/IAUgAC0AACAFLQAARmoFIAULIAhrCyEQIAQgA2shCSABKAIMIQUCQAJAIAQgEU0EQCADKQAAISAgBSADKQAINwAIIAUgIDcAACABKAIMIQYgCUEQTQRAIAEgBiAJajYCDCABKAIEIQMMAwsgAykAECEgIAYgAykAGDcAGCAGICA3ABAgCUEhSA0BIAYgCWohACADQRBqIQMgBkEgaiEFA0AgAykAECEgIAUgAykAGDcACCAFICA3AAAgAykAICEgIAUgAykAKDcAGCAFICA3ABAgA0EgaiEDIAVBIGoiBSAASQ0ACwwBCyADIBFNBEAgAykAACEgIAUgAykACDcACCAFICA3AAAgBSARIANrIghqIQAgCEERTgRAIAVBEGohBQNAIAMpABAhICAFIAMpABg3AAggBSAgNwAAIAMpACAhICAFIAMpACg3ABggBSAgNwAQIANBIGohAyAFQSBqIgUgAEkNAAsLIAAhBSARIQMLIAMgBE8NACAGIANrQQAhBiAEIANrQQdxIgAEQANAIAUgAy0AADoAACAFQQFqIQUgA0EBaiEDIAZBAWoiBiAARw0ACwtBB0kNAANAIAUgAy0AADoAACAFIAMtAAE6AAEgBSADLQACOgACIAUgAy0AAzoAAyAFIAMtAAQ6AAQgBSADLQAFOgAFIAUgAy0ABjoABiAFIAMtAAc6AAcgBUEIaiEFIANBCGoiAyAERw0ACwsgASABKAIMIAlqNgIMIAEoAgQhAyAJQYCABEkNACABQQE2AiQgASADIAEoAgBrQQN1NgIoCyAQQQRqIQogA0EBNgIAIAMgCTsBBCAMIQggEEEBaiIFQf//A00NAQsgAUECNgIkIAEgAyABKAIAa0EDdTYCKCAIIQwLIAMgBTsBBiABIANBCGoiADYCBAJAIAQgCmoiAyAXSw0AIBMgDiAPQQJqIgZqKQAAIiBC48iVvcub741PfiAjiKdBAnRqIAY2AgAgEyADQQJrIgQpAABC48iVvcub741PfiAj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IABB3wAQEUUNASAAIAIQlgIhAwwBCyABIAFBIGpB7RoQDikCADcDCCAAIAFBCGoQGkUNACABQShqIgIgAEEAECggASgCLEUNACAAQfAAEBFFDQAgABCXARogAiAAQQAQKCAAQd8AEBFFDQAgACACEJYCIQMLIAFBQGskACADC88OAgZ/AX4jAEGwAmsiASQAAkAgAEHMABARRQ0AAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAiAyAAKAIEIgRBABAZQf8BcUHBAGsOORMWFhQWFhYWFhYWFhYWFhYWFhYYFRYWFhYWFhYWFhIWAwECEBEPFgQHCBYJCg0OFhYWBQYWFgALDBYLIAAgA0EBajYCACABIAFBqAJqQYkMEA4pAgA3AwAgACABEDQhAgwXCyABIAFBoAJqQZEbEA4pAgA3AxAgACABQRBqEBoEQCABQQA2ApQBIAAgAUGUAWoQpQIhAgwXCyABIAFBmAJqQY0bEA4pAgA3AwggACABQQhqEBpFDRYgAUEBNgKUASAAIAFBlAFqEKUCIQIMFgsgACADQQFqNgIAIAEgAUGQAmpBzg8QDikCADcDGCAAIAFBGGoQNCECDBULIAAgA0EBajYCACABIAFBiAJqQccPEA4pAgA3AyAgACABQSBqEDQhAgwUCyAAIANBAWo2AgAgASABQYACakHFDxAOKQIANwMoIAAgAUEoahA0IQIMEwsgACADQQFqNgIAIAEgAUH4AWpB9woQDikCADcDMCAAIAFBMGoQNCECDBILIAAgA0EBajYCACABIAFB8AFqQe4KEA4pAgA3AzggACABQThqEDQhAgwRCyAAIANBAWo2AgAgASABQegBakHPKRAOKQIANwNAIAAgAUFAaxA0IQIMEAsgACADQQFqNgIAIAEgAUHgAWpBkwoQDikCADcDSCAAIAFByABqEDQhAgwPCyAAIANBAWo2AgAgASABQdgBakHIqAEQDikCADcDUCAAIAFB0ABqEDQhAgwOCyAAIANBAWo2AgAgASABQdABakGrERAOKQIANwNYIAAgAUHYAGoQNCECDA0LIAAgA0EBajYCACABIAFByAFqQckSEA4pAgA3A2AgACABQeAAahA0IQIMDAsgACADQQFqNgIAIAEgAUHAAWpBghIQDikC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AkEBayICDQALC0EAC38CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEOcCIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLpAUCBn4EfyABIAEoAgBBB2pBeHEiAUEQajYCACAAIAEpAwAhAiABKQMIIQcjAEEgayIIJAAgB0L///////8/gyEEAn4gB0IwiEL//wGDIgOnIgpBgfgAa0H9D00EQCAEQgSGIAJCPIiEIQMgCkGA+ABrrSEEAkAgAkL//////////w+DIgJCgYCAgICAgIAIWgRAIANCAXwhAwwBCyACQoCAgICAgICACFINACADQgGDIAN8IQMLQgAgAyADQv////////8HViIAGyECIACtIAR8DAELIAIgBIRQIANC//8BUnJFBEAgBEIEhiACQjyIhEKAgICAgICABIQhAkL/DwwBCyAKQf6HAUsEQEIAIQJC/w8MAQtBgPgAQYH4ACADUCIBGyIAIAprIglB8ABKBEBCACECQgAMAQsgAiEDIAQgBEKAgICAgIDAAIQgARsiBSEGAkBBgAEgCWsiAUHAAHEEQCACIAFBQGqthiEGQgAhAwwBCyABRQ0AIAYgAa0iBIYgA0HAACABa62IhCEGIAMgBIYhAwsgCCADNwMQIAggBjcDGAJAIAlBwABxBEAgBSAJQUBqrYghAkIAIQUMAQsgCUUNACAFQcAAIAlrrYYgAiAJrSIDiIQhAiAFIAOIIQULIAggAjcDACAIIAU3AwggCCkDCEIEhiAIKQMAIgNCPIiEIQICQCAAIApHIAgpAxAgCCkDGIRCAFJxrSADQv//////////D4OEIgNCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyADQoCAgICAgICACFINACACQgGDIAJ8IQILIAJCgICAgICAgAiFIAIgAkL/////////B1YiABshAiAArQshAyAIQSBqJAAgB0KAgICAgICAgIB/gyADQjSGhCAChL85AwAL+RcDEn8BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIZQgBTBEBBASERQboJIRMgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEUG9CSETDAELQcAJ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QCAIIQ0MAQsgCCANTw0AIA0gCGshBAJAIAtFDQBBACEBIAtBBE8EQCALQXxxIQoDQCABIAdqIgIgBEEAIAItAAAiDBsgDGo6AAAgAiAEQQAgAi0AASIMGyAMajoAASACIARBACACLQACIgwbIAxqOgACIAIgBEEAIAItAAMiAhsgAmo6AAMgAUEEaiIBIApHDQALCyALQQNxIgJFDQADQCABIAdqIgogBEEAIAotAAAiChsgCmo6AAAgAUEBaiEBIAVBAWoiBSACRw0ACwsCQCAEIA1PDQAgDSEBIAhBA3EiBQRAQQAhAgNAIAMgAUECdGogAyABIARrQQJ0aigCADYCACABQQFrIQEgAkEBaiICIAVHDQALCyAIQQFrQQNJDQADQCADIAFBAnRqIAMgASAEa0ECdGooAgA2AgAgAyABQQFrIgJBAnRqIAMgAiAEa0ECdGooAgA2AgAgAyABQQJrIgJBAnRqIAMgAiAEa0ECdGooAgA2AgAgAyABQQNrIgJBAnRqIAMgAiAEa0ECdGooAgA2AgAgAUEEayIBIARLDQALCyADQQRqQQAgBEECdBAYGgtBVCANIAZBAWpLDQEaIAAgCUH/gYB4cSANQRB0QYCA/AdxcjYCACANQQFqIhFBA3EhB0EAIQVBACECQQAhASANQQNPBEAgEUF8cSEGIANBNGohCANAIAMgAkECdCIEaigCACEJIAQgCGogATYCACADIARBBHIiCmooAgAhDCAIIApqIAEgCWoiATYCACADIARBCHIiCWooAgAhCiAIIAlqIAEgDGoiATYCACADIARBDHIiBGooAgAhCSAEIAhqIAEgCmoiATYCACABIAlqIQEgAkEEaiICIAZHDQALCyAHBEADQCADIAJBAnRqIgggATYCNCACQQFqIQIgCCgCACABaiEBIAVBAWoiBSAHRw0ACwtBACECIAtBA0oEQCALQQNrIQQgA0E0aiEBIANB1AlqIQggA0HUB2ohBQNAIAEgAiAIai0AAEECdGoiByAHKAIAIgdBAWo2AgAgBSAHaiACOgAAIAEgCCACQQFyIgdqLQAAQQJ0aiIGIAYoAgAiBkEBajYCACAFIAZqIAc6AAAgASAIIAJBAnIiB2otAABBAnRqIgYgBigCACIGQQFqNgIAIAUgBmogBzoAACABIAggAkEDciIHai0AAEECdGoi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Sw0AIANBIGogFyACa00NAQsgCCAIKAJ4NgIQIAggCCkDcDcDCCACIBcgCEEIaiAIQewAaiALIBAgFSATEFYhAwwBCyACIAdqIQEgBSkAACEoIAIgBSkACDcACCACICg3AAACQCAHQRFJDQAgBSkAECEoIAIgBSkAGDcAGCACICg3ABAgB0EQa0ERSA0AIAVBEGohByACQSBqIQUDQCAHKQAQISggBSAHKQAYNwAIIAUgKDcAACAHKQAgISggBSAHKQAoNwAYIAUgKDcAECAHQSBqIQcgBUEgaiIFIAFJDQALCyABIABrIQcgCCAGNgJsIAEgEGsgAEkEQCABIBVrIABJBEBBbCEDDAYLIBMgEyAHIBBrIgVqIgYgBGpPBEAgASAGIAQQHBoMAgsgASAGQQAgBWsQHCAIIAQgBWoiBDYCdCAQIQcgBWshAQsgAEEQTwRAIAcpAAAhKCABIAcpAAg3AAggASAoNwAAIARBEUgNASABIARqIQAgAUEQaiEBA0AgBykAECEoIAEgBykAGDcACCABICg3AAAgBykAICEoIAEgBykAKDcAGCABICg3ABAgB0EgaiEHIAFBIGoiASAASQ0ACwwBCwJAIABBB00EQCABIActAAA6AAAgASAHLQABOgABIAEgBy0AAjoAAiABIActAAM6AAMgASAHIABBAnQiAEHgiwFqKAIAaiIEKAAANgAEIAQgAEGAjAFqKAIAayEHDAELIAEgBykAADcAAAsgCCgCdCIAQQlJDQAgACABaiEFIAFBCGoiBCAHQQhqIgdrQQ9MBEADQCAEIAcpAAA3AAAgB0EIaiEHIARBCGoiBCAFSQ0ADAILAAsgBykAACEoIAQgBykACDcACCAEICg3AAAgAEEZSA0AIAFBGGohAQNAIAcpABAhKCABIAcpABg3AAggASAoNwAAIAcpACAhKCABIAcpACg3ABggASAoNwAQIAdBIGohByABQSBqIgEgBUkNAAsLIANBiH9LDQMgAiADaiECIA9BAWsiD0UNASAIKAI4IgFBIEsNACAIKAI8IgMgCCgCRE8EQCAIIAFBB3EiADYCOCAIIAMgAUEDdmsiATYCPCAIIAEoAAA2AjQgACEBDAELIAMgCCgCQCIARg0AIAggASADIABrIAFBA3YiASADIAFrIABJGyIAQQN0ayIBNgI4IAggAyAAayIA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IApBjAJqIBcgDiAYIBYQViEGDAELIAQgGWohCyAEIAlqIQMgEygCCCECIBkpAAAhKCAJIBkpAAg3AAggCSAoNwAAAkAgBEERSQ0AIAwpAAAhKCAJIAwpAAg3ABggCSAoNwAQIARBEGtBEUgNACAJQSBqIQQgDCEVA0AgFSkAECEoIAQgFSkAGDcACCAEICg3AAAgFSkAICEoIAQgFSkAKDcAGCAEICg3ABAgFUEgaiEVIARBIGoiBCADSQ0ACwsgAyACayEEIAogCzYCjAIgAyAOayACSQRAIAIgAyAYa0sNCSAWIBYgBCAOayIEaiILIBJqTwRAIAMgCyASEBwaDAILIAQgEmohEiADIAtBACAEaxAcIARrIQMgDiEECyACQRBPBEAgBCkAACEoIAMgBCkACDcACCADICg3AAAgEkERSA0BIAMgEmohAiADQRBqIQMDQCAEKQAQISggAyAEKQAYNwAIIAMgKDcAACAEKQAgISggAyAEKQAoNwAYIAMgKDcAECAEQSBqIQQgA0EgaiIDIAJJDQALDAELAkAgAkEHTQRAIAMgBC0AADoAACADIAQtAAE6AAEgAyAELQACOgACIAMgBC0AAzoAAyADIAQgAkECdCICQeCLAWooAgBqIgQoAAA2AAQgBCACQYCMAWooAgBrIQQMAQsgAyAEKQAANwAACyASQQlJDQAgAyASaiELIANBCGoiAiAEQQhqIgRrQQ9MBEADQCACIAQpAAA3AAAgBEEIaiEEIAJBCGoiAiALSQ0ADAILAAsgBCkAACEoIAIgBCkACDcACCACICg3AAAgEkEZSA0AIANBGGohAwNAIAQpABAhKCADIAQpABg3AAggAyAoNwAAIAQpACAhKCADIAQpACg3ABggAyAoNwAQIARBIGohBCADQSBqIgMgC0kNAAsLIAZBiH9LBEAgBiENDAgLIBMgBzYCCCATIBQ2AgQgEyAPNgIAIA8gHWohBCAXIQggBiAJagwDCyAVQSBrIQYCQAJAIAggFUkNACACIBMoAgQiCyAEaiIJaiAGSw0AIAlBIGogGiACa00NAQsgCiATKAIINgJQIAogEykCADcDSCACIBogBiAKQcgAaiAKQYwCaiAIIA4gGCAWEPIBIQkMAgsgAiAEaiESIBMoAgghBiADKQAAISggAiADKQAINwAIIAIgKDcAAAJAIARBEUkNACADKQAQISggAiADKQAYNwAYIAIgKDcAECAEQRBrQRFIDQAgA0EQaiEEIAJBIGohAwNAIAQpABAhKCADIAQpABg3AAggAyAoNwAAIAQpACAhKCADIAQpACg3ABggAyAoNwAQIARBIGohBCADQSBqIgMgEkkNAAsLIBIgBmshBCAKIBU2AowCIBIgDmsgBkkEQCAGIBIgGGtLDQcgFiAWIAQgDmsiA2oiBCALak8EQCASIAQgCxAcGgwDCyADIAtqIQsgEiAEQQAgA2sQHCADayESIA4hBAsgBkEQTwRAIAQpAAAhKCASIAQpAAg3AAggEiAoNwAAIAtBEUgNAiALIBJqIQYgEkEQaiEDA0AgBCkAECEoIAMgBCkAGDcACCADICg3AAAgBCkAICEoIAMgBCkAKDcAGCADICg3ABAgBEEgaiEEIANBIGoiAyAGSQ0ACwwCCwJAIAZBB00EQCASIAQtAAA6AAAgEiAELQABOgABIBIgBC0AAjoAAiASIAQtAAM6AAMgEiAEIAZBAnQiA0HgiwFqKAIAaiIEKAAANgAEIAQgA0GAjAFqKAIAayEEDAELIBIgBCkAADcAAAsgC0EJSQ0BIAsgEmohBiASQQhqIgMgBEEIaiIEa0EPTARAA0AgAyAEKQAANwAAIARBCGohBCADQQhqIgMgBkkNAAwDCwALIAQpAAAhKCADIAQpAAg3AAggAyAoNwAAIAtBGUgNASASQRhqIQMDQCAEKQAQISggAyAEKQAYNwAIIAMgKDcAACAEKQAgISggAyAEKQAoNwAYIAMgKDcAECAEQSBqIQQgA0EgaiIDIAZJDQALDAELAkACQCAKKAKMAiIEIApBoAFqIBFBB3FBDGxqIgYoAgAiC2oiFSAISw0AIAIgBigCBCITIAtqIglqIBxLDQAgCUEgaiAaIAJrTQ0BCyAKIAYoAgg2AmAgCiAGKQIANwNYIAIgGiAKQdgAaiAKQYwCaiAIIA4gGCAWEFYhCQwBCyACIAtqIQMgBigCCCEGIAQpAAAhKCACIAQpAAg3AAggAiAoNwAAAkAgC0ERSQ0AIAQpABAhKCACIAQpABg3ABggAiAoNwAQIAtBEGtBEUgNACAEQRBqIQQgAkEgaiESA0AgBCkAECEoIBIgBCkAGDcACCASICg3AAAgBCkAICEoIBIgBCkAKDcAGCASICg3ABAgBEEgaiEEIBJBIGoiEiADSQ0ACwsgAyAGayEEIAogFTYCjAIgAyAOayAGSQRAIAYgAyAYa0sNBiAWIBYgBCAOayIEaiILIBNqTwRAIAMgCyATEBwaDAILIAQgE2ohEyADIAtBACAEaxAcIARrIQMgDiEECyAGQRBPBEAgBCkAACEoIAMgBCkACDcACCADICg3AAAgE0ERSA0BIAMgE2ohBiADQRBqIQMDQCAEKQAQISggAyAEKQAYNwAIIAMgKDcAACAEKQAgISggAyAEKQAoNwAYIAMgKDcAECAEQSBqIQQgA0EgaiIDIAZJDQALDAELAkAgBkEHTQRAIAMgBC0AADoAACADIAQtAAE6AAEgAyAELQACOgACIAMgBC0AAzoAAyADIAQgBkECdCIGQeCLAWooAgBqIgQoAAA2AAQgBCAGQYCMAWooAgBrIQQMAQsgAyAEKQAANwAACyATQQlJDQAgAyATaiELIANBCGoiBiAEQQhqIgRrQQ9MBEADQCAGIAQpAAA3AAAgBEEIaiEEIAZBCGoiBiALSQ0ADAILAAsgBCkAACEoIAYgBCkACDcACCAGICg3AAAgE0EZSA0AIANBGGohAwNAIAQpABAhKCADIAQpABg3AAggAyAoNwAAIAQpACAhKCADIAQpACg3ABggAyAoNwAQIARBIGohBCADQSBqIgMgC0kNAAsLIAlBiH9LBEAgCSENDAULIApBoAFqIBFBB3FBDGxqIgMgBzYCCCADIBQ2AgQgAyAPNgIAIA8gHWohBCACIAlqCyECIBFBAWohESAEIBRqIR0gCigCbCEDDAELCyAFIBEgHmsiCUoEQANAIApBoAFqIAlBB3FBDGxqIQsCfwJAIAAoAojsAUECRgRAIAooAowCIgMgCygCACIEaiIRIAAoAoTsASIGSwRAAkAgAyAGRgRAIAIhDwwBCyAGIANrIhEgGiACa0sEQEG6fyENDAkLIAIgEWohDwJAIAIgA2siBEF4TCARQQdKcUUEQCARQQBMDQEDQCACIAMtAAA6AAAgA0EBaiEDIAJBAWoiAiAPSQ0ACwwBCyACIAZqAn8gBEFvSwRAIAIhECADIQQgAgwBCyACIRAgAyEEIAIgD0EgayIHIAJJDQAaIAMpAAAhKCACIAMpAAg3AAggAiAoNwAAIAcgAmsiEEERTgRAIAJBEGohBCADIQYDQCAGKQAQISggBCAGKQAYNwAIIAQgKDcAACAGKQAgISggBCAGKQAoNwAYIAQgKDcAECAGQSBqIQYgBEEgaiIEIAdJDQALCyADIBBqIQQgByIQCyIHIANqQX9zakEAIQYgECEDIAIgEWogB2siAkEHcSIHBEADQCADIAQtAAA6AAAgA0EBaiEDIARBAWohBCAGQQFqIgYgB0cNAAsLQQdJDQAgAiAQaiECA0AgAyAELQAAOgAAIAMgBC0AAToAASADIAQtAAI6AAIgAyAELQADOgADIAMgBC0ABDoABCADIAQtAAU6AAUgAyAELQAGOgAGIAMgBC0ABzoAByAEQQhqIQQgA0EIaiIDIAJHDQALCyALIAsoAgAgEWsiBDYCAAsgCiAZNgKMAiAAQQA2AojsAQJAAkACQCAEQYCABEoNACAPIAsoAgQiFCAEaiIGaiAcSw0AIAZBIGogGiAPa00NAQsgCiALKAIINgIQIAogCykCADcDCCAPIBogCkEIaiAKQYwCaiAXIA4gGCAWEFYhBgwBCyAEIBlqIQcgBCAPaiEDIAsoAgghAiAZKQAAISggDyAZKQAINwAIIA8gKDcAAAJAIARBEUkNACAMKQAAISggDyAMKQAINwAYIA8gKDcAECAEQRBrQRFIDQAgD0EgaiEEIAwhEQNAIBEpABAhKCAEIBEpABg3AAggBCAoNwAAIBEpACAhKCAEIBEpACg3ABggBCAoNwAQIBFBIGohESAEQSBqIgQgA0kNAAsLIAMgAmshBCAKIAc2AowCIAMgDmsgAkkEQCACIAMgGGtLDQkgFiAWIAQgDmsiBGoiByAUak8EQCADIAcgFBAcGgwCCyAEIBRqIRQgAyAHQQAgBGsQHCAEayEDIA4hBAsgAkEQTwRAIAQpAAAhKCADIAQpAAg3AAggAyAoNwAAIBRBEUgNASADIBRqIQIgA0EQaiEDA0AgBCkAECEoIAMgBCkAGDcACCADICg3AAAgBCkAICEoIAMgBCkAKDcAGCADICg3ABAgBEEgaiEEIANBIGoiAyACSQ0ACwwBCwJAIAJBB00EQCADIAQtAAA6AAAgAyAELQABOgABIAMgBC0AAjoAAiADIAQtAAM6AAMgAyAEIAJBAnQiAkHgiwFqKAIAaiIEKAAANgAEIAQgAkGAjAFqKAIAayEEDAELIAMgBCkAADcAAAsgFEEJSQ0AIAMgFGohByADQQhqIgIgBEEIaiIEa0EPTARAA0AgAiAEKQAANwAAIARBCGohBCACQQhqIgIgB0kNAAwCCwALIAQpAAAhKCACIAQpAAg3AAggAiAoNwAAIBRBGUgNACADQRhqIQMDQCAEKQAQISggAyAEKQAYNwAIIAMgKDcAACAEKQAgISggAyAEKQAoNwAYIAMgKDcAECAEQSBqIQQgA0EgaiIDIAdJDQALCyAGQYl/TwRAIAYhDQwICyAXIQggBiAPagwDCyARQSBrIRACQAJAIAggEUkNACACIAsoAgQiByAEaiIGaiAQSw0AIAZBIGogGiACa00NAQsgCiALKAIINgIgIAogCykCADcDGCACIBogECAKQRhqIApBjAJqIAggDiAYIBYQ8gEhBgwCCyACIARqIQ8gCygCCCEQIAMpAAAhKCACIAMpAAg3AAggAiAoNwAAAkAgBEERSQ0AIAMpABAhKCACIAMpABg3ABggAiAoNwAQIARBEGtBEUgNACADQRBqIQQgAkEgaiEDA0AgBCkAECEoIAMgBCkAGDcACCADICg3AAAgBCkAICEoIAMgBCkAKDcAGCADICg3ABAgBEEgaiEEIANBIGoiAyAPSQ0ACwsgDyAQayEEIAogETYCjAIgDyAOayAQSQRAIBAgDyAYa0sNByAWIBYgBCAOayIDaiIEIAdqTwRAIA8gBCAHEBwaDAMLIAMgB2ohByAPIARBACADaxAcIANrIQ8gDiEECyAQQRBPBEAgBCkAACEoIA8gBCkACDcACCAPICg3AAAgB0ERSA0CIAcgD2ohByAPQRBqIQMDQCAEKQAQISggAyAEKQAYNwAIIAMgKDcAACAEKQAgISggAyAEKQAoNwAYIAMgKDcAECAEQSBqIQQgA0EgaiIDIAdJDQALDAILAkAgEEEHTQRAIA8gBC0AADoAACAPIAQtAAE6AAEgDyAELQACOgACIA8gBC0AAzoAAyAPIAQgEEECdCIDQeCLAWooAgBqIgQoAAA2AAQgBCADQYCMAWooAgBrIQQMAQsgDyAEKQAANwAACyAHQQlJDQEgByAPaiEQIA9BCGoiAyAEQQhqIgRrQQ9MBEADQCADIAQpAAA3AAAgBEEIaiEEIANBCGoiAyAQSQ0ADAMLAAsgBCkAACEoIAMgBCkACDcACCADICg3AAAgB0EZSA0BIA9BGGohAwNAIAQpABAhKCADIAQpABg3AAggAyAoNwAAIAQpACAhKCADIAQpACg3ABggAyAoNwAQIARBIGohBCADQSBqIgMgEEkNAAsMAQsCQAJAIAooAowCIgQgCygCACIQaiIRIAhLDQAgAiALKAIEIg8gEGoiBmogHEsNACAGQSBqIBogAmtNDQELIAogCygCCDYCMCAKIAspAgA3AyggAiAaIApBKGogCkGMAmogCCAOIBggFhBWIQYMAQsgAiAQaiEDIAsoAgghByAEKQAAISggAiAEKQAINwAIIAIgKDcAAAJAIBBBEUkNACAEKQAQISggAiAEKQAYNwAYIAIgKDcAECAQQRBrQRFIDQAgBEEQaiEEIAJBIGohFANAIAQpABAhKCAUIAQpABg3AAggFCAoNwAAIAQpACAhKCAUIAQpACg3ABggFCAoNwAQIARBIGohBCAUQSBqIhQgA0kNAAsLIAMgB2shBCAKIBE2AowCIAMgDmsgB0kEQCAHIAMgGGtLDQYgFiAWIAQgDmsiBGoiECAPak8EQCADIBAgDxAcGgwCCyAEIA9qIQ8gAyAQQQAgBGsQHCAEayEDIA4hBAsgB0EQTwRAIAQpAAAhKCADIAQpAAg3AAggAyAoNwAAIA9BEUgNASADIA9qIQcgA0EQaiEDA0AgBCkAECEoIAMgBCkAGDcACCADICg3AAAgBCkAICEoIAMgBCkAKDcAGCADICg3ABAgBEEgaiEEIANBIGoiAyAHSQ0ACwwBCwJAIAdBB00EQCADIAQtAAA6AAAgAyAELQABOgABIAMgBC0AAjoAAiADIAQtAAM6AAMgAyAEIAdBAnQiB0HgiwFqKAIAaiIEKAAANgAEIAQgB0GAjAFqKAIAayEEDAELIAMgBCkAADcAAAsgD0EJSQ0AIAMgD2ohByADQQhqIhEgBEEIaiIEa0EPTARAA0AgESAEKQAANwAAIARBCGohBCARQQhqIhEgB0kNAAwCCwALIAQpAAAhKCARIAQpAAg3AAggESAoNwAAIA9BGUgNACADQRhqIQMDQCAEKQAQISggAyAEKQAYNwAIIAMgKDcAACAEKQAgISggAyAEKQAoNwAYIAMgKDcAECAEQSBqIQQgA0EgaiIDIAdJDQALCyAGQYh/SwRAIAYhDQwFCyACIAZqCyECIAlBAWoiCSAFRw0ACwsgJyAbKQIANwIAICcgGygCCDYCCCAAKAKI7AEhDSAKKAKMAiEECyANQQJGBEAgCCAEayIDIBogAmtLBEBBun8hDQwCCyACBH8gAiAEIAMQHCADagVBAAshAiAAQYzsBWohCCAAQYzsAWohBAsgCCAEayIAIBogAmtLBEBBun8hDQwBCyACRQRAQQAgAWshDQwBCyACIAQgABAcIABqIAFrIQ0LIApBkAJqJAAgDQu+IAEkfyMAQRBrIh0kACAAQQA2AjggAEFAaygCACEGAkACQCAAKAIcRQRAIAJBCE0EQCAAQQE2AjgLIAAoAjwiBCgChAhBAkYEQEEAIQIgAEEANgI4IAZBAkcEQCAAQQA2AhggBEEEaiEBIAAoAgAhBgNAIAYgAkECdCIFakEBQQsgASAFai0AACIHa3RBASAHGyIHNgIAIAAgACgCGCAHajYCGCAGIAVBBHIiBWpBAUELIAEgBWotAAAiBWt0QQEgBRsiBTYCACAAIAAoAhggBWo2AhggAkECaiICQYACRw0ACwsgBC8AuBkhAUEAIQIgAEEANgIcIARBASABQQFrdEEBIAEbQQJ0akG8GWohASAAKAIEIQYDQCAGIAJBAnRqQQFBAUEKIAEgAkEDdGooAgRB//8DaiIFQRB2a3QgBUGAgARJGyIFNgIAIAAgBSAAKAIcajYCHCAGIAJBAXIiBUECdGpBAUEBQQogASAFQQN0aigCBEH//wNqIgVBEHZrdCAFQYCABEkbIgU2AgAgACAFIAAoAhxqNgIcIAJBAmoiAkEkRw0ACyAELwCMDiEBQQAhAiAAQQA2AiAgBEEBIAFBAWt0QQEgARtBAnRqQZAOaiEBIAAoAgghBgNAIAYgAkECdGpBAUEBQQogASACQQN0aigCBEH//wNqIgVBEHZrdCAFQYCABEkbIgU2AgAgACAFIAAoAiBqNgIgIAJBNEZFBEAgBiACQQFyIgVBAnRqQQFBAUEKIAEgBUEDdGooAgRB//8DaiIFQRB2a3QgBUGAgARJGyIFNgIAIAAgBSAAKAIgajYCICACQQJqIQIMAQsLIAQvAIgIIQFBACECIABBADYCJCAEQQEgAUEBa3RBASABG0ECdGpBjAhqIQEgACgCDCEGA0AgBiACQQJ0akEBQQFBCiABIAJBA3RqKAIEQf//A2oiBEEQdmt0IARBgIAESRsiBDYCACAAIAQgACgCJGo2AiQgBiACQQFyIgRBAnRqQQFBAUEKIAEgBEEDdGooAgRB//8DaiIEQRB2a3QgBEGAgARJGyIENgIAIAAgBCAAKAIkaiIENgIkIAJBAmoiAkEgRw0ACwwDCyAGQQJHBEAgHUH/ATYCDCAAKAIAIB1BDGogASACEJ8BGiAAKAIAIQZBACECQQAhAQNAIAYgAkECdGoiBCAEKAIAIgVBCHYgBUEAR2oiBTYCACAEIAQoAgQiBEEIdiAEQQBHaiIENgIEIAQgASAFamohASACQf4BRyACQQJqIQINAAsgACABNgIYCyAAKAIEQYDiAEGQARAUGiAAQSg2AhwgACgCCCIBQQE2AtABIAFCgYCAgBA3AsgBIAFCgYCAgBA3AsABIAFCgYCAgBA3ArgBIAFCgYCAgBA3ArABIAFCgYCAgBA3AqgBIAFCgYCAgBA3AqABIAFCgYCAgBA3ApgBIAFCgYCAgBA3ApABIAFCgYCAgBA3AogBIAFCgYCAgBA3AoABIAFCgYCAgBA3AnggAUKBgICAEDcCcCABQoGAgIAQNwJoIAFCgYCAgBA3AmAgAUKBgICAEDcCWCABQoGAgIAQNwJQIAFCgYCAgBA3AkggAUKBgICAEDcCQCABQoGAgIAQNwI4IAFCgYCAgBA3AjAgAUKBgICAEDcCKCABQoGAgIAQNwIgIAFCgYCAgBA3AhggAUKBgICAEDcCECABQoGAgIAQNwIIIAFCgYCAgBA3AgBBNSEEIABBNTYCICAAKAIMQZDjAEGAARAUGgwBCyAGQQJHBEAgACgCACEFQQAhAUEAIQIDQCAFIAJBAnRqIgQoAgwgBCgCCCAEKAIEIAQoAgAgAWpqamohASACQfwBRyACQQRqIQINAAsgAUGAwABPBEAgAUEMdmdBH3MhBkEAIQRBACEBA0AgBSAEQQJ0aiICIAIoAgAgBnZBAWoiBzYCACACIAIoAgQgBnZBAWoiCDYCBCACIAIoAgggBnZBAWoiCTYCCCACIAIoAgwgBnZBAWoiAjYCDCACIAkgCCABIAdqampqIQEgBEH8AUcgBEEEaiEEDQALCyAAIAE2AhgLIAAgACgCBCIBKAKMASABKAKIASABKAKEASABKAKAASABKAJ8IAEoAnggASgCdCABKAJwIAEoAmwgASgCaCABKAJkIAEoAmAgASgCXCIGIAEoAlgiBSABKAJUIgcgASgCUCIIIAEoAkwiCSABKAJIIgogASgCRCILIAEoAkAiDCABKAI8Ig0gASgCOCIOIAEoAjQiDyABKAIwIhAgASgCLCIRIAEoAigiEiABKAIkIhMgASgCICIUIAEoAhwiFSABKAIYIhYgASgCFCIXIAEoAhAiGCABKAIMIAEoAgggASgCBCABKAIAampqampqampqampqampqampqampqampqampqampqampqamoiBEGAIE8EfyABIAEoAgAgBEELdmdBH3MiAnZBAWoiBDYCACABIAEoAgQgAnZBAWoiGTYCBCABIAEoAgggAnZBAWoiGjYCCCABIAEoAgwgAnZBAWoiGzYCDCABIAYgAnZBAWoiBjYCXCABIAUgAnZBAWoiBTYCWCABIAcgAnZBAWoiBzYCVCABIAggAnZBAWoiCDYCUCABIAkgAnZBAWoiCTYCTCABIAogAnZBAWoiCjYCSCABIAsgAnZBAWoiCzYCRCABIAwgAnZBAWoiDDYCQCABIA0gAnZBAWoiDTYCPCABIA4gAnZBAWoiDjYCOCABIA8gAnZBAWoiDzYCNCABIBAgAnZBAWoiEDYCMCABIBEgAnZBAWoiETYCLCABIBIgAnZBAWoiEjYCKCABIBMgAnZBAWoiEzYCJCABIBQgAnZBAWoiFDYCICABIBUgAnZBAWoiFTYCHCABIBYgAnZBAWoiFjYCGCABIBcgAnZBAWoiFzYCFCABIBggAnZBAWoiGDYCECABIAEoAmAgAnZBAWoiHDYCYCABIAEoAmQgAnZBAWoiHjYCZCABIAEoAmggAnZBAWoiHzYCaCABIAEoAmwgAnZBAWoiIDYCbCABIAEoAnAgAnZBAWoiITYCcCABIAEoAnQgAnZBAWoiIjYCdCABIAEoAnggAnZBAWoiIzYCeCABIAEoAnwgAnZBAWoiJDYCfCABIAEoAoABIAJ2QQFqIiU2AoABIAEgASgChAEgAnZBAWoiJjYChAEgASABKAKIASACdkEBaiInNgKIASABIAEoAowBIAJ2QQFqIgE2AowBIAEgJyAmICUgJCAjICIgISAgIB8gHiAcIAYgBSAHIAggCSAKIAsgDCANIA4gDyAQIBEgEiATIBQgFSAWIBcgGCAbIBogBCAZampqampqampqampqampqampqampqampqampqampqampqamoFIAQLNgIcAkAgACgCCCICKALQASACKALMASACKALIASACKALEASACKALAASACKAK8ASACKAK4ASACKAK0ASACKAKwASACKAKsASACKAKoASACKAKkASACKAKgASACKAKcASACKAKYASACKAKUASACKAKQASACKAKMASACKAKIASACKAKEASACKAKAASACKAJ8IAIoAnggAigCdCACKAJwIAIoAmwgAigCaCACKAJkIAIoAmAgAigCXCACKAJYIAIoAlQgAigCUCACKAJMIAIoAkggAigCRCACKAJAIAIoAjwgAigCOCACKAI0IAIoAjAgAigCLCACKAIoIAIoAiQgAigCICACKAIcIAIoAhggAigCFCACKAIQIAIoAgwgAigCCCACKAIEIAIoAgBqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqIgRBgCBJDQAgBEELdmdBH3MhBUEAIQFBACEEA0AgAiABQQJ0aiIGIAYoAgAgBXZBAWoiBzYCACAEIAdqIQQgAUE0Rg0BIAYgBigCBCAFdkEBaiIHNgIEIAYgBigCCCAFdkEBaiIINgIIIAYgBigCDCAFdkEBaiIGNgIMIAYgCCAEIAdqamohBCABQQRqIQEMAAsACyAAIAQ2AiAgACgCDCIBKAJ8IAEoAnggASgCdCABKAJwIAEoAmwgASgCaCABKAJkIAEoAmAiAiABKAJcIgYgASgCWCIFIAEoAlQiByABKAJQIgggASgCTCIJIAEoAkgiCiABKAJEIgsgASgCQCIMIAEoAjwiDSABKAI4Ig4gASgCNCIPIAEoAjAiECABKAIsIhEgASgCKCISIAEoAiQiEyABKAIgIhQgASgCHCIVIAEoAhgiFiABKAIUIhcgASgCECIYIAEoAgwiGSABKAIIIhogASgCBCIbIAEoAgAiHGpqampqampqampqampqampqampqampqampqampqamoiBEGAIEkNACABIAIgBEELdmdBH3MiAnZBAWoiBDYCYCABIAYgAnZBAWoiBjYCXCABIAUgAnZBAWoiBTYCWCABIAcgAnZBAWoiBzYCVCABIAggAnZBAWoiCDYCUCABIAkgAnZBAWoiCTYCTCABIAogAnZBAWoiCjYCSCABIAsg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ayAHSxsgACgCGBsiFCAAKAIMIhxPBEAgACABIAIgAyAEEP4BDwsgAigCACIGQQAgBiAFIBRrIglJIgcbIQVBACAGIAcbIR0gAigCBCIGQQAgBiAJSSIJGyEOQQAgBiAJGyEgAkAgAyAAKALMASIGIAZFakEBaiIhaiIPQQFqIgggAyAEaiISQQhrIhlPDQAgACgCCCIVIBwgFCAUIBxJGyIQaiEeIAsgEGohHyAUIBVqISMgACgCXCEMIAtBAmohJCASQSBrIRdBICAAKALAASIEayETQcAAIARrrSEnQQQgACgCyAEiACAAQQVrQQNPG0EFayEYA0AgA0GAAWohFiADQQFqIQkgFSALIAwCfwJAAkACQAJAAkAgGA4EAAECAwQLIAMpAAFCgICA2Mub741PfiAniKchESADKQAAQoCAgNjLm++NT34gJ4inDAQLIAMpAAFCgIDs/Mub741PfiAniKchESADKQAAQoCA7PzLm++NT34gJ4inDAMLIAMpAAFCgMaV/cub741PfiAniKchESADKQAAQoDGlf3Lm++NT34gJ4inDAILIAMpAAFC48iVvcub741PfiAniKchESADKQAAQuPIlb3Lm++NT34gJ4inDAELIAMoAAFBsfPd8XlsIBN2IREgAygAAEGx893xeWwgE3YLIgpBAnRqKAIAIgAgEEkbIRogBSALaiElICEhBiADIQcCfwNAIAghDSAVIAsgECAPIgQgJWsiCEsiJhshIgJ/IAVFIBAgCGtBBElyRQRAIAggImooAAAMAQsgBCgAAEEBcwsgDCAKQQJ0aiAHIAtrIg82AgAgBCgAACIKRgRAQQVBBCAEQQFrLQAAIAggImoiBkEBay0AAEYiABshCiAGIABrIQggBCAAayEHIB4gEiAmGyEbQQEhFiAFIQ0gDgwCCwJAAkAgACAUSQ0AIAcoAAAgACAaaigAAEcNACAJIQQMAQsgDCARQQJ0aiIHKAIAIQACfwJAAkACQAJAAkAgGA4EAQIDBAALIApBsfPd8XlsIBN2DAQLIAQpAABCgICA2Mub741PfiAniKcMAwsgBCkAAEKAgOz8y5vvjU9+ICeIpwwCCyAEKQAAQoDGlf3Lm++NT34gJ4inDAELIAQpAABC48iVvcub741PfiAniKcLIQogByAJIAtrIg82AgACQCAAIBRJDQAgCSgAACAVIAsgACAQSRsiGiAAaigAAEcNACAKIREgCSEHDAELIAwgCkECdGooAgAhAAJ/AkACQAJAAkACQCAYDgQBAgMEAAsgDSgAAEGx893xeWwgE3YMBAsgDSkAAEKAgIDYy5vvjU9+ICeIpwwDCyANKQAAQoCA7PzLm++NT34gJ4inDAILIA0pAABCgMaV/cub741PfiAniKcMAQsgDSkAAELjyJW9y5vvjU9+ICeIpwshESAVIAsgACAQSRshGiAGIA1qIQggBCAGaiIPIBZPBEAgFkGAAWohFiAGQQFqIQYLIA0hCSAEIQcgCCAZSQ0BDAQLCyAeIBIgACAcSSIGGyEbIA8gAGsiDUEDaiEWQQQhCgJ/AkAgACAaaiIIICMgHyAGGyIJTSADIAdPcg0AA0AgB0EBayIGLQAAIAhBAWsiAC0AAEcNASAKQQFqIQogACAJSwRAIAAhCCAGIgcgA0sNAQsLIAAhCCAGIQcgBAwBCyAECyEJIAULIQYgByAKaiAIIApqIBIgGyAfEA8gCmohDiAHIANrIQUgASgCDCEAAkACQCAHIBdNBEAgAykAACEoIAAgAykACDcACCAAICg3AAAgASgCDCEEIAVBEE0EQCABIAQgBWo2AgwgASgCBCEADAMLIAMpABAhKCAEIAMpABg3ABggBCAoNwAQIAVBIUgNASAEIAVqIQggA0EQaiEAIARBIGohAwNAIAApABAhKCADIAApABg3AAggAyAoNwAAIAApACAhKCADIAApACg3ABggAyAoNwAQIABBIGohACADQSBqIgMgCEkNAAsMAQsgAyAXTQRAIAMpAAAhKCAAIAMpAAg3AAggACAoNwAAIAAgFyADayIIaiEEIAhBEU4EQCAAQRBqIQADQCADKQAQISggACADKQAYNwAIIAAgKDcAACADKQAgISggACADKQAoNwAYIAAgKDcAECADQSBqIQMgAEEgaiIAIARJDQALCyAXIQMgBCEACyADIAdPDQBBACEKIAMhBCAHIANrQQdxIggEQANAIAAgBC0AADoAACAAQQFqIQAgBEEBaiEEIApBAWoiCiAIRw0ACwsgAyAHa0F4Sw0AA0AgACAELQAAOgAAIAAgBC0AAToAASAAIAQtAAI6AAIgACAELQADOgADIAAgBC0ABDoABCAAIAQtAAU6AAUgACAELQAGOgAGIAAgBC0ABzoAByAAQQhqIQAgBEEIaiIEIAdHDQALCyABIAEoAgwgBWo2AgwgASgCBCEAIAVBgIAESQ0AIAFBATYCJCABIAAgASgCAGtBA3U2AigLIAAgFjYCACAAIAU7AQQgDkEDayIDQYCABE8EQCABQQI2AiQgASAAIAEoAgBrQQN1NgIoCyAAIAM7AQYgASAAQQhqIgA2AgQgByAOaiIDIAlLBEAgDCARQQJ0aiAJIAtrNgIACwJAIAMgGUsEQCAGIQ4gDSEFDAELIA8gJGohBCAPQQJqIQUgDAJ/AkACQAJAAkACQCAYDgQAAQIDBAsgDCAEKQAAQoCAgNjLm++NT34gJ4inQQJ0aiAFNgIAIANBAmsiBCkAAEKAgIDYy5vvjU9+ICeIpwwECyAMIAQpAABCgIDs/Mub741PfiAniKdBAnRqIAU2AgAgA0ECayIEKQAAQoCA7PzLm++NT34gJ4inDAMLIAwgBCkAAEKAxpX9y5vvjU9+ICeIp0ECdGogBTYCACADQQJrIgQpAABCgMaV/cub741PfiAniKcMAgsgDCAEKQAAQuPIlb3Lm++NT34gJ4inQQJ0aiAFNgIAIANBAmsiBCkAAELjyJW9y5vvjU9+ICeIpwwBCyAMIAQoAABBsfPd8XlsIBN2QQJ0aiAFNgIAIANBAmsiBCgAAEGx893xeWwgE3YLQQJ0aiAEIAtrNgIAA0ACQCAGIQUgDSEGIAVFDQAgAyALayIJIAVrIgQgEGtBfEsNACAEIBUgCyAEIBBJIgQbaiIHKAAAIAMoAABHDQAgA0EEaiAHQQRqIBIgHiASIAQbIB8QDyEEIAMgF00EQCADKQAAISggASgCDCIAIAMpAAg3AAggACAoNwAAIAEoAgQhAAsgAEEBNgIAIABBADsBBCAEQQFqIgdBgIAETwRAIAFBAjYCJCABIAAgASgCAGtBA3U2AigLIARBBGohBCAAIAc7AQYgASAAQQhqIgA2AgQgDAJ/AkACQAJAAkACQCAYDgQBAgMEAAsgAygAAEGx893xeWwgE3YMBAsgAykAAEKAgIDYy5vvjU9+ICeIpwwDCyADKQAAQoCA7PzLm++NT34gJ4inDAILIAMpAABCgMaV/cub741PfiAniKcMAQsgAykAAELjyJW9y5vvjU9+ICeIpwtBAnRqIAk2AgAgBSENIAYhDiADIARqIgMgGU0NAQwCCwsgBSEOIAYhBQsgAyAhaiIPQQFqIgggGUkNAAsLIAIgBSAdIAUbNgIAIAIgDiAdICAgBRsgICAdGyAOGzYCBCASIANrC6ZkAiB/A35BASAAKALMASIMIAxBAU0bIRggAyAEaiIOQQhrIRIgACgCtAEiBSgCBCIWIAUoAgwiIWohGiAFKAIAIhcgAyAAKAIEIg8gACgCDCIQaiITa2ohCUEAIBYgF2sgEGoiG2shCyAAKALYASEGIAIoAgQhCCACKAIAIQwgACgCwAEhByAAKAJcIRQgBSgCwAEhBCAFKAJcIRwCQAJAAkACQAJAIAAoAsgBQQVrDgMDAgEACyAGRSAEQR1LckUEQEEEIAR0IQVBACEAA0AgAEFAayIAIAVJDQALCyASIAMgGGoiBkkEQCADIQAMBAsgD0ECaiEfIAsgFmohICAOQQFrISIgDkEDayEZIA5BIGshCyAQQQFrIR1BGCAEayEeQSAgB2shESADIAkgGkZqIQADQCAAKAAAQbHz3fF5bCINIB52IgQgHCAEQQZ2Qfz//x9xaigCACIKcyEHIABBgAJqIQUgGCEJAkACQAJ/A0AgFCANIBF2QQJ0aiIVKAIAIQ0gBiIEKAAAISMgFSAAIA9rIhU2AgACQCAdIBUgDGtBAWoiBmtBA0kNACAWIAYgG2tqIAYgD2ogBiAQSSIGGyIkKAAAIAAoAAFHDQAgAEEFaiAkQQRqIA4gFyAOIAYbIBMQDyEHIABBAWoiBSADayEJIAEoAgwhBAJAAkAgBSALTQRAIAMpAAAhJSAEIAMpAAg3AAggBCAlNwAAIAEoAgwhBCAJQRBNBEAgASAEIAlqNgIMIAEoAgQhAAwDCyADKQAQISUgBCADKQAYNwAYIAQgJTcAECAJQSFIDQEgBCAJaiEGIANBEGohACAEQSBqIQMDQCAAKQAQISUgAyAAKQAYNwAIIAMgJTcAACAAKQAgISUgAyAAKQAoNwAYIAMgJTcAECAAQSBqIQAgA0EgaiIDIAZJDQALDAELIAMgC00EQCADKQAAISUgBCADKQAINwAIIAQgJTcAACAEIAsgA2siCmohBiAKQRFOBEAgBEEQaiEEA0AgAykAECElIAQgAykAGDcACCAEICU3AAAgAykAICElIAQgAykAKDcAGCAEICU3ABAgA0EgaiEDIARBIGoiBCAGSQ0ACwsgBiEEIAshAwsgAyAFTw0AIAAgA2tBACEAIAUgA2tBB3EiCgRAA0AgBCADLQAAOgAAIARBAWohBCADQQFqIQMgAEEBaiIAIApHDQALC0EHSQ0AA0AgBCADLQAAOgAAIAQgAy0AAToAASAEIAMtAAI6AAIgBCADLQADOgADIAQgAy0ABDoABCAEIAMtAAU6AAUgBCADLQAGOgAGIAQgAy0ABzoAByAEQQhqIQQgA0EIaiIDIAVHDQALCyABIAEoAgwgCWo2AgwgASgCBCEAIAlBgIAESQ0AIAFBATYCJCABIAAgASgCAGtBA3U2AigLIAdBBGohCiAAQQE2AgAgACAJOwEEIAwhBiAHQQFqIgNB//8DSw0DDAQLAkAgB0H/AXENACAKQQh2IgYgIU0NACAGIBZqIgcoAAAgACgAAEcgDSAQS3INACAAQQRqIAdBBGogDiAXIBMQD0EEaiEKIBUgBiAbamshBiAAIQUCQCAAIANNDQADQCAAQQFrIgUtAAAgB0EBayIHLQAARwRAIAAhBQwCCyAKQQFqIQogAyAFTw0BIAUhACAHIBpLDQALCyAGQQNqIQkgBSADayEIIAEoAgwhAAJAAkAgBSALTQRAIAMpAAAhJSAAIAMpAAg3AAggACAlNwAAIAEoAgwhBCAIQRBNBEAgASAEIAhqNgIMIAEoAgQhAAwDCyADKQAQISUgBCADKQAYNwAYIAQgJTcAECAIQSFIDQEgBCAIaiEHIANBEGohACAEQSBqIQMDQCAAKQAQISUgAyAAKQAYNwAIIAMgJTcAACAAKQAgISUgAyAAKQAoNwAYIAMgJTcAECAAQSBqIQAgA0EgaiIDIAdJDQALDAELIAMgC00EQCADKQAAISUgACADKQAINwAIIAAgJTcAACAAIAsgA2siB2ohBCAHQRFOBEAgAEEQaiEAA0AgAykAECElIAAgAykAGDcACCAAICU3AAAgAykAICElIAAgAykAKDcAGCAAICU3ABAgA0EgaiEDIABBIGoiACAESQ0ACwsgCyEDIAQhAAsgAyAFTw0AQQAhDSADIQQgBSADa0EHcSIHBEADQCAAIAQtAAA6AAAgAEEBaiEAIARBAWohBCANQQFqIg0gB0cNAAsLIAMgBWtBeEsNAANAIAAgBC0AADoAACAAIAQtAAE6AAEgACAELQACOgACIAAgBC0AAzoAAyAAIAQtAAQ6AAQgACAELQAFOgAFIAAgBC0ABjoABiAAIAQtAAc6AAcgAEEIaiEAIARBCGoiBCAFRw0ACwsgASABKAIMIAhqNgIMIAEoAgQhACAIQYCABEkNACABQQE2AiQgASAAIAEoAgBrQQN1NgIoCyAAIAk2AgAgACAIOwEEIAwhCCAGIQwgCkEDayIDQf//A00NBAwDCwJAAkAgDSAQTQ0AIA0gD2oiBygAACAAKAAARw0AIAdBBGohBSAAQQRqIgYgGU8EQCAGIQQMAgsgBiIEKAAAIgggBSgAACIJRwRAIAggCXNoQQN2DAQLA0AgBUEEaiEFIARBBGoiBCAZTw0CIAQoAAAiCCAFKAAAIglGDQALIAQgCCAJc2hBA3ZqIAZrDAMLIBIgBCAJIAQgBU8iAGoiCWoiBkkEQCADIQAMCgsgBSAAQQh0aiEFIBwgI0Gx893xeWwiDSAediIAQQZ2Qfz//x9xaigCACIKIABzIQcgBCEADAELCwJAIAQgIk8NACAFLwAAIAQvAABHDQAgBUECaiEFIARBAmohBAsgBCAOSQR/IAQgBS0AACAELQAARmoFIAQLIAZrC0EEaiEKAkAgACADTQRAIAAhBQwBCyAAIQkgByEEIAAhBSANIBBMDQADQCAJQQFrIgUtAAAgBEEBayIELQAARwRAIAkhBQwCCyAKQQFqIQogAyAFTw0BIAUhCSAEIBNLDQALCyAAIAdrIgZBA2ohCSAFIANrIQggASgCDCEAAkACQCAFIAtNBEAgAykAACElIAAgAykACDcACCAAICU3AAAgASgCDCEEIAhBEE0EQCABIAQgCGo2AgwgASgCBCEADAMLIAMpABAhJSAEIAMpABg3ABggBCAlNwAQIAhBIUgNASAEIAhqIQcgA0EQaiEAIARBIGohAwNAIAApABAhJSADIAApABg3AAggAyAlNwAAIAApACAhJSADIAApACg3ABggAyAlNwAQIABBIGohACADQSBqIgMgB0kNAAsMAQsgAyALTQRAIAMpAAAhJSAAIAMpAAg3AAggACAlNwAAIAAgCyADayIHaiEEIAdBEU4EQCAAQRBqIQADQCADKQAQISUgACADKQAYNwAIIAAgJTcAACADKQAgISUgACADKQAoNwAYIAAgJTcAECADQSBqIQMgAEEgaiIAIARJDQALCyALIQMgBCEACyADIAVPDQBBACENIAMhBCAFIANrQQdxIgcEQANAIAAgBC0AADoAACAAQQFqIQAgBEEBaiEEIA1BAWoiDSAHRw0ACwsgAyAFa0F4Sw0AA0AgACAELQAAOgAAIAAgBC0AAToAASAAIAQtAAI6AAIgACAELQADOgADIAAgBC0ABDoABCAAIAQtAAU6AAUgACAELQAGOgAGIAAgBC0ABzoAByAAQQhqIQAgBEEIaiIEIAVHDQALCyABIAEoAgwgCGo2AgwgASgCBCEAIAhBgIAESQ0AIAFBATYCJCABIAAgASgCAGtBA3U2AigLIAAgCTYCACAAIAg7AQQgDCEIIAYhDCAKQQNrIgNB//8DTQ0BCyABQQI2AiQgASAAIAEoAgBrQQN1NgIoIAYhDAsgACADOwEGIAEgAEEIaiIDNgIEAkAgBSAKaiIAIBJLDQAgFCAVIB9qKAAAQbHz3fF5bCARdkECdGogFUECajYCACAUIABBAmsiBCgAAEGx893xeWwgEXZBAnRqIAQgD2s2AgAgDCEFIAghBANAAkAgBCEMIAUhBCAdIAAgD2siCCAMayIFa0EDSQ0AIAUgICAPIAUgEEkiBRtqIgYoAAAgACgAAEcNACAAQQRqIAZBBGogDiAXIA4gBRsgExAPIQYgACALTQRAIAApAAAhJSABKAIMIgMgACkACDcACCADICU3AAAgASgCBCEDCyADQQE2AgAgA0EAOwEEIAZBAWoiBUGAgARPBEAgAUECNgIkIAEgAyABKAIAa0EDdTYCKAsgAyAFOwEGIAEgA0EIaiIDNgIEIBQgACgAAEGx893xeWwgEXZBAnRqIAg2AgAgDCEFIAQhCCAGQQRqIABqIgAgEk0NAQwCCwsgDCEIIAQhDAsgACEDIAAgGGoiBiASTQ0ACwwDCyAGRSAEQR1LckUEQEEEIAR0IQVBACEAA0AgAEFAayIAIAVJDQALCyASIAMgGGoiBkkEQCADIQAMAwsgD0ECaiEdIAsgFmohHiAOQQFrIR8gDkEDayEVIA5BIGshCyAQQQFrIRkgAyAJIBpGaiEAQTggBGutISdBwAAgB2utISYDQCAcIAApAABCgMaV/cub741PfiIlICeIpyIEQQZ2Qfz//x9xaigCACIKIARzIQcgAEGAAmohBSAYIQkCQAJAAn8DQCAUICUgJoinQQJ0aiIRKAIAIQ0gBiIEKQAAISUgESAAIA9rIhE2AgACQCAZIBEgDGtBAWoiBmtBA0kNACAWIAYgG2tqIAYgD2ogBiAQSSIGGyIgKAAAIAAoAAFHDQAgAEEFaiAgQQRqIA4gFyAOIAYbIBMQDyEHIABBAWoiBSADayEJIAEoAgwhBAJAAkAgBSALTQRAIAMpAAAhJSAEIAMpAAg3AAggBCAlNwAAIAEoAgwhBCAJQRBNBEAgASAEIAlqNgIMIAEoAgQhAAwDCyADKQAQISUgBCADKQAYNwAYIAQgJTcAECAJQSFIDQEgBCAJaiEGIANBEGohACAEQSBqIQMDQCAAKQAQISUgAyAAKQAYNwAIIAMgJTcAACAAKQAgISUgAyAAKQAoNwAYIAMgJTcAECAAQSBqIQAgA0EgaiIDIAZJDQALDAELIAMgC00EQCADKQAAISUgBCADKQAINwAIIAQgJTcAACAEIAsgA2siCmohBiAKQRFOBEAgBEEQaiEEA0AgAykAECElIAQgAykAGDcACCAEICU3AAAgAykAICElIAQgAykAKDcAGCAEICU3ABAgA0EgaiEDIARBIGoiBCAGSQ0ACwsgBiEEIAshAwsgAyAFTw0AIAAgA2tBACEAIAUgA2tBB3EiCgRAA0AgBCADLQAAOgAAIARBAWohBCADQQFqIQMgAEEBaiIAIApHDQALC0EHSQ0AA0AgBCADLQAAOgAAIAQgAy0AAToAASAEIAMtAAI6AAIgBCADLQADOgADIAQgAy0ABDoABCAEIAMtAAU6AAUgBCADLQAGOgAGIAQgAy0ABzoAByAEQQhqIQQgA0EIaiIDIAVHDQALCyABIAEoAgwgCWo2AgwgASgCBCEAIAlBgIAESQ0AIAFBATYCJCABIAAgASgCAGtBA3U2AigLIAdBBGohCiAAQQE2AgAgACAJOwEEIAwhBiAHQQFqIgNB//8DSw0DDAQLAkAgB0H/AXENACAKQQh2IgYgIU0NACAGIBZqIgcoAAAgACgAAEcgDSAQS3INACAAQQRqIAdBBGogDiAXIBMQD0EEaiEKIBEgBiAbamshBiAAIQUCQCAAIANNDQADQCAAQQFrIgUtAAAgB0EBayIHLQAARwRAIAAhBQwCCyAKQQFqIQogAyAFTw0BIAUhACAHIBpLDQALCyAGQQNqIQkgBSADayEIIAEoAgwhAAJAAkAgBSALTQRAIAMpAAAhJSAAIAMpAAg3AAggACAlNwAAIAEoAgwhBCAIQRBNBEAgASAEIAhqNgIMIAEoAgQhAAwDCyADKQAQISUgBCADKQAYNwAYIAQgJTcAECAIQSFIDQEgBCAIaiEHIANBEGohACAEQSBqIQMDQCAAKQAQISUgAyAAKQAYNwAIIAMgJTcAACAAKQAgISUgAyAAKQAoNwAYIAMgJTcAECAAQSBqIQAgA0EgaiIDIAdJDQALDAELIAMgC00EQCADKQAAISUgACADKQAINwAIIAAgJTcAACAAIAsgA2siB2ohBCAHQRFOBEAgAEEQaiEAA0AgAykAECElIAAgAykAGDcACCAAICU3AAAgAykAICElIAAgAykAKDcAGCAAICU3ABAgA0EgaiEDIABBIGoiACAESQ0ACwsgCyEDIAQhAAsgAyAFTw0AQQAhDSADIQQgBSADa0EHcSIHBEADQCAAIAQtAAA6AAAgAEEBaiEAIARBAWohBCANQQFqIg0gB0cNAAsLIAMgBWtBeEsNAANAIAAgBC0AADoAACAAIAQtAAE6AAEgACAELQACOgACIAAgBC0AAzoAAyAAIAQtAAQ6AAQgACAELQAFOgAFIAAgBC0ABjoABiAAIAQtAAc6AAcgAEEIaiEAIARBCGoiBCAFRw0ACwsgASABKAIMIAhqNgIMIAEoAgQhACAIQYCABEkNACABQQE2AiQgASAAIAEoAgBrQQN1NgIoCyAAIAk2AgAgACAIOwEEIAwhCCAGIQwgCkEDayIDQf//A00NBAwDCwJAAkAgDSAQTQ0AIA0gD2oiBygAACAAKAAARw0AIAdBBGohBSAAQQRqIgYgFU8EQCAGIQQMAgsgBiIEKAAAIgggBSgAACIJRwRAIAggCXNoQQN2DAQLA0AgBUEEaiEFIARBBGoiBCAVTw0CIAQoAAAiCCAFKAAAIglGDQALIAQgCCAJc2hBA3ZqIAZrDAMLIBIgBCAJIAQgBU8iAGoiCWoiBkkEQCADIQAMCQsgBSAAQQh0aiEFIBwgJUKAxpX9y5vvjU9+IiUgJ4inIgBBBnZB/P//H3FqKAIAIgogAHMhByAEIQAMAQsLAkAgBCAfTw0AIAUvAAAgBC8AAEcNACAFQQJqIQUgBEECaiEECyAEIA5JBH8gBCAFLQAAIAQtAABGagUgBAsgBmsLQQRqIQoCQCAAIANNBEAgACEFDAELIAAhCSAHIQQgACEFIA0gEEwNAANAIAlBAWsiBS0AACAEQQFrIgQtAABHBEAgCSEFDAILIApBAWohCiADIAVPDQEgBSEJIAQgE0sNAAsLIAAgB2siBkEDaiEJIAUgA2shCCABKAIMIQACQAJAIAUgC00EQCADKQAAISUgACADKQAINwAIIAAgJTcAACABKAIMIQQgCEEQTQRAIAEgBCAIajYCDCABKAIEIQAMAwsgAykAECElIAQgAykAGDcAGCAEICU3ABAgCEEhSA0BIAQgCGohByADQRBqIQAgBEEgaiEDA0AgACkAECElIAMgACkAGDcACCADICU3AAAgACkAICElIAMgACkAKDcAGCADICU3ABAgAEEgaiEAIANBIGoiAyAHSQ0ACwwBCyADIAtNBEAgAykAACElIAAgAykACDcACCAAICU3AAAgACALIANrIgdqIQQgB0ERTgRAIABBEGohAANAIAMpABAhJSAAIAMpABg3AAggACAlNwAAIAMpACAhJSAAIAMpACg3ABggACAlNwAQIANBIGohAyAAQSBqIgAgBEkNAAsLIAshAyAEIQALIAMgBU8NAEEAIQ0gAyEEIAUgA2tBB3EiBwRAA0AgACAELQAAOgAAIABBAWohACAEQQFqIQQgDUEBaiINIAdHDQALCyADIAVrQXhLDQADQCAAIAQtAAA6AAAgACAELQABOgABIAAgBC0AAjoAAiAAIAQtAAM6AAMgACAELQAEOgAEIAAgBC0ABToABSAAIAQtAAY6AAYgACAELQAHOgAHIABBCGohACAEQQhqIgQgBUcNAAsLIAEgASgCDCAIajYCDCABKAIEIQAgCEGAgARJDQAgAUEBNgIkIAEgACABKAIAa0EDdTYCKAsgACAJNgIAIAAgCDsBBCAMIQggBiEMIApBA2siA0H//wNNDQELIAFBAjYCJCABIAAgASgCAGtBA3U2AiggBiEMCyAAIAM7AQYgASAAQQhqIgM2AgQCQCAFIApqIgAgEksNACAUIBEgHWopAABCgMaV/cub741PfiAmiKdBAnRqIBFBAmo2AgAgFCAAQQJrIgQpAABCgMaV/cub741PfiAmiKdBAnRqIAQgD2s2AgAgDCEFIAghBANAAkAgBCEMIAUhBCAZIAAgD2siCCAMayIFa0EDSQ0AIAUgHiAPIAUgEEkiBRtqIgYoAAAgACgAAEcNACAAQQRqIAZBBGogDiAXIA4gBRsgExAPIQYgACALTQRAIAApAAAhJSABKAIMIgMgACkACDcACCADICU3AAAgASgCBCEDCyADQQE2AgAgA0EAOwEEIAZBAWoiBUGAgARPBEAgAUECNgIkIAEgAyABKAIAa0EDdTYCKAsgAyAFOwEGIAEgA0EIaiIDNgIEIBQgACkAAEKAxpX9y5vvjU9+ICaIp0ECdGogCDYCACAMIQUgBCEIIAZBBGogAGoiACASTQ0BDAILCyAMIQggBCEMCyAAIQMgACAYaiIGIBJNDQALDAILIAZFIARBHUtyRQRAQQQgBHQhBUEAIQADQCAAQUBrIgAgBUkNAAsLIBIgAyAYaiIGSQRAIAMhAAwCCyAPQQJqIR0gCyAWaiEeIA5BAWshHyAOQQNrIRUgDkEgayELIBBBAWshGSADIAkgGkZqIQBBOCAEa60hJ0HAACAHa60hJgNAIBwgACkAAEKAgOz8y5vvjU9+IiUgJ4inIgRBBnZB/P//H3FqKAIAIgogBHMhByAAQYACaiEFIBghCQJAAkACfwNAIBQgJSAmiKdBAnRqIhEoAgAhDSAGIgQpAAAhJSARIAAgD2siETYCAAJAIBkgESAMa0EBaiIGa0EDSQ0AIBYgBiAba2ogBiAPaiAGIBBJIgYbIiAoAAAgACgAAUcNACAAQQVqICBBBGogDiAXIA4gBhsgExAPIQcgAEEBaiIFIANrIQkgASgCDCEEAkACQCAFIAtNBEAgAykAACElIAQgAykACDcACCAEICU3AAAgASgCDCEEIAlBEE0EQCABIAQgCWo2AgwgASgCBCEADAMLIAMpABAhJSAEIAMpABg3ABggBCAlNwAQIAlBIUgNASAEIAlqIQYgA0EQaiEAIARBIGohAwNAIAApABAhJSADIAApABg3AAggAyAlNwAAIAApACAhJSADIAApACg3ABggAyAlNwAQIABBIGohACADQSBqIgMgBkkNAAsMAQsgAyALTQRAIAMpAAAhJSAEIAMpAAg3AAggBCAlNwAAIAQgCyADayIKaiEGIApBEU4EQCAEQRBqIQQDQCADKQAQISUgBCADKQAYNwAIIAQgJTcAACADKQAgISUgBCADKQAoNwAYIAQgJTcAECADQSBqIQMgBEEgaiIEIAZJDQALCyAGIQQgCyEDCyADIAVPDQAgACADa0EAIQAgBSADa0EHcSIKBEADQCAEIAMtAAA6AAAgBEEBaiEEIANBAWohAyAAQQFqIgAgCkcNAAsLQQdJDQADQCAEIAMtAAA6AAAgBCADLQABOgABIAQgAy0AAjoAAiAEIAMtAAM6AAMgBCADLQAEOgAEIAQgAy0ABToABSAEIAMtAAY6AAYgBCADLQAHOgAHIARBCGohBCADQQhqIgMgBUcNAAsLIAEgASgCDCAJajYCDCABKAIEIQAgCUGAgARJDQAgAUEBNgIkIAEgACABKAIAa0EDdTYCKAsgB0EEaiEKIABBATYCACAAIAk7AQQgDCEGIAdBAWoiA0H//wNLDQMMBAsCQCAHQf8BcQ0AIApBCHYiBiAhTQ0AIAYgFmoiBygAACAAKAAARyANIBBLcg0AIABBBGogB0EEaiAOIBcgExAPQQRqIQogESAGIBtqayEGIAAhBQJAIAAgA00NAANAIABBAWsiBS0AACAHQQFrIgctAABHBEAgACEFDAILIApBAWohCiADIAVPDQEgBSEAIAcgGksNAAsLIAZBA2ohCSAFIANrIQggASgCDCEAAkACQCAFIAtNBEAgAykAACElIAAgAykACDcACCAAICU3AAAgASgCDCEEIAhBEE0EQCABIAQgCGo2AgwgASgCBCEADAMLIAMpABAhJSAEIAMpABg3ABggBCAlNwAQIAhBIUgNASAEIAhqIQcgA0EQaiEAIARBIGohAwNAIAApABAhJSADIAApABg3AAggAyAlNwAAIAApACAhJSADIAApACg3ABggAyAlNwAQIABBIGohACADQSBqIgMgB0kNAAsMAQsgAyALTQRAIAMpAAAhJSAAIAMpAAg3AAggACAlNwAAIAAgCyADayIHaiEEIAdBEU4EQCAAQRBqIQADQCADKQAQISUgACADKQAYNwAIIAAgJTcAACADKQAgISUgACADKQAoNwAYIAAgJTcAECADQSBqIQMgAEEgaiIAIARJDQALCyALIQMgBCEACyADIAVPDQBBACENIAMhBCAFIANrQQdxIgcEQANAIAAgBC0AADoAACAAQQFqIQAgBEEBaiEEIA1BAWoiDSAHRw0ACwsgAyAFa0F4Sw0AA0AgACAELQAAOgAAIAAgBC0AAToAASAAIAQtAAI6AAIgACAELQADOgADIAAgBC0ABDoABCAAIAQtAAU6AAUgACAELQAGOgAGIAAgBC0ABzoAByAAQQhqIQAgBEEIaiIEIAVHDQALCyABIAEoAgwgCGo2AgwgASgCBCEAIAhBgIAESQ0AIAFBATYCJCABIAAgASgCAGtBA3U2AigLIAAgCTYCACAAIAg7AQQgDCEIIAYhDCAKQQNrIgNB//8DTQ0EDAMLAkACQCANIBBNDQAgDSAPaiIHKAAAIAAoAABHDQAgB0EEaiEFIABBBGoiBiAVTwRAIAYhBAwCCyAGIgQoAAAiCCAFKAAAIglHBEAgCCAJc2hBA3YMBAsDQCAFQQRqIQUgBEEEaiIEIBVPDQIgBCgAACIIIAUoAAAiCUYNAAsgBCAIIAlzaEEDdmogBmsMAwsgEiAEIAkgBCAFTyIAaiIJaiIGSQRAIAMhAAwICyAFIABBCHRqIQUgHCAlQoCA7PzLm++NT34iJSAniKciAEEGdkH8//8fcWooAgAiCiAAcyEHIAQhAAwBCwsCQCAEIB9PDQAgBS8AACAELwAARw0AIAVBAmohBSAEQQJqIQQLIAQgDkkEfyAEIAUtAAAgBC0AAEZqBSAECyAGawtBBGohCgJAIAAgA00EQCAAIQUMAQsgACEJIAchBCAAIQUgDSAQTA0AA0AgCUEBayIFLQAAIARBAWsiBC0AAEcEQCAJIQUMAgsgCkEBaiEKIAMgBU8NASAFIQkgBCATSw0ACwsgACAHayIGQQNqIQkgBSADayEIIAEoAgwhAAJAAkAgBSALTQRAIAMpAAAhJSAAIAMpAAg3AAggACAlNwAAIAEoAgwhBCAIQRBNBEAgASAEIAhqNgIMIAEoAgQhAAwDCyADKQAQISUgBCADKQAYNwAYIAQgJTcAECAIQSFIDQEgBCAIaiEHIANBEGohACAEQSBqIQMDQCAAKQAQISUgAyAAKQAYNwAIIAMgJTcAACAAKQAgISUgAyAAKQAoNwAYIAMgJTcAECAAQSBqIQAgA0EgaiIDIAdJDQALDAELIAMgC00EQCADKQAAISUgACADKQAINwAIIAAgJTcAACAAIAsgA2siB2ohBCAHQRFOBEAgAEEQaiEAA0AgAykAECElIAAgAykAGDcACCAAICU3AAAgAykAICElIAAgAykAKDcAGCAAICU3ABAgA0EgaiEDIABBIGoiACAESQ0ACwsgCyEDIAQhAAsgAyAFTw0AQQAhDSADIQQgBSADa0EHcSIHBEADQCAAIAQtAAA6AAAgAEEBaiEAIARBAWohBCANQQFqIg0gB0cNAAsLIAMgBWtBeEsNAANAIAAgBC0AADoAACAAIAQtAAE6AAEgACAELQACOgACIAAgBC0AAzoAAyAAIAQtAAQ6AAQgACAELQAFOgAFIAAgBC0ABjoABiAAIAQtAAc6AAcgAEEIaiEAIARBCGoiBCAFRw0ACwsgASABKAIMIAhqNgIMIAEoAgQhACAIQYCABEkNACABQQE2AiQgASAAIAEoAgBrQQN1NgIoCyAAIAk2AgAgACAIOwEEIAwhCCAGIQwgCkEDayIDQf//A00NAQsgAUECNgIkIAEgACABKAIAa0EDdTYCKCAGIQwLIAAgAzsBBiABIABBCGoiAzYCBAJAIAUgCmoiACASSw0AIBQgESAdaikAAEKAgOz8y5vvjU9+ICaIp0ECdGogEUECajYCACAUIABBAmsiBCkAAEKAgOz8y5vvjU9+ICaIp0ECdGogBCAPazYCACAMIQUgCCEEA0ACQCAEIQwgBSEEIBkgACAPayIIIAxrIgVrQQNJDQAgBSAeIA8gBSAQSSIFG2oiBigAACAAKAAARw0AIABBBGogBkEEaiAOIBcgDiAFGyATEA8hBiAAIAtNBEAgACkAACElIAEoAgwiAyAAKQAINwAIIAMgJTcAACABKAIEIQMLIANBATYCACADQQA7AQQgBkEBaiIFQYCABE8EQCABQQI2AiQgASADIAEoAgBrQQN1NgIoCyADIAU7AQYgASADQQhqIgM2AgQgFCAAKQAAQoCA7PzLm++NT34gJoinQQJ0aiAINgIAIAwhBSAEIQggBkEEaiAAaiIAIBJNDQEMAgsLIAwhCCAEIQwLIAAhAyAAIBhqIgYgEk0NAAsMAQsgBkUgBEEdS3JFBEBBBCAEdCEFQQAhAANAIABBQGsiACAFSQ0ACwsgEiADIBhqIgZJBEAgAyEADAELIA9BAmohHSALIBZqIR4gDkEBayEfIA5BA2shFSAOQSBrIQsgEEEBayEZIAMgCSAaRmohAEE4IARrrSEnQcAAIAdrrSEmA0AgHCAAKQAAQoCAgNjLm++NT34iJSAniKciBEEGdkH8//8fcWooAgAiCiAEcyEHIABBgAJqIQUgGCEJAkACQAJ/A0AgFCAlICaIp0ECdGoiESgCACENIAYiBCkAACElIBEgACAPayIRNgIAAkAgGSARIAxrQQFqIgZrQQNJDQAgFiAGIBtraiAGIA9qIAYgEEkiBhsiICgAACAAKAABRw0AIABBBWogIEEEaiAOIBcgDiAGGyATEA8hByAAQQFqIgUgA2shCSABKAIMIQQCQAJAIAUgC00EQCADKQAAISUgBCADKQAINwAIIAQgJTcAACABKAIMIQQgCUEQTQRAIAEgBCAJajYCDCABKAIEIQAMAwsgAykAECElIAQgAykAGDcAGCAEICU3ABAgCUEhSA0BIAQgCWohBiADQRBqIQAgBEEgaiEDA0AgACkAECElIAMgACkAGDcACCADICU3AAAgACkAICElIAMgACkAKDcAGCADICU3ABAgAEEgaiEAIANBIGoiAyAGSQ0ACwwBCyADIAtNBEAgAykAACElIAQgAykACDcACCAEICU3AAAgBCALIANrIgpqIQYgCkERTgRAIARBEGohBANAIAMpABAhJSAEIAMpABg3AAggBCAlNwAAIAMpACAhJSAEIAMpACg3ABggBCAlNwAQIANBIGohAyAEQSBqIgQgBkkNAAsLIAYhBCALIQMLIAMgBU8NACAAIANrQQAhACAFIANrQQdxIgoEQANAIAQgAy0AADoAACAEQQFqIQQgA0EBaiEDIABBAWoiACAKRw0ACwtBB0kNAANAIAQgAy0AADoAACAEIAMtAAE6AAEgBCADLQACOgACIAQgAy0AAzoAAyAEIAMtAAQ6AAQgBCADLQAFOgAFIAQgAy0ABjoABiAEIAMtAAc6AAcgBEEIaiEEIANBCGoiAyAFRw0ACwsgASABKAIMIAlqNgIMIAEoAgQhACAJQYCABEkNACABQQE2AiQgASAAIAEoAgBrQQN1NgIoCyAHQQRqIQogAEEBNgIAIAAgCTsBBCAMIQYgB0EBaiIDQf//A0sNAwwECwJAIAdB/wFxDQAgCkEIdiIGICFNDQAgBiAWaiIHKAAAIAAoAABHIA0gEEtyDQAgAEEEaiAHQQRqIA4gFyATEA9BBGohCiARIAYgG2prIQYgACEFAkAgACADTQ0AA0AgAEEBayIFLQAAIAdBAWsiBy0AAEcEQCAAIQUMAgsgCkEBaiEKIAMgBU8NASAFIQAgByAaSw0ACwsgBkEDaiEJIAUgA2shCCABKAIMIQACQAJAIAUgC00EQCADKQAAISUgACADKQAINwAIIAAgJTcAACABKAIMIQQgCEEQTQRAIAEgBCAIajYCDCABKAIEIQAMAwsgAykAECElIAQgAykAGDcAGCAEICU3ABAgCEEhSA0BIAQgCGohByADQRBqIQAgBEEgaiEDA0AgACkAECElIAMgACkAGDcACCADICU3AAAgACkAICElIAMgACkAKDcAGCADICU3ABAgAEEgaiEAIANBIGoiAyAHSQ0ACwwBCyADIAtNBEAgAykAACElIAAgAykACDcACCAAICU3AAAgACALIANrIgdqIQQgB0ERTgRAIABBEGohAANAIAMpABAhJSAAIAMpABg3AAggACAlNwAAIAMpACAhJSAAIAMpACg3ABggACAlNwAQIANBIGohAyAAQSBqIgAgBEkNAAsLIAshAyAEIQALIAMgBU8NAEEAIQ0gAyEEIAUgA2tBB3EiBwRAA0AgACAELQAAOgAAIABBAWohACAEQQFqIQQgDUEBaiINIAdHDQALCyADIAVrQXhLDQADQCAAIAQtAAA6AAAgACAELQABOgABIAAgBC0AAjoAAiAAIAQtAAM6AAMgACAELQAEOgAEIAAgBC0ABToABSAAIAQtAAY6AAYgACAELQAHOgAHIABBCGohACAEQQhqIgQgBUcNAAsLIAEgASgCDCAIajYCDCABKAIEIQAgCEGAgARJDQAgAUEBNgIkIAEgACABKAIAa0EDdTYCKAsgACAJNgIAIAAgCDsBBCAMIQggBiEMIApBA2siA0H//wNNDQQMAwsCQAJAIA0gEE0NACANIA9qIgcoAAAgACgAAEcNACAHQQRqIQUgAEEEaiIGIBVPBEAgBiEEDAILIAYiBCgAACIIIAUoAAAiCUcEQCAIIAlzaEEDdgwECwNAIAVBBGohBSAEQQRqIgQgFU8NAiAEKAAAIgggBSgAACIJRg0ACyAEIAggCXNoQQN2aiAGawwDCyASIAQgCSAEIAVPIgBqIglqIgZJBEAgAyEADAcLIAUgAEEIdGohBSAcICVCgICA2Mub741PfiIlICeIpyIAQQZ2Qfz//x9xaigCACIKIABzIQcgBCEADAELCwJAIAQgH08NACAFLwAAIAQvAABHDQAgBUECaiEFIARBAmohBAsgBCAOSQR/IAQgBS0AACAELQAARmoFIAQLIAZrC0EEaiEKAkAgACADTQRAIAAhBQwBCyAAIQkgByEEIAAhBSANIBBMDQADQCAJQQFrIgUtAAAgBEEBayIELQAARwRAIAkhBQwCCyAKQQFqIQogAyAFTw0BIAUhCSAEIBNLDQALCyAAIAdrIgZBA2ohCSAFIANrIQggASgCDCEAAkACQCAFIAtNBEAgAykAACElIAAgAykACDcACCAAICU3AAAgASgCDCEEIAhBEE0EQCABIAQgCGo2AgwgASgCBCEADAMLIAMpABAhJSAEIAMpABg3ABggBCAlNwAQIAhBIUgNASAEIAhqIQcgA0EQaiEAIARBIGohAwNAIAApABAhJSADIAApABg3AAggAyAlNwAAIAApACAhJSADIAApACg3ABggAyAlNwAQIABBIGohACADQSBqIgMgB0kNAAsMAQsgAyALTQRAIAMpAAAhJSAAIAMpAAg3AAggACAlNwAAIAAgCyADayIHaiEEIAdBEU4EQCAAQRBqIQADQCADKQAQISUgACADKQAYNwAIIAAgJTcAACADKQAgISUgACADKQAoNwAYIAAgJTcAECADQSBqIQMgAEEgaiIAIARJDQALCyALIQMgBCEACyADIAVPDQBBACENIAMhBCAFIANrQQdxIgcEQANAIAAgBC0AADoAACAAQQFqIQAgBEEBaiEEIA1BAWoiDSAHRw0ACwsgAyAFa0F4Sw0AA0AgACAELQAAOgAAIAAgBC0AAToAASAAIAQtAAI6AAIgACAELQADOgADIAAgBC0ABDoABCAAIAQtAAU6AAUgACAELQAGOgAGIAAgBC0ABzoAByAAQQhqIQAgBEEIaiIEIAVHDQALCyABIAEoAgwgCGo2AgwgASgCBCEAIAhBgIAESQ0AIAFBATYCJCABIAAgASgCAGtBA3U2AigLIAAgCTYCACAAIAg7AQQgDCEIIAYhDCAKQQNrIgNB//8DTQ0BCyABQQI2AiQgASAAIAEoAgBrQQN1NgIoIAYhDAsgACADOwEGIAEgAEEIaiIDNgIEAkAgBSAKaiIAIBJLDQAgFCARIB1qKQAAQoCAgNjLm++NT34gJoinQQJ0aiARQQJqNgIAIBQgAEECayIEKQAAQoCAgNjLm++NT34gJoinQQJ0aiAE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BiAXSQ0ACwwCCwJAIBJFDQAgCEEeSQRAQQQgCHQhBkEAIQADQCAAQUBrIgAgBkkNAAsLIAVBHUsNAEEEIAV0IQZBACEAA0AgAEFAayIAIAZJDQALCyADIAkgCkZqIgYgF08NASANIBNqISAgDEEgayENIAxBAWshGiAMQQNrIRIgD0EBayEdQTggBWutISpBOCAIa60hKEHAACARa60hJkHAACALa60hJwNAIBUgBikAACIlQuPIlb3Lm++NT34iKSAniKdBAnRqIgAoAgAhCiAZICVCgIDs/Mub741PfiIrICaIp0ECdGoiESgCACEJIB8gKSAoiKciG0EGdkH8//8fcWooAgAhBSAiICsgKoinIiFBBnZB/P//H3FqKAIAIQggESAGIA5rIhE2AgAgACARNgIAAkACQAJAAkAgHSARQQFqIgsgBGsiAGtBA0kNACATIAAgFmtqIAAgDmogACAPSSIAGyIeKAAAIAYoAAFHDQAgBkEFaiAeQQRqIAwgFCAMIAAbIBAQDyEKIAZBAWoiBSADayEJIAEoAgwhAAJAAkAgBSANTQRAIAMpAAAhJSAAIAMpAAg3AAggACAlNwAAIAEoAgwhACAJQRBNBEAgASAAIAlqNgIMIAEoAgQhAwwDCyADKQAQISUgACADKQAYNwAYIAAgJTcAECAJQSFIDQEgACAJaiEGIANBEGohAyAAQSBqIQADQCADKQAQISUgACADKQAYNwAIIAAgJTcAACADKQAgISUgACADKQAoNwAYIAAgJTcAECADQSBqIQMgAEEgaiIAIAZJDQALDAELIAMgDU0EQCADKQAAISUgACADKQAINwAIIAAgJTcAACAAIA0gA2siC2ohCCALQRFOBEAgAEEQaiEAA0AgAykAECElIAAgAykAGDcACCAAICU3AAAgAykAICElIAAgAykAKDcAGCAAICU3ABAgA0EgaiEDIABBIGoiACAISQ0ACwsgDSEDIAghAAsgAyAFTw0AIAYgA2tBACEGIAUgA2tBB3EiCwRAA0AgACADLQAAOgAAIABBAWohACADQQFqIQMgBkEBaiIGIAtHDQALC0EHSQ0AA0AgACADLQAAOgAAIAAgAy0AAToAASAAIAMtAAI6AAIgACADLQADOgADIAAgAy0ABDoABCAAIAMtAAU6AAUgACADLQAGOgAGIAAgAy0ABzoA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BSEHIAlBBGogA2oiAyEGIAMgF00NAQwCCwsgBCEHIAUhBCADIQYLIAYgF0kNAAsMAQsCQCASRQ0AIAhBHkkEQEEEIAh0IQZBACEAA0AgAEFAayIAIAZJDQALCyAFQR1LDQBBBCAFdCEGQQAhAANAIABBQGsiACAGSQ0ACwsgAyAJIApGaiIGIBdPDQAgDSATaiEgIAxBIGshDSAMQQFrIRogDEEDayESIA9BAWshHUE4IAVrrSEqQTggCGutIShBwAAgEWutISZBwAAgC2utIScDQCAVIAYpAAAiJULjyJW9y5vvjU9+IikgJ4inQQJ0aiIAKAIAIQogGSAlQoCAgNjLm++NT34iKyAmiKdBAnRqIhEoAgAhCSAfICkgKIinIhtBBnZB/P//H3FqKAIAIQUgIiArICqIpyIhQQZ2Qfz//x9xaigCACEIIBEgBiAOayIRNgIAIAAgETYCAAJAAkACQAJAIB0gEUEBaiILIARrIgBrQQNJDQAgEyAAIBZraiAAIA5qIAAgD0kiABsiHigAACAGKAABRw0AIAZBBWogHkEEaiAMIBQgDCAAGyAQEA8hCiAGQQFqIgUgA2shCSABKAIMIQACQAJAIAUgDU0EQCADKQAAISUgACADKQAINwAIIAAgJTcAACABKAIMIQAgCUEQTQRAIAEgACAJajYCDCABKAIEIQMMAwsgAykAECElIAAgAykAGDcAGCAAICU3ABAgCUEhSA0BIAAgCWohBiADQRBqIQMgAEEgaiEAA0AgAykAECElIAAgAykAGDcACCAAICU3AAAgAykAICElIAAgAykAKDcAGCAAICU3ABAgA0EgaiEDIABBIGoiACAGSQ0ACwwBCyADIA1NBEAgAykAACElIAAgAykACDcACCAAICU3AAAgACANIANrIgtqIQggC0ERTgRAIABBEGohAANAIAMpABAhJSAAIAMpABg3AAggACAlNwAAIAMpACAhJSAAIAMpACg3ABggACAlNwAQIANBIGohAyAAQSBqIgAgCEkNAAsLIA0hAyAIIQALIAMgBU8NACAGIANrQQAhBiAFIANrQQdxIgsEQANAIAAgAy0AADoAACAAQQFqIQAgA0EBaiEDIAZBAWoiBiALRw0ACwtBB0kNAANAIAAgAy0AADoAACAAIAMtAAE6AAEgACADLQACOgACIAAgAy0AAzoA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dGogBjYCACAVICVC48iVvcub741PfiAniKdBAnRqIAY2AgAgBCEIIAUhByAJQQRqIANqIgMhBiADIBdNDQEMAgsLIAQhByAFIQQgAyEGCyAGIBdJDQALCyACIAc2AgQgAiAENgIAIAwgA2sLVwEBfyMAQRBrIgIkACABIAJBCGpBsicQDiIBKAIAIAEoAgQQECEBIAAoAgggARAXIAEgAkH0IxAOIgEoAgAgASgCBBAQIQEgACgCDCABEBcgAkEQaiQACz0BAX8jAEEQayICJAAgAEEIaiABIAJBCGpB+yIQDiIAKAIAIAAoAgQQECIAEC8gAEHdABAkGiACQRBqJAALNwEBfyMAQRBrIgIkACABIAJBCGpB8yUQDiIBKAIAIAEoAgQQECEBIAAoAgggARAXIAJBEGokAAu5AgECfyMAQTBrIgMkACABQSgQIiAAQRBqIAEQLyABQSkQISAAKAIIIgIEQCACIAEgAigCACgCFBEAAAsgACgCICICQQFxBEAgASADQShqQbIKEA4iAigCACACKAIEEBAaIAAoAiAhAgsgAkECcQR/IAEgA0EgakHSFRAOIgIoAgAgAigCBBAQGiAAKAIgBSACC0EEcQRAIAEgA0EYakHBCxAOIgIoAgAgAigCBBAQGgsCQCABAn8CQAJAIAAtACRBAWsOAgABAwsgA0EUaiECIANBEGpBvCUQDgwBCyADQQxqIQIgA0EIakG4JRAOCygCACACKAIAEBAaCyAAKAIYIgIEQCACIAEQFwsgACgCHARAIAEgA0H5JRAOIgEoAgAgASgCBBAQIQEgACgCHCABEBcLIANBMGokAAtdAQJ/IwBBEGsiAyQAAkAgACgCCCICRQ0AIAIgASACKAIAKAIQEQAAIAAoAgggARBcDQAgASADQQhqQc4pEA4iAigCACACKAIEEBAaCyAAKAIMIAEQFyADQRBqJAALVQEBfyMAQRBrIgIkACAAKAIIIAEQFyABIAJBCGpBkCUQDiIBKAIAIAEoAgQQECAAKAIMIAAoAhAQECACQY4lEA4iACgCACAAKAIEEBAaIAJBEGokAAsbACABIAAoAgggACgCDBAQIQEgACgCECABEBcLRQEBfyMAQRBrIgIkACABIAJBCGpB/goQDiIBKAIAIAEoAgQQECIBQSgQIiAAKAIIIAFBE0EAEC0gAUEpECEgAkEQaiQAC0EBAX8jAEEQayICJAAgASACQQhqQdAJEA4iASgCACABKAIEEBAiAUEoECIgAEEIaiABEC8gAUEpECEgAkEQaiQAC5UCAQJ/IwBBMGsiAyQAIAFBKBAiIABBDGogARAvIAFBKRAhIAAoAggiAiABIAIoAgAoAhQRAAAgACgCFCICQQFxBEAgASADQShqQbIKEA4iAigCACACKAIEEBAaIAAoAhQhAgsgAkECcQR/IAEgA0EgakHSFRAOIgIoAgAgAigCBBAQGiAAKAIUBSACC0EEcQRAIAEgA0EYakHBCxAOIgIoAgAgAigCBBAQGgsCQCABAn8CQAJAIAAtABhBAWsOAgABAwsgA0EUaiECIANBEGpBvCUQDgwBCyADQQxqIQIgA0EIakG4JRAOCygCACACKAIAEBAaCyAAKAIcBEAgAUEgECQhASAAKAIcIAEQFwsgA0EwaiQAC0EBAX8jAEEQayICJAAgACgCCCIAIAEgACgCACgCEBEAACABIAJBCGpBzikQDiIAKAIAIAAoAgQQEBogAkEQaiQAC1UBAX8jAEEQayICJAAgACgCCCABEBcgASACQQhqQfMiEA4iASgCACABKAIEEBAgACgCDCAAKAIQEBAgAkGkIRAOIgAoAgAgACgCBBAQGiACQRBqJAALUwEBfyMAQRBrIgIkACAAKAIIIAEQFyABIAJBCGpBzikQDiIBKAIAIAEoAgQQECAAKAIMIAAoAhAQECEBIAAoAhQiAARAIAAgARAXCyACQRBqJAALFgAgACgCDCIAIAEgACgCACgCFBEAAAudAQECfyAAKAIMIgMgASADKAIAKAIQEQAAIwBBIGsiAyQAIAAoAggiAkEBcQRAIAEgA0EYakGyChAOIgIoAgAgAigCBBAQGiAAKAIIIQILIAJBAnEEfyABIANBEGpB0hUQDiICKAIAIAIoAgQQEBogACgCCAUgAgtBBHEEQCABIANBCGpBwQsQDiIAKAIAIAAoAgQQEBoLIANBIGokAAsLACAAKAIMIAEQQwsLACAAKAIMIAEQPgsmACABIAAoAgggACgCDBAQQSgQJCEBIAAoAhAgARAXIAFBKRAkGgs3AQF/IwBBEGsiAiQAIAEgAkEIakHzCxAOIgEoAgAgASgCBBAQIQEgACgCCCABEBcgAkEQaiQAC6gCAQV/IwBBQGoiAiQAAkAgASgCFA0AIAAoAhAhAyAAKAIMIQQgAiACQThqQaQhEA4pAgA3AxAgBCADIAJBEGoQXUUEQCACIAJBMGpBjCEQDikCADcDCCAEIAMgAkEIahBdRQ0BCyABQSgQIkEBIQULIAAoAgggAUEPIAAvAAUQRCIDIANBEUYiBhsgA0ERRxAtIAAoAhAhAyAAKAIMIQQgAiACQShqQYwkEA4pAgA3AwAgBCADIAIQXUUEQCABIAJBIGpBzikQDiIDKAIAIAMoAgQQEBogACgCDCEEIAAoAhAhAwsgASAEIAMQECACQRhqQc4pEA4iASgCACABKAIEEBAhASAAKAIUIAEgAC8ABRBEIAYQLSAFBEAgAUEpECELIAJBQGskAAskACABIAAoAgggACgCDBAQIQEgACgCECABIAAvAAUQREEAEC0LIwAgACgCCCABIAAvAAUQREEBEC0gASAAKAIMIAAoAhAQEBoLLwAgACgCCCABIAAvAAUQREEAEC0gAUHbABAiIAAoAgwgAUETQQAQLSABQd0AECELNgAgACgCCCABIAAvAAUQREEBEC0gASAAKAIMIAAoAhAQECEBIAAoAhQgASAALwAFEERBABAtC9ABAQJ/IwBBIGsiAiQAIAAtABxBAUYEQCABIAJBGGpBiyMQDiIDKAIAIAMoAgQQEBoLIAEgAkEQakGIChAOIgEoAgAgASgCBBAQIQEgAC0AHUEBRgRAIAEgAkEIakGpGhAOIgMoAgAgAygCBBAQGgsgACgCDARAIAFBKBAiIABBCGogARAvIAFBKRAhCyABIAJBzikQDiIBKAIAIAEoAgQQECEBIAAoAhAgARAXIAAoAhgEQCABQSgQIiAAQRRqIAEQLyABQSkQIQsgAkEgaiQAC4cBAQJ/IwBBIGsiAiQAIAAtAAxBAUYEQCABIAJBGGpBiyMQDiIDKAIAIAMoAgQQEBoLIAEgAkEQakG8FRAOIgEoAgAgASgCBBAQIQEgAC0ADUEBRgRAIAEgAkEIakGpGhAOIgMoAgAgAygCBBAQGgsgAUEgECQhASAAKAIIIAEQFyACQSBqJAALIAAgACgCCCABEBcgAUEoECIgAEEMaiABEC8gAUEpECELLAAgAUEoECIgACgCCCABEBcgAUEpECEgAUEoECIgAEEMaiABEC8gAUEpECELcQEBfyMAQRBrIgIkACAAKAIIIAEgAC8ABRBEQQAQLSABIAJBCGpBjCkQDiIBKAIAIAEoAgQQECEBIAAoAgwgAUETQQAQLSABIAJBrCkQDiIBKAIAIAEoAgQQECEBIAAoAhAgAUERQQEQLSACQRBqJAALpQEBA38jAEEgayICJAAgAkEYaiABIAAoAgggACgCDBAQIgFBFGpBABBFIQMgASACQRBqQfMiEA4iASgCACABKAIEEBAhAQZAIAAoAhAiBCABIAQoAgAoAhARAAAZIAIkACADEDAJAAsgASACQQhqQaQhEA4iASgCACABKAIEEBAhASADEDAgAUEoECIgACgCFCABQRNBABAtIAFBKRAhIAJBIGokAAs5AQF/IwBBEGsiAiQAIAEgAkEIakHZDxAOIgEoAgAgASgCBBAQIAAoAgggACgCDBAQGiACQRBqJAAL+AEBA38jAEEwayICJAAgAiAANgIsIAIgATYCKCABQSgQIiAAKAIMIgNFIAAtABgiBEEBRnFFBEACQCAEBEAgAyABQQNBARAtDAELIAJBKGoQkQILIAEgAkEgakHOKRAOKQMAEC4gACkCEBAuIAJBGGpBzikQDikDABAuGgsgASACQRBqQeYjEA4pAwAQLiEBAkAgAC0AGEUEQCAAKAIMRQ0BCyABIAJBCGpBzikQDikDABAuIAApAhAQLiACQc4pEA4pAwAQLiEDIAAtABhBAUYEQCACQShqEJECDAELIAAoAgwgA0EDQQEQLQsgAUEpECEgAkEwaiQAC4wBAQJ/IwBBEGsiAyQAAkAgAC0AEEEBRgRAIAFB2wAQJCECIAAoAgggAhAXIAJB3QAQJBoMAQsgAUEuECQhAiAAKAIIIAIQFwsgACgCDCICLQAEQdEAa0H/AXFBAk8EfyABIANBCGpBlSkQDiICKAIAIAIoAgQQEBogACgCDAUgAgsgARAXIANBEGokAAuMAQECfyMAQRBrIgIkACABQdsAECQhASAAKAIIIAEQFyABIAJBCGpBuykQDiIBKAIAIAEoAgQQECEBIAAoAgwgARAXIAFB3QAQJCEBIAAoAhAiAy0ABEHRAGtB/wFxQQJPBH8gASACQZUpEA4iAygCACADKAIEEBAaIAAoAhAFIAMLIAEQFyACQRBqJAALLAAgAUEoECIgACgCCCABEBcgAUEpECEgAUEoECIgACgCDCABEBcgAUEpECELwwEBAn8jAEEgayIDJAAgASADQRhqQc4pEA4iASgCACABKAIEEBAhAQJAIAAtAAxFBEAgACgCEEUNAQsgAUH7ABAiCyAAKAIIIAEQFwJAIAAtAAxFBEAgACgCEEUNAQsgAUH9ABAhIAAtAAxBAXEEQCABIANBEGpB/QoQDiICKAIAIAIoAgQQEBoLIAAoAhBFDQAgASADQQhqQZApEA4iAigCACACKAIEEBAhAiAAKAIQIAIQFwsgAUE7ECQaIANBIGokAAs+AQF/IwBBEGsiAiQAIAEgAkEIakHNKBAOIgEoAgAgASgCBBAQIQEgACgCCCABEBcgAUE7ECQaIAJBEGokAAs+AQF/IwBBEGsiAiQAIAEgAkEIakH5JRAOIgEoAgAgASgCBBAQIQEgACgCCCABEBcgAUE7ECQaIAJBEGokAAuZAQECfyMAQRBrIgMkACABIANBCGpB9gwQDiIBKAIAIAEoAgQQECEBIAAoAgwEQCABQSAQJCICQSgQIiAAQQhqIAIQLyACQSkQIQsgAUEgECQiAkH7ABAiIAAoAhAiASAAKAIUEKYCIQADQCAAIAFGBEAgAkEgECRB/QAQISADQRBqJAAPCyABKAIAIAIQFyABQQRqIQEMAAsAC+gBAQN/IwBBMGsiAiQAIAAoAgwgARAXIAEgAkEoakHvIhAOIgEoAgAgASgCBBAQIQEgACgCCCABEBcgASACQSBqQeclEA4iASgCACABKAIEEBAhBAJAIAAoAhQiAUUEQCACQRhqQcojEA4oAgAhAyACKAIcIQEMAQsgACgCECIDLQAAQe4ARw0AIAQgAkEQakGCJBAOIgEoAgAgASgCBBAQGiACQQhqIAAoAhBBAWogACgCFEEBaxAqKAIAIQMgAigCDCEBCyAEIAMgARAQIAJBpCEQDiIAKAIAIAAoAgQQEBogAkEwaiQAC0oBAX8jAEEgayICJAAgASACQRhqQeAjEA4iASgCACABKAIEEBAiAUEoECIgAkEMaiAAKAIIENQBIAEQnQIgAUEpECEgAkEgaiQACywBAX8gACgCCCICBEAgAiABEBcLIABBDGogAUH7ABAkIgAQLyAAQf0AECQaCzcBAX8jAEEQayICJAAgASACQQhqQdYlEA4iASgCACABKAIEEBAhASAAKAIIIAEQFyACQRBqJAALQgEBfyMAQRBrIgIkACABIAJBCGpBiAgQDiIBKAIAIAEoAgQQECEBIAAoAggiACABIAAoAgAoAhARAAAgAkEQaiQACzcBAX8jAEEQayICJAAgASACQQhqQYsjEA4iASgCACABKAIEEBAhASAAKAIIIAEQFyACQRBqJAALZAECfyMAQRBrIgIkACAALQAMRQRAIAEgAkEIakGCKRAOIgMoAgAgAygCBBAQGgsgASACQZQLEA4iASgCACABKAIEEBAiAUEoECIgACgCCCABQRNBABAtIAFBKRAhIAJBEGokAAs0ACABIAAoAgggACgCDBAQIgFBKBAiIAAoAhAgARAXIAFBKRAhIAEgACgCFCAAKAIYEBAaC00BAX8jAEEQayICJAAgASACQQhqQawaEA4iASgCACABKAIEEBAhASAAKAIIIAEQFyABIAJBqhoQDiIAKAIAIAAoAgQQEBogAkEQaiQAC10BAX8jAEEQayICJAAgACgCCCABEBcgASACQQhqQbEaEA4iASgCACABKAIEEBAhASAAKAIMIgAEQCAAIAEQFwsgASACQaoaEA4iACgCACAAKAIEEBAaIAJBEGokAAuoAQEDfyMAQSBrIgMkACABKAIAIAEoAgQiBEUEQBAxAAsgBGpBAWssAABB3QBHBEAgASADQRhqQc4pEA4iAigCACACKAIEEBAaCyABIANBEGpBuBoQDiIBKAIAIAEoAgQQECEBIAAoAgwiAgRAIAIgARAXCyABIANBCGpBqhoQDiIBKAIAIAEoAgQQECEBIAAoAggiACABIAAoAgAoAhQRAAAgA0EgaiQACxYAIAAoAggiACABIAAoAgAoAhARAAALXQECfyMAQRBrIgIkAAJAIAAoAgwgARA+RQRAIAAoAgwgARBDRQ0BCyABIAJBCGpBjiUQDiIDKAIAIAMoAgQQEBoLIAAoAgwiACABIAAoAgAoAhQRAAAgAkEQaiQAC5sBAQJ/IwBBIGsiAiQAIAAoAgwiAyABIAMoAgAoAhARAAAgAQJ/AkAgACgCDCABED5FBEAgACgCDCABEENFDQELIAJBHGohAyACQRhqQZElEA4MAQsgAkEUaiEDIAJBEGpBzikQDgsoAgAgAygCABAQIQEgACgCCCABEBcgASACQQhqQbkkEA4iACgCACAAKAIEEBAaIAJBIGokAAsfACABIAAoAgggACgCDBAQQSAQJCEBIAAoAhAgARAXC1MBAn8jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARA7IQMGQCAAKAIMIgAgASAAKAIAKAIUEQAAGSACJAAgAxAlCQALIAMQJQsgAkEQaiQAC1MBAn8jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARA7IQMGQCAAKAIMIgAgASAAKAIAKAIQEQAAGSACJAAgAxAlCQALIAMQJQsgAkEQaiQAC1cBAn8jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARA7IQMGQCAAKAIMIgAgASAAKAIAKAIMEQEAIQAZIAIkACADECUJAAsgAxAlCyACQRBqJAAgAAtMAQN/IwBBEGsiAiQAIAAtABBFBEAgAkEIaiAAQRBqQQEQOyEEBkAgACgCDCABEEMhAxkgAiQAIAQQJQkACyAEECULIAJBEGokACADC0wBA38jAEEQayICJAAgAC0AEEUEQCACQQhqIABBEGpBARA7IQQGQCAAKAIMIAEQPiEDGSACJAAgBBAlCQALIAQQJQsgAkEQaiQAIAMLTAEDfyMAQRBrIgIkACAALQAQRQRAIAJBCGogAEEQakEBEDshBAZAIAAoAgwgARBcIQMZIAIkACAEECUJAAsgBBAlCyACQRBqJAAgAwuUAQECfyMAQRBrIgMkACAAKAIMQQRPBEAgAUEoECIgASAAKAIIIAAoAgwQEEEpECELAkAgACgCECICLQAAQe4ARgRAIAEQpAIgA0EIaiAAKAIQQQFqIAAoAhRBAWsQKikDABAuGgwBCyABIAIgACgCFBAQGgsgACgCDCICQQNNBEAgASAAKAIIIAIQEBoLIANBEGokAAs2AQF/IwBBEGsiAiQAIAEgAkEIakGuFUHDFSAALQAHGxAOIgAoAgAgACgCBBAQGiACQRBqJAAL2QEBBX8jAEEwayICJAAgACgCDEEITwRAIAAoAgghBSACQSxqIQNBACEAA0AgAEEIRkUEQCADQVBBqX8gACAFaiIELAABIgZBMGtBCkkbIAZqQQlBACAELAAAIgRBMGtBCk8bIARqQQR0ajoAACADQQFqIQMgAEECaiEADAELCyACQSxqIAMQ1QEgAkIANwMgIAJCADcDGCACQgA3AxAgAiACKgIsuzkDACABIAJBCGogAkEQaiIAIABBGEGqFSACEO8BECoiACgCACAAKAIEEBAaCyACQTBqJAAL3wEBBX8jAEFAaiICJAAgACgCDEEQTwRAIAAoAgghBSACQThqIQNBACEAA0AgAEEQRkUEQCADQVBBqX8gACAFaiIELAABIgZBMGtBCkkbIAZqQQlBACAELAAAIgRBMGtBCk8bIARqQQR0ajoAACADQQFqIQMgAEECaiEADAELCyACQThqIAMQ1QEgAkIANwMoIAJCADcDICACQgA3AxggAkIANwMQIAIgAisDODkDACABIAJBCGogAkEQaiIAIABBIEHsGSACEO8BECoiACgCACAAKAIEEBAaCyACQUBrJAAL2gEBBX8jAEHgAGsiAiQAIAAoAgxBIE8EQCAAKAIIIQUgAkHQAGohA0EAIQADQCAAQSBGRQRAIANBUEGpfyAAIAVqIgQsAAEiBkEwa0EKSRsgBmpBCUEAIAQsAAAiBEEwa0EKTxsgBGpBBHRqOgAAIANBAWohAyAAQQJqIQAMAQsLIAJB0ABqIAMQ1QEgAkEgaiIAQQBBKhAYGiACIAIpA1A3AwAgAiACKQNYNwMIIAEgAkEYaiAAIABBKkHwGiACEO8BECoiACgCACAAKAIEEBAaCyACQeAAaiQAC00BAX8jAEEQayICJAAgASACQQhqQfIiEA4iASgCACABKAIEEBAhASAAKAIIIAEQFyABIAJBySUQDiIAKAIAIAAoAgQQEBogAkEQaiQAC1sBAX8jAEEQayICJAAgASACQQhqQakaEA4iASgCACABKAIEEBAhASAAKAIIIgAtAARBNEYEQCAAIAEQrgILIAEgAkGKCBAOIgAoAgAgACgCBBAQGiACQRBqJAALaQEBfyMAQRBrIgIkACABQSgQIiAAKAIIIAEQFyABQSkQIQJAIAAoAgwtAABB7gBGBEAgARCkAiACQQhqIAAoAgxBAWogACgCEEEBaxAqKQMAEC4aDAELIAEgACkCDBAuGgsgAkEQaiQACzUBAX8gACgCDCABEFsgASgCDCICIAAoAgxJBEAgACgCCCACEFoiACABIAAoAgAoAhQRAAALCzUBAX8gACgCDCABEFsgASgCDCICIAAoAgxJBEAgACgCCCACEFoiACABIAAoAgAoAhARAAALCzgBAX8gACgCDCABEFsgASgCDCICIAAoAgxJBH8gACgCCCACEFoiACABIAAoAgAoAgwRAQAFIAALCy0BAn8gACgCDCABEFsgASgCDCIDIAAoAgxJBH8gACgCCCADEFogARBDBSACCwstAQJ/IAAoAgwgARBbIAEoAgwiAyAAKAIMSQR/IAAoAgggAxBaIAEQPgUgAgsLLQECfyAAKAIMIAEQWyABKAIMIgMgACgCDEkEfyAAKAIIIAMQWiABEFwFIAILC3ABAn8jAEEgayICJAAgAkEYaiABQRRqQQAQRSEDBkAgAEEIaiABIAJBEGpB8yIQDiIAKAIAIAAoAgQQECIAEC8ZIAIkACADEDAJAAsgACACQQhqQaQhEA4iACgCACAAKAIEEBAaIAMQMCACQSBqJAALJAECfyAAKAIEIgAQTUEBaiIBECMiAgR/IAIgACABEBQFQQALCxQAIAAoAgggARAXIAAoAgwgARAXC3cBAn8jAEEQayIDJAACQCAAKAIIIgItAARBC0YEQCACKAIIEKcCDQELAkAgAiABED5FBEAgACgCCCABEENFDQELIAEgA0EIakGOJRAOIgIoAgAgAigCBBAQGgsgACgCCCIAIAEgACgCACgCFBEAAAsgA0EQaiQAC/MBAQJ/IwBBMGsiAiQAIAECfwJAIAAoAggiAy0ABEELRgRAIAMoAggQpwINAQsgAyABIAMoAgAoAhARAAAgACgCCCABED4EQCABIAJBKGpBzikQDiIDKAIAIAMoAgQQEBoLAkAgACgCCCABED5FBEAgACgCCCABEENFDQELIAEgAkEgakGRJRAOIgAoAgAgACgCBBAQGgsgAkEcaiEAIAJBGGpBxiQQDgwBCyACQQxqIQAgASACQRBqQeAiEA4iASgCACABKAIEEBAgAygCDCADKAIQEBAaIAJBCGpBpCEQDgsoAgAgACgCABAQGiACQTBqJAALpgEBAn8jAEEgayICJAAgAC0AEEUEQCACQRhqIABBEGpBARA7IQMGQAJAIAJBEGogACgCCCAAKAIMIAEQqAIgAigCFCIARQ0AAkAgACABED5FBEAgAigCFCABEENFDQELIAEgAkEIakGOJRAOIgAoAgAgACgCBBAQGgsgAigCFCIAIAEgACgCACgCFBEAAAsZIAIkACADECUJAAsgAxAlCyACQSBqJAAL8AEBAn8jAEEwayICJAAgAC0AEEUEQCACQShqIABBEGpBARA7IQMCQAJAAkAGQCACQSBqIAAoAgggACgCDCABEKgCIAIoAiQiAEUNAyAAIAEgACgCACgCEBEAACACKAIkIAEQPgRAIAEgAkEYakHOKRAOIgAoAgAgACgCBBAQGgsgAigCJCABED4NASACKAIkIAEQQyEAGSACJAAgAxAlCQALIABFDQELIAEgAkEQakGRJRAOIgAoAgAgACgCBBAQGgsgASACQQhqQbklQb0lIAIoAiAbEA4iACgCACAAKAIEEBAaCyADECULIAJBMGokAAsnAQF/IAAoAggiAiABIAIoAgAoAhARAAAgASAAKAIMIAAoAhAQEBoLNAEBfyMAQRBrIgIkACABIAJBCGpBiCMQDikDABAuIAIgABCrAiACKQMAEC4aIAJBEGokAAtUAQF/AkACQAJAIAAoAggiAkUNACACIAEQFyAAKAIIRQ0AQTpBLiAALQAQQQFxGyECDAELQTohAiAALQAQQQFHDQELIAEgAhAkGgsgACgCDCABEBcLTAEBfyMAQRBrIgIkACABIAJBCGpBxhkQDiIBKAIAIAEoAgQQECAAKAIIIAAoAgwQECACQaElEA4iACgCACAAKAIEEBAaIAJBEGokAAvjAQIEfwJ+IwBBIGsiAiQAAkAgAQJ/AkACQAJAIAAoAggOAwABAgQLIAJBHGohAyACQRhqQcsaEA4MAgsgAkEUaiEDIAJBEGpB6hoQDgwBCyACQQxqIQMgAkEIakHHGhAOCygCACADKAIAEBAaCyAAKAIMIgAEQCAAQQFrrSEGIwBBIGsiAyQAIANBIGoiBCEAA0AgAEEBayIAIAZCCoAiB0L2AX4gBnynQTByOgAAIAZCCVYgByEGDQALIAEgAyAAIAQgAGsQKiIAKAIAIAAoAgQQEBogA0EgaiQACyACQSBqJAALCwAgACgCCCABEBcLKwAjAEEQayIAJAAgASAAQQhqQc4oEA4iASgCACABKAIEEBAaIABBEGokAAs2AQF/IwBBEGsiAiQAIAAoAgggARAXIAEgAkEIakHOKRAOIgAoAgAgACgCBBAQGiACQRBqJAALHwAgACgCCCABEBcgACgCDCIAIAEgACgCACgCFBEAAAtOAQJ/IwBBEGsiAiQAIAAoAgwiAyABIAMoAgAoAhARAAAgACgCDCABEFxFBEAgASACQQhqQc4pEA4iACgCACAAKAIEEBAaCyACQRBqJAALSAEBfyMAQRBrIgIkACAAKAIIIAEQFyAAKAIUBEAgASACQQhqQfklEA4iASgCACABKAIEEBAhASAAKAIUIAEQFwsgAkEQaiQAC3ABAn8jAEEgayICJAAgAkEYaiABQRRqQQAQRSEDBkAgAEEMaiABIAJBEGpB1iIQDiIAKAIAIAAoAgQQECIAEC8ZIAIkACADEDAJAAsgACACQQhqQcwoEA4iACgCACAAKAIEEBAaIAMQMCACQSBqJAALFgAgACgCCCIAIAEgACgCACgCFBEAAAtBAQF/IwBBEGsiAiQAIAAoAggiACABIAAoAgAoAhARAAAgASACQQhqQeYjEA4iACgCACAAKAIEEBAaIAJBEGokAAtQAQF/IwBBEGsiAiQAIAAgASACQQhqQeQZEA4iASgCACABKAIEEBAgACgCICAAKAIkEBAgAkGhJRAOIgAoAgAgACgCBBAQEK4CIAJBEGokAAsMACAAIAEpAgg3AgALEQAgASAAKAIIIAAoAgwQEBoLGQAgAUHbABAiIABBCGogARAvIAFB3QAQIQuNAQEBfyMAQTBrIgIkACABIAJBKGpBiCMQDikDABAuIAJBIGogACAAKAIAKAIYEQAAIAIpAyAQLiEBIAAoAggQsAIEQCABIAJBGGpB/R4QDikDABAuIQEgACgCCEECRgRAIAEgAkEQakGbHxAOKQMAEC4aCyABIAJBCGpBpCEQDikDABAuGgsgAkEwaiQAC1sBAn8jAEEQayICJAAgAC0ADEEBRgRAIAEgAkEIakGICBAOIgMoAgAgAygCBBAQGgsgAiAAKAIIIgAgACgCACgCGBEAACABIAIoAgAgAigCBBAQGiACQRBqJAALNwEBfyMAQRBrIgIkACABIAJBCGpBhCYQDiIBKAIAIAEoAgQQECEBIAAoAgggARAXIAJBEGokAAs3AQF/IwBBEGsiAiQAIAEgAkEIakHEKRAOIgEoAgAgASgCBBAQIQEgACgCCCABEBcgAkEQaiQACx0AIAAoAgwgARAXIAFBwAAQJCEBIAAoAgggARAXC2ABAn8jAEEQayICJAAgACgCCCIDIAEgAygCACgCEBEAACABIAJBCGpB9SIQDiIBKAIAIAEoAgQQECAAKAIMIAAoAhAQECACQaoaEA4iACgCACAAKAIEEBAaIAJBEGokAAtAAQF/IwBBEGsiAiQAIAAoAgggARAXIAEgAkEIakHwKBAOIgEoAgAgASgCBBAQIQEgACgCDCABEBcgAkEQaiQACwMAAAsHACAAEEsaCwIACwQAIAALuQcCCX8BfiMAQRBrIgckACAHIAA2AgwgABBgKAIAIgsoAgQhCiAHQQA2AgggB0EIaiEIIwBBwCNrIgkkAAJAIAoiAEUEQCAIRQ0BIAhBfTYCAAwBCwJ/AkAGQAJAIAlBIGoiAyAAEE0gAGo2AgQgAyAANgIAIANBCGoQjwIgA0GUAWoQjwIgA0GgAmoQpwEaIANBzAJqENIBGiADQegCahDSARogA0IANwKMAyADQX82AogDIANBADoAhgMgA0EBOwGEAyADQQA2ApQDIANCADcDmAMgA0GYA2oiACAANgKAICADIQAjAEHgAGsiBCQAIAQgBEHYAGpBwBoQDikCADcDIAJAAkAgACAEQSBqEBpFBEAgBCAEQdAAakG/GhAOKQIANwMYIAAgBEEYahAaRQ0BCyAEIAAQUSIFNgJMIAVFBEBBACEFDAILIAAoAgAiBiAAKAIEIgNBABAZQS5GBEAgAEGYA2ogBEHEAGogBiADIAZrECohA0EUEBIgBCgCTCEGIAMpAgAhDEEBQQBBAUEBQQEQFiIDIAw3AgwgAyAGNgIIIANByNYBNgIAIAMhBSAAIAAoAgQiAzYCACADIQYLQQAgBSAGIAMQOhshBQwBCyAEIARBPGpBvhoQDikCADcDEAJAIAAgBEEQahAaRQRAIAQgBEE0akG9GhAOKQIANwMIIAAgBEEIahAaRQ0BCyAEIAAQUSIDNgJMIANFDQEgBCAEQSxqQegVEA4pAgA3AwAgACAEEBpFDQEgAEHfABARIQMgBEHEAGogAEEAEChBACADIAQoAkgbDQEgACgCACIGIAAoAgQiA0EAEBlBLkYEfyAAIAM2AgAgAwUgBgsgAxA6DQEgAEGZKCAEQcwAahDSAiEFDAELQQAgABAbIAAoAgAgACgCBBA6GyEFCyAEQeAAaiQAIAVFBEBBfiEGQQAMBAsgCUEIaiIDQv////8fNwIQIANCgICAgHA3AgggA0IANwIAIAAoAugCIAAoAuwCELIBRQ0AIAUgAxAXDAILGSAJJAAgABDUAgkACxAxAAtBACEGIANBABAkKAIACyEDIAgEQCAIIAY2AgALIAAQ1AILIAlBwCNqJAACQCAHKAIIIANFckUEQCABIAM2AgAMAQsgAxAVIAEgChBNQQFqECMiADYCACAAIAoQ1QILIAJBADYCAEGQlQEgCyAHQQxqEOkBBEAgAiAHKAIMIgAgACgCACgCCBEEACIAEE1BAWoQIyIBNgIAIAEgABDVAgsgB0EQaiQACwoAIAAQ7QEQ3wILCQAgABDTAhAVCwUAQc8ZCwUAQfUPCwUAEDEACxsAIAAgASgCCCAFED8EQCABIAIgAyAEENsCCwuSAQAgACABKAIIIAQQPwRAIAEgAiADENoCDwsCQCAAIAEoAgAgBBA/RQ0AAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0BIAFBATYCIA8LIAEgAjYCFCABIAM2AiAgASABKAIoQQFqNgIoAkAgASgCJEEBRw0AIAEoAhhBAkcNACABQQE6ADYLIAFBBDYCLAsLGQAgACABKAIIQQAQPwRAIAEgAiADENkCCwsyACAAIAEoAghBABA/BEAgASACIAMQ2QIPCyAAKAIIIgAgASACIAMgACgCACgCHBELAAv2AQAgACABKAIIIAQQPwRAIAEgAiADENoCDwsCQCAAIAEoAgAgBBA/BEACQCACIAEoAhBHBEAgASgCFCACRw0BCyADQQFHDQIgAUEBNgIgDwsgASADNgIgAkAgASgCLEEERg0AIAFBADsBNCAAKAIIIgAgASACIAJBASAEIAAoAgAoAhQRDQAgAS0ANUEBRgRAIAFBAzYCLCABLQA0RQ0BDAMLIAFBBDYCLAsgASACNgIUIAEgASgCKEEBajYCKCABKAIkQQFHDQEgASgCGEECRw0BIAFBAToANg8LIAAoAggiACABIAIgAyAEIAAoAgAoAhgRDAALCzgAIAAgASgCCCAFED8EQCABIAIgAyAEENsCDwsgACgCCCIAIAEgAiADIAQgBSAAKAIAKAIUEQ0ACwoAIAAgAUEAED8LBQAQVAAL7AECBH8BfiMAQRBrIgEkAAJAQYDwASgCACIARQ0AIAApAzAiBBDuAUUNACABIARCgdasmfTIk6bDAFIEfyAAQdAAagUgACgCLAs2AgwgACgCACICKAIEIQMjAEEQayIAJAAgAEEgNgIMIAFBBGogAxDqAUEEaiAAKAIMEOoBGiAAQRBqJAAGQEGQlQEgAiABQQxqEOkBIQAZIAEkACABQQRqIgEoAgAhACABQQA2AgAgAARAIwAhAgZAIAAgASgCBBEGABkgAiQAEFQACwsJAAsgAEUNACABKAIMIgEgASgCACgCCBEEABoLEDEACxQAIAAEQCAAEGBBLGpBARDdAhoLCx4AIABBAUcEQCABEO0BKAIMEOwBAAsgAUEgahDeAguoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGEBQaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEEBQaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACC+ESASh/IwBB0IABayIFJAAgBUEAQYSAARAYIgRBDDYCAAJAIAQgAiADEPMCIgVBiH9LDQAgAyAFTQRAQbh/IQUMAQsgAyAFayILQQpJBEBBbCEFDAELIAIgBWoiAy8AACIHIAMvAAIiCGogAy8ABCIJakEGaiIRIAtLBEBBbCEFDAELIAdFBEBBuH8hBQwBCyAEKAIAIRMgA0EGaiIFIAdqIQIgBCAFNgLMgAECQCAHQQRPBEAgBCACQQRrIgM2AsiAASAEIAMoAAAiAzYCwIABIANBgICACEkEQEF/IQUMAwsgBEEIIANBGHZnQR9zazYCxIABDAELIAQgBTYCyIABIAQgAy0ABiIFNgLAgAECQAJAAkAgB0ECaw4CAQACCyADLQAIQRB0IAVyIQULIAQgAy0AB0EIdCAFajYCwIABC0F/IQUgAkEBay0AACIDRQ0BIAQgA2cgB0EDdGtBCWo2AsSAAQsgCEUEQEG4fyEFDAELIAIgCGohAyAEIAI2AryAAQJAIAhBBE8EQCAEIANBBGsiAjYCuIABIAQgAigAACICNgKwgAEgAkGAgIAISQRAQX8hBQwDCyAEQQggAkEYdmdBH3NrNgK0gAEMAQsgBCACNgK4gAEgBCACLQAAIgU2ArCAAQJAAkACQCAIQQJrDgIBAAILIAItAAJBEHQgBXIhBQsgBCACLQABQQh0IAVqNgKwgAELQX8hBSADQQFrLQAAIgJFDQEgBCACZyAIQQN0a0EJajYCtIABC0G4fyEFIAlFDQAgAyAJaiECIAQgAzYCrIABAkAgCUEETwRAIAQgAkEEayIDNgKogAEgBCADKAAAIgM2AqCAASADQYCAgAhJBEBBfyEFDAMLIARBCCADQRh2Z0Efc2s2AqSAAQwBCyAEIAM2AqiAASAEIAMtAAAiBTYCoIABAkACQAJAIAlBAmsOAgEAAgsgAy0AAkEQdCAFciEFCyAEIAMtAAFBCHQgBWo2AqCAAQtBfyEFIAJBAWstAAAiA0UNASAEIANnIAlBA3RrQQlqNgKkgAELIARBkIABaiIHIAIgCyARaxC6ASIFQYh/Sw0AIAAgAUEDakECdiICaiIXIAJqIhggAmohESAAIAFqISQgBEEEciEKIARBwIABahAmIQIgBEGwgAFqECYhAyAEQaCAAWoQJiEFIAcQJiEHIAQoApCAASEZIAQoAqCAASEUIAQoArCAASEVIAQoAsCAASEWAkACQCAHIAUgAiADcnJyDQAgESAkQQdrIiVPDQAgBCgCnIABIhpBBGohJiAEKAKsgAEiG0EEaiEnIAQoAryAASIcQQRqISggBCgCzIABIh1BBGohKUEAIBNrQR9xIQ8gBCgCmIABIRAgBCgCqIABIQwgBCgCuIABIQ0gBCgCyIABIQ4gBCgClIABIQggBCgCpIABIQMgBCgCtIABIQUgBCgCxIABIQkgESECIBghByAXIQsDQCAAIAogFiAJdCAPdkECdGoiBi8BADsAACAGLQACIRIgBi0AAyEeIAsgCiAVIAV0IA92QQJ0aiIGLwEAOwAAIAYtAAIhHyAGLQADISAgByAKIBQgA3QgD3ZBAnRqIgYvAQA7AAAgBi0AAiEhIAYtAAMhIiACIAogGSAIdCAPdkECdGoiBi8BADsAACAGLQACISMgBi0AAyEGIAAgHmoiHiAKIBYgCSASaiIJdCAPdkECdGoiAC8BADsAACAALQACIRIgAC0AAyEqIAsgIGoiCyAKIBUgBSAfaiIFdCAPdkECdGoiAC8BADsAACAALQACIR8gAC0AAyEgIAcgImoiIiAKIBQgAyAhaiIDdCAPdkECdGoiAC8BADsAACAALQACIQcgAC0AAyACIAZqIisgCiAZIAggI2oiI3QgD3ZBAnRqIggvAQA7AAAgBSAfaiEAAkAgCSASaiICQSBLBEAgAiEJQQMhBgwBCyAOIClPBEAgAkEHcSEJIA4gAkEDdmsiDigAACEWQQAhBgwBCyAOIB1GBEBBAkEBIAJBIEYbIQYgHSEOIAIhCQwBCyACIA4gHWsgAkEDdiICIA4gAmsgHUkiBhsiAkEDdGshCSAOIAJrIg4oAAAhFgsgCC0AAiADIAdqIQJBAyEHAkAgAEEgSwRAIAAhBUEDIQMMAQsgDSAoTwRAIABBB3EhBSANIABBA3ZrIg0oAAAhFUEAIQMMAQsgDSAcRgRAQQJBASAAQSBGGyEDIBwhDSAAIQUMAQsgACANIBxrIABBA3YiACANIABrIBxJIgMbIgBBA3RrIQUgDSAAayINKAAAIRULICNqIQAgAyAGcgJAIAJBIEsEQCACIQMMAQsgDCAnTwRAIAJBB3EhAyAMIAJBA3ZrIgwoAAAhFEEAIQcMAQsgDCAbRgRAQQJBASACQSBGGyEHIBshDCACIQMMAQsgAiAMIBtrIAJBA3YiAiAMIAJrIBtJIgcbIgJBA3RrIQMgDCACayIMKAAAIRQLIAgtAAMhAiAHciESQQMhBgJAIABBIEsEQCAAIQgMAQsCQCAQICZPBEAgAEEHcSEIIABBA3YhAEEAIQYMAQsgECAaRgRAIBohECAAIQgMAgsgACAQIBprIABBA3YiACAQIABrIBpJIgYbIgBBA3RrIQgLIBAgAGsiECgAACEZCyAeICpqIQAgCyAgaiELICJqIQcgBiASckUgJSACICtqIgJLcQ0ACyAEIAU2ArSAASAEIAk2AsSAASAEIAM2AqSAASAEIAg2ApSAASAEIA42AsiAASAEIA02AriAASAEIAw2AqiAASAEIBA2ApiAAQwBCyAXIQsgGCEHIBEhAgsgBCAVNgKwgAEgBCAWNgLAgAEgBCAUNgKggAEgBCAZNgKQgAEgACAXSwRAQWwhBQwBCyALIBhLBEBBbCEFDAELQWwhBSAHIBFLDQAgACAEQcCAAWogFyAKIBMQNiALIARBsIABaiAYIAogExA2IAcgBEGggAFqIBEgCiATEDYgAiAEQZCAAWogJCAKIBMQNkFsQWxBbEFsQWxBbEFsQWwgASAEKAKUgAFBIEcbIAQoApiAASAEKAKcgAFHGyAEKAKkgAFBIEcbIAQoAqiAASAEKAKsgAFHGyAEKAK0gAFBIEcbIAQoAriAASAEKAK8gAFHGyAEKALEgAFBIEcbIAQoAsiAASAEKALMgAFHGyEFCyAEQdCAAWokACAFC9MRASR/IwBB0MAAayITJAAgE0EAQYLAABAYIgRBDDsBAAJAIAQgAiADEPUCIgZBiH9LDQAgAyAGTQRAQbh/IQYMAQsgAyAGayITQQpJBEBBbCEGDAELIAIgBmoiCy8AACIHIAsvAAIiDWogCy8ABCIFakEGaiIDIBNLBEBBbCEGDAELIAdFBEBBuH8hBgwBCyAELwEAIRggC0EGaiICIAdqIQkgBCACNgLMQAJAIAdBBE8EQCAEIAlBBGsiAjYCyEAgBCACKAAAIgI2AsBAIAJBgICACEkEQEF/IQYMAwsgBEEIIAJBGHZnQR9zazYCxEAMAQsgBCACNgLIQCAEIAstAAYiCjYCwEACQAJAAkAgB0ECaw4CAQACCyALLQAIQRB0IApyIQoLIAQgCy0AB0EIdCAKajYCwEALQX8hBiAJQQFrLQAAIgJFDQEgBCACZyAHQQN0a0EJajYCxEALIA1FBEBBuH8hBgwBCyAJIA1qIQcgBCAJNgK8QAJAIA1BBE8EQCAEIAdBBGsiAjYCuEAgBCACKAAAIgI2ArBAIAJBgICACEkEQEF/IQYMAwsgBEEIIAJBGHZnQR9zazYCtEAMAQsgBCAJNgK4QCAEIAktAAAiBjYCsEACQAJAAkAgDUECaw4CAQACCyAJLQACQRB0IAZyIQYLIAQgCS0AAUEIdCAGajYCsEALQX8hBiAHQQFrLQAAIgJFDQEgBCACZyANQQN0a0EJajYCtEALQbh/IQYgBUUNACAFIAdqIQ0gBCAHNgKsQAJAIAVBBE8EQCAEIA1BBGsiAjYCqEAgBCACKAAAIgI2AqBAIAJBgICACEkEQEF/IQYMAwsgBEEIIAJBGHZnQR9zazYCpEAMAQsgBCAHNgKoQCAEIActAAAiBjYCoEACQAJAAkAgBUECaw4CAQACCyAHLQACQRB0IAZyIQYLIAQgBy0AAUEIdCAGajYCoEALQX8hBiANQQFrLQAAIgJFDQEgBCACZyAFQQN0a0EJajYCpEALIARBkMAAaiIIIA0gEyADaxC6ASIGQYh/Sw0AIAAgAUEDakECdiICaiITIAJqIgMgAmohDSAAIAFqISIgBEECciEOIARBwMAAahAmIQsgBEGwwABqECYhByAEQaDAAGoQJiEFIAgQJiECIAQoApBAIRcgBCgCoEAhGSAEKAKwQCEaIAQoAsBAIRsCQAJAIAIgBSAHIAtycnINACANICJBB2siI08NACAEKAKcQCIcQQRqISQgBCgCrEAiHUEEaiElIAQoArxAIh5BBGohJiAEKALMQCIfQQRqISdBACAYa0EfcSEUIAQoAphAIRUgBCgCqEAhDyAEKAK4QCEQIAQoAshAIREgBCgClEAhCCAEKAKkQCEKIAQoArRAIQYgBCgCxEAhCSANIQIgAyELIBMhBwNAIA4gGyAJdCAUdkEBdGoiBS0AASEWIAAgBS0AADoAACAOIBogBnQgFHZBAXRqIgUtAAEhDCAHIAUtAAA6AAAgDiAZIAp0IBR2QQF0aiIFLQABISAgCyAFLQAAOgAAIA4gFyAIdCAUdkEBdGoiBS0AASEhIAIgBS0AADoAACAOIBsgCSAWaiISdCAUdkEBdGoiBS0AASEWIAAgBS0AADoAASAOIBogBiAMaiIMdCAUdkEBdGoiBS0AASAHIAUtAAA6AAEgDiAZIAogIGoiCnQgFHZBAXRqIgUtAAEhBiALIAUtAAA6AAEgDiAXIAggIWoiIHQgFHZBAXRqIgUtAAEhISACIAUtAAA6AAEgDGohDAJAIBIgFmoiBUEgSwRAIAUhCUEDIRYMAQsgESAnTwRAIAVBB3EhCSARIAVBA3ZrIhEoAAAhG0EAIRYMAQsgESAfRgRAQQJBASAFQSBGGyEWIB8hESAFIQkMAQsgBSARIB9rIAVBA3YiBSARIAVrIB9JIhYbIgVBA3RrIQkgESAFayIRKAAAIRsLIAYgCmohCEEDIRICQCAMQSBLBEAgDCEGQQMhCgwBCyAQICZPBEAgDEEHcSEGIBAgDEEDdmsiECgAACEaQQAhCgwBCyAQIB5GBEBBAkEBIAxBIEYbIQogHiEQIAwhBgwBCyAMIBAgHmsgDEEDdiIFIBAgBWsgHkkiChsiBUEDdGshBiAQIAVrIhAoAAAhGgsgICAhaiEFIAogFnICQCAIQSBLBEAgCCEKDAELIA8gJU8EQCAIQQdxIQogDyAIQQN2ayIPKAAAIRlBACESDAELIA8gHUYEQEECQQEgCEEgRhshEiAdIQ8gCCEKDAELIAggDyAdayAIQQN2IgggDyAIayAdSSISGyIIQQN0ayEKIA8gCGsiDygAACEZCyASckEDIRICQCAFQSBLBEAgBSEIDAELAn8gFSAkTwRAIAVBA3YhF0EAIRIgBUEHcQwBCyAVIBxGBEAgHCEVIAUhCAwCCyAFIBUgHGsgBUEDdiIFIBUgBWsgHEkiEhsiF0EDdGsLIQggFSAXayIVKAAAIRcLIAtBAmohCyAHQQJqIQcgAEECaiEAIBJyRSAjIAJBAmoiAktxDQALIAQgBjYCtEAgBCAJNgLEQCAEIAo2AqRAIAQgCDYClEAgBCARNgLIQCAEIBA2ArhAIAQgDzYCqEAgBCAVNgKYQAwBCyATIQcgAyELIA0hAgsgBCAaNgKwQCAEIBs2AsBAIAQgGTYCoEAgBCAXNgKQQCAAIBNLBEBBbCEGDAELIAMgB0kEQEFsIQYMAQtBbCEGIAsgDUsNACAAIARBwMAAaiATIA4gGBAzIAcgBEGwwABqIAMgDiAYEDMgCyAEQaDAAGogDSAOIBgQMyACIARBkMAAaiAiIA4gGBAzQWxBbEFsQWxBbEFsQWxBbCABIAQoApRAQSBHGyAEKAKYQCAEKAKcQEcbIAQoAqRAQSBHGyAEKAKoQCAEKAKsQEcbIAQoArRAQSBHGyAEKAK4QCAEKAK8QEcbIAQoAsRAQSBHGyAEKALIQCAEKALMQEcbIQYLIARB0MAAaiQAIAYLCwBBsO8BKAIAEBUL4RIBKH8jAEHQgAFrIgUkACAFQQBBhIABEBgiBEEMNgIAAkAgBCACIAMQ+AIiBUGIf0sNACADIAVNBEBBuH8hBQwBCyADIAVrIgtBCkkEQEFsIQUMAQsgAiAFaiIDLwAAIgcgAy8AAiIIaiADLwAEIglqQQZqIhEgC0sEQEFsIQUMAQsgB0UEQEG4fyEFDAELIAQoAgAhEyADQQZqIgUgB2ohAiAEIAU2AsyAAQJAIAdBBE8EQCAEIAJBBGsiAzYCyIABIAQgAygAACIDNgLAgAEgA0GAgIAISQRAQX8hBQwDCyAEQQggA0EYdmdBH3NrNgLEgAEMAQsgBCAFNgLIgAEgBCADLQAGIgU2AsCAAQJAAkACQCAHQQJrDgIBAAILIAMtAAhBEHQgBXIhBQsgBCADLQAHQQh0IAVqNgLAgAELQX8hBSACQQFrLQAAIgNFDQEgBCADZyAHQQN0a0EJajYCxIABCyAIRQRAQbh/IQUMAQsgAiAIaiEDIAQgAjYCvIABAkAgCEEETwRAIAQgA0EEayICNgK4gAEgBCACKAAAIgI2ArCAASACQYCAgAhJBEBBfyEFDAMLIARBCCACQRh2Z0Efc2s2ArSAAQwBCyAEIAI2AriAASAEIAItAAAiBTYCsIABAkACQAJAIAhBAmsOAgEAAgsgAi0AAkEQdCAFciEFCyAEIAItAAFBCHQgBWo2ArCAAQtBfyEFIANBAWstAAAiAkUNASAEIAJnIAhBA3RrQQlqNgK0gAELQbh/IQUgCUUNACADIAlqIQIgBCADNgKsgAECQCAJQQRPBEAgBCACQQRrIgM2AqiAASAEIAMoAAAiAzYCoIABIANBgICACEkEQEF/IQUMAwsgBEEIIANBGHZnQR9zazYCpIABDAELIAQgAzYCqIABIAQgAy0AACIFNgKggAECQAJAAkAgCUECaw4CAQACCyADLQACQRB0IAVyIQULIAQgAy0AAUEIdCAFajYCoIABC0F/IQUgAkEBay0AACIDRQ0BIAQgA2cgCUEDdGtBCWo2AqSAAQsgBEGQgAFqIgcgAiALIBFrELoBIgVBiH9LDQAgACABQQNqQQJ2IgJqIhcgAmoiGCACaiERIAAgAWohJCAEQQRyIQogBEHAgAFqECYhAiAEQbCAAWoQJiEDIARBoIABahAmIQUgBxAmIQcgBCgCkIABIRkgBCgCoIABIRQgBCgCsIABIRUgBCgCwIABIRYCQAJAIAcgBSACIANycnINACARICRBB2siJU8NACAEKAKcgAEiGkEEaiEmIAQoAqyAASIbQQRqIScgBCgCvIABIhxBBGohKCAEKALMgAEiHUEEaiEpQQAgE2tBH3EhDyAEKAKYgAEhECAEKAKogAEhDCAEKAK4gAEhDSAEKALIgAEhDiAEKAKUgAEhCCAEKAKkgAEhAyAEKAK0gAEhBSAEKALEgAEhCSARIQIgGCEHIBchCwNAIAAgCiAWIAl0IA92QQJ0aiIGLwEAOwAAIAYtAAIhEiAGLQADIR4gCyAKIBUgBXQgD3ZBAnRqIgYvAQA7AAAgBi0AAiEfIAYtAAMhICAHIAogFCADdCAPdkECdGoiBi8BADsAACAGLQACISEgBi0AAyEiIAIgCiAZIAh0IA92QQJ0aiIGLwEAOwAAIAYtAAIhIyAGLQADIQYgACAeaiIeIAogFiAJIBJqIgl0IA92QQJ0aiIALwEAOwAAIAAtAAIhEiAALQADISogCyAgaiILIAogFSAFIB9qIgV0IA92QQJ0aiIALwEAOwAAIAAtAAIhHyAALQADISAgByAiaiIiIAogFCADICFqIgN0IA92QQJ0aiIALwEAOwAAIAAtAAIhByAALQADIAIgBmoiKyAKIBkgCCAjaiIjdCAPdkECdGoiCC8BADsAACAFIB9qIQACQCAJIBJqIgJBIEsEQCACIQlBAyEGDAELIA4gKU8EQCACQQdxIQkgDiACQQN2ayIOKAAAIRZBACEGDAELIA4gHUYEQEECQQEgAkEgRhshBiAdIQ4gAiEJDAELIAIgDiAdayACQQN2IgIgDiACayAdSSIGGyICQQN0ayEJIA4gAmsiDigAACEWCyAILQACIAMgB2ohAkEDIQcCQCAAQSBLBEAgACEFQQMhAwwBCyANIChPBEAgAEEHcSEFIA0gAEEDdmsiDSgAACEVQQAhAwwBCyANIBxGBEBBAkEBIABBIEYbIQMgHCENIAAhBQwBCyAAIA0gHGsgAEEDdiIAIA0gAGsgHEkiAxsiAEEDdGshBSANIABrIg0oAAAhFQsgI2ohACADIAZyAkAgAkEgSwRAIAIhAwwBCyAMICdPBEAgAkEHcSEDIAwgAkEDdmsiDCgAACEUQQAhBwwBCyAMIBtGBEBBAkEBIAJBIEYbIQcgGyEMIAIhAwwBCyACIAwgG2sgAkEDdiICIAwgAmsgG0kiBxsiAkEDdGshAyAMIAJrIgwoAAAhFAsgCC0AAyECIAdyIRJBAyEGAkAgAEEgSwRAIAAhCAwBCwJAIBAgJk8EQCAAQQdxIQggAEEDdiEAQQAhBgwBCyAQIBpGBEAgGiEQIAAhCAwCCyAAIBAgGmsgAEEDdiIAIBAgAGsgGkkiBhsiAEEDdGshCAsgECAAayIQKAAAIRkLIB4gKmohACALICBqIQsgImohByAGIBJyRSAlIAIgK2oiAktxDQALIAQgBTYCtIABIAQgCTYCxIABIAQgAzYCpIABIAQgCDYClIABIAQgDjYCyIABIAQgDTYCuIABIAQgDDYCqIABIAQgEDYCmIABDAELIBchCyAYIQcgESECCyAEIBU2ArCAASAEIBY2AsCAASAEIBQ2AqCAASAEIBk2ApCAASAAIBdLBEBBbCEFDAELIAsgGEsEQEFsIQUMAQtBbCEFIAcgEUsNACAAIARBwIABaiAXIAogExA2IAsgBEGwgAFqIBggCiATEDYgByAEQaCAAWogESAKIBMQNiACIARBkIABaiAkIAogExA2QWxBbEFsQWxBbEFsQWxBbCABIAQoApSAAUEgRxsgBCgCmIABIAQoApyAAUcbIAQoAqSAAUEgRxsgBCgCqIABIAQoAqyAAUcbIAQoArSAAUEgRxsgBCgCuIABIAQoAryAAUcbIAQoAsSAAUEgRxsgBCgCyIABIAQoAsyAAUcbIQULIARB0IABaiQAIAUL0xEBJH8jAEHQwABrIhMkACATQQBBgsAAEBgiBEEMOwEAAkAgBCACIAMQ+gIiBkGIf0sNACADIAZNBEBBuH8hBgwBCyADIAZrIhNBCkkEQEFsIQYMAQsgAiAGaiILLwAAIgcgCy8AAiINaiALLwAEIgVqQQZqIgMgE0sEQEFsIQYMAQsgB0UEQEG4fyEGDAELIAQvAQAhGCALQQZqIgIgB2ohCSAEIAI2AsxAAkAgB0EETwRAIAQgCUEEayICNgLIQCAEIAIoAAAiAjYCwEAgAkGAgIAISQRAQX8hBgwDCyAEQQggAkEYdmdBH3NrNgLEQAwBCyAEIAI2AshAIAQgCy0ABiIKNgLAQAJAAkACQCAHQQJrDgIBAAILIAstAAhBEHQgCnIhCgsgBCALLQAHQQh0IApqNgLAQAtBfyEGIAlBAWstAAAiAkUNASAEIAJnIAdBA3RrQQlqNgLEQAsgDUUEQEG4fyEGDAELIAkgDWohByAEIAk2ArxAAkAgDUEETwRAIAQgB0EEayICNgK4QCAEIAIoAAAiAjYCsEAgAkGAgIAISQRAQX8hBgwDCyAEQQggAkEYdmdBH3NrNgK0QAwBCyAEIAk2ArhAIAQgCS0AACIGNgKwQAJAAkACQCANQQJrDgIBAAILIAktAAJBEHQgBnIhBgsgBCAJLQABQQh0IAZqNgKwQAtBfyEGIAdBAWstAAAiAkUNASAEIAJnIA1BA3RrQQlqNgK0QAtBuH8hBiAFRQ0AIAUgB2ohDSAEIAc2AqxAAkAgBUEETwRAIAQgDUEEayICNgKoQCAEIAIoAAAiAjYCoEAgAkGAgIAISQRAQX8hBgwDCyAEQQggAkEYdmdBH3NrNgKkQAwBCyAEIAc2AqhAIAQgBy0AACIGNgKgQAJAAkACQCAFQQJrDgIBAAILIActAAJBEHQgBnIhBgsgBCAHLQABQQh0IAZqNgKgQAtBfyEGIA1BAWstAAAiAkUNASAEIAJnIAVBA3RrQQlqNgKkQAsgBEGQwABqIgggDSATIANrELoBIgZBiH9LDQAgACABQQNqQQJ2IgJqIhMgAmoiAyACaiENIAAgAWohIiAEQQJyIQ4gBEHAwABqECYhCyAEQbDAAGoQJiEHIARBoMAAahAmIQUgCBAmIQIgBCgCkEAhFyAEKAKgQCEZIAQoArBAIRogBCgCwEAhGwJAAkAgAiAFIAcgC3Jycg0AIA0gIkEHayIjTw0AIAQoApxAIhxBBGohJCAEKAKsQCIdQQRqISUgBCgCvEAiHkEEaiEmIAQoAsxAIh9BBGohJ0EAIBhrQR9xIRQgBCgCmEAhFSAEKAKoQCEPIAQoArhAIRAgBCgCyEAhESAEKAKUQCEIIAQoAqRAIQogBCgCtEAhBiAEKALEQCEJIA0hAiADIQsgEyEHA0AgDiAbIAl0IBR2QQF0aiIFLQABIRYgACAFLQAAOgAAIA4gGiAGdCAUdkEBdGoiBS0AASEMIAcgBS0AADoAACAOIBkgCnQgFHZBAXRqIgUtAAEhICALIAUtAAA6AAAgDiAXIAh0IBR2QQF0aiIFLQABISEgAiAFLQAAOgAAIA4gGyAJIBZqIhJ0IBR2QQF0aiIFLQABIRYgACAFLQAAOgABIA4gGiAGIAxqIgx0IBR2QQF0aiIFLQABIAcgBS0AADoAASAOIBkgCiAgaiIKdCAUdkEBdGoiBS0AASEGIAsgBS0AADoAASAOIBcgCCAhaiIgdCAUdkEBdGoiBS0AASEhIAIgBS0AADoAASAMaiEMAkAgEiAWaiIFQSBLBEAgBSEJQQMhFgwBCyARICdPBEAgBUEHcSEJIBEgBUEDdmsiESgAACEbQQAhFgwBCyARIB9GBEBBAkEBIAVBIEYbIRYgHyERIAUhCQwBCyAFIBEgH2sgBUEDdiIFIBEgBWsgH0kiFhsiBUEDdGshCSARIAVrIhEoAAAhGwsgBiAKaiEIQQMhEgJAIAxBIEsEQCAMIQZBAyEKDAELIBAgJk8EQCAMQQdxIQYgECAMQQN2ayIQKAAAIRpBACEKDAELIBAgHkYEQEECQQEgDEEgRhshCiAeIRAgDCEGDAELIAwgECAeayAMQQN2IgUgECAFayAeSSIKGyIFQQN0ayEGIBAgBWsiECgAACEaCyAgICFqIQUgCiAWcgJAIAhBIEsEQCAIIQoMAQsgDyAlTwRAIAhBB3EhCiAPIAhBA3ZrIg8oAAAhGUEAIRIMAQsgDyAdRgRAQQJBASAIQSBGGyESIB0hDyAIIQoMAQsgCCAPIB1rIAhBA3YiCCAPIAhrIB1JIhIbIghBA3RrIQogDyAIayIPKAAAIRkLIBJyQQMhEgJAIAVBIEsEQCAFIQgMAQsCfyAVICRPBEAgBUEDdiEXQQAhEiAFQQdxDAELIBUgHEYEQCAcIRUgBSEIDAILIAUgFSAcayAFQQN2IgUgFSAFayAcSSISGyIXQQN0awshCCAVIBdrIhUoAAAhFwsgC0ECaiELIAdBAmohByAAQQJqIQAgEnJFICMgAkECaiICS3ENAAsgBCAGNgK0QCAEIAk2AsRAIAQgCjYCpEAgBCAINgKUQCAEIBE2AshAIAQgEDYCuEAgBCAPNgKoQCAEIBU2AphADAELIBMhByADIQsgDSECCyAEIBo2ArBAIAQgGzYCwEAgBCAZNgKgQCAEIBc2ApBAIAAgE0sEQEFsIQYMAQsgAyAHSQRAQWwhBgwBC0FsIQYgCyANSw0AIAAgBEHAwABqIBMgDiAYEDMgByAEQbDAAGogAyAOIBgQMyALIARBoMAAaiANIA4gGBAzIAIgBEGQwABqICIgDiAYEDNBbEFsQWxBbEFsQWxBbEFsIAEgBCgClEBBIEcbIAQoAphAIAQoApxARxsgBCgCpEBBIEcbIAQoAqhAIAQoAqxARxsgBCgCtEBBIEcbIAQoArhAIAQoArxARxsgBCgCxEBBIEcbIAQoAshAIAQoAsxARxshBgsgBEHQwABqJAAgBgsHACAAEQkAC/t0Akl/A34jAEHQHWsiFyQAIAEoAgAgASABLAALIgRBAEgiBRshGgJAIAEoAgQgBCAFGyIPQf/9g3hNBEAgD0EIdiAPakGAgAggD2tBC3ZBACAPQYCACEkbaiIdDQELQbh/IR0LQbDvASAdECMiITYCACAXQQhqIgNBAEHIHRAYGiAXQQE2AjQgF0EDNgJAIwBBwAJrIggkACAPQYGAEEkgD0GBgAhJaiAPQYGAAUlqQYQFbEEWIAIiASABQRZPG0EAIAFBAE4bQQMgARtBHGxqIgRB6DNqKAIAIQYgBEHYM2ooAgAhBSAEQdQzaigCACELIARB0DNqKAIAIQIgD0GAgICAAk0EQCACQQZBICAPQQFrZ2sgD0HAAEkbIg4gAiAOSRshAgsgBEHkM2ooAgAhDiAEQeAzaigCACEJIARB3DNqKAIAIQQgBSACQQFqIgcgBSAHSRshBSACIAZBBUsiB2ogCyALIAdrIAJLGyELIAZBBmsiB0F9TwRAIAVBBEEGIAQgBEEGTxsiDCAMQQRNG0EYciIMIAUgDEkbIQULIANB5AJqQQBBpAEQGCEMIAMgAUEDIAEbIhQ2ApADIANBATYChAMgAyAGNgKAAyADIAk2AvgCIAMgBDYC9AIgAyAFNgLwAiADIAs2AuwCIANBCiACIAJBCk0bNgLoAiADQQBBgIB4IAEgAUGAgHhNG2sgDiABQQBIGzYC/AICQAJAIAdBfE0EQEECIQEgA0ECNgLoAyAGQQZLDQEgA0ECNgLkAwwCC0ECIQEgA0ECNgLkAyADQQFBAiACQRFLGzYC6AMMAQsgA0EBQQIgAkEQSxs2AuQDQQFBAiACQRpLGyEBCyAPrSFNIANBATYC3AUgA0GAgAg2AogEIAMgATYCuAMgA0ECQQEgFEEKSBs2AowEIANBuAFqIAxBrAEQFCEvIAMoArwBIQECQCADKAKMAiICQQFHBEAgAygAmAIhDQwBCyADIAE2AqACIAMoApgCIg1FBEAgA0HAADYCmAJBwAAhDQsgAygCkAIiBEUEQCADQQYgAUEHayIEIARBBk0bIgQ2ApACCyADKAKUAiEFIAMoApwCRQRAIAMgASAEayIGQQAgASAGTxs2ApwCCyADIAVBAyAFGyIFIAQgBCAFSxs2ApQCC0EBIRQgAygC3AIiBEIBIAGtIkyGIk4gTSBNIE5WG6dBASAPGyIFIAQgBUkbIg5BA0EDQQQgAygC2AIiCxsgAygCzAEiB0EDRhsiKG4hCSACQQFGBEAgDiANbiEZCyADKALYECADQdwQaigCAGtBgICA+HlNBEAgAygC4AVFIRQLIAMoArwCIQYCf0EAIAMoAtQBIgVBAUYNABogBkEBRgRAQQAgBUEDa0EDSQ0BGgtBBCADKALAAXQLIQwCQEEBIAMoAsQBIgp0QT9qQUBxQQAgBUEGa0F9TxtBACAGQQFGGyAEQYCACCAEGyIEQgEgTIYiTCBNIEwgTVQbp0EBIA8bIgYgBCAGSRsiBCAobiIQQQN0QT9qQUBxQcCOCUGAASAFQQZLG0GoqwFB4I0BIAMoAsgFIgYbakEEQREgASABQRFPG0EAIAdBA0YbIgF0QQAgARtqIARqIARBA25BBHRBzwBqQUBxQQAgCxtqIAxqIBBBA2xqQQQgCnRqQQEgAygAkAIiASADKACUAmsiBUEAIAEgBU8bdEEIIAF0akEAIAJBAUYiARtqamogAQR/IAQgDW4FQQALQQxsQT9qQUBxQQAgAkEBRhtqIgFBiH9LBEAgASECDAELIAZFBEAgAyADKAK4BEEBajYCuAQLAkAgAygCrAQgAygCpARrIAFBA2xPBH8gAygCuARBgAFKBUEAC0UgAygCnAQiBSADKAKYBCIEayABT3FFBEBBQCECIAYNAiADKALABSEGIAMoArwFIQUgA0EANgLABCADQgA3ArgEIANCADcCsAQgA0IANwKoBCADQgA3AqAEIANCADcCmAQCQCAERQ0AIAUEQCAGIAQgBREAAAwBCyAEEBULAn8gAygCuAUiBARAIAMoAsAFIAEgBBEBAAwBCyABECMLIgRFDQIgA0EANgLABCADIAQ2AqgEIAMgBDYCoAQgAyAENgKYBCADQgA3ArgEIANBADoAtAQgAyABIARqIgU2ApwEIAMgBDYCpAQgAyAFQUBxIgo2ArAEIAMgCjYCrAQgAUHzI0wEQCADQQA2AtAQIANBAToAtAQMAwsgAyAENgLQECADIARB9CNqIgI2AqgEIAMgAjYCoAQgAyACNgKkBCABQefHAE0EQCADQQA2AtQQIANBAToAtARBQCECDAMLIAMgAjYC1BAgAyAEQejHAGoiAjYCqAQgAyACNgKgBCADIAI2AqQEIAFBv40BTQRAIANBADYCuBIgA0EBOgC0BEFAIQIMAwsgA0G0BGohCyADQbwEaiEMIAMgAjYCuBIgAyAEQcCNAWoiATYCqAQgAyABNgKgBCADIAE2AqQEQQEhFAwBCyADQQA6ALQEIAMgBUFAcSIKNgKsBCADIAMoAqAEIgE2AqQEIANBtARqIQsgA0G8BGohDCADKAK8BEECSQ0AIANBATYCvAQLIAMgAykCvAE3ApASIANBqBJqIAMoAtQBNgIAIANBoBJqIAMpAswBNwIAIANBmBJqIAMpAsQBNwIAIAMgAygC0AJBAUY2ArASIANCADcD0AQgAyBNQgF8NwPIBCADQgA3A9gEIAMgDjYCxARBACEEIANB4ARqQQBB2AAQGCE1IANC+erQ0OfJoeThADcDgAUgA0LP1tO+0ser2UI3A/AEIANC1uuC7ur9ifXgADcD6AQgA0IANwOQBCADQQE2AgAgAygC0BAiAkEANgLkIyACQgA3AtwjIAJBADYChAggAkHwI2pB2IIBKAIANgIAIAJB6CNqQdCCASkCADcCACADKAK8AiEHAn9BACADKALUASICQQFGDQAaIAdBAUYEQEEAIAJBA2tBA0kNARoLQQQgAygCwAF0CyESIAMoAsQBIRAgAygCzAFBA0YEQEERIAMoArwBIgIgAkERTxshBAsCfyAURQRAIAMoAtgQIQYgA0HcEGooAgAMAQsgA0HOKTYC4BAgA0EANgLsEEHQKSEGIANB0Ck2AtgQIAMgATYCqAQgA0HcEGpBzik2AgBBzikLIQIgA0EANgK0EiADIAQ2AvgQIANBADYCjBIgA0EANgLkESADQQA2AvAQIAMgBiACayICNgLoECADIAI2AvQQIAMgAjYC5BAgAyABNgKkBAJ/AkACQCADKAK8BARAIAEhAgwBCyADIAE2AqgEIAMgBUFAcSIGNgKwBCAFIAFBACABa0E/cSIUaiICSQ0BIAMgAjYCoAQgAyACNgKkBCAUBEAgAyACNgKoBAsgA0EBNgK8BAsCfyAKIAJBBCAQdGoiAUkEQCADQQE6ALQEQQAhBiACIQFBAQwBCyADIAE2AqQEIAIhBkEACyEFQQQgBHQhFCADIAY2ArQRIAMCfyAKIAEgEmoiAkkEQEEBIQUgA0EBOgC0BCABIQJBAAwBCyADIAI2AqQEIAELNgK8ESAKIAIgFEEAIAQbaiIBSQRAIANBADYCuBEgA0EBOgC0BEFAIQIMAwsgAyACNgK4ESADIAE2AqQEIAUEQEFAIQIMAwsgA0G4EWoMAQsgA0EANgK8ESADIAY2ArAEIANCADcCtBEgA0G4EWoLITsgASADKAKoBCICSwRAIAJBACABIAJrEBgaIAMoAqgEIQIgAygCpAQhAQsgASACSwRAIAMgATYCqAQgASECCyAHQQFHIAMoAtQBIgRBBmtBfUlyRQRAAkAgAygCvARFBEAgAyADKAKgBCICNgKoBCADIAMoApwEIgZBQHE2ArAEQQAhBSAGIAJBACACa0E/cSIHaiIBSQ0BIAMgATYCoAQgAyABNgKkBCAHBEAgAyABNgKoBCABIQILIANBATYCvAQLQQAhBUEBIBB0QT9qQUBxIgdFDQAgASADKAKsBCAHayIGSwRAIANBAToAtAQMAQsgAiAGSwRAIAMgBjYCqAQLIAMgBjYCrAQgAygCsAQiASAGSwRAIAMgBkEAIAEgBmsiASAHIAEgB0kbEBg2ArAEIAMoAtQBIQQLIAYhBQsgAyAFNgKAESADIAMoAsQBQQRBBiADKALIASIBIAFBBk8bIgEgAUEETRtrNgL8ECADIAMpA6gRIkxCKIkgTEIPiYUgTIVCpb7j9NGMh9mff34iTEIjiEIIfCBMhUKlvuP00YyH2Z9/fiJOIE4gAzUCsBEiTEIoiSBMQg+GhSBMhUKlvuP00YyH2Z9/fiJMQiOIQgR8IEyFQqW+4/TRjIfZn39+IkyFQhyIhSBMhTcDqBELIARBB08EQAJAAkAgAygCvAQiAUEBTQRAAkAgAQ0AIAMgAygCoAQiATYCqAQgAyADKAKcBCICQUBxIgU2ArAEQQAhBCACIAFBACABa0E/cSIGaiIBSQ0CIAMgATYCoAQgAyABNgKkBCAGRQ0AIAMgATYCqAQLIANBAjYCvAQLIAMCfyADKAKsBCIBQYAIayIEIAMoAqQEIgJJBEAgA0EBOgC0BCABIQRBAAwBCyADKAKoBCAESwRAIAMgBDYCqAQLIAMgBDYCrAQgBAs2AsgRIAMCfyACIARBwAFrIgVLBEAgA0EBOgC0BCAEIQVBAAwBCyADKAKoBCAFSwRAIAMgBTYCqAQLIAMgBTYCrAQgBQs2AswRIAMCfyACIAVBgAJrIgRLBEAgA0EBOgC0BCAFIQRBAAwBCyADKAKoBCAESwRAIAMgBDYCqAQLIAMgBDYCrAQgBAs2AtARIAMCfyACIARBgAFrIgVLBEAgA0EBOgC0BCAEIQVBAAwBCyADKAKoBCAFSwRAIAMgBTYCqAQLIAMgBTYCrAQgBQs2AtQRIAMCfyACIAVBwIACayIESwRAIANBAToAtAQgBSEEQQAMAQsgAygCqAQgBEsEQCADIAQ2AqgECyADIAQ2AqwEIAQLNgLYESACIARBwIAHayIESwRAIANBAToAtARBACEEDAILIAMoAqgEIARLBEAgAyAENgKoBAsgAyAENgKsBAwBCyADIAU2ArAEIANCADcDyBEgA0EANgLQESADQgA3AtQRCyADIAQ2AtwRCyADQZASaiIBIAMpArwBNwIAIAEgAygC1AE2AhggASADKQLMATcCECABIAMpAsQBNwIIIAMtALQEBEBBQCECDAELAkAgDCgCACIBQQFNBEACQCABDQAgAyADKAKgBCIENgKoBCADIAMoApwEIgVBQHE2ArAEQQAhAUEAIQIgBSAEQQAgBGtBP3EiBmoiBEkNAiADIAQ2AqAEIAMgBDYCpAQgBkUNACADIAQ2AqgECyAMQQI2AgBBAiEBC0EAIQIgCUEDdEE/akFAcSIERQ0AIAMoAqwEIARrIgIgAygCpARJBEAgC0EBOgAAQQAhAgwBCyADKAKoBCACSwRAIAMgAjYCqAQLIAMgAjYCrAQLIAMgAjYC5AUgAygCjAJBAUYEQEEIIAMoApACdCEEAkAgAUEBTQRAIAMgAygCoAQiAjYCqAQgAyADKAKcBCIFQUBxNgKwBEEAIQEgBSACQQAgAmtBP3EiBmoiAkkNASADIAI2AqAEIAMgAjYCpAQgBgRAIAMgAjYCqAQLIAxBAjYCAAtBACEBIARBP2pBQHEiAkUNACADKAKsBCACayIBIAMoAqQESQRAIAtBAToAAEEAIQEMAQsgAygCqAQgAUsEQCADIAE2AqgECyADIAE2AqwECyADIAE2AqgGIAFBACAEEBgaAkAgAygCvAQiAUEBTQRAAkAgAQ0AIAMgAygCoAQiBDYCqAQgAyADKAKcBCIFQUBxNgKwBEEAIQFBACECIAUgBEEAIARrQT9xIgZqIgRJDQIgAyAENgKgBCADIAQ2AqQEIAZFDQAgAyAENgKoBAsgDEECNgIAQQIhAQsgGUEMbEE/akFAcSICRQRAQQAhAgwBCyADKAKsBCACayICIAMoAqQESQRAIAtBAToAAEEAIQIMAQsgAygCqAQgAksEQCADIAI2AqgECyADIAI2AqwECyADIBk2ArgQIAMgAjYCtBAgA0KCgICAIDcCnAYgA0HOKTYCmAYgA0HOKTYClAYgA0EANgKsBiADQQA2AqQGIANB0Ck2ApAGCyADKALYAgRAIAMgDkEDbkEBaiIFNgLAHQJAIAFBAU0EQCADIAMoAqAEIgQ2AqgEIAMgAygCnAQiBkFAcTYCsARBACEBQQAhAiAGIARBACAEa0E/cSIHaiIESQ0BIAMgBDYCoAQgAyAENgKkBCAHBEAgAyAENgKoBAsgDEECNgIAQQIhAQtBACECIAVBBHRBP2pBQHEiBEUNACADKAKsBCAEayICIAMoAqQESQRAIAtBAToAAEEAIQIMAQsgAygCqAQgAksEQCADIAI2AqgECyADIAI2AqwECyADIAI2ArwdCwJAAkAgAUECTQRAAkAgAQ0AIAMgAygCoAQiAjYCqAQgAyADKAKcBCIEQUBxIgU2ArAEQQAhASAEIAJBACACa0E/cSIGaiICSQ0CIAMgAjYCoAQgAyACNgKkBCAGRQ0AIAMgAjYCqAQLIAxBAzYCAEEDIQELQQAhAgJAIA5BYEYNACADKAKsBCAOa0EgayICIAMoAqQESQRAIAtBAToAAEEAIQIMAQsgAygCqAQgAksEQCADIAI2AqgECyADIAI2AqwECyADQQA2AsQSIAMgDjYChAYgAyACNgLsBSADQQA2AtgSIANCADcCvBIMAQsgA0EANgLEEiADIA42AoQGIANBADYC7AUgA0EANgLYEiADQgA3ArwSIAMgBTYCsAQLIANBADYC1BIgAygCjAJBAUYEQEEBIAMoApACIAMoApQCa3QhAiABQQJNBEAgAyADKAKgBCIBNgKoBCADIAMoApwEQUBxNgKwBCADIAFBACABa0E/cSIEaiIBNgKkBCADIAE2AqAEIAQEQCADIAE2AqgECyAMQQM2AgALIAMoAqwEIAJrIgEgAygCqARJBEAgAyABNgKoBAsgAyABNgKwBiADIAE2AqwEIAFBACACEBgaCwJAIAMoAgAiBEEBRw0AIAMoAowCQQFGDQAgA0IANwK8ECADQcwQakEANgIAIANBxBBqQgA3AgALIAMgCTYCgAYCQAJAIAMoArwEIgFBAk0EQAJAIAENACADIAMoAqAEIgI2AqgEIAMgAygCnAQiBUFAcSIGNgKwBEEAIQEgBSACQQAgAmtBP3EiB2oiAkkNAiADIAI2AqAEIAMgAjYCpAQgB0UNACADIAI2AqgECyAMQQM2AgALQQAhAUEAIQICQCAOIChJIgUNACADKAKsBCAJayICIAMoAqQESQRAIAtBAToAAEEAIQIMAQsgAygCqAQgAksEQCADIAI2AqgECyADIAI2AqwECyADIAI2AvQFAkAgBQ0AIAMoAqwEIAlrIgEgAygCpARJBEAgC0EBOgAAQQAhAQwBCyADKAKoBCABSwRAIAMgATYCqAQLIAMgATYCrAQLIAMgATYC+AVBACEBIAUNASADKAKsBCAJayIBIAMoAqQESQRAIAtBAToAAEEAIQEMAgsgAygCqAQgAUsEQCADIAE2AqgECyADIAE2AqwEDAELIAMgBjYCsAQgA0IANwL0BQsgA0EBNgLgBSADIAE2AvwFIANCADcDkARBRCECIARFDQBBACESIB0hFCAhISggBEEBRgRAIAMpA8gEQgF9IUwgAygCvAEhBCADKALcAUEAIQEgAygC2AEiBQRAIExC/wFWIExC/4EEVmogTEL+////D1ZqIQELIB1BEkkEQEG6fyECDAILQQBKQQJ0QSBBACAFQQBHIExBASAEdK1YcSIFG3IgAUEGdHIhBkEAIQIgLygCAEUEQCAhQajqvmk2AABBBCECCyACICFqIAY6AAAgAkEBciESIAVFBEAgEiAhaiAEQQN0QdAAazoAACACQQJyIRILAkACQAJAAkACQCABQQFrDgMBAgMACyAFRQ0DIBIgIWogTDwAACASQQFqIRIMAwsgEiAhaiBMp0GAAms7AAAgEkECaiESDAILIBIgIWogTD4AACASQQRqIRIMAQsgEiAhaiBMNwAAIBJBCHIhEgsgA0ECNgIAIBIgIWohKCAdIBJrIRRBAiEECyAPBEACQCADKALAEUEARyADKALYECIBIBpHciIGRQRAIAMoAuQQIQEgAygC6BAhBSADKALgECECDAELIAMgAygC5BAiBTYC6BAgAyADQdwQaiIEKAIAIgI2AuAQIAMgASACayIBNgLkECAEIBogAWs2AgAgASAFa0EHSw0AIAMgATYC6BAgASEFCyADIA8gGmoiBDYC2BAgBCACIAVqTSABIAJqIBpNckUEQCADIAQgAmsiAiABIAEgAkobNgLoEAsgBgRAIAMgATYC9BAgA0EANgLAEQsCQCADKAKMAkEBRw0AAkAgGiADKAKQBiIBRgRAIAMoApwGIQEgAygCoAYhBSADKAKYBiECDAELIAMgAygCnAYiBTYCoAYgAyADKAKUBiICNgKYBiADIAEgAmsiATYCnAYgAyAaIAFrNgKUBiABIAVrQQdLDQAgAyABNgKgBiABIQULIAMgBDYCkAYgBCACIAVqTSABIAJqIBpNcg0AIAMgBCACayICIAEgASACShs2AqAGCyADKAK8ASEBIAMoAsQEIRAgAygC3AEEQCA1IBogDxCSAQsgA0HkBWohHkEBIAF0ITEgA0GoFGohGyADQYAVaiE2IAhBnAFqITwgCEEMaiE9IANB3BBqITIgA0HUFGohHCAoIQ4DQCAaIQwgFEEGSQRAQbp/IQIMAwsCfyAMIA8gECI3IA8gEEkbIhBqIhogMigCACIBayIEQYCAgIB6TQRAIAMoAvAQDAELIAMgAygCoAQ2AqgEIAMgAygC7BBBAWo2AuwQIDIgDEEBIAMoAsABIAMoAtQBQQVLa3QiAkEBIAMoArwBdCIEIAIgBEsbIAwgAWsiASACQQFrcSIEakECIAIgAkECTRtBACAEQQJJG2oiAms2AgAgAyABIAJrIgIgAygC4BBqNgLgECADQQIgAygC6BAiASACayABIAJBAmoiBEkbNgLoECADQQIgAygC5BAiASACayABIARJGzYC5BAgAygCtBFBASADKALEAXQgAhDIASADKALUASEBAkACQCADKALEEQ0AIAFBAUYNASABQQNrQQJLDQAgAygCvAJBAUYNAQtBASADKALAAXQhBiADKAK8ESELIAFBBkYEQEEAIQVBACEHIAZBEEgNASAGQRBtIQkDQCALIAVBAnRqIgFBASABKAIAIgYgAmtBACAEIAZNGyAGQQFGGzYCACABQQEgASgCBCIGIAJrQQAgBCAGTRsgBkEBRhs2AgQgAUEBIAEoAggiBiACa0EAIAQgBk0bIAZBAUYbNgIIIAFBASABKAIMIgYgAmtBACAEIAZNGyAGQQFGGzYCDCABQQEgASgCECIGIAJrQQAgBCAGTRsgBkEBRhs2AhAgAUEBIAEoAhQiBiACa0EAIAQgBk0bIAZBAUYbNgIUIAFBASABKAIYIgYgAmtBACAEIAZNGyAGQQFGGzYCGCABQQEgASgCHCIGIAJrQQAgBCAGTRsgBkEBRhs2AhwgAUEBIAEoAiAiBiACa0EAIAQgBk0bIAZBAUYbNgIgIAFBASABKAIkIgYgAmtBACAEIAZNGyAGQQFGGzYCJCABQQEgASgCKCIGIAJrQQAgBCAGTRsgBkEBRhs2AiggAUEBIAEoAiwiBiACa0EAIAQgBk0bIAZBAUYbNgIsIAFBASABKAIwIgYgAmtBACAEIAZNGyAGQQFGGzYCMCABQQEgASgCNCIGIAJrQQAgBCAGTRsgBkEBRhs2AjQgAUEBIAEoAjgiBiACa0EAIAQgBk0bIAZBAUYbNgI4IAFBASABKAI8IgEgAmtBACABIARPGyABQQFGGzYCPCAFQRBqIQUgB0EBaiIHIAlHDQALDAELIAsgBiACEMgBCyADKAL4ECIBBEAgOygCAEEBIAF0IAIQyAELIAMoAqQEIgEgAygCqARLBEAgAyABNgKoBAsgA0EANgKMEiADQQA2AvAQIAMgAygC9BAiASACayICQQAgASACTxs2AvQQIBogMigCACIBayEEQQALIQICQCACIDFqIARPBEAgAiADKALkEEYNAQtBACECIANBADYCjBIgA0EANgLwEAsCQCAMIAFrIgQgAiAxak0EQCADKALoECEBDAELIAMoAugQIgEgBCAxayICSQRAIAMgAjYC6BAgAiEBCyABIAMoAuQQSwRAIAMgATYC5BALIANBADYCjBIgA0EANgLwEAsgASADKAL0EEsEQCADIAE2AvQQCyAPIDdNIRkCQAJAAkACQCADKALsAQRAIAMgDCAQEMsBIgJBiH9LDQcgAg0CAkAgAygC3AUNACADKALoBSADKALkBWtBH0sNACADKALwBSADKALsBWtBCUsNACAMIBAQygFFDQAgDiAMLQAAOgADIA4gEEENdjoAAiAOIBBBA3QgGXJBAnI7AABBBCECDAQLAkACQCAeIAMoAtAQIAMoAtQQIC8gCEEIaiADKAK4EhCiAiICQYh/Sw0AIAgoAghBAkYhJyAOIBRqIS0gAygC1BAiFkGQDmohPiAWQbwZaiE/IBZBjAhqIUAgFkEEaiEzIBZBjA5qIUEgFkG4GWohQiAWQYgIaiFDIAMoAugFIjhBCGshRCADKALsASE5IAMoAvwFIR8gAygC+AUhIyADKAL0BSEkIAMoAvAFIUUgAygC7AUhIiADKAK4EiETIAMoAtAQITRBASEsIBZBighqIUYgFkG6GWohRyAWQY4OaiFIIA4hCyAMISkgAygC5AUiKiEEAkADQEEAIQlBgIABQcgBQQAgJxsiAWshSUGACCABayFKIAtBA2ohFSBFICJrITogLSALa0EDayEwQQAhCgNAAn8gKiA4RgRAQQEhICA6DAELIAQgCkEDdGoiAiBERiEgIAIvAQQhASAKQQFqIQogOiADKAKM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KAK86QEhBwwQCyADKALk6wEiBEUEQCAcKAIADAILIAMoApDrAQ0ZIAMoAtzrASAEIAlBCGogCUEUahDOAiIEDRQMFgsgA0EBNgK06wEgA0IANwPQ6wEgA0IANwLk6wEgA0EANgLY6wEgA0EANgLA6wEgICAJKAIQNgIIICAgCSkCCDcCAEEACyADKALs6gEQmwEhBgJAIAMoAqzrAUUNACADKAKo6wEiBEUNACADKAKY6wFFDQAgCSADKALc6QEiBTYCMCAEKAIEQQFrIhUgCUEwakEEEOUBp3EhByAEKAIAIQQDQCAEIAdBAnRqKAIAIhBFDQEgBSAQKAKo1QEiI0cEQCAHIBVxQQFqIQcgIw0BCwsCQCADKAKU6wEiBEUNACAEKAK41QEhByAEKAK01QEhBQJAAkACQCAEKAIAIhUEQCAFRQ0CIAcgFSAFEQAADAELIAVFDQILIAcgBCAFEQAADAILIBUQFQsgBBAVCyADQQA2ApTrASADQX82AqTrASADIBA2ApjrASADIAMoAtzpATYCnOsBCyAGQYl/TwRAIApBBEkEQCAGIQQMGwsgBiEEIBIoAAAiB0HblcEWaiIOQQJLDRoCfwJAAkACQCADKAKk6wFBAWoOAwIAAQALIAMoApTrASIBBEACQCABKAK41QEhBCABKAK01QEhAgJAAkAgASgCACIGBEAgAkUNASAEIAYgAhEAACAEIAEgAhEAAAwDCyACRQ0BIAQgASACEQAADAILIAYQFQsgARAVCwtBACEFIANBADYCpOsBIANCADcClOsBQQAMAgsgA0EANgKk6wELIAMoApjrASIBRQRAQQAhBUEADAELIAEoAgQhBSABKAIICyEGQUAhBCADKAKQ6wENGgJAIAMoAuDrASIIIAdB4JXBFmoiB0YiAg0AIAMoAtzrASEBAkACQAJAIAhBBWsOAwABAgMLIAEEQCABKAIAEBUgASgCMBAVIAEoAjwQFSABEBULDAILIAEEQCABKAIAEBUgASgCHBAVIAEoAigQFSABEBULDAELIAEEQCABKAIAIggEQCAIKALEqQEgCCAIKALAqQERAAALIAEoAiQiCARAIAEoAmQgCCABKAJgEQAACyABKAIwIggEQCABKAJkIAggASgCYBEAAAsgASgCZCABIAEoAmARAAALCwJAAkACQAJAAkACQCAODgMB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AEcNACAFQQJqIQUgCEECaiEICyAEIAhLBH8gCCAFLQAAIAgtAABGagUgCAsgAmsLIBZqIgJJBEAgACALQQN0aiIFIAI2AgQgBSAYIA1rNgIAIAIgDWogESACIBEgDWtLGyERIAtBAWohCyACQYAgSw0CIAIiByADaiAERg0CCyAbIA0gEnFBA3RqIQUCQAJAIAIgHGotAAAgAiADai0AAEkEQCAQIA02AgAgDSAPSw0BIBdBDGohEAwECyAGIA02AgAgDSAPSwRAIAUhBiACIQwMAgsgF0EMaiEGDAMLIAIhCSAFQQRqIhAhBQsgCkEBayIKRQ0BIAUoAgAiDSAOTw0ACwsgBkEANgIAIBBBADYCACABIBFBCGs2AhwLIBdBEGokACALC3YBAn8jAEEgayICJAAGQAZAIAJBGGohAyACQQxqIAFBBGogASgCABDtAiEBGAEgAyABIAARAAAZIAIkACABLAALQQBIBEAgASgCABAVCwkACyACKAIcIAJBADYCHCABLAALQQBIBEAgASgCABAVCyACQSBqJAALxxUBGH8jAEEQayIcJAACQCABKAIEIg8gASgCHCINaiADSw0AAn8gAyAPayIJIA1NBEAgCQwBCwNAIAEgDSAPaiAEIAlBA0EBED0gDWoiDSAJSQ0ACyADIAEoAgQiD2sLIQwgASAJNgIcIAEoAhAiCSAMQQEgASgCuAF0IghrIAkgDCAJayAISxsgASgCGBshDiABKAK8ASEdIAEoAlwgAygAACIQQbHz3fF5bEEgIAEoAsABa3ZBAnRqIh4oAgAhDUH/HyABKALMASIJIAlB/x9PGyETIAdBAWshCSAPIAEoAgwiEmohGSABKAIIIhYgEmohGiABKAJkIR8gASgCxAEhGwJAIAZBfEsEQAwBCyAMIBJrIRQgBEEBayEXIARBA2shESADQQNqIQggDCAOayEYIAwCfyAGQQNGBEAgBSgCAEEBawwBCyAFIAZBAnRqKAIACyIHayEKAkACfwJAAkAgFCAHQQFrIhVLBEAgCiAOSQ0EIAMgB2soAAAgEHNB////B3ENBCAIIAdrIQcgCCARTwRAIAghCwwDCyAIKAAAIgsgBygAACIKRw0BIAghCwNAIAdBBGohByALQQRqIgsgEU8NAyALKAAAIgogBygAACIQRg0ACyALIAogEHNoQQN2aiAI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dWludDY0X3QAY2hhcjMyX3QAVXQAVHQAU3QAZGVjb21wcmVzcwBVbnN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBwYXJhbWV0ZXJzAHRoaXMAZ3MAcmVxdWlyZXMAQ2Fubm90IGNyZWF0ZSBEaWN0aW9uYXJ5IGZyb20gcHJvdmlkZWQgc2FtcGxlcwBUcwBudWxscHRyAHNyAFVua25vd24gZnJhbWUgZGVzY3JpcHRvcgBvcGVyYXRvcgBhbGxvY2F0b3IAenN0ZCBjb2RlYyBlcnJvcjogY29udGVudCBzaXplIGVycm9yAFVuc3VwcG9ydGVkIGZyYW1lIHBhcmFtZXRlcgBVbnN1cHBvcnRlZCBwYXJhbWV0ZXIAenN0ZCBjb2RlYyBlcnJvcjogY2Fubm90IGFsbG9jYXRlIG91dHB1dCBidWZmZXIAenN0ZCBjb2RlYyBlcnJvcjogY291bGQgbm90IGV4cGFuZCBvdXRwdXQgYnVmZmVyAE9wZXJhdGlvbiBvbiBOVUxMIGRlc3RpbmF0aW9uIGJ1ZmZlcgB1bnNpZ25lZCBjaGFyAHJxAHNwAGZwAFRwACBhdXRvAG9iamNwcm90bwBzbwBEbwBzdGQ6OmV4Y2VwdGlvbgBIZWFkZXIgb2YgTGl0ZXJhbHMnIGJsb2NrIGRvZXNuJ3QgcmVzcGVjdCBmb3JtYXQgc3BlY2lmaWNhdGlvbgB1bmlvbgBkbgBuYW4AVG4ARG4AUmVzdG9yZWQgZGF0YSBkb2Vzbid0IG1hdGNoIGNoZWNrc3VtAGVudW0AYmFzaWNfaW9zdHJlYW0AYmFzaWNfb3N0cmVhbQBiYXNpY19pc3RyZWFtAHVsAHRsAGJvb2wAT3BlcmF0aW9uIG1hZGUgbm8gcHJvZ3Jlc3Mgb3ZlciBtdWx0aXBsZSBjYWxscywgZHVlIHRvIG91dHB1dCBidWZmZXIgYmVpbmcgZnVsbABEZXN0aW5hdGlvbiBidWZmZXIgaXMgdG9vIHNtYWxsAFNwZWNpZmllZCBtYXhTeW1ib2xWYWx1ZSBpcyB0b28gc21hbGwAaWwAc3RyaW5nIGxpdGVyYWwAVWwAeXB0bmsAVGsAcGkAbGkAd29ya1NwYWNlIGJ1ZmZlciBpcyBub3QgbGFyZ2UgZW5vdWdoAERpY3Rpb25hcnkgbWlzbWF0Y2gARGVzdGluYXRpb24gYnVmZmVyIGlzIHdyb25nAFNvdXJjZSBidWZmZXIgaXMgd3JvbmcAdW5zaWduZWQgbG9uZyBsb25nAHVuc2lnbmVkIGxvbmcAc3RkOjp3c3RyaW5nAGJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBBbiBJL08gZXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nL3NlZWtpbmcARnJhbWUgcmVxdWlyZXMgdG9vIG11Y2ggbWVtb3J5IGZvciBkZWNvZGluZwBfX3V1aWRvZgBpbmYAaGFsZgAlYWYAdHJ1ZQBvcGVyYXRvciBkZWxldGUAZmFsc2UAZGVjbHR5cGUAIHZvbGF0aWxlAGxvbmcgZG91YmxlAF9ibG9ja19pbnZva2UARnJhbWUgaW5kZXggaXMgdG9vIGxhcmdlAFVuc3VwcG9ydGVkIG1heCBTeW1ib2wgVmFsdWUgOiB0b28gbGFyZ2UAT3BlcmF0aW9uIG5vdCBhdXRob3JpemVkIGF0IGN1cnJlbnQgcHJvY2Vzc2luZyBzdGFnZQBCbG9jay1sZXZlbCBleHRlcm5hbCBzZXF1ZW5jZSBwcm9kdWNlciByZXR1cm5lZCBhbiBlcnJvciBjb2RlAFVuc3BlY2lmaWVkIGVycm9yIGNvZGUAVGUAc3RkAFBhcmFtZXRlciBpcyBvdXQgb2YgYm91bmQAdm9pZABFeHRlcm5hbCBzZXF1ZW5jZXMgYXJlIG5vdCB2YWxpZAB0YWJsZUxvZyByZXF1aXJlcyB0b28gbXVjaCBtZW1vcnkgOiB1bnN1cHBvcnRlZABWZXJzaW9uIG5vdCBzdXBwb3J0ZWQARGljdGlvbmFyeSBpcyBjb3JydXB0ZWQATm8gZXJyb3IgZGV0ZWN0ZWQARGF0YSBjb3JydXB0aW9uIGRldGVjdGVkAHBsZWRnZWQgYnVmZmVyIHN0YWJpbGl0eSBjb25kaXRpb24gaXMgbm90IHJlc3BlY3RlZAAndW5uYW1lZABzdGQ6OmJhZF9hbGxvYwBtYwBVYgAnbGFtYmRhACVhAGJhc2ljXwBvcGVyYXRvcl4Ab3BlcmF0b3IgbmV3W10Ab3BlcmF0b3JbXQBvcGVyYXRvciBkZWxldGVbXQBwaXhlbCB2ZWN0b3JbAHNaAF9fX19aAGZwVAAkVFQAJFQAclEAc1AARE8Ac3JOAF9HTE9CQUxfX04ATkFOACROAGZMACVMYUwAVWE5ZW5hYmxlX2lmSQBJTkYAUkUAT0UAYjFFAGIwRQBEQwBvcGVyYXRvcj8AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4Ab3BlcmF0b3I+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+ADxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ACwgc3RkOjphbGxvY2F0b3I8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4Ab3BlcmF0b3I+PgBvcGVyYXRvcjw9PgBvcGVyYXRvci0+AG9wZXJhdG9yfD0Ab3BlcmF0b3I9AG9wZXJhdG9yXj0Ab3BlcmF0b3I+PQBvcGVyYXRvcj4+PQBvcGVyYXRvcj09AG9wZXJhdG9yPD0Ab3BlcmF0b3I8PD0Ab3BlcmF0b3IvPQBvcGVyYXRvci09AG9wZXJhdG9yKz0Ab3BlcmF0b3IqPQBvcGVyYXRvciY9AG9wZXJhdG9yJT0Ab3BlcmF0b3IhPQBvcGVyYXRvcjwAdGVtcGxhdGU8AGlkPABvcGVyYXRvcjw8AC48ACI8AFthYmk6ACBbZW5hYmxlX2lmOgBzdGQ6OgB1bnNpZ25lZCBfX2ludDEyOABfX2Zsb2F0MTI4AGRlY2ltYWwxMjgAZGVjaW1hbDY0AGRlY2ltYWwzMgAwAG9wZXJhdG9yLwBvcGVyYXRvci4Ac2l6ZW9mLi4uAG9wZXJhdG9yLQAtaW4tAG9wZXJhdG9yLS0Ab3BlcmF0b3IsAG9wZXJhdG9yKwBvcGVyYXRvcisrAG9wZXJhdG9yKgBvcGVyYXRvci0+KgA6OioAb3BlcmF0b3IuKgAgZGVjbHR5cGUoYXV0bykAKG51bGwpAChhbm9ueW1vdXMgbmFtZXNwYWNlKQBFcnJvciAoZ2VuZXJpYykAb3BlcmF0b3IoKQAgKAAnYmxvY2stbGl0ZXJhbCcAb3BlcmF0b3ImAG9wZXJhdG9yJiYAICYmACAmAG9wZXJhdG9yJQA+IgBvcGVyYXRvciEAdGhyb3cgAG5vZXhjZXB0IAAgYXQgb2Zmc2V0IAB0aGlzIAAgcmVxdWlyZXMgAG9wZXJhdG9yIAByZWZlcmVuY2UgdGVtcG9yYXJ5IGZvciAAdGVtcGxhdGUgcGFyYW1ldGVyIG9iamVjdCBmb3IgAHR5cGVpbmZvIGZvciAAdGhyZWFkLWxvY2FsIHdyYXBwZXIgcm91dGluZSBmb3IgAHRocmVhZC1sb2NhbCBpbml0aWFsaXphdGlvbiByb3V0aW5lIGZvciAAdHlwZWluZm8gbmFtZSBmb3IgAGNvbnN0cnVjdGlvbiB2dGFibGUgZm9yIABndWFyZCB2YXJpYWJsZSBmb3IgAFZUVCBmb3IgAGNvdmFyaWFudCByZXR1cm4gdGh1bmsgdG8gAG5vbi12aXJ0dWFsIHRodW5rIHRvIABpbnZvY2F0aW9uIGZ1bmN0aW9uIGZvciBibG9jayBpbiAAYWxpZ25vZiAAc2l6ZW9mIAA+IHR5cGVuYW1lIABpbml0aWFsaXplciBmb3IgbW9kdWxlIAA6OmZyaWVuZCAAdHlwZWlkIAB1bnNpZ25lZCAAID8gACAtPiAAID0gAHpzdGQgY29kZWMgZXJyb3I6IAAgOiAAc2l6ZW9mLi4uIAAgLi4uIAAsIABvcGVyYXRvciIiIAB8FgAAOBUAAHBwcAB8FgAAOBUAAARJAABwcHBpAAAAALBIAAB2cABOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAACRLAAD3FAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAACRLAABAFQAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAACRLAACIFQAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAAkSwAA0BUAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAJEsAABwWAABOMTBlbXNjcmlwdGVuM3ZhbEUAACRLAABoFgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAAAkSwAAhBYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAJEsAAKwWAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAACRLAADUFgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAAkSwAA/BYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAAJEsAACQXAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAACRLAABMFwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAAkSwAAdBcAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAAJEsAAJwXAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAACRLAADEFwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeEVFAAAkSwAA7BcAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXlFRQAAJEsAABQYAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAACRLAAA8GAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAAAkSwAAZBgAAAAAAAAhAAAAIQAAACIAAAAjAAAAJAAAACUAAAAmAAAAJwAAACgAAAApAAAAKgAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMQAAADIAAAAyAAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAAOQAAADkAQZQyCwk6AAAAOwAAADwAQbAyC90xPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAAAQAEAAMAAgACAAIAAgACAAIAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQD//////////////////wAAAAAAABMAAAAMAAAADQAAAAEAAAAGAAAAAQAAAAEAAAATAAAADQAAAA4AAAABAAAABwAAAAAAAAABAAAAFAAAAA8AAAAQAAAAAQAAAAYAAAAAAAAAAQAAABUAAAAQAAAAEQAAAAEAAAAFAAAAAAAAAAIAAAAVAAAAEgAAABIAAAABAAAABQAAAAAAAAACAAAAFQAAABIAAAATAAAAAwAAAAUAAAACAAAAAwAAABUAAAASAAAAEwAAAAMAAAAFAAAABAAAAAQAAAAVAAAAEwAAABQAAAAEAAAABQAAAAgAAAAEAAAAFQAAABMAAAAUAAAABAAAAAUAAAAQAAAABQAAABYAAAAUAAAAFQAAAAQAAAAFAAAAEAAAAAUAAAAWAAAAFQAAABYAAAAFAAAABQAAABAAAAAFAAAAFgAAABUAAAAWAAAABgAAAAUAAAAQAAAABQAAABYAAAAWAAAAFwAAAAYAAAAFAAAAIAAAAAUAAAAWAAAAFgAAABYAAAAEAAAABQAAACAAAAAGAAAAFgAAABYAAAAXAAAABQAAAAUAAAAgAAAABgAAABYAAAAXAAAAFwAAAAYAAAAFAAAAIAAAAAYAAAAWAAAAFgAAABYAAAAFAAAABQAAADAAAAAHAAAAFwAAABcAAAAWAAAABQAAAAQAAABAAAAABwAAABcAAAAXAAAAFgAAAAYAAAADAAAAQAAAAAgAAAAXAAAAGAAAABYAAAAHAAAAAwAAAAABAAAJAAAAGQAAABkAAAAXAAAABwAAAAMAAAAAAQAACQAAABoAAAAaAAAAGAAAAAcAAAADAAAAAAIAAAkAAAAbAAAAGwAAABkAAAAJAAAAAwAAAOcDAAAJAAAAEgAAAAwAAAANAAAAAQAAAAUAAAABAAAAAQAAABIAAAANAAAADgAAAAEAAAAGAAAAAAAAAAEAAAASAAAADgAAAA4AAAABAAAABQAAAAAAAAACAAAAEgAAABAAAAAQAAAAAQAAAAQAAAAAAAAAAgAAABIAAAAQAAAAEQAAAAMAAAAFAAAAAgAAAAMAAAASAAAAEQAAABIAAAAFAAAABQAAAAIAAAADAAAAEgAAABIAAAATAAAAAwAAAAUAAAAEAAAABAAAABIAAAASAAAAEwAAAAQAAAAEAAAABAAAAAQAAAASAAAAEgAAABMAAAAEAAAABAAAAAgAAAAFAAAAEgAAABIAAAATAAAABQAAAAQAAAAIAAAABQAAABIAAAASAAAAEwAAAAYAAAAEAAAACAAAAAUAAAASAAAAEgAAABMAAAAFAAAABAAAAAwAAAAGAAAAEgAAABMAAAATAAAABwAAAAQAAAAMAAAABgAAABIAAAASAAAAEwAAAAQAAAAEAAAAEAAAAAcAAAASAAAAEgAAABMAAAAEAAAAAwAAACAAAAAHAAAAEgAAABIAAAATAAAABgAAAAMAAACAAAAABwAAABIAAAATAAAAEwAAAAYAAAADAAAAgAAAAAgAAAASAAAAEwAAABMAAAAIAAAAAwAAAAABAAAIAAAAEgAAABMAAAATAAAABgAAAAMAAACAAAAACQAAABIAAAATAAAAEwAAAAgAAAADAAAAAAEAAAkAAAASAAAAEwAAABMAAAAKAAAAAwAAAAACAAAJAAAAEgAAABMAAAATAAAADAAAAAMAAAAAAgAACQAAABIAAAATAAAAEwAAAA0AAAADAAAA5wMAAAkAAAARAAAADAAAAAwAAAABAAAABQAAAAEAAAABAAAAEQAAAAwAAAANAAAAAQAAAAYAAAAAAAAAAQAAABEAAAANAAAADwAAAAEAAAAFAAAAAAAAAAEAAAARAAAADwAAABAAAAACAAAABQAAAAAAAAACAAAAEQAAABEAAAARAAAAAgAAAAQAAAAAAAAAAgAAABEAAAAQAAAAEQAAAAMAAAAEAAAAAgAAAAMAAAARAAAAEAAAABEAAAADAAAABAAAAAQAAAAEAAAAEQAAABAAAAARAAAAAwAAAAQAAAAIAAAABQAAABEAAAAQAAAAEQAAAAQAAAAEAAAACAAAAAUAAAARAAAAEAAAABEAAAAFAAAABAAAAAgAAAAFAAAAEQAAABAAAAARAAAABgAAAAQAAAAIAAAABQAAABEAAAARAAAAEQAAAAUAAAAEAAAACAAAAAYAAAARAAAAEgAAABEAAAAHAAAABAAAAAwAAAAGAAAAEQAAABIAAAARAAAAAwAAAAQAAAAMAAAABwAAABEAAAASAAAAEQAAAAQAAAADAAAAIAAAAAcAAAARAAAAEgAAABEAAAAGAAAAAwAAAAABAAAHAAAAEQAAABIAAAARAAAABgAAAAMAAACAAAAACAAAABEAAAASAAAAEQAAAAgAAAADAAAAAAEAAAgAAAARAAAAEgAAABEAAAAKAAAAAwAAAAACAAAIAAAAEQAAABIAAAARAAAABQAAAAMAAAAAAQAACQAAABEAAAASAAAAEQAAAAcAAAADAAAAAAIAAAkAAAARAAAAEgAAABEAAAAJAAAAAwAAAAACAAAJAAAAEQAAABIAAAARAAAACwAAAAMAAADnAwAACQAAAA4AAAAMAAAADQAAAAEAAAAFAAAAAQAAAAEAAAAOAAAADgAAAA8AAAABAAAABQAAAAAAAAABAAAADgAAAA4AAAAPAAAAAQAAAAQAAAAAAAAAAQAAAA4AAAAOAAAADwAAAAIAAAAEAAAAAAAAAAIAAAAOAAAADgAAAA4AAAAEAAAABAAAAAIAAAADAAAADgAAAA4AAAAOAAAAAwAAAAQAAAAEAAAABAAAAA4AAAAOAAAADgAAAAQAAAAEAAAACAAAAAUAAAAOAAAADgAAAA4AAAAGAAAABAAAAAgAAAAFAAAADgAAAA4AAAAOAAAACAAAAAQAAAAIAAAABQAAAA4AAAAPAAAADgAAAAUAAAAEAAAACAAAAAYAAAAOAAAADwAAAA4AAAAJAAAABAAAAAgAAAAGAAAADgAAAA8AAAAOAAAAAwAAAAQAAAAMAAAABwAAAA4AAAAPAAAADgAAAAQAAAADAAAAGAAAAAcAAAAOAAAADwAAAA4AAAAFAAAAAwAAACAAAAAIAAAADgAAAA8AAAAPAAAABgAAAAMAAABAAAAACAAAAA4AAAAPAAAADwAAAAcAAAADAAAAAAEAAAgAAAAOAAAADwAAAA8AAAAFAAAAAwAAADAAAAAJAAAADgAAAA8AAAAPAAAABgAAAAMAAACAAAAACQAAAA4AAAAPAAAADwAAAAcAAAADAAAAAAEAAAkAAAAOAAAADwAAAA8AAAAIAAAAAwAAAAABAAAJAAAADgAAAA8AAAAPAAAACAAAAAMAAAAAAgAACQAAAA4AAAAPAAAADwAAAAkAAAADAAAAAAIAAAkAAAAOAAAADwAAAA8AAAAKAAAAAwAAAOcDAAAJAAAAAAAAAGs4BwANsgcAnPIHAHBkCABgrgoAsHELADCqDAAAAAAAAAgAAAAHAABqBgAAAAYAAK0FAABqBQAAMQUAAAAFAADUBAAArQQAAIoEAABqBAAATAQAADEEAAAXBAAAAAQAAOkDAADUAwAAwAMAAK0DAACbAwAAigMAAHkDAABqAwAAWwMAAEwDAAA+AwAAMQMAACQDAAAXAwAACwMAAAADAAD0AgAA6QIAAN4CAADUAgAAygIAAMACAAC2AgAArQIAAKQCAACbAgAAkgIAAIoCAACCAgAAeQIAAHICAABqAgAAYgIAAFsCAABTAgAATAIAAEUCAAA+AgAANwIAADECAAAqAgAAJAIAAB4CAAAXAgAAEQIAAAsCAAAFAgAAAAIAAPoBAAD0AQAA7wEAAOkBAADkAQAA3gEAANkBAADUAQAAzwEAAMoBAADFAQAAwAEAALsBAAC2AQAAsgEAAK0BAACoAQAApAEAAJ8BAACbAQAAlwEAAJIBAACOAQAAigEAAIYBAACCAQAAfgEAAHkBAAB1AQAAcgEAAG4BAABqAQAAZgEAAGIBAABeAQAAWwEAAFcBAABTAQAAUAEAAEwBAABJAQAARQEAAEIBAAA+AQAAOwEAADcBAAA0AQAAMQEAAC4BAAAqAQAAJwEAACQBAAAhAQAAHgEAABoBAAAXAQAAFAEAABEBAAAOAQAACwEAAAgBAAAFAQAAAgEAAAABAAD9AAAA+gAAAPcAAAD0AAAA8QAAAO8AAADsAAAA6QAAAOYAAADkAAAA4QAAAN4AAADcAAAA2QAAANcAAADUAAAA0QAAAM8AAADMAAAAygAAAMcAAADFAAAAwgAAAMAAAAC+AAAAuwAAALkAAAC2AAAAtAAAALIAAACvAAAArQAAAKsAAACoAAAApgAAAKQAAACiAAAAnwAAAJ0AAACbAAAAmQAAAJcAAACVAAAAkgAAAJAAAACOAAAAjAAAAIoAAACIAAAAhgAAAIQAAACCAAAAgAAAAH4AAAB7AAAAeQAAAHcAAAB1AAAAcwAAAHIAAABwAAAAbgAAAGwAAABqAAAAaAAAAGYAAABkAAAAYgAAAGAAAABeAAAAXQAAAFsAAABZAAAAVwAAAFUAAABTAAAAUgAAAFAAAABOAAAATAAAAEoAAABJAAAARwAAAEUAAABDAAAAQgAAAEAAAAA+AAAAPQAAADsAAAA5AAAANwAAADYAAAA0AAAAMgAAADEAAAAvAAAALgAAACwAAAAqAAAAKQAAACcAAAAlAAAAJAAAACIAAAAhAAAAHwAAAB4AAAAcAAAAGgAAABkAAAAXAAAAFgAAABQAAAATAAAAEQAAABAAAAAOAAAADQAAAAsAAAAKAAAACAAAAAcAAAAFAAAABAAAAAIAAAABAAAAAQABAAEAAQABAAEAAgACAAIAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEA/////////////wAAAAAAAAQAAwACAAIAAgACAAIAAgACAAIAAgACAAIAAQABAAEAAgACAAIAAgACAAIAAgACAAIAAwACAAEAAQABAAEAAQD//////////wAAAAAAAAAAAQAEAAMAAgACAAIAAgACAAIAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQD//////////////////wAAAAAAAFx3d18s97j1EsR6ayZfk4TMDHPKqa1Htt6xTxFLu2Ww0J86jH5OWDQFa+JqfOGXTgSmmbxD1wM6TwTEIiQEzc6eJSSFxXbedsrqrVv2KIWcKXUJ4gY3VoaJ2HWjX0cC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AAAAgAAAAAABAEGU/gALbQEAAAADAAAABwAAAA8AAAAfAAAAPwAAAH8AAAD/AAAA/wEAAP8DAAD/BwAA/w8AAP8fAAD/PwAA/38AAP//AAD//wEA//8DAP//BwD//w8A//8fAP//PwD//38A////AP///wH///8DAQAAAAEAQZD/AAs1AQAAAAIAAAADAAAABAAAAAcAAAAIAAAADwAAABAAAAAfAAAAIAAAAD8AAABAAAAAfwAAAIAAQdj/AAsNAQAAAAEAAAACAAAAAgBB8P8AC+kCAQAAAAEAAAACAAAAAgAAACYAAACCAAAAIQUAAEoAAABnCAAAJgAAAMABAACAAAAASQUAAEoAAAC+CAAAKQAAACwCAACAAAAASQUAAEoAAAC+CAAALwAAAMoCAACAAAAAigUAAEoAAACECQAANQAAAHMDAACAAAAAnQUAAEoAAACgCQAAPQAAAIEDAACAAAAA6wUAAEsAAAA+CgAARAAAAJ4DAACAAAAATQYAAEsAAACqCgAASwAAALMDAACAAAAAwQYAAE0AAAAfDQAATQAAAFMEAACAAAAAIwgAAFEAAACmDwAAVAAAAJkEAACAAAAASwkAAFcAAACxEgAAWAAAANoEAACAAAAAbwkAAF0AAAAjFAAAVAAAAEUFAACAAAAAVAoAAGoAAACMFAAAagAAAK8FAACAAAAAdgkAAHwAAABOEAAAfAAAANICAACAAAAAYwcAAJEAAACQBwAAkgAAAAEAAAAEAAAACABB5IIBC5YCAQAAAAIAAAAEAAAAAAAAAAIAAAAEAAAACAAAAAQAAwACAAIAAgACAAIAAgACAAIAAgACAAIAAQABAAEAAgACAAIAAgACAAIAAgACAAIAAwACAAEAAQABAAEAAQD//////////wAAAAAAAAAAAQABAAEAAQABAAEAAgACAAIAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEA/////////////wAAAAAAAAEABAADAAIAAgACAAIAAgACAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEA//////////////////8AQcCFAQtNAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAE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AGIAAABjAAAAZAAAAJ4AAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZEVFAMxKAAC4VQAAbEsAAAAAAABgVgAAXQAAAF4AAABfAAAAYAAAAJ8AAABiAAAAYwAAAGQAAACgAAAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGbG9hdExpdGVyYWxJbXBsSWVFRQDMSgAAKFYAAGxLAAAAAAAAzFYAAF0AAABeAAAAXwAAAGAAAAChAAAAYgAAAGMAAABkAAAAogAAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzU3RyaW5nTGl0ZXJhbEUAAADMSgAAmFYAAGxLAAB2AAAAAAAAADxXAABdAAAAXgAAAF8AAABgAAAAowAAAGIAAABjAAAAZAAAAKQAAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNVVubmFtZWRUeXBlTmFtZUUAzEoAAAhXAABsSwAAAAAAALRXAABdAAAAXgAAAF8AAABgAAAApQAAAGIAAABjAAAAZAAAAKYAAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyNlN5bnRoZXRpY1RlbXBsYXRlUGFyYW1OYW1lRQAAzEoAAHRXAABsSwAAAAAAAChYAABdAAAAXgAAAF8AAABgAAAApwAAAKgAAABjAAAAZAAAAKkAAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMVR5cGVUZW1wbGF0ZVBhcmFtRGVjbEUAAADMSgAA7FcAAGxLAAAAAAAAqFgAAF0AAABeAAAAXwAAAGAAAACqAAAAqwAAAGMAAABkAAAArAAAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTMyQ29uc3RyYWluZWRUeXBlVGVtcGxhdGVQYXJhbURlY2xFAAAAAMxKAABgWAAAbEsAAAAAAAAgWQAAXQAAAF4AAABfAAAAYAAAAK0AAACuAAAAYwAAAGQAAACvAAAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjROb25UeXBlVGVtcGxhdGVQYXJhbURlY2xFAAAAAMxKAADgWAAAbEsA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");
    DEFAULT_CLEVEL = 1;
    MAX_CLEVEL = 22;
    init4 = () => zstd_codec_default({ noInitialRun: true, wasmBinary: zstd_codec_default2 });
    Zstd = (_a3 = class {
      constructor(level = DEFAULT_CLEVEL) {
        __publicField(this, "level");
        if (!Number.isInteger(level)) {
          throw Error(`Invalid acceleration "${level}". Must be a positive integer.`);
        }
        this.level = level;
      }
      static fromConfig({ level }) {
        return new _a3(level);
      }
      async encode(data) {
        if (!emscriptenModule3) {
          emscriptenModule3 = init4();
        }
        let level = this.level;
        if (level <= 0) {
          level = DEFAULT_CLEVEL;
        }
        if (level > MAX_CLEVEL) {
          level = MAX_CLEVEL;
        }
        const module = await emscriptenModule3;
        const view = module.compress(data, level);
        const result = new Uint8Array(view);
        module.free_result();
        return result;
      }
      async decode(data, out) {
        if (!emscriptenModule3) {
          emscriptenModule3 = init4();
        }
        const module = await emscriptenModule3;
        try {
          const view = module.decompress(data);
          const result = new Uint8Array(view);
          module.free_result();
          if (out !== void 0) {
            out.set(result);
            return out;
          }
          return result;
        } catch (err2) {
          throw new Error(module.getExceptionMessage(err2).toString());
        }
      }
    }, __publicField(_a3, "codecId", "zstd"), __publicField(_a3, "DEFAULT_CLEVEL", DEFAULT_CLEVEL), __publicField(_a3, "MAX_CLEVEL", MAX_CLEVEL), _a3);
    zstd_default = Zstd;
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i3 = dim; i3 < outerLen; i3 += dim) {
          x2 = data[i3];
          y2 = data[i3 + 1];
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i3, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i3 = start; i3 < end; i3 += dim)
          last = insertNode(i3, data[i3], data[i3 + 1], last);
      } else {
        for (i3 = end - dim; i3 >= start; i3 -= dim)
          last = insertNode(i3, data[i3], data[i3 + 1], last);
      }
      if (last && equals6(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals6(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next)
            break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c2.next;
      while (p2 !== a2) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p2 = start;
      do {
        var a2 = p2.prev, b2 = p2.next.next;
        if (!equals6(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
          triangles.push(a2.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start = b2;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints(p2);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b2 = a2.next.next;
        while (b2 !== a2.prev) {
          if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
            var c2 = splitPolygon(a2, b2);
            a2 = filterPoints(a2, a2.next);
            c2 = filterPoints(c2, c2.next);
            earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i3, len4, start, end, list;
      for (i3 = 0, len4 = holeIndices.length; i3 < len4; i3++) {
        start = holeIndices[i3] * dim;
        end = i3 < len4 - 1 ? holeIndices[i3 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i3 = 0; i3 < queue.length; i3++) {
        outerNode = eliminateHole(queue[i3], outerNode);
      }
      return outerNode;
    }
    function compareX(a2, b2) {
      return a2.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m2 = p2.x < p2.next.x ? p2 : p2.next;
            if (x2 === hx)
              return m2;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m2)
        return null;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
      p2 = m2;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
            m2 = p2;
            tanMin = tan2;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p2) {
      return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === 0)
          p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i3, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q2 = p2;
          pSize = 0;
          for (i3 = 0; i3 < inSize; i3++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
              e2 = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e2 = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e2;
            else
              list = e2;
            e2.prevZ = tail;
            tail = e2;
          }
          p2 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
          leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a2, b2) {
      return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
      (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
      (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
      equals6(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
    }
    function area(p2, q2, r2) {
      return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
    }
    function equals6(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o22 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o22 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o22 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p2, q2, r2) {
      return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a2, b2) {
      var p2 = a2;
      do {
        if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
          return true;
        p2 = p2.next;
      } while (p2 !== a2);
      return false;
    }
    function locallyInside(a2, b2) {
      return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
    }
    function middleInside(a2, b2) {
      var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a2);
      return inside;
    }
    function splitPolygon(a2, b2) {
      var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
      a2.next = b2;
      b2.prev = a2;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i3, x2, y2, last) {
      var p2 = new Node(i3, x2, y2);
      if (!last) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ)
        p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ)
        p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i3, x2, y2) {
      this.i = i3;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i3 = 0, len4 = holeIndices.length; i3 < len4; i3++) {
          var start = holeIndices[i3] * dim;
          var end = i3 < len4 - 1 ? holeIndices[i3 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i3 = 0; i3 < triangles.length; i3 += 3) {
        var a2 = triangles[i3] * dim;
        var b2 = triangles[i3 + 1] * dim;
        var c2 = triangles[i3 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i3 = start, j2 = end - dim; i3 < end; i3 += dim) {
        sum += (data[j2] - data[i3]) * (data[i3 + 1] + data[j2 + 1]);
        j2 = i3;
      }
      return sum;
    }
    earcut3.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i3 = 0; i3 < data.length; i3++) {
        for (var j2 = 0; j2 < data[i3].length; j2++) {
          for (var d2 = 0; d2 < dim; d2++)
            result.vertices.push(data[i3][j2][d2]);
        }
        if (i3 > 0) {
          holeIndex += data[i3 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/geotiff/dist-module/compression/index.js
var registry = /* @__PURE__ */ new Map();
function addDecoder(cases, importFn) {
  if (!Array.isArray(cases)) {
    cases = [cases];
  }
  cases.forEach((c2) => registry.set(c2, importFn));
}
addDecoder([void 0, 1], () => Promise.resolve().then(() => (init_raw(), raw_exports)).then((m2) => m2.default));
addDecoder(5, () => Promise.resolve().then(() => (init_lzw(), lzw_exports)).then((m2) => m2.default));
addDecoder(6, () => {
  throw new Error("old style JPEG compression is not supported.");
});
addDecoder(7, () => Promise.resolve().then(() => (init_jpeg(), jpeg_exports)).then((m2) => m2.default));
addDecoder([8, 32946], () => Promise.resolve().then(() => (init_deflate(), deflate_exports)).then((m2) => m2.default));
addDecoder(32773, () => Promise.resolve().then(() => (init_packbits(), packbits_exports)).then((m2) => m2.default));
addDecoder(
  34887,
  () => Promise.resolve().then(() => (init_lerc(), lerc_exports)).then(async (m2) => {
    await m2.zstd.init();
    return m2;
  }).then((m2) => m2.default)
);
addDecoder(50001, () => Promise.resolve().then(() => (init_webimage(), webimage_exports)).then((m2) => m2.default));

// node_modules/geotiff/dist-module/geotiff.js
init_basedecoder();

// node_modules/lzw-tiff-decoder/index.mjs
var A;
var I = null;
function g() {
  return null !== I && I.buffer === A.memory.buffer || (I = new Uint8Array(A.memory.buffer)), I;
}
var B = 0;
var Q = null;
function C() {
  return null !== Q && Q.buffer === A.memory.buffer || (Q = new Int32Array(A.memory.buffer)), Q;
}
async function E(I3) {
  void 0 === I3 && (I3 = "".replace(/\.js$/, "_bg.wasm"));
  ("string" == typeof I3 || "function" == typeof Request && I3 instanceof Request || "function" == typeof URL && I3 instanceof URL) && (I3 = fetch(I3));
  const { instance: g3, module: B3 } = await async function(A3, I4) {
    if ("function" == typeof Response && A3 instanceof Response) {
      if ("function" == typeof WebAssembly.instantiateStreaming)
        try {
          return await WebAssembly.instantiateStreaming(A3, I4);
        } catch (I5) {
          if ("application/wasm" == A3.headers.get("Content-Type"))
            throw I5;
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", I5);
        }
      const g4 = await A3.arrayBuffer();
      return await WebAssembly.instantiate(g4, I4);
    }
    {
      const g4 = await WebAssembly.instantiate(A3, I4);
      return g4 instanceof WebAssembly.Instance ? { instance: g4, module: A3 } : g4;
    }
  }(await I3, {});
  return A = g3.exports, E.__wbindgen_wasm_module = B3, A;
}
var D = Object.freeze({ __proto__: null, decompress: function(I3, Q3) {
  try {
    const F2 = A.__wbindgen_add_to_stack_pointer(-16);
    var E3 = function(A3, I4) {
      const Q4 = I4(1 * A3.length);
      return g().set(A3, Q4 / 1), B = A3.length, Q4;
    }(I3, A.__wbindgen_malloc), D3 = B;
    A.decompress(F2, E3, D3, Q3);
    var i3 = C()[F2 / 4 + 0], w3 = C()[F2 / 4 + 1], G3 = (o3 = i3, N3 = w3, g().subarray(o3 / 1, o3 / 1 + N3)).slice();
    return A.__wbindgen_free(i3, 1 * w3), G3;
  } finally {
    A.__wbindgen_add_to_stack_pointer(16);
  }
  var o3, N3;
}, default: E });
var i = [62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
function w(A3) {
  return i[A3 - 43];
}
var G = function(A3) {
  let I3, g3 = A3.endsWith("==") ? 2 : A3.endsWith("=") ? 1 : 0, B3 = A3.length, Q3 = new Uint8Array(B3 / 4 * 3);
  for (let g4 = 0, C3 = 0; g4 < B3; g4 += 4, C3 += 3)
    I3 = w(A3.charCodeAt(g4)) << 18 | w(A3.charCodeAt(g4 + 1)) << 12 | w(A3.charCodeAt(g4 + 2)) << 6 | w(A3.charCodeAt(g4 + 3)), Q3[C3] = I3 >> 16, Q3[C3 + 1] = I3 >> 8 & 255, Q3[C3 + 2] = 255 & I3;
  return Q3.subarray(0, Q3.length - g3);
}("AGFzbQEAAAABWQ5gAn9/AX9gA39/fwF/YAJ/fwBgAX8AYAN/f38AYAF/AX9gBH9/f38AYAR/f39/AX9gBn9/f39/fwBgAX8BfmAAAGAFf39/f38AYAV/f39/fwF/YAJ+fwF/A21sBQgICwMBAgUMAQABAAIABQACAgYGDQYDAgACAAAEBAQCAgYGAAYBBgIHAwQDBAQDAwADBQMDBAQEBAQCAgAHAAQAAgMBAgcFBAIDAQUCAgIDAgIDAwcCAQAABAIACgAAAQAFAgADBQkJCQMCBAUBcAErKwUDAQARBgkBfwFBgIDAAAsHXwUGbWVtb3J5AgAKZGVjb21wcmVzcwAnH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAYhFfX3diaW5kZ2VuX21hbGxvYwBMD19fd2JpbmRnZW5fZnJlZQBWCTABAEEBCypqJDUCZmVDNQFmZUNha2pXDD1pVBohSVtTaGdfXDEOXlhqaQscQWAbP2QKsugBbNMqAgh/AX4CQAJAAkACQCAAQfUBTwRAIABBzf97Tw0CIABBC2oiAEF4cSEGQZCnwAAoAgAiCEUNAUEAIAZrIQQCQAJAAn9BACAAQQh2IgBFDQAaQR8gBkH///8HSw0AGiAGQQYgAGciAGtBH3F2QQFxIABBAXRrQT5qCyIHQQJ0QZypwABqKAIAIgAEQCAGQQBBGSAHQQF2a0EfcSAHQR9GG3QhAgNAAkAgAEEEaigCAEF4cSIFIAZJDQAgBSAGayIFIARPDQAgACEDIAUiBA0AQQAhBAwDCyAAQRRqKAIAIgUgASAFIAAgAkEddkEEcWpBEGooAgAiAEcbIAEgBRshASACQQF0IQIgAA0ACyABBEAgASEADAILIAMNAgtBACEDQQIgB0EfcXQiAEEAIABrciAIcSIARQ0DIABBACAAa3FoQQJ0QZypwABqKAIAIgBFDQMLA0AgACADIABBBGooAgBBeHEiAiAGTyACIAZrIgIgBElxIgEbIQMgAiAEIAEbIQQgACgCECICBH8gAgUgAEEUaigCAAsiAA0ACyADRQ0CC0GcqsAAKAIAIgAgBk9BACAEIAAgBmtPGw0BIAMoAhghBwJAAkAgAyADKAIMIgFGBEAgA0EUQRAgA0EUaiICKAIAIgEbaigCACIADQFBACEBDAILIAMoAggiACABNgIMIAEgADYCCAwBCyACIANBEGogARshAgNAIAIhBSAAIgFBFGoiAigCACIARQRAIAFBEGohAiABKAIQIQALIAANAAsgBUEANgIACwJAIAdFDQACQCADIAMoAhxBAnRBnKnAAGoiACgCAEcEQCAHQRBBFCAHKAIQIANGG2ogATYCACABRQ0CDAELIAAgATYCACABDQBBkKfAAEGQp8AAKAIAQX4gAygCHHdxNgIADAELIAEgBzYCGCADKAIQIgAEQCABIAA2AhAgACABNgIYCyADQRRqKAIAIgBFDQAgAUEUaiAANgIAIAAgATYCGAsCQCAEQRBPBEAgAyAGQQNyNgIEIAMgBmoiBSAEQQFyNgIEIAQgBWogBDYCACAEQYACTwRAIAVCADcCECAFAn9BACAEQQh2IgBFDQAaQR8gBEH///8HSw0AGiAEQQYgAGciAGtBH3F2QQFxIABBAXRrQT5qCyIANgIcIABBAnRBnKnAAGohAgJAAkACQAJAQZCnwAAoAgAiAUEBIABBH3F0IgZxBEAgAigCACICQQRqKAIAQXhxIARHDQEgAiEADAILQZCnwAAgASAGcjYCACACIAU2AgAMAwsgBEEAQRkgAEEBdmtBH3EgAEEfRht0IQEDQCACIAFBHXZBBHFqQRBqIgYoAgAiAEUNAiABQQF0IQEgACECIABBBGooAgBBeHEgBEcNAAsLIAAoAggiAiAFNgIMIAAgBTYCCCAFQQA2AhggBSAANgIMIAUgAjYCCAwECyAGIAU2AgALIAUgAjYCGCAFIAU2AgwgBSAFNgIIDAILIARBA3YiAkEDdEGUp8AAaiEAAn9BjKfAACgCACIBQQEgAnQiAnEEQCAAKAIIDAELQYynwAAgASACcjYCACAACyECIAAgBTYCCCACIAU2AgwgBSAANgIMIAUgAjYCCAwBCyADIAQgBmoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAsgA0EIag8LAkACQEGMp8AAKAIAIgFBECAAQQtqQXhxIABBC0kbIgZBA3YiAHYiAkEDcUUEQCAGQZyqwAAoAgBNDQMgAg0BQZCnwAAoAgAiAEUNAyAAQQAgAGtxaEECdEGcqcAAaigCACIBQQRqKAIAQXhxIAZrIQQgASECA0AgASgCECIARQRAIAFBFGooAgAiAEUNBAsgAEEEaigCAEF4cSAGayIBIAQgASAESSIBGyEEIAAgAiABGyECIAAhAQwACwALAkAgAkF/c0EBcSAAaiIAQQN0QYynwABqIgNBEGooAgAiAkEIaiIFKAIAIgQgA0EIaiIDRwRAIAQgAzYCDCADIAQ2AggMAQtBjKfAACABQX4gAHdxNgIACyACIABBA3QiAEEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBCAFDwsCQEECIAB0IgRBACAEa3IgAiAAdHEiAEEAIABrcWgiAkEDdEGMp8AAaiIDQRBqKAIAIgBBCGoiBSgCACIEIANBCGoiA0cEQCAEIAM2AgwgAyAENgIIDAELQYynwAAgAUF+IAJ3cTYCAAsgACAGQQNyNgIEIAAgBmoiAyACQQN0IgIgBmsiAUEBcjYCBCAAIAJqIAE2AgBBnKrAACgCACIABEAgAEEDdiIEQQN0QZSnwABqIQBBpKrAACgCACECAn9BjKfAACgCACIGQQEgBEEfcXQiBHEEQCAAKAIIDAELQYynwAAgBCAGcjYCACAACyEEIAAgAjYCCCAEIAI2AgwgAiAANgIMIAIgBDYCCAtBpKrAACADNgIAQZyqwAAgATYCACAFDwsgAigCGCEHAkACQCACIAIoAgwiAUYEQCACQRRBECACQRRqIgEoAgAiAxtqKAIAIgANAUEAIQEMAgsgAigCCCIAIAE2AgwgASAANgIIDAELIAEgAkEQaiADGyEDA0AgAyEFIAAiAUEUaiIDKAIAIgBFBEAgAUEQaiEDIAEoAhAhAAsgAA0ACyAFQQA2AgALIAdFDQMgAiACKAIcQQJ0QZypwABqIgAoAgBHBEAgB0EQQRQgBygCECACRhtqIAE2AgAgAUUNBAwDCyAAIAE2AgAgAQ0CQZCnwABBkKfAACgCAEF+IAIoAhx3cTYCAAwDCwJAAkACQAJAAkBBnKrAACgCACIAIAZJBEBBoKrAACgCACIAIAZLDQNBACECIAZBr4AEaiIAQRB2QAAiAUF/Rg0GIAFBEHQiBUUNBkGsqsAAIABBgIB8cSIEQayqwAAoAgBqIgA2AgBBsKrAAEGwqsAAKAIAIgEgACABIABLGzYCAEGoqsAAKAIAIgNFDQFBtKrAACEAA0AgACgCACIBIAAoAgQiB2ogBUYNAyAAKAIIIgANAAsMBAtBpKrAACgCACECAn8gACAGayIBQQ9NBEBBpKrAAEEANgIAQZyqwABBADYCACACIABBA3I2AgQgACACaiIBQQRqIQAgASgCBEEBcgwBC0GcqsAAIAE2AgBBpKrAACACIAZqIgQ2AgAgBCABQQFyNgIEIAAgAmogATYCACACQQRqIQAgBkEDcgshASAAIAE2AgAgAkEIag8LQciqwAAoAgAiAEEAIAAgBU0bRQRAQciqwAAgBTYCAAtBzKrAAEH/HzYCAEG0qsAAIAU2AgBBwKrAAEEANgIAQbiqwAAgBDYCAEGgp8AAQZSnwAA2AgBBqKfAAEGcp8AANgIAQZynwABBlKfAADYCAEGwp8AAQaSnwAA2AgBBpKfAAEGcp8AANgIAQbinwABBrKfAADYCAEGsp8AAQaSnwAA2AgBBwKfAAEG0p8AANgIAQbSnwABBrKfAADYCAEHIp8AAQbynwAA2AgBBvKfAAEG0p8AANgIAQdCnwABBxKfAADYCAEHEp8AAQbynwAA2AgBB2KfAAEHMp8AANgIAQcynwABBxKfAADYCAEHgp8AAQdSnwAA2AgBB1KfAAEHMp8AANgIAQdynwABB1KfAADYCAEHop8AAQdynwAA2AgBB5KfAAEHcp8AANgIAQfCnwABB5KfAADYCAEHsp8AAQeSnwAA2AgBB+KfAAEHsp8AANgIAQfSnwABB7KfAADYCAEGAqMAAQfSnwAA2AgBB/KfAAEH0p8AANgIAQYiowABB/KfAADYCAEGEqMAAQfynwAA2AgBBkKjAAEGEqMAANgIAQYyowABBhKjAADYCAEGYqMAAQYyowAA2AgBBlKjAAEGMqMAANgIAQaCowABBlKjAADYCAEGoqMAAQZyowAA2AgBBnKjAAEGUqMAANgIAQbCowABBpKjAADYCAEGkqMAAQZyowAA2AgBBuKjAAEGsqMAANgIAQayowABBpKjAADYCAEHAqMAAQbSowAA2AgBBtKjAAEGsqMAANgIAQciowABBvKjAADYCAEG8qMAAQbSowAA2AgBB0KjAAEHEqMAANgIAQcSowABBvKjAADYCAEHYqMAAQcyowAA2AgBBzKjAAEHEqMAANgIAQeCowABB1KjAADYCAEHUqMAAQcyowAA2AgBB6KjAAEHcqMAANgIAQdyowABB1KjAADYCAEHwqMAAQeSowAA2AgBB5KjAAEHcqMAANgIAQfiowABB7KjAADYCAEHsqMAAQeSowAA2AgBBgKnAAEH0qMAANgIAQfSowABB7KjAADYCAEGIqcAAQfyowAA2AgBB/KjAAEH0qMAANgIAQZCpwABBhKnAADYCAEGEqcAAQfyowAA2AgBBmKnAAEGMqcAANgIAQYypwABBhKnAADYCAEGoqsAAIAU2AgBBlKnAAEGMqcAANgIAQaCqwAAgBEFYaiIANgIAIAUgAEEBcjYCBCAAIAVqQSg2AgRBxKrAAEGAgIABNgIADAMLIABBDGooAgAgBSADTXIgASADS3INASAAIAQgB2o2AgRBqKrAAEGoqsAAKAIAIgBBD2pBeHEiAUF4ajYCAEGgqsAAQaCqwAAoAgAgBGoiBCAAIAFrakEIaiIDNgIAIAFBfGogA0EBcjYCACAAIARqQSg2AgRBxKrAAEGAgIABNgIADAILQaCqwAAgACAGayICNgIAQaiqwABBqKrAACgCACIAIAZqIgE2AgAgASACQQFyNgIEIAAgBkEDcjYCBCAAQQhqIQIMAgtByKrAAEHIqsAAKAIAIgAgBSAAIAVJGzYCACAEIAVqIQFBtKrAACEAAkADQCABIAAoAgBHBEAgACgCCCIADQEMAgsLIABBDGooAgANACAAIAU2AgAgACAAKAIEIARqNgIEIAUgBkEDcjYCBCAFIAZqIQAgASAFayAGayEGAkACQCABQaiqwAAoAgBHBEBBpKrAACgCACABRg0BIAFBBGooAgAiAkEDcUEBRgRAIAEgAkF4cSICEBEgAiAGaiEGIAEgAmohAQsgASABKAIEQX5xNgIEIAAgBkEBcjYCBCAAIAZqIAY2AgAgBkGAAk8EQCAAQgA3AhAgAAJ/QQAgBkEIdiICRQ0AGkEfIAZB////B0sNABogBkEGIAJnIgJrQR9xdkEBcSACQQF0a0E+agsiATYCHCABQQJ0QZypwABqIQICQAJAAkACQEGQp8AAKAIAIgRBASABQR9xdCIDcQRAIAIoAgAiAkEEaigCAEF4cSAGRw0BIAIhBAwCC0GQp8AAIAMgBHI2AgAgAiAANgIADAMLIAZBAEEZIAFBAXZrQR9xIAFBH0YbdCEBA0AgAiABQR12QQRxakEQaiIDKAIAIgRFDQIgAUEBdCEBIAQiAkEEaigCAEF4cSAGRw0ACwsgBCgCCCICIAA2AgwgBCAANgIIIABBADYCGCAAIAQ2AgwgACACNgIIDAULIAMgADYCAAsgACACNgIYIAAgADYCDCAAIAA2AggMAwsgBkEDdiIBQQN0QZSnwABqIQICf0GMp8AAKAIAIgRBASABdCIBcQRAIAIoAggMAQtBjKfAACABIARyNgIAIAILIQEgAiAANgIIIAEgADYCDCAAIAI2AgwgACABNgIIDAILQaiqwAAgADYCAEGgqsAAQaCqwAAoAgAgBmoiAjYCACAAIAJBAXI2AgQMAQtBpKrAACAANgIAQZyqwABBnKrAACgCACAGaiICNgIAIAAgAkEBcjYCBCAAIAJqIAI2AgALIAVBCGoPC0G0qsAAIQADQAJAIAAoAgAiASADTQRAIAEgACgCBGoiByADSw0BCyAAKAIIIQAMAQsLQaiqwAAgBTYCAEGgqsAAIARBWGoiADYCACAFIABBAXI2AgQgACAFakEoNgIEQcSqwABBgICAATYCACADIAdBYGpBeHFBeGoiACAAIANBEGpJGyIBQRs2AgRBtKrAACkCACEJIAFBEGpBvKrAACkCADcCACABIAk3AghBwKrAAEEANgIAQbiqwAAgBDYCAEG0qsAAIAU2AgBBvKrAACABQQhqNgIAIAFBHGohAANAIABBBzYCACAHIABBBGoiAEsNAAsgASADRg0AIAEgASgCBEF+cTYCBCADIAEgA2siBUEBcjYCBCABIAU2AgAgBUGAAk8EQCADQgA3AhAgA0EcagJ/QQAgBUEIdiIARQ0AGkEfIAVB////B0sNABogBUEGIABnIgBrQR9xdkEBcSAAQQF0a0E+agsiADYCACAAQQJ0QZypwABqIQECQAJAAkACQEGQp8AAKAIAIgRBASAAQR9xdCIHcQRAIAEoAgAiBEEEaigCAEF4cSAFRw0BIAQhAAwCC0GQp8AAIAQgB3I2AgAgASADNgIAIANBGGogATYCAAwDCyAFQQBBGSAAQQF2a0EfcSAAQR9GG3QhAQNAIAQgAUEddkEEcWpBEGoiBygCACIARQ0CIAFBAXQhASAAIQQgAEEEaigCAEF4cSAFRw0ACwsgACgCCCIBIAM2AgwgACADNgIIIANBGGpBADYCACADIAA2AgwgAyABNgIIDAMLIAcgAzYCACADQRhqIAQ2AgALIAMgAzYCDCADIAM2AggMAQsgBUEDdiIBQQN0QZSnwABqIQACf0GMp8AAKAIAIgRBASABdCIBcQRAIAAoAggMAQtBjKfAACABIARyNgIAIAALIQEgACADNgIIIAEgAzYCDCADIAA2AgwgAyABNgIIC0GgqsAAKAIAIgAgBk0NAEGgqsAAIAAgBmsiAjYCAEGoqsAAQaiqwAAoAgAiACAGaiIBNgIAIAEgAkEBcjYCBCAAIAZBA3I2AgQgAEEIag8LIAIPCyABIAc2AhggAigCECIABEAgASAANgIQIAAgATYCGAsgAkEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLAkAgBEEQTwRAIAIgBkEDcjYCBCACIAZqIgMgBEEBcjYCBCADIARqIAQ2AgBBnKrAACgCACIABEAgAEEDdiIFQQN0QZSnwABqIQBBpKrAACgCACEBAn9BjKfAACgCACIGQQEgBUEfcXQiBXEEQCAAKAIIDAELQYynwAAgBSAGcjYCACAACyEFIAAgATYCCCAFIAE2AgwgASAANgIMIAEgBTYCCAtBpKrAACADNgIAQZyqwAAgBDYCAAwBCyACIAQgBmoiAEEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAsgAkEIagvhEAISfwJ+IwBBgAFrIgYkACAGIAM2AiwgBiACNgIoAkACfwJAAkACQAJAIAEtAEdFBEAgASkDOCEYIAFCADcDOAJ/IBhC//8Dg1BFBEAgGEIwiKchESAYQhCIpyEMIBhCIIinDAELIAZBIGogASAGQShqECsgBi8BIEUEQEEBIQ0MBgtBAyENIAYvASIiDCICIAEvAUBPDQUgAiABLwFCRg0CIAEvAUQgDEH//wNxRg0DIAFBGGooAgBFDQUgAUEoaiABQRBqIgcgDBAmGiABKAIYIgIgDEH//wNxIgpNDQQgBygCACAKQQJ0aiICLQACIREgAi8BAAshEyAGQRhqIAFBKGoQQiAGKAIYIQICQCAGKAIcIgcgBU0EQCAHDQFBASESQQEhDSAFIQdBAQwHCyAFRQRAQQEhDUEAIQdBAQwHCyAEIAIgBRBLGiABQTBqIgIgAigCACAFajYCAEGIg8AAIQRBACENQQAhB0EBDAYLIAQgAiAHEEsgAUEwaiICIAIoAgAgB2o2AgAgB2ohBCAFIAdrIQdBACENQQEMBQsgAEECOgAIIABCADcCAAwFCyABIAEtAEYiB0EBaiICOgAKIAFBASAHQQ9xdEECajsBQCABQX8gAkEPcXRBf3M7AQggAUEQaiAHEA1BACEMQQAhDSAFIQdBAAwDCyABQQE6AEdBAiENDAELIAogAkHohsAAEDYAC0EAIQwgBSEHQQALIQIgBkE4akEANgIAIAZCADcDMCAGQcgAakEANgIAIAZCADcDQCAGQfwAakEANgIAIAZB9ABqQQA2AgAgBkHsAGpBADYCACAGQeQAakEANgIAIAZB3ABqQQA2AgAgBkHYicAANgJ4IAZB2InAADYCcCAGQdiJwAA2AmggBkHYicAANgJgIAZB2InAADYCWCAGQQA2AlQgBkHYicAANgJQAkACfwJAIAJFDQAgAUEQaiEUIAFBKGohFSAGQcgAaiEXIAZBPmohFgJAAkACQAJAAkACQAJAAkADQAJAAkAgBw0AIAZBEGogFRBCIAYoAhRFDQBBACEHDAELIAEgBkEoahAYQQAhCyAXIRBBACEOAkACQAJAAkACQAJAAkACQAJAA0AgAS0ACyICIAEtAAoiCEkNASABIAIgCGs6AAsgBkEwaiALaiIKIAEvAQgiAiABKQMAIAitiSIYp3E7AQAgASAYIAKtQn+FQoCAfISDNwMAIA4EQCAOQX9qQQVLDQUgByALIBZqLwEAIgJJDQYgECAENgIAIBBBBGogAjYCACAHIAJrIQcgAiAEaiEECyABLwFAIgIgDmpB//8DcSABLwEIIAEtAEhrQf//A3FGDQIgCi8BACIKIAEvAUJGIAogAk9yDQIgCiABLwFERg0CIAEoAiQiAiAKTQ0GIAcgASgCHCAKQQF0ai8BACICSQ0CIA5BAWohDiALIBZqQQJqIAI7AQAgEEEIaiEQIAtBAmoiC0EMRw0AC0EGIQ5BBSEQIAYvATohCAwHCyAODQFBASANIBIbIQ0MCAsgDkEBaiEOCyAOQQdPDQMgBkEwaiAOQX9qIhBBAXRqLwEAIQggEA0EIAwhCgwFCyAOQX9qQQZBmITAABA2AAtB6IHAAEEjQfiCwAAQSAALIAogAkGohMAAEDYACyAOQQZBuITAABA3AAsgBkHQAGohAiAGQTBqIQsDQCAGQQhqIBQgFCALLwEAIgogAigCACACQQRqKAIAECkgDBAjIAYtAAohESAGLwEIIRMgASABLwFAQQFqOwFAIAtBAmohCyACQQhqIQIgCiEMIBBBf2oiEA0ACyAOQQN0IAZqQUBrIgIoAgQhCSACQQA2AgQgAigCACEPIAJBiIPAADYCAAsgCCIMIAEvAUJGDQMCQCABLwFEIAhHBEAgCCABLwFAIgJNDQFBAyENQQAMDQsgAUEBOgBHQQIhDUEADAwLAn8gBwJ/AkACQCACIAhHBEAgASgCJCICIAhLDQEgCCACQdiEwAAQNgALIAEoAiQiAiAKQf//A3EiCE0NCCAHIAEoAhwgCEEBdGovAQBBAWpB//8DcSICTw0BIA8EQCABKAIsIgIgCUkNCiABKAIoIA8gCRBLGiABIAk2AjAgASAJNgI0C0EAIQ8gFRAzIQtBAQwDCyAHIAEoAhwgCEEBdGovAQAiAkkEQEEAIQ8gFSAUIAwQJiELQQEMAwsgFCAMIAQgAhApIQsgAgwBCyAPRQRAIAEoAiwiCCABKAI0IglJDQkgFSgCACEPCyAJRQ0EIAkgAksNCSAPLQAAIQsgBCAPIAkQSyACIAlGDQogCWogCzoAACACCyIJayEHIAkgBCIPaiEEQQALIAEoAhhB/x9NBEAgBiAUIAsgChAjIAEvAUAhECAGLQACIREgBi8BACETAkAgAS0ACiIIQQtLDQAgECABLwEIIgogAS0ASGtB//8DcUcNACABIAhBAWo6AAogASAKQQF0QQFyOwEICyABIBBBAWo7AUALQQAhEkUNAQsLQgEhGSAPRQ0KIAEoAiwiAiAJSQ0HIAEoAiggDyAJEEsaIAEgCTYCMCABIAk2AjQMCgtBAEEAQYiFwAAQNgALIAEQNAwGCyAIIAJByITAABA2AAsgCSACQeiEwAAQNwALIAkgCEH4hMAAEDcACyAJIAJBmIXAABA3AAtBAEEAQaiFwAAQNgALIAkgAkG4hcAAEDcAC0EACyEMQQAhE0EAIRELIAAgBSAHazYCBCAAIAMgBigCLCICazYCACAAQQAgDSADIAJLGyANIA1BAUYbOgAIIAEgDK1C//8Dg0IQhiAZhCATrUL//wODQiCGhCARrUL/AYNCMIaENwM4CyAGQYABaiQAC9YQAhF/An4jAEGAAWsiBiQAIAYgAzYCLCAGIAI2AigCQAJ/AkACQAJAAkAgAS0AR0UEQCABKQM4IRcgAUIANwM4An8gF0L//wODUEUEQCAXQjCIpyERIBdCEIinIQwgF0IgiKcMAQsgBkEgaiABIAZBKGoQLiAGLwEgRQRAQQEhDQwGC0EDIQ0gBi8BIiIMIgIgAS8BQE8NBSACIAEvAUJGDQIgAS8BRCAMQf//A3FGDQMgAUEYaigCAEUNBSABQShqIAFBEGoiByAMECYaIAEoAhgiAiAMQf//A3EiCU0NBCAHKAIAIAlBAnRqIgItAAIhESACLwEACyESIAZBGGogAUEoahBCIAYoAhghAgJAIAYoAhwiByAFTQRAIAcNAUEBIQhBASENIAUhB0EBDAcLIAVFBEBBASENQQAhB0EBDAcLIAQgAiAFEEsaIAFBMGoiAiACKAIAIAVqNgIAQYiDwAAhBEEAIQ1BACEHQQEMBgsgBCACIAcQSyABQTBqIgIgAigCACAHajYCACAHaiEEIAUgB2shB0EAIQ1BAQwFCyAAQQI6AAggAEIANwIADAULIAEgAS0ARiIHQQFqIgI6AAogAUEBIAdBD3F0QQJqOwFAIAFBfyACQQ9xdEF/czsBCCABQRBqIAcQDUEAIQxBACENIAUhB0EADAMLIAFBAToAR0ECIQ0MAQsgCSACQeiGwAAQNgALQQAhDCAFIQdBAAshAiAGQThqQQA2AgAgBkIANwMwIAZByABqQQA2AgAgBkIANwNAIAZB/ABqQQA2AgAgBkH0AGpBADYCACAGQewAakEANgIAIAZB5ABqQQA2AgAgBkHcAGpBADYCACAGQdiJwAA2AnggBkHYicAANgJwIAZB2InAADYCaCAGQdiJwAA2AmAgBkHYicAANgJYIAZBADYCVCAGQdiJwAA2AlACQAJ/AkAgAkUNACABQRBqIRMgAUEoaiEUIAZByABqIRYgBkE+aiEVAkACQAJAAkACQAJAAkACQANAAkACQCAHDQAgBkEQaiAUEEIgBigCFEUNAEEAIQcMAQsgASAGQShqECBBACELIBYhEEEAIQ4CQAJAAkACQAJAAkACQAJAAkADQCABLQALIgIgAS0ACiIJSQ0BIAEgAiAJazoACyABIAEpAwAiFyAJrUI/g4g3AwAgBkEwaiALaiIJIAEvAQggF6dxOwEAIA4EQCAOQX9qQQVLDQUgByALIBVqLwEAIgJJDQYgECAENgIAIBBBBGogAjYCACAHIAJrIQcgAiAEaiEECyABLwFAIgIgDmpB//8DcSABLwEIIAEtAEhrQf//A3FGDQIgCS8BACIJIAEvAUJGIAkgAk9yDQIgCSABLwFERg0CIAEoAiQiAiAJTQ0GIAcgASgCHCAJQQF0ai8BACICSQ0CIA5BAWohDiALIBVqQQJqIAI7AQAgEEEIaiEQIAtBAmoiC0EMRw0AC0EGIQ5BBSEQIAYvATohCAwHCyAODQFBASANIAgbIQ0MCAsgDkEBaiEOCyAOQQdPDQMgBkEwaiAOQX9qIhBBAXRqLwEAIQggEA0EIAwhCQwFCyAOQX9qQQZBmITAABA2AAtB6IHAAEEjQfiCwAAQSAALIAkgAkGohMAAEDYACyAOQQZBuITAABA3AAsgBkHQAGohAiAGQTBqIQsDQCAGQQhqIBMgEyALLwEAIgkgAigCACACQQRqKAIAECkgDBAjIAYtAAohESAGLwEIIRIgASABLwFAQQFqOwFAIAtBAmohCyACQQhqIQIgCSEMIBBBf2oiEA0ACyAOQQN0IAZqQUBrIgIoAgQhCiACQQA2AgQgAigCACEPIAJBiIPAADYCAAsgCCIMIAEvAUJGDQMCQCABLwFEIAhHBEAgCCABLwFAIgJNDQFBAyENQQAMDQsgAUEBOgBHQQIhDUEADAwLAn8gBwJ/AkACQCACIAhHBEAgASgCJCICIAhLDQEgCCACQdiEwAAQNgALIAEoAiQiAiAJQf//A3EiCE0NCCAHIAEoAhwgCEEBdGovAQBBAWpB//8DcSICTw0BIA8EQCABKAIsIgIgCkkNCiABKAIoIA8gChBLGiABIAo2AjAgASAKNgI0C0EAIQ8gFBAzIQtBAQwDCyAHIAEoAhwgCEEBdGovAQAiAkkEQEEAIQ8gFCATIAwQJiELQQEMAwsgEyAMIAQgAhApIQsgAgwBCyAPRQRAIAEoAiwiCCABKAI0IgpJDQkgFCgCACEPCyAKRQ0EIAogAksNCSAPLQAAIQsgBCAPIAoQSyACIApGDQogCmogCzoAACACCyIKayEHIAogBCIPaiEEQQALIAEoAhhB/x9NBEAgBiATIAsgCRAjIAEvAUAhECAGLQACIREgBi8BACESAkAgAS0ACiIIQQtLDQAgECABLwEIIgkgAS0ASGtB//8DcUcNACABIAhBAWo6AAogASAJQQF0QQFyOwEICyABIBBBAWo7AUALQQAhCEUNAQsLQgEhGCAPRQ0KIAEoAiwiAiAKSQ0HIAEoAiggDyAKEEsaIAEgCjYCMCABIAo2AjQMCgtBAEEAQYiFwAAQNgALIAEQNAwGCyAIIAJByITAABA2AAsgCiACQeiEwAAQNwALIAogCEH4hMAAEDcACyAKIAJBmIXAABA3AAtBAEEAQaiFwAAQNgALIAogAkG4hcAAEDcAC0EACyEMQQAhEkEAIRELIAAgBSAHazYCBCAAIAMgBigCLCICazYCACAAQQAgDSADIAJLGyANIA1BAUYbOgAIIAEgDK1C//8Dg0IQhiAYhCASrUL//wODQiCGhCARrUL/AYNCMIaENwM4CyAGQYABaiQAC6oIAQZ/IwBB8ABrIgUkACAFIAM2AgwgBSACNgIIQQEhByABIQYCQCABQYECSQ0AQQAgAWshCUGAAiEIA0ACQCAIIAFPDQBBACEHIAAgCGosAABBv39MDQAgCCEGDAILIAhBf2ohBkEAIQcgCEEBRg0BIAggCWogBiEIQQFHDQALCyAFIAY2AhQgBSAANgIQIAVBAEEFIAcbNgIcIAVB8IvAAEHAksAAIAcbNgIYAkACfwJAAkAgAiABSyIHIAMgAUtyRQRAIAIgA0sNAQJAIAJFIAEgAkZyRQRAIAEgAk0NASAAIAJqLAAAQUBIDQELIAMhAgsgBSACNgIgIAJBACABIAJHG0UEQCACIQcMAwsgAUEBaiEDA0ACQCACIAFPDQAgACACaiwAAEFASA0AIAIhByAFQSRqDAULIAJBf2ohByACQQFGDQMgAiADRiAHIQJFDQALDAILIAUgAiADIAcbNgIoIAVBxABqQQM2AgAgBUHcAGpBHTYCACAFQdQAakEdNgIAIAVCAzcCNCAFQeiSwAA2AjAgBUEcNgJMIAUgBUHIAGo2AkAgBSAFQRhqNgJYIAUgBUEQajYCUCAFIAVBKGo2AkgMAwsgBUHkAGpBHTYCACAFQdwAakEdNgIAIAVB1ABqQRw2AgAgBUHEAGpBBDYCACAFQgQ3AjQgBUGkk8AANgIwIAVBHDYCTCAFIAVByABqNgJAIAUgBUEYajYCYCAFIAVBEGo2AlggBSAFQQxqNgJQIAUgBUEIajYCSAwCCyAFQSRqCyEIAkAgASAHRg0AQQEhAwJAAkACQCAAIAdqIgYsAAAiAkF/TARAQQAhAyAAIAFqIgEhACABIAZBAWpHBEAgBi0AAUE/cSEDIAZBAmohAAsgAkEfcSEJIAJB/wFxQd8BSw0BIAMgCUEGdHIhAgwCCyAFIAJB/wFxNgIkIAVBKGohAQwCC0EAIQogASEGIAAgAUcEQCAALQAAQT9xIQogAEEBaiEGCyAKIANBBnRyIQAgAkH/AXFB8AFJBEAgACAJQQx0ciECDAELQQAhAiABIAZHBH8gBi0AAEE/cQVBAAsgCUESdEGAgPAAcSAAQQZ0cnIiAkGAgMQARg0CCyAFIAI2AiRBASEDIAVBKGohASACQYABSQ0AQQIhAyACQYAQSQ0AQQNBBCACQYCABEkbIQMLIAUgBzYCKCAFIAMgB2o2AiwgBUHEAGpBBTYCACAFQewAakEdNgIAIAVB5ABqQR02AgAgBUHcAGpBHjYCACAFQdQAakEfNgIAIAVCBTcCNCAFQfiTwAA2AjAgBSABNgJYIAUgCDYCUCAFQRw2AkwgBSAFQcgAajYCQCAFIAVBGGo2AmggBSAFQRBqNgJgIAUgBUEgajYCSAwBC0H8i8AAQSsgBBBIAAsgBUEwaiAEEFEAC9IIAQV/IABBeGoiASAAQXxqKAIAIgNBeHEiAGohAgJAAkAgA0EBcQ0AIANBA3FFDQEgASgCACIDIABqIQAgASADayIBQaSqwAAoAgBGBEAgAigCBEEDcUEDRw0BQZyqwAAgADYCACACIAIoAgRBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAA8LIAEgAxARCwJAIAJBBGoiBCgCACIDQQJxBEAgBCADQX5xNgIAIAEgAEEBcjYCBCAAIAFqIAA2AgAMAQsCQCACQaiqwAAoAgBHBEBBpKrAACgCACACRg0BIAIgA0F4cSICEBEgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFBpKrAACgCAEcNAkGcqsAAIAA2AgAPC0GoqsAAIAE2AgBBoKrAAEGgqsAAKAIAIABqIgA2AgAgASAAQQFyNgIEQaSqwAAoAgAgAUYEQEGcqsAAQQA2AgBBpKrAAEEANgIAC0HEqsAAKAIAIgIgAE8NAkGoqsAAKAIAIgBFDQICQEGgqsAAKAIAIgNBKUkNAEG0qsAAIQEDQCABKAIAIgQgAE0EQCAEIAEoAgRqIABLDQILIAEoAggiAQ0ACwtBzKrAAAJ/Qf8fQbyqwAAoAgAiAEUNABpBACEBA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGws2AgAgAyACTQ0CQcSqwABBfzYCAA8LQaSqwAAgATYCAEGcqsAAQZyqwAAoAgAgAGoiADYCACABIABBAXI2AgQgACABaiAANgIADwtBzKrAAAJ/AkAgAEGAAk8EQCABQgA3AhAgAUEcagJ/QQAgAEEIdiICRQ0AGkEfIABB////B0sNABogAEEGIAJnIgJrQR9xdkEBcSACQQF0a0E+agsiAzYCACADQQJ0QZypwABqIQICQAJAAkACQAJAQZCnwAAoAgAiBEEBIANBH3F0IgVxBEAgAigCACICQQRqKAIAQXhxIABHDQEgAiEDDAILQZCnwAAgBCAFcjYCACACIAE2AgAMAwsgAEEAQRkgA0EBdmtBH3EgA0EfRht0IQQDQCACIARBHXZBBHFqQRBqIgUoAgAiA0UNAiAEQQF0IQQgAyICQQRqKAIAQXhxIABHDQALCyADKAIIIgAgATYCDCADIAE2AgggAUEYakEANgIAIAEgAzYCDCABIAA2AggMAgsgBSABNgIACyABQRhqIAI2AgAgASABNgIMIAEgATYCCAtBzKrAAEHMqsAAKAIAQX9qIgA2AgAgAA0DQbyqwAAoAgAiAA0BQf8fDAILIABBA3YiAkEDdEGUp8AAaiEAAn9BjKfAACgCACIDQQEgAnQiAnEEQCAAKAIIDAELQYynwAAgAiADcjYCACAACyECIAAgATYCCCACIAE2AgwgASAANgIMIAEgAjYCCA8LQQAhAQNAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsLNgIACwuWBwEKfyAAKAIQIQMCQAJAAkAgACgCCCIMQQFHBEAgA0EBRg0BDAMLIANBAUcNAQsgASACaiEDAkACQCAAQRRqKAIAIghFBEAgASEEDAELIAEhBANAIAMgBCIHRg0CIAdBAWohBAJAIAcsAAAiBkF/Sg0AIAZB/wFxIQkCfyADIARGBEBBACEKIAMMAQsgBy0AAUE/cSEKIAdBAmoiBAshBiAJQeABSQ0AAn8gAyAGRgRAQQAhCyADDAELIAYtAABBP3EhCyAGQQFqIgQLIQYgCUHwAUkNACADIAZGBH9BAAUgBkEBaiEEIAYtAABBP3ELIAlBEnRBgIDwAHEgCkEMdHIgC0EGdHJyQYCAxABGDQMLIAQgB2sgBWohBSAIQX9qIggNAAsLIAMgBEYNAAJAIAQsAAAiB0F/Sg0AAn8gAyAEQQFqRgRAIAMhCEEADAELIARBAmohCCAELQABQT9xQQZ0CyAHQf8BcUHgAUkNAAJ/IAMgCEYEQCADIQZBAAwBCyAIQQFqIQYgCC0AAEE/cQsgB0H/AXFB8AFJDQAgB0H/AXEhB3IhBCADIAZGBH9BAAUgBi0AAEE/cQsgB0ESdEGAgPAAcSAEQQZ0cnJBgIDEAEYNAQsCQCAFRSACIAVGckUEQEEAIQMgBSACTw0BIAEgBWosAABBQEgNAQsgASEDCyAFIAIgAxshAiADIAEgAxshAQsgDEEBRg0ADAELAkAgAgRAQQAhBCACIQUgASEDA0AgBCADLQAAQcABcUGAAUZqIQQgA0EBaiEDIAVBf2oiBQ0ACyACIARrIAAoAgwiBk8NAkEAIQQgAiEFIAEhAwNAIAQgAy0AAEHAAXFBgAFGaiEEIANBAWohAyAFQX9qIgUNAAsMAQtBACEEIAAoAgwiBg0ADAELQQAhAyAEIAJrIAZqIgQhBQJAAkACQEEAIAAtACAiBiAGQQNGG0EDcUEBaw4DAQABAgsgBEEBdiEDIARBAWpBAXYhBQwBC0EAIQUgBCEDCyADQQFqIQMCQANAIANBf2oiAwRAIAAoAhggACgCBCAAKAIcKAIQEQAARQ0BDAILCyAAKAIEIQQgACgCGCABIAIgACgCHCgCDBEBAA0AIAVBAWohAyAAKAIcIQEgACgCGCEAA0AgA0F/aiIDRQRAQQAPCyAAIAQgASgCEBEAAEUNAAsLQQEPCyAAKAIYIAEgAiAAQRxqKAIAKAIMEQEAC7sGAQR/IAAgAWohAgJAAkAgAEEEaigCACIDQQFxDQAgA0EDcUUNASAAKAIAIgMgAWohASAAIANrIgBBpKrAACgCAEYEQCACKAIEQQNxQQNHDQFBnKrAACABNgIAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgAiABNgIADwsgACADEBELAkAgAkEEaigCACIDQQJxBEAgAkEEaiADQX5xNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgAMAQsCQCACQaiqwAAoAgBHBEBBpKrAACgCACACRg0BIAIgA0F4cSICEBEgACABIAJqIgFBAXI2AgQgACABaiABNgIAIABBpKrAACgCAEcNAkGcqsAAIAE2AgAPC0GoqsAAIAA2AgBBoKrAAEGgqsAAKAIAIAFqIgE2AgAgACABQQFyNgIEIABBpKrAACgCAEcNAkGcqsAAQQA2AgBBpKrAAEEANgIADwtBpKrAACAANgIAQZyqwABBnKrAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgAPCyABQYACTwRAIABCADcCECAAQRxqAn9BACABQQh2IgJFDQAaQR8gAUH///8HSw0AGiABQQYgAmciAmtBH3F2QQFxIAJBAXRrQT5qCyIDNgIAIANBAnRBnKnAAGohAgJAAkACQAJAQZCnwAAoAgAiBEEBIANBH3F0IgVxBEAgAigCACICQQRqKAIAQXhxIAFHDQEgAiEDDAILQZCnwAAgBCAFcjYCACACIAA2AgAMAwsgAUEAQRkgA0EBdmtBH3EgA0EfRht0IQQDQCACIARBHXZBBHFqQRBqIgUoAgAiA0UNAiAEQQF0IQQgAyICQQRqKAIAQXhxIAFHDQALCyADKAIIIgEgADYCDCADIAA2AgggAEEYakEANgIAIAAgAzYCDCAAIAE2AggPCyAFIAA2AgALIABBGGogAjYCACAAIAA2AgwgACAANgIIDwsgAUEDdiICQQN0QZSnwABqIQECf0GMp8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtBjKfAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIICwuqBgEHfwJAAkACQAJAAkACQAJAAkAgAEGAgARPBEAgAEGAgAhJDQEgAEG12XNqQbXbK0kgAEHii3RqQeILSXIgAEGfqHRqQZ8YSSAAQd7idGpBDklyciAAQf7//wBxQZ7wCkYgAEGisnVqQSJJciAAQcuRdWpBC0lycg0CIABB8IM4SQ8LIABBgP4DcUEIdiEGQeiUwAAhASAAQf8BcSEHA0ACQCABQQJqIQUgAiABLQABIgRqIQMgBiABLQAAIgFHBEAgASAGSw0BIAMhAiAFIgFBupXAAEcNAgwBCyADIAJJDQQgA0GiAksNBSACQbqVwABqIQECQANAIARFDQEgBEF/aiEEIAEtAAAgAUEBaiEBIAdHDQALQQAhBAwECyADIQIgBSIBQbqVwABHDQELCyAAQf//A3EhA0Hcl8AAIQFBASEEA0AgAUEBaiEAAn8gACABLQAAIgJBGHRBGHUiBUEATg0AGiAAQZGawABGDQYgAS0AASAFQf8AcUEIdHIhAiABQQJqCyEBIAMgAmsiA0EASA0CIARBAXMhBCABQZGawABHDQALDAELIABBgP4DcUEIdiEGQZGawAAhASAAQf8BcSEHA0ACQCABQQJqIQUgAiABLQABIgRqIQMgBiABLQAAIgFHBEAgASAGSw0BIAMhAiAFIgFB3ZrAAEcNAgwBCyADIAJJDQYgA0GvAUsNByACQd2awABqIQECQANAIARFDQEgBEF/aiEEIAEtAAAgAUEBaiEBIAdHDQALQQAhBAwDCyADIQIgBSIBQd2awABHDQELCyAAQf//A3EhA0GMnMAAIQFBASEEA0AgAUEBaiEAAn8gACABLQAAIgJBGHRBGHUiBUEATg0AGiAAQa+fwABGDQggAS0AASAFQf8AcUEIdHIhAiABQQJqCyEBIAMgAmsiA0EASA0BIARBAXMhBCABQa+fwABHDQALCyAEQQFxDwsgAiADQciUwAAQOAALIANBogJByJTAABA3AAtB/IvAAEErQdiUwAAQSAALIAIgA0HIlMAAEDgACyADQa8BQciUwAAQNwALQfyLwABBK0HYlMAAEEgAC7EFAQd/QStBgIDEACAAKAIAIglBAXEiBRshCiAEIAVqIQgCQCAJQQRxRQRAQQAhAQwBCyACBEAgAiEGIAEhBQNAIAcgBS0AAEHAAXFBgAFGaiEHIAVBAWohBSAGQX9qIgYNAAsLIAIgCGogB2shCAsCQAJAIAAoAghBAUcEQCAAIAogASACEEYNAQwCCyAAQQxqKAIAIgYgCE0EQCAAIAogASACEEYNAQwCCwJAAkACQAJAIAlBCHEEQCAAKAIEIQkgAEEwNgIEIAAtACAhCyAAQQE6ACAgACAKIAEgAhBGDQVBACEFIAYgCGsiASECQQEgAC0AICIGIAZBA0YbQQNxQQFrDgMCAQIDC0EAIQUgBiAIayIGIQgCQAJAAkBBASAALQAgIgcgB0EDRhtBA3FBAWsOAwEAAQILIAZBAXYhBSAGQQFqQQF2IQgMAQtBACEIIAYhBQsgBUEBaiEFA0AgBUF/aiIFRQ0EIAAoAhggACgCBCAAKAIcKAIQEQAARQ0AC0EBDwsgAUEBdiEFIAFBAWpBAXYhAgwBC0EAIQIgASEFCyAFQQFqIQUCQANAIAVBf2oiBUUNASAAKAIYIAAoAgQgACgCHCgCEBEAAEUNAAtBAQ8LIAAoAgQhASAAKAIYIAMgBCAAKAIcKAIMEQEADQEgAkEBaiEHIAAoAhwhAiAAKAIYIQMDQCAHQX9qIgcEQCADIAEgAigCEBEAAEUNAQwDCwsgACALOgAgIAAgCTYCBEEADwsgACgCBCEFIAAgCiABIAIQRg0AIAAoAhggAyAEIAAoAhwoAgwRAQANACAIQQFqIQcgACgCHCEBIAAoAhghAANAIAdBf2oiB0UEQEEADwsgACAFIAEoAhARAABFDQALC0EBDwsgACgCGCADIAQgAEEcaigCACgCDBEBAAv0BQEKfyMAQTBrIgMkACADQSRqIAE2AgAgA0EDOgAoIANCgICAgIAENwMIIAMgADYCICADQQA2AhggA0EANgIQAn8CQAJAAkAgAigCCCIEBEAgAigCACEGIAIoAgQiCCACQQxqKAIAIgUgBSAISxsiBUUNASAAIAYoAgAgBigCBCABKAIMEQEADQMgBkEMaiEAIAIoAhQhByACKAIQIQogBSEJA0AgAyAEQRxqLQAAOgAoIAMgBEEEaikCAEIgiTcDCCAEQRhqKAIAIQJBACELQQAhAQJAAkACQCAEQRRqKAIAQQFrDgIAAgELIAIgB08EQCACIAdBtJDAABA2AAsgAkEDdCAKaiIMKAIEQSBHDQEgDCgCACgCACECC0EBIQELIAMgAjYCFCADIAE2AhAgBEEQaigCACECAkACQAJAIARBDGooAgBBAWsOAgACAQsgAiAHTwRAIAIgB0G0kMAAEDYACyACQQN0IApqIgEoAgRBIEcNASABKAIAKAIAIQILQQEhCwsgAyACNgIcIAMgCzYCGCAEKAIAIgEgB0kEQCAKIAFBA3RqIgEoAgAgA0EIaiABKAIEEQAADQUgCUF/aiIJRQ0EIARBIGohBCAAQXxqIQEgACgCACECIABBCGohACADKAIgIAEoAgAgAiADKAIkKAIMEQEARQ0BDAULCyABIAdBpJDAABA2AAsgAigCACEGIAIoAgQiCCACQRRqKAIAIgUgBSAISxsiBUUNACACKAIQIQQgACAGKAIAIAYoAgQgASgCDBEBAA0CIAZBDGohACAFIQIDQCAEKAIAIANBCGogBEEEaigCABEAAA0DIAJBf2oiAkUNAiAEQQhqIQQgAEF8aiEBIAAoAgAhCSAAQQhqIQAgAygCICABKAIAIAkgAygCJCgCDBEBAEUNAAsMAgtBACEFCyAIIAVLBEAgAygCICAGIAVBA3RqIgAoAgAgACgCBCADKAIkKAIMEQEADQELQQAMAQtBAQsgA0EwaiQAC40FAQd/AkAgAUHM/3tLDQBBECABQQtqQXhxIAFBC0kbIQIgAEF8aiIFKAIAIgZBeHEhAwJAAkACQAJAAkACQCAGQQNxBEAgAEF4aiIHIANqIQggAyACTw0BQaiqwAAoAgAgCEYNAkGkqsAAKAIAIAhGDQMgCEEEaigCACIGQQJxDQYgBkF4cSIGIANqIgMgAk8NBAwGCyACQYACSSADIAJBBHJJciADIAJrQYGACE9yDQUMBAsgAyACayIBQRBJDQMgBSACIAZBAXFyQQJyNgIAIAIgB2oiBCABQQNyNgIEIAggCCgCBEEBcjYCBCAEIAEQBgwDC0GgqsAAKAIAIANqIgMgAk0NAyAFIAIgBkEBcXJBAnI2AgAgAiAHaiIBIAMgAmsiBEEBcjYCBEGgqsAAIAQ2AgBBqKrAACABNgIADAILQZyqwAAoAgAgA2oiAyACSQ0CAkAgAyACayIBQQ9NBEAgBSAGQQFxIANyQQJyNgIAIAMgB2oiASABKAIEQQFyNgIEQQAhAQwBCyAFIAIgBkEBcXJBAnI2AgAgAiAHaiIEIAFBAXI2AgQgAyAHaiICIAE2AgAgAiACKAIEQX5xNgIEC0GkqsAAIAQ2AgBBnKrAACABNgIADAELIAggBhARIAMgAmsiAUEQTwRAIAUgAiAFKAIAQQFxckECcjYCACACIAdqIgQgAUEDcjYCBCADIAdqIgIgAigCBEEBcjYCBCAEIAEQBgwBCyAFIAMgBSgCAEEBcXJBAnI2AgAgAyAHaiIBIAEoAgRBAXI2AgQLIAAhBAwBCyABEAAiAkUNACACIAAgAUF8QXggBSgCACIEQQNxGyAEQXhxaiIEIAQgAUsbEEsgABAEDwsgBAv0BAEJfyMAQTBrIgQkAAJAAn8gAgRAIARBKGohCQNAAkAgACgCCC0AAEUNACAAKAIAQciNwABBBCAAKAIEKAIMEQEARQ0AQQEMAwsgBEEKNgIoIARCioCAgBA3AyAgBCACNgIcQQAhBSAEQQA2AhggBCACNgIUIAQgATYCEEEBIQcgASEGIAIiAyEIAn8CQAJAA0AgBSAGaiEGIAQgB2pBJ2otAAAhCgJAAkACQCADQQdNBEAgA0UNASAIIAVrIQtBACEDA0AgAyAGai0AACAKRg0EIAsgA0EBaiIDRw0ACwwBCyAEQQhqIAogBiADEBQgBCgCCEEBRg0BIAQoAhwhCAsgBCAINgIYDAQLIAQoAgwhAyAEKAIkIQcgBCgCGCEFCyAEIAMgBWpBAWoiBTYCGAJAAkAgBSAHSQRAIAQoAhQhAwwBCyAEKAIUIgMgBUkNACAHQQVPDQMgBSAHayIGIAQoAhBqIgggCUYNASAIIAkgBxBERQ0BCyAEKAIcIgggBUkgAyAISXINAyAIIAVrIQMgBCgCECEGDAELCyAAKAIIQQE6AAAgBkEBagwCCyAHQQRBsJLAABA3AAsgACgCCEEAOgAAIAILIQMgACgCBCEGIAAoAgAhBQJAAkAgA0UgAiADRnJFBEAgAiADSwRAIAEgA2oiBywAAEG/f0oNAgsgASACQQAgA0HMjcAAEAMACyAFIAEgAyAGKAIMEQEARQ0BQQEMBAtBASAFIAEgAyAGKAIMEQEADQMaIAcsAABBv39MDQQLIAEgA2ohASACIANrIgINAAsLQQALIARBMGokAA8LIAEgAiADIAJB3I3AABADAAu6AwEEfyMAQRBrIgIkACAAKAIAIQQCQAJAAkACfwJAAkAgAUGAAU8EQCACQQA2AgwgAUGAEEkNASACQQxqIQAgAUGAgARJBEAgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAyEBDAYLIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBCEBDAULIAQoAggiACAEQQRqKAIARwRAIAQoAgAhBQwECwJAIABBAWoiAyAASQ0AIABBAXQiBSADIAUgA0sbIgNBCCADQQhLGyEDIAAEQCADQQBIDQEgBCgCACIFRQ0DIAUgAEEBIAMQVQwECyADQQBODQILEF0ACyACIAFBP3FBgAFyOgANIAIgAUEGdkHAAXI6AAwgAkEMaiEAQQIhAQwDCyADQQEQWQsiBQRAIAQgBTYCACAEQQRqIAM2AgAgBCgCCCEADAELIANBARBjAAsgACAFaiABOgAAIAQgBCgCCEEBajYCCAwBCyAEIAAgACABahAfCyACQRBqJABBAAu0AwEEfyAAQQA2AgggAEEUakEANgIAIAFBD3EhBCAAQQxqIQJBACEBA0AgACgCBCABRgRAIAAgARA8IAAoAgghAQsgACgCACABQQJ0aiIBIAM6AAIgAUEAOwEAIAAgACgCCEEBajYCCCAAKAIUIgEgACgCEEYEQCACIAEQOyAAKAIUIQELIAAoAgwgAUEBdGpBATsBACAAIAAoAhRBAWo2AhQgACgCCCEBIANBAWoiBSEDIAVB//8DcSAEdkUNAAsgACgCBCABRgRAIAAgARA8IAAoAgghAQsgACgCACABQQJ0aiIBQQA6AAIgAUEAOwEAIAAgACgCCEEBajYCCCAAKAIUIgEgACgCEEYEQCACIAEQOyAAKAIUIQELIAAoAgwgAUEBdGpBADsBACAAIAAoAhRBAWo2AhQgACgCCCIBIAAoAgRGBEAgACABEDwgACgCCCEBCyAAKAIAIAFBAnRqIgFBADoAAiABQQA7AQAgACAAKAIIQQFqNgIIIAAoAhQiASAAKAIQRgRAIAIgARA7IAAoAhQhAQsgACgCDCABQQF0akEAOwEAIAAgACgCFEEBajYCFAv+AwIDfwF+IAEoAhhBJyABQRxqKAIAKAIQEQAARQRAQfQAIQNBAiECAkACQAJAAkACQAJAIAAoAgAiAEF3ag4fBQEDAwADAwMDAwMDAwMDAwMDAwMDAwMDAwQDAwMDBAILQfIAIQMMBAtB7gAhAwwDCyAAQdwARg0BCwJ/An4CQCAAEA9FBEAgABAHRQ0BQQEMAwsgAEEBcmdBAnZBB3OtQoCAgIDQAIQMAQsgAEEBcmdBAnZBB3OtQoCAgIDQAIQLIQVBAwshAiAAIQMMAQsgACEDCwNAIAIhBEHcACEAQQEhAgJAAn4CQAJAAkACQCAEQQFrDgMBBQACCwJAAkACQAJAIAVCIIinQf8BcUEBaw4FAwIBAAYFC0H1ACEAIAVC/////49gg0KAgICAMIQMBgtB+wAhACAFQv////+PYINCgICAgCCEDAULQTBB1wAgAyAFpyIEQQJ0QRxxdkEPcSIAQQpJGyAAaiEAIAVCf3xC/////w+DIAVCgICAgHCDhCAEDQQaIAVC/////49gg0KAgICAEIQMBAtB/QAhACAFQv////+PYIMMAwtBACECIAMhAAwDCyABKAIYQScgASgCHCgCEBEAAA8LIAVC/////49gg0KAgICAwACECyEFQQMhAgsgASgCGCAAIAEoAhwoAhARAABFDQALC0EBC6ADAQV/AkACQEEAQQ8gAEGkmgRJGyIBIAFBCGoiASABQQJ0QZigwABqKAIAQQt0IABBC3QiAksbIgEgAUEEaiIBIAFBAnRBmKDAAGooAgBBC3QgAksbIgEgAUECaiIBIAFBAnRBmKDAAGooAgBBC3QgAksbIgEgAUEBaiIBIAFBAnRBmKDAAGooAgBBC3QgAksbIgNBAnRBmKDAAGooAgBBC3QiASACRiABIAJJaiADaiICQR5NBEBBsQUhBCACQR5HBEAgAkECdEGcoMAAaigCAEEVdiEEC0EAIQEgAkF/aiIDIAJNBEAgA0EfTw0DIANBAnRBmKDAAGooAgBB////AHEhAQsCQCAEIAJBAnRBmKDAAGooAgBBFXYiA0EBakYNACAAIAFrIQIgA0GxBSADQbEFSxshBSAEQX9qIQFBACEAA0AgAyAFRg0DIAAgA0GUocAAai0AAGoiACACSw0BIAEgA0EBaiIDRw0ACyABIQMLIANBAXEPCyACQR9B2J/AABA2AAsgBUGxBUHon8AAEDYACyADQR9B+J/AABA2AAvoAgEFfwJAQc3/eyAAQRAgAEEQSxsiAGsgAU0NACAAQRAgAUELakF4cSABQQtJGyIEakEMahAAIgJFDQAgAkF4aiEBAkAgAEF/aiIDIAJxRQRAIAEhAAwBCyACQXxqIgUoAgAiBkF4cSACIANqQQAgAGtxQXhqIgIgACACaiACIAFrQRBLGyIAIAFrIgJrIQMgBkEDcQRAIAAgAyAAKAIEQQFxckECcjYCBCAAIANqIgMgAygCBEEBcjYCBCAFIAIgBSgCAEEBcXJBAnI2AgAgACAAKAIEQQFyNgIEIAEgAhAGDAELIAEoAgAhASAAIAM2AgQgACABIAJqNgIACwJAIABBBGooAgAiAUEDcUUNACABQXhxIgIgBEEQak0NACAAQQRqIAQgAUEBcXJBAnI2AgAgACAEaiIBIAIgBGsiBEEDcjYCBCAAIAJqIgIgAigCBEEBcjYCBCABIAQQBgsgAEEIaiEDCyADC4UDAQR/AkACQCABQYACTwRAIABBGGooAgAhBAJAAkAgACAAKAIMIgJGBEAgAEEUQRAgAEEUaiICKAIAIgMbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyACIABBEGogAxshAwNAIAMhBSABIgJBFGoiAygCACIBRQRAIAJBEGohAyACKAIQIQELIAENAAsgBUEANgIACyAERQ0CIAAgAEEcaigCAEECdEGcqcAAaiIBKAIARwRAIARBEEEUIAQoAhAgAEYbaiACNgIAIAJFDQMMAgsgASACNgIAIAINAUGQp8AAQZCnwAAoAgBBfiAAKAIcd3E2AgAPCyAAQQxqKAIAIgIgAEEIaigCACIARwRAIAAgAjYCDCACIAA2AggPC0GMp8AAQYynwAAoAgBBfiABQQN2d3E2AgAMAQsgAiAENgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAEUNACACQRRqIAA2AgAgACACNgIYCwujAwIEfwJ+IwBBQGoiAiQAQQEhBAJAIAAtAAQNACAALQAFIQUgACgCACIDLQAAQQRxRQRAIAMoAhhB8Y3AAEHzjcAAIAUbQQJBAyAFGyADQRxqKAIAKAIMEQEADQEgACgCACIDKAIYQc6mwABBByADQRxqKAIAKAIMEQEADQEgACgCACIDKAIYQaeMwABBAiADQRxqKAIAKAIMEQEADQEgASAAKAIAQZSgwAAoAgARAAAhBAwBCyAFRQRAIAMoAhhB7I3AAEEDIANBHGooAgAoAgwRAQANASAAKAIAIQMLIAJBAToAFyACQTRqQbCNwAA2AgAgAiADKQIYNwMIIAIgAkEXajYCECADKQIIIQYgAykCECEHIAIgAy0AIDoAOCACIAc3AyggAiAGNwMgIAIgAykCADcDGCACIAJBCGo2AjAgAkEIakHOpsAAQQcQCw0AIAJBCGpBp4zAAEECEAsNACABIAJBGGpBlKDAACgCABEAAA0AIAIoAjBB743AAEECIAIoAjQoAgwRAQAhBAsgAEEBOgAFIAAgBDoABCACQUBrJAAL5gICBn8BfiMAQTBrIgQkACAEQRBqECogBCAEKAIUIgU2AhwgBCAEKAIQIgY2AhggBEEIaiADQQAQQCAEKQMIIQogAEEANgIIIAAgCjcCAAJAAkAgAwRAQQAhBkEAIQUDQCAAIAVBgCAQOiAAIAMgACgCBCIHIAcgA0sbEE8gBiACSw0CIAAoAgAhCCAAKAIIIgcgBUkNAyAEQSBqIARBGGoiCSgCACABIAZqIAIgBmsgBSAIaiAHIAVrIAkoAgQoAgwRCAAgBCgCJCAFaiEHIAQoAiAhCCAAKAIIIgUgB08EQCAAKAIAGiAAIAc2AgggByEFCyAELQAoQQJHBEAgBiAIaiEGIAUgA0kNAQsLIAQoAhghBiAEKAIcIQULIAYgBSgCABEDACAEKAIcIgAoAggaIAQoAhghASAAKAIEBEAgARAECyAEQTBqJAAPCyAGIAJByIHAABA5AAsgBSAHQdiBwAAQOQAL2AIBBX8CQAJAAkACQAJAIAJBA2pBfHEgAmsiBEUNACADIAQgBCADSxsiBUUNAEEAIQQgAUH/AXEhBgJAA0AgAiAEai0AACAGRg0BIAUgBEEBaiIERw0ACyAFIANBeGoiBE0NAgwDC0EBIQcMAwsgA0F4aiEEQQAhBQsgAUH/AXFBgYKECGwhBgNAIAIgBWoiB0EEaigCACAGcyIIQX9zIAhB//37d2pxIAcoAgAgBnMiB0F/cyAHQf/9+3dqcXJBgIGChHhxRQRAIAVBCGoiBSAETQ0BCwsgBSADSw0CC0EAIQYCf0EAIAMgBUYNABogAiAFaiECIAMgBWshBkEAIQQgAUH/AXEhAQJAA0AgAiAEai0AACABRg0BIAYgBEEBaiIERw0AC0EADAELIAQhBkEBCyEHIAUgBmohBAsgACAENgIEIAAgBzYCAA8LIAUgA0HokMAAEDkAC74CAgV/AX4jAEEwayIEJABBJyECAkAgAEKQzgBUBEAgACEHDAELA0AgBEEJaiACaiIDQXxqIAAgAEKQzgCAIgdCkM4Afn2nIgVB//8DcUHkAG4iBkEBdEGmjsAAai8AADsAACADQX5qIAUgBkHkAGxrQf//A3FBAXRBpo7AAGovAAA7AAAgAkF8aiECIABC/8HXL1YgByEADQALCyAHpyIDQeMASgRAIAJBfmoiAiAEQQlqaiAHpyIDIANB//8DcUHkAG4iA0HkAGxrQf//A3FBAXRBpo7AAGovAAA7AAALAkAgA0EKTgRAIAJBfmoiAiAEQQlqaiADQQF0QaaOwABqLwAAOwAADAELIAJBf2oiAiAEQQlqaiADQTBqOgAACyABQfCLwABBACAEQQlqIAJqQScgAmsQCCAEQTBqJAALowICBH8BfiMAQUBqIgQkAAJAAkACQCACIANqIgMgAk8EQCABKAIEIQUgBEEYakKBgICAEDcDACAEKAIcIgJBf2oiBiAEKAIYakEAIAJrIgdxrSAFQQF0IgUgAyAFIANLGyIDQQggA0EISxutfiIIQiCIpyACRXINASACaUEBRgRAIAinIAZqIAdxIQMMAwsgBEEwahAwAAsgBEEIaiADQQAQWiAAIAQpAwg3AgRBASECDAILQQAhAgsgBEEwaiABEE0gBEEgaiADIAIgBEEwahAlQQEhAiAEQShqKAIAIQMgBCgCJCEFIAQoAiBBAUcEQCABIAUgAxBaQQAhAgwBCyAEQRBqIAUgAxBaIAAgBCkDEDcCBAsgACACNgIAIARBQGskAAuuAgEIfyMAQTBrIgEkAEGAICECIAFBGGoQLyABKAIcIQQgASgCGCEFIAFBEGoQMiABKAIUIQYgASgCECEHIAFBCGpBgCBBARBAIAFBgCA2AiggASABKAIMIgg2AiQgASABKAIIIgM2AiAgCEGBIE8EQCABQSBqQYAgEEUgASgCICEDIAEoAighAgsgAEEAOwBHIABBADsBOCAAIAM2AiggACAFNgIQIABBCDoARiAAQQA6AAsgAEIANwMAIABBMGpCADcDACAAQSxqIAI2AgAgAEEkakEANgIAIABBIGogBjYCACAAQRxqIAc2AgAgAEEYakEANgIAIABBFGogBDYCACAAQQk6AAogAEGAAjsBQiAAQYECOwFEIABBggI7AUAgAEH/AzsBCCABQTBqJAALxwICBX8BfiMAQRBrIgMkACAALQALIQIgA0IANwMIIAEoAgAhBQJAAkAgAAJ/IAEoAgQiBEHAACACayIGQfgBcUEDdiICSQRAIARBCU8NAiADQQhqIAUgBBBLGiABQQA2AgQgAUGIg8AANgIAIARBA3QMAQsgBkH/AXFByABPDQIgA0EIaiAFIAIQSxogASAEIAJrNgIEIAEgAiAFajYCACAGQfgBcQsgAC0ACyIBajoACyAAIAApAwAgAykDCCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhCABQT9xrYiENwMAIANBEGokAA8LIARBCEHYhcAAEDcACyACQQhByIXAABA3AAuqAgEDfyMAQYABayIEJAACQAJAAn8CQCABKAIAIgNBEHFFBEAgACgCACECIANBIHENASACrSABEBUMAgsgACgCACECQQAhAANAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQX9qIQAgAkEEdiICDQALIABBgAFqIgJBgQFPDQIgAUGkjsAAQQIgACAEakGAAWpBACAAaxAIDAELQQAhAANAIAAgBGpB/wBqIAJBD3EiA0EwciADQTdqIANBCkkbOgAAIABBf2ohACACQQR2IgINAAsgAEGAAWoiAkGBAU8NAiABQaSOwABBAiAAIARqQYABakEAIABrEAgLIARBgAFqJAAPCyACQYABQZSOwAAQOQALIAJBgAFBlI7AABA5AAuxAgEEfyMAQUBqIgIkACABKAIEIgNFBEAgAUEEaiEDIAEoAgAhBCACQQA2AiAgAkIBNwMYIAIgAkEYajYCJCACQThqIARBEGopAgA3AwAgAkEwaiAEQQhqKQIANwMAIAIgBCkCADcDKCACQSRqQdiJwAAgAkEoahAJGiACQRBqIgQgAigCIDYCACACIAIpAxg3AwgCQCABKAIEIgVFDQAgAUEIaigCAEUNACAFEAQLIAMgAikDCDcCACADQQhqIAQoAgA2AgAgAygCACEDCyABQQE2AgQgAUEMaigCACEEIAFBCGoiASgCACEFIAFCADcCAEEMQQQQWSIBRQRAQQxBBBBjAAsgASAENgIIIAEgBTYCBCABIAM2AgAgAEGQi8AANgIEIAAgATYCACACQUBrJAAL/AEBAn8jAEEQayICJAAgACgCACACQQA2AgwCfwJAAkAgAUGAAU8EQCABQYAQSQ0BIAJBDGohACABQYCABE8NAiACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAMLIAIgAToADCACQQxqIQBBAQwCCyACIAFBP3FBgAFyOgANIAIgAUEGdkHAAXI6AAwgAkEMaiEAQQIMAQsgAiABQT9xQYABcjoADyACIAFBEnZB8AFyOgAMIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADUEECyEBIAAgARALIAJBEGokAAv5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QSxqQQI2AgAgAUE8akEhNgIAIAFCAjcCHCABQayMwAA2AhggAUEdNgI0IAEgAUEwajYCKCABIAFBEGo2AjggASABQQhqNgIwIAFBGGpB8IDAABBRAAtxAQN/IwBBIGsiAiQAAkAgACABEBkNACABQRxqKAIAIQMgASgCGCACQRxqQQA2AgAgAkHwi8AANgIYIAJCATcCDCACQfSLwAA2AgggAyACQQhqEAkNACAAQQRqIAEQGSACQSBqJAAPCyACQSBqJABBAQswAQF/AkACQEGAwABBAhBZIgENAQwAC0GAwABBAhBjAAsgACABNgIAIABBgCA2AgQLewECfwJAAkAgACgCBCIBBEAgACgCDCICIAFPDQEgACgCACIBIAJqIAEtAAA6AAAgAEEANgIIIAAgACgCDEEBajYCDCAAKAIERQ0CIAAoAgAtAAAPC0EAQQBBiIbAABA2AAsgAiABQZiGwAAQNgALQQBBAEGohsAAEDYAC2gBAn8gACAALQBGIgFBAWoiAjoACiAAQQEgAUEPcXRBAmoiATsBQCAAQX8gAkEPcXRBf3M7AQggAEEYaigCACABQf//A3EiAU8EQCAAIAE2AhgLIABBJGooAgAgAU8EQCAAIAE2AiQLC1ABAX8gAEEUaigCACIBRSABQQJ0RXJFBEAgACgCEBAECyAAQSBqKAIAIgFFIAFBAXRFckUEQCAAKAIcEAQLIABBLGooAgAEQCAAKAIoEAQLC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEcNgIAIANCAjcCDCADQYCNwAA2AgggA0EcNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBRAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBHDYCACADQgI3AgwgA0HMkcAANgIIIANBHDYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQUQALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQRw2AgAgA0ICNwIMIANBgJLAADYCCCADQRw2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFEAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEcNgIAIANCAjcCDCADQayRwAA2AgggA0EcNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBRAAtcAQF/IwBBEGsiAyQAAkAgACgCBCABayACTwRAIANBADYCAAwBCyADIAAgASACEBYgAygCAEEBRw0AIANBCGooAgAiAARAIAMoAgQgABBjAAsQXQALIANBEGokAAtaAQF/IwBBEGsiAiQAAkAgACgCBCABa0EBTwRAIAJBADYCAAwBCyACIAAgARAeIAIoAgBBAUcNACACQQhqKAIAIgAEQCACKAIEIAAQYwALEF0ACyACQRBqJAALWgEBfyMAQRBrIgIkAAJAIAAoAgQgAWtBAU8EQCACQQA2AgAMAQsgAiAAIAEQHSACKAIAQQFHDQAgAkEIaigCACIABEAgAigCBCAAEGMACxBdAAsgAkEQaiQAC1kBAX8jAEEgayICJAAgAiAAKAIANgIEIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpB2InAACACQQhqEAkgAkEgaiQAC0YAAkBBCCACSQRAAn9BCCACSQRAIAIgAxAQDAELIAMQAAsiAg0BQQAPCyAAIAMQCg8LIAIgACADIAEgASADSxsQSyAAEAQLWQEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHwj8AAIAJBCGoQCSACQSBqJAALWQACQAJAAkAgAUF/SgRAAkAgAgRAIAENAQwECyABRQ0DIAFBARBZIgINBAwCCyABEEciAkUNAQwDCxBdAAsgAUEBEGMAC0EBIQILIAAgATYCBCAAIAI2AgALVgEBfyMAQSBrIgIkACACIAA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHwj8AAIAJBCGoQCSACQSBqJAALWQEDfwJAIAEoAgwiAiABKAIIIgNPBEAgASgCBCIEIAJJDQEgASgCACEBIAAgAiADazYCBCAAIAEgA2o2AgAPCyADIAJB2IbAABA4AAsgAiAEQdiGwAAQNwALVQEBfyAAQRBqIAAt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");
var o;
async function N(A3, I3) {
  o || (o = await (async () => (await E(G), D))());
  const g3 = o.decompress(A3, I3);
  if (0 === g3.length)
    throw Error("Failed to decode with LZW decoder.");
  return g3;
}

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_2) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub5) => {
      this.issues = [...this.issues, sub5];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub5 of this.issues) {
      if (sub5.path.length > 0) {
        const firstEl = sub5.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub5));
      } else {
        formErrors.push(mapper(sub5));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx2, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx2.data,
    path: ctx2.path,
    errorMaps: [
      ctx2.common.contextualErrorMap,
      // contextual error map is first priority
      ctx2.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx2.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx2, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx2.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx2.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx2) => {
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 ?? ctx2.defaultError };
    }
    if (typeof ctx2.data === "undefined") {
      return { message: message2 ?? required_error ?? ctx2.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx2.defaultError };
    return { message: message2 ?? invalid_type_error ?? ctx2.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx2) {
    return ctx2 || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx2 = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx2.path, parent: ctx2 });
    return handleResult(ctx2, result);
  }
  "~validate"(data) {
    const ctx2 = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx2 });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx2.common.issues
        };
      } catch (err2) {
        if (err2?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx2.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx2 }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx2.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx2 = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx2.path, parent: ctx2 });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx2, result);
  }
  refine(check, message2) {
    const getIssueProperties = (val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    };
    return this._refinement((val, ctx2) => {
      const result = check(val);
      const setError = () => ctx2.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx2) => {
      if (!check(val)) {
        ctx2.addIssue(typeof refinementData === "function" ? refinementData(val, ctx2) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target2) {
    return ZodPipeline.create(this, target2);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx3 = this._getOrReturnCtx(input);
      addIssueToContext(ctx3, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx3.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx2 = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          if (tooBig) {
            addIssueToContext(ctx2, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx2, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  nanoid(message2) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  base64(message2) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
  }
  base64url(message2) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message2)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message2) {
    return this._addCheck({ kind: "date", message: message2 });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message2) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message2) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value, message2) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len4, message2) {
    return this._addCheck({
      kind: "length",
      value: len4,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxLength() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx3 = this._getOrReturnCtx(input);
      addIssueToContext(ctx3, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx3.parsedType
      });
      return INVALID;
    }
    let ctx2 = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxValue() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max4 = null;
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      } else if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return Number.isFinite(min4) && Number.isFinite(max4);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx2 = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx2 = this._getOrReturnCtx(input);
    addIssueToContext(ctx2, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx2.parsedType
    });
    return INVALID;
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxValue() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx3 = this._getOrReturnCtx(input);
      addIssueToContext(ctx3, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx3.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx3 = this._getOrReturnCtx(input);
      addIssueToContext(ctx3, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx2 = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx2 = this._getOrReturnCtx(input, ctx2);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4 != null ? new Date(min4) : null;
  }
  get maxDate() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4 != null ? new Date(max4) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx2 = this._getOrReturnCtx(input);
    addIssueToContext(ctx2, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx2.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx: ctx2, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx2.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx2.data.length > def.exactLength.value;
      const tooSmall = ctx2.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx2, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx2.data.length < def.minLength.value) {
        addIssueToContext(ctx2, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx2.data.length > def.maxLength.value) {
        addIssueToContext(ctx2, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx2.common.async) {
      return Promise.all([...ctx2.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx2, item, ctx2.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx2.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx2, item, ctx2.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len4, message2) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len4, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx3 = this._getOrReturnCtx(input);
      addIssueToContext(ctx3, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx3.parsedType
      });
      return INVALID;
    }
    const { status, ctx: ctx2 } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx2.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx2.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx2, value, ctx2.path, key)),
        alwaysSet: key in ctx2.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx2.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx2, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx2.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx2, value, ctx2.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx2.data
        });
      }
    }
    if (ctx2.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: (issue, ctx2) => {
          const defaultError = this._def.errorMap?.(issue, ctx2).message ?? ctx2.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message2).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx2.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx2.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx2,
          common: {
            ...ctx2.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx2.data,
            path: ctx2.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx2,
          common: {
            ...ctx2.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx2.data,
          path: ctx2.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx2.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx2.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx2.common.async) {
      return option._parseAsync({
        data: ctx2.data,
        path: ctx2.path,
        parent: ctx2
      });
    } else {
      return option._parseSync({
        data: ctx2.data,
        path: ctx2.path,
        parent: ctx2
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx: ctx2 } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx2.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx2.data,
          path: ctx2.path,
          parent: ctx2
        }),
        this._def.right._parseAsync({
          data: ctx2.data,
          path: ctx2.path,
          parent: ctx2
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx2.data,
        path: ctx2.path,
        parent: ctx2
      }), this._def.right._parseSync({
        data: ctx2.data,
        path: ctx2.path,
        parent: ctx2
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (ctx2.data.length < this._def.items.length) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx2.data.length > this._def.items.length) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx2.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx2, item, ctx2.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx2.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx2.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx2, key, ctx2.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx2, ctx2.data[key], ctx2.path, key)),
        alwaysSet: key in ctx2.data
      });
    }
    if (ctx2.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx2.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx2, key, ctx2.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx2, value, ctx2.path, [index, "value"]))
      };
    });
    if (ctx2.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx2.data.size < def.minSize.value) {
        addIssueToContext(ctx2, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx2.data.size > def.maxSize.value) {
        addIssueToContext(ctx2, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx2.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx2, item, ctx2.path, i3)));
    if (ctx2.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size, message2) {
    return this.min(size, message2).max(size, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx2.path,
        errorMaps: [ctx2.common.contextualErrorMap, ctx2.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx2.path,
        errorMaps: [ctx2.common.contextualErrorMap, ctx2.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx2.common.contextualErrorMap };
    const fn = ctx2.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx2.data, path: ctx2.path, parent: ctx2 });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        received: ctx2.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx2 = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx2, {
        expected: util.joinValues(expectedValues),
        received: ctx2.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx2 = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx2, {
        received: ctx2.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx2 = this._getOrReturnCtx(input);
    if (ctx2.parsedType !== ZodParsedType.string && ctx2.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx2, {
        expected: util.joinValues(expectedValues),
        received: ctx2.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx2, {
        received: ctx2.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.parsedType !== ZodParsedType.promise && ctx2.common.async === false) {
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const promisified = ctx2.parsedType === ZodParsedType.promise ? ctx2.data : Promise.resolve(ctx2.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx2.path,
        errorMap: ctx2.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx: ctx2 } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx2, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx2.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx2.data, checkCtx);
      if (ctx2.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx2.path,
            parent: ctx2
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx2.path,
          parent: ctx2
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx2.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx2.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx2.data,
          path: ctx2.path,
          parent: ctx2
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx2.data, path: ctx2.path, parent: ctx2 }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx2.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx2.data,
          path: ctx2.path,
          parent: ctx2
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx2.data, path: ctx2.path, parent: ctx2 }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    let data = ctx2.data;
    if (ctx2.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx2.path,
      parent: ctx2
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    const newCtx = {
      ...ctx2,
      common: {
        ...ctx2.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx: ctx2 } = this._processInputParams(input);
    const data = ctx2.data;
    return this._def.type._parse({
      data,
      path: ctx2.path,
      parent: ctx2
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx: ctx2 } = this._processInputParams(input);
    if (ctx2.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx2.data,
          path: ctx2.path,
          parent: ctx2
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx2.path,
            parent: ctx2
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx2.data,
        path: ctx2.path,
        parent: ctx2
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx2.path,
          parent: ctx2
        });
      }
    }
  }
  static create(a2, b2) {
    return new _ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};

// node_modules/@zarrita/storage/dist/src/util.js
function fetch_range(url, offset, length5, opts = {}) {
  if (offset !== void 0 && length5 !== void 0) {
    opts = {
      ...opts,
      headers: {
        ...opts.headers,
        Range: `bytes=${offset}-${offset + length5 - 1}`
      }
    };
  }
  return fetch(url, opts);
}
function merge_init(storeOverrides, requestOverrides) {
  return {
    ...storeOverrides,
    ...requestOverrides,
    headers: {
      ...storeOverrides.headers,
      ...requestOverrides.headers
    }
  };
}

// node_modules/@zarrita/storage/dist/src/fetch.js
function resolve(root2, path) {
  const base = typeof root2 === "string" ? new URL(root2) : root2;
  if (!base.pathname.endsWith("/")) {
    base.pathname += "/";
  }
  const resolved = new URL(path.slice(1), base);
  resolved.search = base.search;
  return resolved;
}
async function handle_response(response) {
  if (response.status === 404) {
    return void 0;
  }
  if (response.status === 200 || response.status === 206) {
    return new Uint8Array(await response.arrayBuffer());
  }
  throw new Error(`Unexpected response status ${response.status} ${response.statusText}`);
}
async function fetch_suffix(url, suffix_length, init5, use_suffix_request) {
  if (use_suffix_request) {
    return fetch(url, {
      ...init5,
      headers: { ...init5.headers, Range: `bytes=-${suffix_length}` }
    });
  }
  let response = await fetch(url, { ...init5, method: "HEAD" });
  if (!response.ok) {
    return response;
  }
  let content_length = response.headers.get("Content-Length");
  let length5 = Number(content_length);
  return fetch_range(url, length5 - suffix_length, length5, init5);
}
var _overrides, _use_suffix_request, _merge_init, merge_init_fn;
var FetchStore = class {
  constructor(url, options = {}) {
    __privateAdd(this, _merge_init);
    __publicField(this, "url");
    __privateAdd(this, _overrides, void 0);
    __privateAdd(this, _use_suffix_request, void 0);
    this.url = url;
    __privateSet(this, _overrides, options.overrides ?? {});
    __privateSet(this, _use_suffix_request, options.useSuffixRequest ?? false);
  }
  async get(key, options = {}) {
    let href = resolve(this.url, key).href;
    let response = await fetch(href, __privateMethod(this, _merge_init, merge_init_fn).call(this, options));
    return handle_response(response);
  }
  async getRange(key, range3, options = {}) {
    let url = resolve(this.url, key);
    let init5 = __privateMethod(this, _merge_init, merge_init_fn).call(this, options);
    let response;
    if ("suffixLength" in range3) {
      response = await fetch_suffix(url, range3.suffixLength, init5, __privateGet(this, _use_suffix_request));
    } else {
      response = await fetch_range(url, range3.offset, range3.length, init5);
    }
    return handle_response(response);
  }
};
_overrides = new WeakMap();
_use_suffix_request = new WeakMap();
_merge_init = new WeakSet();
merge_init_fn = function(overrides) {
  return merge_init(__privateGet(this, _overrides), overrides);
};
var fetch_default = FetchStore;

// node_modules/zarrita/dist/src/typedarray.js
var _bytes;
var BoolArray = class {
  constructor(x2, byteOffset, length5) {
    __privateAdd(this, _bytes, void 0);
    if (typeof x2 === "number") {
      __privateSet(this, _bytes, new Uint8Array(x2));
    } else if (x2 instanceof ArrayBuffer) {
      __privateSet(this, _bytes, new Uint8Array(x2, byteOffset, length5));
    } else {
      __privateSet(this, _bytes, new Uint8Array(Array.from(x2, (v2) => v2 ? 1 : 0)));
    }
  }
  get BYTES_PER_ELEMENT() {
    return 1;
  }
  get byteOffset() {
    return __privateGet(this, _bytes).byteOffset;
  }
  get byteLength() {
    return __privateGet(this, _bytes).byteLength;
  }
  get buffer() {
    return __privateGet(this, _bytes).buffer;
  }
  get length() {
    return __privateGet(this, _bytes).length;
  }
  get(idx) {
    let value = __privateGet(this, _bytes)[idx];
    return typeof value === "number" ? value !== 0 : value;
  }
  set(idx, value) {
    __privateGet(this, _bytes)[idx] = value ? 1 : 0;
  }
  fill(value) {
    __privateGet(this, _bytes).fill(value ? 1 : 0);
  }
  *[Symbol.iterator]() {
    for (let i3 = 0; i3 < this.length; i3++) {
      yield this.get(i3);
    }
  }
};
_bytes = new WeakMap();
var _encoder;
var ByteStringArray = class {
  constructor(chars, x2, byteOffset, length5) {
    __publicField(this, "_data");
    __publicField(this, "chars");
    __privateAdd(this, _encoder, void 0);
    this.chars = chars;
    __privateSet(this, _encoder, new TextEncoder());
    if (typeof x2 === "number") {
      this._data = new Uint8Array(x2 * chars);
    } else if (x2 instanceof ArrayBuffer) {
      if (length5)
        length5 = length5 * chars;
      this._data = new Uint8Array(x2, byteOffset, length5);
    } else {
      let values = Array.from(x2);
      this._data = new Uint8Array(values.length * chars);
      for (let i3 = 0; i3 < values.length; i3++) {
        this.set(i3, values[i3]);
      }
    }
  }
  get BYTES_PER_ELEMENT() {
    return this.chars;
  }
  get byteOffset() {
    return this._data.byteOffset;
  }
  get byteLength() {
    return this._data.byteLength;
  }
  get buffer() {
    return this._data.buffer;
  }
  get length() {
    return this.byteLength / this.BYTES_PER_ELEMENT;
  }
  get(idx) {
    const view = new Uint8Array(this.buffer, this.byteOffset + this.chars * idx, this.chars);
    return new TextDecoder().decode(view).replace(/\x00/g, "");
  }
  set(idx, value) {
    const view = new Uint8Array(this.buffer, this.byteOffset + this.chars * idx, this.chars);
    view.fill(0);
    view.set(__privateGet(this, _encoder).encode(value));
  }
  fill(value) {
    const encoded = __privateGet(this, _encoder).encode(value);
    for (let i3 = 0; i3 < this.length; i3++) {
      this._data.set(encoded, i3 * this.chars);
    }
  }
  *[Symbol.iterator]() {
    for (let i3 = 0; i3 < this.length; i3++) {
      yield this.get(i3);
    }
  }
};
_encoder = new WeakMap();
var _data;
var _UnicodeStringArray = class _UnicodeStringArray {
  constructor(chars, x2, byteOffset, length5) {
    __privateAdd(this, _data, void 0);
    __publicField(this, "chars");
    this.chars = chars;
    if (typeof x2 === "number") {
      __privateSet(this, _data, new Int32Array(x2 * chars));
    } else if (x2 instanceof ArrayBuffer) {
      if (length5)
        length5 *= chars;
      __privateSet(this, _data, new Int32Array(x2, byteOffset, length5));
    } else {
      const values = x2;
      const d2 = new _UnicodeStringArray(chars, 1);
      __privateSet(this, _data, new Int32Array(function* () {
        for (let str5 of values) {
          d2.set(0, str5);
          yield* __privateGet(d2, _data);
        }
      }()));
    }
  }
  get BYTES_PER_ELEMENT() {
    return __privateGet(this, _data).BYTES_PER_ELEMENT * this.chars;
  }
  get byteLength() {
    return __privateGet(this, _data).byteLength;
  }
  get byteOffset() {
    return __privateGet(this, _data).byteOffset;
  }
  get buffer() {
    return __privateGet(this, _data).buffer;
  }
  get length() {
    return __privateGet(this, _data).length / this.chars;
  }
  get(idx) {
    const offset = this.chars * idx;
    let result = "";
    for (let i3 = 0; i3 < this.chars; i3++) {
      result += String.fromCodePoint(__privateGet(this, _data)[offset + i3]);
    }
    return result.replace(/\u0000/g, "");
  }
  set(idx, value) {
    const offset = this.chars * idx;
    const view = __privateGet(this, _data).subarray(offset, offset + this.chars);
    view.fill(0);
    for (let i3 = 0; i3 < this.chars; i3++) {
      view[i3] = value.codePointAt(i3) ?? 0;
    }
  }
  fill(value) {
    this.set(0, value);
    let encoded = __privateGet(this, _data).subarray(0, this.chars);
    for (let i3 = 1; i3 < this.length; i3++) {
      __privateGet(this, _data).set(encoded, i3 * this.chars);
    }
  }
  *[Symbol.iterator]() {
    for (let i3 = 0; i3 < this.length; i3++) {
      yield this.get(i3);
    }
  }
};
_data = new WeakMap();
var UnicodeStringArray = _UnicodeStringArray;

// node_modules/zarrita/dist/src/util.js
function json_decode_object(bytes) {
  const str5 = new TextDecoder().decode(bytes);
  return JSON.parse(str5);
}
function byteswap_inplace(view, bytes_per_element2) {
  const numFlips = bytes_per_element2 / 2;
  const endByteIndex = bytes_per_element2 - 1;
  let t2 = 0;
  for (let i3 = 0; i3 < view.length; i3 += bytes_per_element2) {
    for (let j2 = 0; j2 < numFlips; j2 += 1) {
      t2 = view[i3 + j2];
      view[i3 + j2] = view[i3 + endByteIndex - j2];
      view[i3 + endByteIndex - j2] = t2;
    }
  }
}
function get_ctr(data_type) {
  if (data_type === "v2:object") {
    return globalThis.Array;
  }
  let match = data_type.match(/v2:([US])(\d+)/);
  if (match) {
    let [, kind, chars] = match;
    return (kind === "U" ? UnicodeStringArray : ByteStringArray).bind(null, Number(chars));
  }
  let ctr = {
    int8: Int8Array,
    int16: Int16Array,
    int32: Int32Array,
    int64: globalThis.BigInt64Array,
    uint8: Uint8Array,
    uint16: Uint16Array,
    uint32: Uint32Array,
    uint64: globalThis.BigUint64Array,
    float16: globalThis.Float16Array,
    float32: Float32Array,
    float64: Float64Array,
    bool: BoolArray
  }[data_type];
  assert(ctr, `Unknown or unsupported data_type: ${data_type}`);
  return ctr;
}
function get_strides(shape, order) {
  const rank2 = shape.length;
  if (typeof order === "string") {
    order = order === "C" ? Array.from({ length: rank2 }, (_2, i3) => i3) : Array.from({ length: rank2 }, (_2, i3) => rank2 - 1 - i3);
  }
  assert(rank2 === order.length, "Order length must match the number of dimensions.");
  let step = 1;
  let stride = new Array(rank2);
  for (let i3 = order.length - 1; i3 >= 0; i3--) {
    stride[order[i3]] = step;
    step *= shape[order[i3]];
  }
  return stride;
}
function create_chunk_key_encoder({ name: name2, configuration }) {
  if (name2 === "default") {
    const separator = configuration?.separator ?? "/";
    return (chunk_coords) => ["c", ...chunk_coords].join(separator);
  }
  if (name2 === "v2") {
    const separator = configuration?.separator ?? ".";
    return (chunk_coords) => chunk_coords.join(separator) || "0";
  }
  throw new Error(`Unknown chunk key encoding: ${name2}`);
}
function coerce_dtype(dtype) {
  if (dtype === "|O") {
    return { data_type: "v2:object" };
  }
  let match = dtype.match(/^([<|>])(.*)$/);
  assert(match, `Invalid dtype: ${dtype}`);
  let [, endian, rest] = match;
  let data_type = {
    b1: "bool",
    i1: "int8",
    u1: "uint8",
    i2: "int16",
    u2: "uint16",
    i4: "int32",
    u4: "uint32",
    i8: "int64",
    u8: "uint64",
    f2: "float16",
    f4: "float32",
    f8: "float64"
  }[rest] ?? (rest.startsWith("S") || rest.startsWith("U") ? `v2:${rest}` : void 0);
  assert(data_type, `Unsupported or unknown dtype: ${dtype}`);
  if (endian === "|") {
    return { data_type };
  }
  return { data_type, endian: endian === "<" ? "little" : "big" };
}
function v2_to_v3_array_metadata(meta, attributes = {}) {
  let codecs = [];
  let dtype = coerce_dtype(meta.dtype);
  if (meta.order === "F") {
    codecs.push({ name: "transpose", configuration: { order: "F" } });
  }
  if ("endian" in dtype && dtype.endian === "big") {
    codecs.push({ name: "bytes", configuration: { endian: "big" } });
  }
  for (let { id, ...configuration } of meta.filters ?? []) {
    codecs.push({ name: id, configuration });
  }
  if (meta.compressor) {
    let { id, ...configuration } = meta.compressor;
    codecs.push({ name: id, configuration });
  }
  return {
    zarr_format: 3,
    node_type: "array",
    shape: meta.shape,
    data_type: dtype.data_type,
    chunk_grid: {
      name: "regular",
      configuration: {
        chunk_shape: meta.chunks
      }
    },
    chunk_key_encoding: {
      name: "v2",
      configuration: {
        separator: meta.dimension_separator ?? "."
      }
    },
    codecs,
    fill_value: meta.fill_value,
    attributes
  };
}
function v2_to_v3_group_metadata(_meta, attributes = {}) {
  return {
    zarr_format: 3,
    node_type: "group",
    attributes
  };
}
function is_dtype(dtype, query) {
  if (query !== "number" && query !== "bigint" && query !== "boolean" && query !== "object" && query !== "string") {
    return dtype === query;
  }
  let is_boolean = dtype === "bool";
  if (query === "boolean")
    return is_boolean;
  let is_string = dtype.startsWith("v2:U") || dtype.startsWith("v2:S");
  if (query === "string")
    return is_string;
  let is_bigint = dtype === "int64" || dtype === "uint64";
  if (query === "bigint")
    return is_bigint;
  let is_object = dtype === "v2:object";
  if (query === "object")
    return is_object;
  return !is_string && !is_bigint && !is_boolean && !is_object;
}
function is_sharding_codec(codec) {
  return codec?.name === "sharding_indexed";
}
function ensure_correct_scalar(metadata) {
  if ((metadata.data_type === "uint64" || metadata.data_type === "int64") && metadata.fill_value != null) {
    return BigInt(metadata.fill_value);
  }
  return metadata.fill_value;
}
function rethrow_unless(error, ...errors) {
  if (!errors.some((ErrorClass) => error instanceof ErrorClass)) {
    throw error;
  }
}
function assert(expression, msg = "") {
  if (!expression) {
    throw new Error(msg);
  }
}
async function decompress2(data, { format, signal }) {
  const response = data instanceof Response ? data : new Response(data);
  assert(response.body, "Response does not contain body.");
  try {
    const decompressedResponse = new Response(response.body.pipeThrough(new DecompressionStream(format), { signal }));
    const buffer = await decompressedResponse.arrayBuffer();
    return buffer;
  } catch {
    signal?.throwIfAborted();
    throw new Error(`Failed to decode ${format}`);
  }
}

// node_modules/zarrita/dist/src/codecs/bitround.js
var BitroundCodec = class _BitroundCodec {
  constructor(configuration, _meta) {
    __publicField(this, "kind", "array_to_array");
    assert(configuration.keepbits >= 0, "keepbits must be zero or positive");
  }
  static fromConfig(configuration, meta) {
    return new _BitroundCodec(configuration, meta);
  }
  /**
   * Encode a chunk of data with bit-rounding.
   * @param _arr - The chunk to encode
   */
  encode(_arr) {
    throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.");
  }
  /**
   * Decode a chunk of data (no-op).
   * @param arr - The chunk to decode
   * @returns The decoded chunk
   */
  decode(arr) {
    return arr;
  }
};

// node_modules/zarrita/dist/src/codecs/bytes.js
var LITTLE_ENDIAN_OS = system_is_little_endian();
function system_is_little_endian() {
  const a2 = new Uint32Array([305419896]);
  const b2 = new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength);
  return !(b2[0] === 18);
}
function bytes_per_element(TypedArray) {
  if ("BYTES_PER_ELEMENT" in TypedArray) {
    return TypedArray.BYTES_PER_ELEMENT;
  }
  return 4;
}
var _stride, _TypedArray, _BYTES_PER_ELEMENT, _shape, _endian;
var _BytesCodec = class _BytesCodec {
  constructor(configuration, meta) {
    __publicField(this, "kind", "array_to_bytes");
    __privateAdd(this, _stride, void 0);
    __privateAdd(this, _TypedArray, void 0);
    __privateAdd(this, _BYTES_PER_ELEMENT, void 0);
    __privateAdd(this, _shape, void 0);
    __privateAdd(this, _endian, void 0);
    __privateSet(this, _endian, configuration?.endian);
    __privateSet(this, _TypedArray, get_ctr(meta.data_type));
    __privateSet(this, _shape, meta.shape);
    __privateSet(this, _stride, get_strides(meta.shape, "C"));
    const sample = new (__privateGet(this, _TypedArray))(0);
    __privateSet(this, _BYTES_PER_ELEMENT, sample.BYTES_PER_ELEMENT);
  }
  static fromConfig(configuration, meta) {
    return new _BytesCodec(configuration, meta);
  }
  encode(arr) {
    let bytes = new Uint8Array(arr.data.buffer);
    if (LITTLE_ENDIAN_OS && __privateGet(this, _endian) === "big") {
      byteswap_inplace(bytes, bytes_per_element(__privateGet(this, _TypedArray)));
    }
    return bytes;
  }
  decode(bytes) {
    if (LITTLE_ENDIAN_OS && __privateGet(this, _endian) === "big") {
      byteswap_inplace(bytes, bytes_per_element(__privateGet(this, _TypedArray)));
    }
    return {
      data: new (__privateGet(this, _TypedArray))(bytes.buffer, bytes.byteOffset, bytes.byteLength / __privateGet(this, _BYTES_PER_ELEMENT)),
      shape: __privateGet(this, _shape),
      stride: __privateGet(this, _stride)
    };
  }
};
_stride = new WeakMap();
_TypedArray = new WeakMap();
_BYTES_PER_ELEMENT = new WeakMap();
_shape = new WeakMap();
_endian = new WeakMap();
var BytesCodec = _BytesCodec;

// node_modules/zarrita/dist/src/codecs/crc32c.js
var Crc32cCodec = class _Crc32cCodec {
  constructor() {
    __publicField(this, "kind", "bytes_to_bytes");
  }
  static fromConfig() {
    return new _Crc32cCodec();
  }
  encode(_2) {
    throw new Error("Not implemented");
  }
  decode(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength - 4);
  }
};

// node_modules/zarrita/dist/src/codecs/gzip.js
var GzipCodec = class _GzipCodec {
  constructor() {
    __publicField(this, "kind", "bytes_to_bytes");
  }
  static fromConfig(_2) {
    return new _GzipCodec();
  }
  encode(_bytes2) {
    throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.");
  }
  async decode(bytes) {
    const buffer = await decompress2(bytes, { format: "gzip" });
    return new Uint8Array(buffer);
  }
};

// node_modules/zarrita/dist/src/codecs/json2.js
function throw_on_nan_replacer(_key, value) {
  assert(!Number.isNaN(value), "JsonCodec allow_nan is false but NaN was encountered during encoding.");
  assert(value !== Number.POSITIVE_INFINITY, "JsonCodec allow_nan is false but Infinity was encountered during encoding.");
  assert(value !== Number.NEGATIVE_INFINITY, "JsonCodec allow_nan is false but -Infinity was encountered during encoding.");
  return value;
}
function sort_keys_replacer(_key, value) {
  return value instanceof Object && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {
    sorted[key] = value[key];
    return sorted;
  }, {}) : value;
}
var _encoder_config, _decoder_config;
var _JsonCodec = class _JsonCodec {
  constructor(configuration = {}) {
    __publicField(this, "configuration");
    __publicField(this, "kind", "array_to_bytes");
    __privateAdd(this, _encoder_config, void 0);
    __privateAdd(this, _decoder_config, void 0);
    this.configuration = configuration;
    const { encoding = "utf-8", skipkeys = false, ensure_ascii = true, check_circular = true, allow_nan = true, sort_keys = true, indent, strict = true } = configuration;
    let separators = configuration.separators;
    if (!separators) {
      if (!indent) {
        separators = [",", ":"];
      } else {
        separators = [", ", ": "];
      }
    }
    __privateSet(this, _encoder_config, {
      encoding,
      skipkeys,
      ensure_ascii,
      check_circular,
      allow_nan,
      indent,
      separators,
      sort_keys
    });
    __privateSet(this, _decoder_config, { strict });
  }
  static fromConfig(configuration) {
    return new _JsonCodec(configuration);
  }
  encode(buf) {
    const { indent, encoding, ensure_ascii, check_circular, allow_nan, sort_keys } = __privateGet(this, _encoder_config);
    assert(encoding === "utf-8", "JsonCodec does not yet support non-utf-8 encoding.");
    const replacer_functions = [];
    assert(check_circular, "JsonCodec does not yet support skipping the check for circular references during encoding.");
    if (!allow_nan) {
      replacer_functions.push(throw_on_nan_replacer);
    }
    if (sort_keys) {
      replacer_functions.push(sort_keys_replacer);
    }
    const items = Array.from(buf.data);
    items.push("|O");
    items.push(buf.shape);
    let replacer;
    if (replacer_functions.length) {
      replacer = (key, value) => {
        let new_value = value;
        for (let sub_replacer of replacer_functions) {
          new_value = sub_replacer(key, new_value);
        }
        return new_value;
      };
    }
    let json_str = JSON.stringify(items, replacer, indent);
    if (ensure_ascii) {
      json_str = json_str.replace(/[\u007F-\uFFFF]/g, (chr) => {
        const full_str = `0000${chr.charCodeAt(0).toString(16)}`;
        const sub_str = full_str.substring(full_str.length - 4);
        return `\\u${sub_str}`;
      });
    }
    return new TextEncoder().encode(json_str);
  }
  decode(bytes) {
    const { strict } = __privateGet(this, _decoder_config);
    assert(strict, "JsonCodec does not yet support non-strict decoding.");
    const items = json_decode_object(bytes);
    const shape = items.pop();
    items.pop();
    assert(shape, "0D not implemented for JsonCodec.");
    const stride = get_strides(shape, "C");
    const data = items;
    return { data, shape, stride };
  }
};
_encoder_config = new WeakMap();
_decoder_config = new WeakMap();
var JsonCodec = _JsonCodec;

// node_modules/zarrita/dist/src/codecs/transpose.js
function proxy(arr) {
  if (arr instanceof BoolArray || arr instanceof ByteStringArray || arr instanceof UnicodeStringArray) {
    const arrp = new Proxy(arr, {
      get(target2, prop) {
        return target2.get(Number(prop));
      },
      set(target2, prop, value) {
        target2.set(Number(prop), value);
        return true;
      }
    });
    return arrp;
  }
  return arr;
}
function empty_like(chunk, order) {
  let data;
  if (chunk.data instanceof ByteStringArray || chunk.data instanceof UnicodeStringArray) {
    data = new chunk.constructor(
      // @ts-expect-error
      chunk.data.length,
      chunk.data.chars
    );
  } else {
    data = new chunk.constructor(chunk.data.length);
  }
  return {
    data,
    shape: chunk.shape,
    stride: get_strides(chunk.shape, order)
  };
}
function convert_array_order(src, target2) {
  let out = empty_like(src, target2);
  let n_dims = src.shape.length;
  let size = src.data.length;
  let index = Array(n_dims).fill(0);
  let src_data = proxy(src.data);
  let out_data = proxy(out.data);
  for (let src_idx = 0; src_idx < size; src_idx++) {
    let out_idx = 0;
    for (let dim = 0; dim < n_dims; dim++) {
      out_idx += index[dim] * out.stride[dim];
    }
    out_data[out_idx] = src_data[src_idx];
    index[0] += 1;
    for (let dim = 0; dim < n_dims; dim++) {
      if (index[dim] === src.shape[dim]) {
        if (dim + 1 === n_dims) {
          break;
        }
        index[dim] = 0;
        index[dim + 1] += 1;
      }
    }
  }
  return out;
}
function get_order(chunk) {
  let rank2 = chunk.shape.length;
  assert(rank2 === chunk.stride.length, "Shape and stride must have the same length.");
  return chunk.stride.map((s2, i3) => ({ stride: s2, index: i3 })).sort((a2, b2) => b2.stride - a2.stride).map((entry) => entry.index);
}
function matches_order(chunk, target2) {
  let source3 = get_order(chunk);
  assert(source3.length === target2.length, "Orders must match");
  return source3.every((dim, i3) => dim === target2[i3]);
}
var _order, _inverseOrder;
var _TransposeCodec = class _TransposeCodec {
  constructor(configuration, meta) {
    __publicField(this, "kind", "array_to_array");
    __privateAdd(this, _order, void 0);
    __privateAdd(this, _inverseOrder, void 0);
    let value = configuration.order ?? "C";
    let rank2 = meta.shape.length;
    let order = new Array(rank2);
    let inverseOrder = new Array(rank2);
    if (value === "C") {
      for (let i3 = 0; i3 < rank2; ++i3) {
        order[i3] = i3;
        inverseOrder[i3] = i3;
      }
    } else if (value === "F") {
      for (let i3 = 0; i3 < rank2; ++i3) {
        order[i3] = rank2 - i3 - 1;
        inverseOrder[i3] = rank2 - i3 - 1;
      }
    } else {
      order = value;
      order.forEach((x2, i3) => {
        assert(inverseOrder[x2] === void 0, `Invalid permutation: ${JSON.stringify(value)}`);
        inverseOrder[x2] = i3;
      });
    }
    __privateSet(this, _order, order);
    __privateSet(this, _inverseOrder, inverseOrder);
  }
  static fromConfig(configuration, meta) {
    return new _TransposeCodec(configuration, meta);
  }
  encode(arr) {
    if (matches_order(arr, __privateGet(this, _inverseOrder))) {
      return arr;
    }
    return convert_array_order(arr, __privateGet(this, _inverseOrder));
  }
  decode(arr) {
    return {
      data: arr.data,
      shape: arr.shape,
      stride: get_strides(arr.shape, __privateGet(this, _order))
    };
  }
};
_order = new WeakMap();
_inverseOrder = new WeakMap();
var TransposeCodec = _TransposeCodec;

// node_modules/zarrita/dist/src/codecs/vlen-utf8.js
var _shape2, _strides;
var _VLenUTF8 = class _VLenUTF8 {
  constructor(shape) {
    __publicField(this, "kind", "array_to_bytes");
    __privateAdd(this, _shape2, void 0);
    __privateAdd(this, _strides, void 0);
    __privateSet(this, _shape2, shape);
    __privateSet(this, _strides, get_strides(shape, "C"));
  }
  static fromConfig(_2, meta) {
    return new _VLenUTF8(meta.shape);
  }
  encode(_chunk) {
    throw new Error("Method not implemented.");
  }
  decode(bytes) {
    let decoder = new TextDecoder();
    let view = new DataView(bytes.buffer);
    let data = Array(view.getUint32(0, true));
    let pos = 4;
    for (let i3 = 0; i3 < data.length; i3++) {
      let item_length = view.getUint32(pos, true);
      pos += 4;
      data[i3] = decoder.decode(bytes.buffer.slice(pos, pos + item_length));
      pos += item_length;
    }
    return { data, shape: __privateGet(this, _shape2), stride: __privateGet(this, _strides) };
  }
};
_shape2 = new WeakMap();
_strides = new WeakMap();
var VLenUTF8 = _VLenUTF8;

// node_modules/zarrita/dist/src/codecs/zlib.js
var ZlibCodec = class _ZlibCodec {
  constructor() {
    __publicField(this, "kind", "bytes_to_bytes");
  }
  static fromConfig(_2) {
    return new _ZlibCodec();
  }
  encode(_bytes2) {
    throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.");
  }
  async decode(bytes) {
    const buffer = await decompress2(bytes, { format: "deflate" });
    return new Uint8Array(buffer);
  }
};

// node_modules/zarrita/dist/src/codecs.js
function create_default_registry() {
  return (/* @__PURE__ */ new Map()).set("blosc", () => Promise.resolve().then(() => (init_blosc(), blosc_exports)).then((m2) => m2.default)).set("lz4", () => Promise.resolve().then(() => (init_lz4(), lz4_exports)).then((m2) => m2.default)).set("zstd", () => Promise.resolve().then(() => (init_zstd(), zstd_exports)).then((m2) => m2.default)).set("gzip", () => GzipCodec).set("zlib", () => ZlibCodec).set("transpose", () => TransposeCodec).set("bytes", () => BytesCodec).set("crc32c", () => Crc32cCodec).set("vlen-utf8", () => VLenUTF8).set("json2", () => JsonCodec).set("bitround", () => BitroundCodec);
}
var registry2 = create_default_registry();
function create_codec_pipeline(chunk_metadata) {
  let codecs;
  return {
    async encode(chunk) {
      if (!codecs)
        codecs = await load_codecs(chunk_metadata);
      for (const codec of codecs.array_to_array) {
        chunk = await codec.encode(chunk);
      }
      let bytes = await codecs.array_to_bytes.encode(chunk);
      for (const codec of codecs.bytes_to_bytes) {
        bytes = await codec.encode(bytes);
      }
      return bytes;
    },
    async decode(bytes) {
      if (!codecs)
        codecs = await load_codecs(chunk_metadata);
      for (let i3 = codecs.bytes_to_bytes.length - 1; i3 >= 0; i3--) {
        bytes = await codecs.bytes_to_bytes[i3].decode(bytes);
      }
      let chunk = await codecs.array_to_bytes.decode(bytes);
      for (let i3 = codecs.array_to_array.length - 1; i3 >= 0; i3--) {
        chunk = await codecs.array_to_array[i3].decode(chunk);
      }
      return chunk;
    }
  };
}
async function load_codecs(chunk_meta) {
  let promises = chunk_meta.codecs.map(async (meta) => {
    let Codec = await registry2.get(meta.name)?.();
    assert(Codec, `Unknown codec: ${meta.name}`);
    return { Codec, meta };
  });
  let array_to_array = [];
  let array_to_bytes;
  let bytes_to_bytes = [];
  for await (let { Codec, meta } of promises) {
    let codec = Codec.fromConfig(meta.configuration, chunk_meta);
    switch (codec.kind) {
      case "array_to_array":
        array_to_array.push(codec);
        break;
      case "array_to_bytes":
        array_to_bytes = codec;
        break;
      default:
        bytes_to_bytes.push(codec);
    }
  }
  if (!array_to_bytes) {
    assert(is_typed_array_like_meta(chunk_meta), `Cannot encode ${chunk_meta.data_type} to bytes without a codec`);
    array_to_bytes = BytesCodec.fromConfig({ endian: "little" }, chunk_meta);
  }
  return { array_to_array, array_to_bytes, bytes_to_bytes };
}
function is_typed_array_like_meta(meta) {
  return meta.data_type !== "v2:object";
}

// node_modules/zarrita/dist/src/errors.js
var NodeNotFoundError = class extends Error {
  constructor(context, options = {}) {
    super(`Node not found: ${context}`, options);
    this.name = "NodeNotFoundError";
  }
};
var KeyError = class extends Error {
  constructor(path) {
    super(`Missing key: ${path}`);
    this.name = "KeyError";
  }
};

// node_modules/zarrita/dist/src/codecs/sharding.js
var MAX_BIG_UINT = 18446744073709551615n;
function create_sharded_chunk_getter(location, shard_shape, encode_shard_key, sharding_config) {
  assert(location.store.getRange, "Store does not support range requests");
  let get_range = location.store.getRange.bind(location.store);
  let index_shape = shard_shape.map((d2, i3) => d2 / sharding_config.chunk_shape[i3]);
  let index_codec = create_codec_pipeline({
    data_type: "uint64",
    shape: [...index_shape, 2],
    codecs: sharding_config.index_codecs
  });
  let cache3 = {};
  return async (chunk_coord) => {
    let shard_coord = chunk_coord.map((d2, i3) => Math.floor(d2 / index_shape[i3]));
    let shard_path = location.resolve(encode_shard_key(shard_coord)).path;
    let index;
    if (shard_path in cache3) {
      index = cache3[shard_path];
    } else {
      let checksum_size = 4;
      let index_size = 16 * index_shape.reduce((a2, b2) => a2 * b2, 1);
      let bytes = await get_range(shard_path, {
        suffixLength: index_size + checksum_size
      });
      index = cache3[shard_path] = bytes ? await index_codec.decode(bytes) : null;
    }
    if (index === null) {
      return void 0;
    }
    let { data, shape, stride } = index;
    let linear_offset = chunk_coord.map((d2, i3) => d2 % shape[i3]).reduce((acc, sel, idx) => acc + sel * stride[idx], 0);
    let offset = data[linear_offset];
    let length5 = data[linear_offset + 1];
    if (offset === MAX_BIG_UINT && length5 === MAX_BIG_UINT) {
      return void 0;
    }
    return get_range(shard_path, {
      offset: Number(offset),
      length: Number(length5)
    });
  };
}

// node_modules/zarrita/dist/src/hierarchy.js
var Location = class _Location {
  constructor(store, path = "/") {
    __publicField(this, "store");
    __publicField(this, "path");
    this.store = store;
    this.path = path;
  }
  resolve(path) {
    let root2 = new URL(`file://${this.path.endsWith("/") ? this.path : `${this.path}/`}`);
    return new _Location(this.store, decodeURIComponent(new URL(path, root2).pathname));
  }
};
function root(store) {
  return new Location(store ?? /* @__PURE__ */ new Map());
}
var _metadata;
var Group = class extends Location {
  constructor(store, path, metadata) {
    super(store, path);
    __publicField(this, "kind", "group");
    __privateAdd(this, _metadata, void 0);
    __privateSet(this, _metadata, metadata);
  }
  get attrs() {
    return __privateGet(this, _metadata).attributes;
  }
};
_metadata = new WeakMap();
function get_array_order(codecs) {
  const maybe_transpose_codec = codecs.find((c2) => c2.name === "transpose");
  return maybe_transpose_codec?.configuration?.order ?? "C";
}
var CONTEXT_MARKER = Symbol("zarrita.context");
function get_context(obj) {
  return obj[CONTEXT_MARKER];
}
function create_context(location, metadata) {
  let { configuration } = metadata.codecs.find(is_sharding_codec) ?? {};
  let shared_context = {
    encode_chunk_key: create_chunk_key_encoder(metadata.chunk_key_encoding),
    TypedArray: get_ctr(metadata.data_type),
    fill_value: metadata.fill_value
  };
  if (configuration) {
    let native_order2 = get_array_order(configuration.codecs);
    return {
      ...shared_context,
      kind: "sharded",
      chunk_shape: configuration.chunk_shape,
      codec: create_codec_pipeline({
        data_type: metadata.data_type,
        shape: configuration.chunk_shape,
        codecs: configuration.codecs
      }),
      get_strides(shape) {
        return get_strides(shape, native_order2);
      },
      get_chunk_bytes: create_sharded_chunk_getter(location, metadata.chunk_grid.configuration.chunk_shape, shared_context.encode_chunk_key, configuration)
    };
  }
  let native_order = get_array_order(metadata.codecs);
  return {
    ...shared_context,
    kind: "regular",
    chunk_shape: metadata.chunk_grid.configuration.chunk_shape,
    codec: create_codec_pipeline({
      data_type: metadata.data_type,
      shape: metadata.chunk_grid.configuration.chunk_shape,
      codecs: metadata.codecs
    }),
    get_strides(shape) {
      return get_strides(shape, native_order);
    },
    async get_chunk_bytes(chunk_coords, options) {
      let chunk_key = shared_context.encode_chunk_key(chunk_coords);
      let chunk_path = location.resolve(chunk_key).path;
      return location.store.get(chunk_path, options);
    }
  };
}
var _metadata2, _a4;
var Array2 = class extends Location {
  constructor(store, path, metadata) {
    super(store, path);
    __publicField(this, "kind", "array");
    __privateAdd(this, _metadata2, void 0);
    __publicField(this, _a4);
    __privateSet(this, _metadata2, {
      ...metadata,
      fill_value: ensure_correct_scalar(metadata)
    });
    this[CONTEXT_MARKER] = create_context(this, metadata);
  }
  get attrs() {
    return __privateGet(this, _metadata2).attributes;
  }
  get shape() {
    return __privateGet(this, _metadata2).shape;
  }
  get chunks() {
    return this[CONTEXT_MARKER].chunk_shape;
  }
  get dtype() {
    return __privateGet(this, _metadata2).data_type;
  }
  async getChunk(chunk_coords, options) {
    let context = this[CONTEXT_MARKER];
    let maybe_bytes = await context.get_chunk_bytes(chunk_coords, options);
    if (!maybe_bytes) {
      let size = context.chunk_shape.reduce((a2, b2) => a2 * b2, 1);
      let data = new context.TypedArray(size);
      data.fill(context.fill_value);
      return {
        data,
        shape: context.chunk_shape,
        stride: context.get_strides(context.chunk_shape)
      };
    }
    return context.codec.decode(maybe_bytes);
  }
  /**
   * A helper method to narrow `zarr.Array` Dtype.
   *
   * ```typescript
   * let arr: zarr.Array<DataType, FetchStore> = zarr.open(store, { kind: "array" });
   *
   * // Option 1: narrow by scalar type (e.g. "bool", "raw", "bigint", "number")
   * if (arr.is("bigint")) {
   *   // zarr.Array<"int64" | "uint64", FetchStore>
   * }
   *
   * // Option 3: exact match
   * if (arr.is("float32")) {
   *   // zarr.Array<"float32", FetchStore, "/">
   * }
   * ```
   */
  is(query) {
    return is_dtype(this.dtype, query);
  }
};
_a4 = CONTEXT_MARKER;
_metadata2 = new WeakMap();

// node_modules/zarrita/dist/src/indexing/util.js
function* range(start, stop, step = 1) {
  if (stop === void 0) {
    stop = start;
    start = 0;
  }
  for (let i3 = start; i3 < stop; i3 += step) {
    yield i3;
  }
}
function* product(...iterables) {
  if (iterables.length === 0) {
    return;
  }
  const iterators = iterables.map((it2) => it2[Symbol.iterator]());
  const results = iterators.map((it2) => it2.next());
  if (results.some((r2) => r2.done)) {
    throw new Error("Input contains an empty iterator.");
  }
  for (let i3 = 0; ; ) {
    if (results[i3].done) {
      iterators[i3] = iterables[i3][Symbol.iterator]();
      results[i3] = iterators[i3].next();
      if (++i3 >= iterators.length) {
        return;
      }
    } else {
      yield results.map(({ value }) => value);
      i3 = 0;
    }
    results[i3] = iterators[i3].next();
  }
}
function slice_indices({ start, stop, step }, length5) {
  if (step === 0) {
    throw new Error("slice step cannot be zero");
  }
  step = step ?? 1;
  const step_is_negative = step < 0;
  const [lower, upper] = step_is_negative ? [-1, length5 - 1] : [0, length5];
  if (start === null) {
    start = step_is_negative ? upper : lower;
  } else {
    if (start < 0) {
      start += length5;
      if (start < lower) {
        start = lower;
      }
    } else if (start > upper) {
      start = upper;
    }
  }
  if (stop === null) {
    stop = step_is_negative ? lower : upper;
  } else {
    if (stop < 0) {
      stop += length5;
      if (stop < lower) {
        stop = lower;
      }
    } else if (stop > upper) {
      stop = upper;
    }
  }
  return [start, stop, step];
}
function slice(start, stop, step = null) {
  if (stop === void 0) {
    stop = start;
    start = null;
  }
  return {
    start,
    stop,
    step
  };
}
function create_queue() {
  const promises = [];
  return {
    add: (fn) => promises.push(fn()),
    onIdle: () => Promise.all(promises)
  };
}

// node_modules/zarrita/dist/src/indexing/indexer.js
var IndexError = class extends Error {
  constructor(msg) {
    super(msg);
    this.name = "IndexError";
  }
};
function err_too_many_indices(selection, shape) {
  throw new IndexError(`too many indicies for array; expected ${shape.length}, got ${selection.length}`);
}
function err_boundscheck(dim_len) {
  throw new IndexError(`index out of bounds for dimension with length ${dim_len}`);
}
function err_negative_step() {
  throw new IndexError("only slices with step >= 1 are supported");
}
function check_selection_length(selection, shape) {
  if (selection.length > shape.length) {
    err_too_many_indices(selection, shape);
  }
}
function normalize_integer_selection(dim_sel, dim_len) {
  dim_sel = Math.trunc(dim_sel);
  if (dim_sel < 0) {
    dim_sel = dim_len + dim_sel;
  }
  if (dim_sel >= dim_len || dim_sel < 0) {
    err_boundscheck(dim_len);
  }
  return dim_sel;
}
var IntDimIndexer = class {
  constructor({ dim_sel, dim_len, dim_chunk_len }) {
    __publicField(this, "dim_sel");
    __publicField(this, "dim_len");
    __publicField(this, "dim_chunk_len");
    __publicField(this, "nitems");
    dim_sel = normalize_integer_selection(dim_sel, dim_len);
    this.dim_sel = dim_sel;
    this.dim_len = dim_len;
    this.dim_chunk_len = dim_chunk_len;
    this.nitems = 1;
  }
  *[Symbol.iterator]() {
    const dim_chunk_ix = Math.floor(this.dim_sel / this.dim_chunk_len);
    const dim_offset = dim_chunk_ix * this.dim_chunk_len;
    const dim_chunk_sel = this.dim_sel - dim_offset;
    yield { dim_chunk_ix, dim_chunk_sel };
  }
};
var SliceDimIndexer = class {
  constructor({ dim_sel, dim_len, dim_chunk_len }) {
    __publicField(this, "start");
    __publicField(this, "stop");
    __publicField(this, "step");
    __publicField(this, "dim_len");
    __publicField(this, "dim_chunk_len");
    __publicField(this, "nitems");
    __publicField(this, "nchunks");
    const [start, stop, step] = slice_indices(dim_sel, dim_len);
    this.start = start;
    this.stop = stop;
    this.step = step;
    if (this.step < 1)
      err_negative_step();
    this.dim_len = dim_len;
    this.dim_chunk_len = dim_chunk_len;
    this.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));
    this.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);
  }
  *[Symbol.iterator]() {
    const dim_chunk_ix_from = Math.floor(this.start / this.dim_chunk_len);
    const dim_chunk_ix_to = Math.ceil(this.stop / this.dim_chunk_len);
    for (const dim_chunk_ix of range(dim_chunk_ix_from, dim_chunk_ix_to)) {
      const dim_offset = dim_chunk_ix * this.dim_chunk_len;
      const dim_limit = Math.min(this.dim_len, (dim_chunk_ix + 1) * this.dim_chunk_len);
      const dim_chunk_len = dim_limit - dim_offset;
      let dim_out_offset = 0;
      let dim_chunk_sel_start = 0;
      if (this.start < dim_offset) {
        const remainder = (dim_offset - this.start) % this.step;
        if (remainder)
          dim_chunk_sel_start += this.step - remainder;
        dim_out_offset = Math.ceil((dim_offset - this.start) / this.step);
      } else {
        dim_chunk_sel_start = this.start - dim_offset;
      }
      const dim_chunk_sel_stop = this.stop > dim_limit ? dim_chunk_len : this.stop - dim_offset;
      const dim_chunk_sel = [
        dim_chunk_sel_start,
        dim_chunk_sel_stop,
        this.step
      ];
      const dim_chunk_nitems = Math.ceil((dim_chunk_sel_stop - dim_chunk_sel_start) / this.step);
      const dim_out_sel = [
        dim_out_offset,
        dim_out_offset + dim_chunk_nitems,
        1
      ];
      yield { dim_chunk_ix, dim_chunk_sel, dim_out_sel };
    }
  }
};
function normalize_selection(selection, shape) {
  let normalized = [];
  if (selection === null) {
    normalized = shape.map((_2) => slice(null));
  } else if (Array.isArray(selection)) {
    normalized = selection.map((s2) => s2 ?? slice(null));
  }
  check_selection_length(normalized, shape);
  return normalized;
}
var BasicIndexer = class {
  constructor({ selection, shape, chunk_shape }) {
    __publicField(this, "dim_indexers");
    __publicField(this, "shape");
    this.dim_indexers = normalize_selection(selection, shape).map((dim_sel, i3) => {
      return new (typeof dim_sel === "number" ? IntDimIndexer : SliceDimIndexer)({
        // @ts-expect-error ts inference not strong enough to know correct chunk
        dim_sel,
        dim_len: shape[i3],
        dim_chunk_len: chunk_shape[i3]
      });
    });
    this.shape = this.dim_indexers.filter((ixr) => ixr instanceof SliceDimIndexer).map((sixr) => sixr.nitems);
  }
  *[Symbol.iterator]() {
    for (const dim_projections of product(...this.dim_indexers)) {
      const chunk_coords = dim_projections.map((p2) => p2.dim_chunk_ix);
      const mapping = dim_projections.map((p2) => {
        if ("dim_out_sel" in p2) {
          return { from: p2.dim_chunk_sel, to: p2.dim_out_sel };
        }
        return { from: p2.dim_chunk_sel, to: null };
      });
      yield { chunk_coords, mapping };
    }
  }
};

// node_modules/zarrita/dist/src/indexing/get.js
function unwrap(arr, idx) {
  return "get" in arr ? arr.get(idx) : arr[idx];
}
async function get(arr, selection, opts, setter2) {
  let context = get_context(arr);
  let indexer = new BasicIndexer({
    selection,
    shape: arr.shape,
    chunk_shape: arr.chunks
  });
  let out = setter2.prepare(new context.TypedArray(indexer.shape.reduce((a2, b2) => a2 * b2, 1)), indexer.shape, context.get_strides(indexer.shape));
  let queue = opts.create_queue?.() ?? create_queue();
  for (const { chunk_coords, mapping } of indexer) {
    queue.add(async () => {
      let { data, shape, stride } = await arr.getChunk(chunk_coords, opts.opts);
      let chunk = setter2.prepare(data, shape, stride);
      setter2.set_from_chunk(out, chunk, mapping);
    });
  }
  await queue.onIdle();
  return indexer.shape.length === 0 ? unwrap(out.data, 0) : out;
}

// node_modules/zarrita/dist/src/indexing/ops.js
function object_array_view(arr, offset = 0, size) {
  let length5 = size ?? arr.length - offset;
  return {
    length: length5,
    subarray(from, to = length5) {
      return object_array_view(arr, offset + from, to - from);
    },
    set(data, start = 0) {
      for (let i3 = 0; i3 < data.length; i3++) {
        arr[offset + start + i3] = data.get(i3);
      }
    },
    get(index) {
      return arr[offset + index];
    }
  };
}
function compat_chunk(arr) {
  if (globalThis.Array.isArray(arr.data)) {
    return {
      // @ts-expect-error
      data: object_array_view(arr.data),
      stride: arr.stride,
      bytes_per_element: 1
    };
  }
  return {
    data: new Uint8Array(arr.data.buffer, arr.data.byteOffset, arr.data.byteLength),
    stride: arr.stride,
    bytes_per_element: arr.data.BYTES_PER_ELEMENT
  };
}
function get_typed_array_constructor(arr) {
  if ("chars" in arr) {
    return arr.constructor.bind(null, arr.chars);
  }
  return arr.constructor;
}
function compat_scalar(arr, value) {
  if (globalThis.Array.isArray(arr.data)) {
    return object_array_view([value]);
  }
  let TypedArray = get_typed_array_constructor(arr.data);
  let data = new TypedArray([value]);
  return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
var setter = {
  prepare(data, shape, stride) {
    return { data, shape, stride };
  },
  set_scalar(dest, sel, value) {
    let view = compat_chunk(dest);
    set_scalar_binary(view, sel, compat_scalar(dest, value), view.bytes_per_element);
  },
  set_from_chunk(dest, src, projections) {
    let view = compat_chunk(dest);
    set_from_chunk_binary(view, compat_chunk(src), view.bytes_per_element, projections);
  }
};
async function get2(arr, selection = null, opts = {}) {
  return get(arr, selection, opts, setter);
}
function indices_len(start, stop, step) {
  if (step < 0 && stop < start) {
    return Math.floor((start - stop - 1) / -step) + 1;
  }
  if (start < stop)
    return Math.floor((stop - start - 1) / step) + 1;
  return 0;
}
function set_scalar_binary(out, out_selection, value, bytes_per_element2) {
  if (out_selection.length === 0) {
    out.data.set(value, 0);
    return;
  }
  const [slice2, ...slices] = out_selection;
  const [curr_stride, ...stride] = out.stride;
  if (typeof slice2 === "number") {
    const data = out.data.subarray(curr_stride * slice2 * bytes_per_element2);
    set_scalar_binary({ data, stride }, slices, value, bytes_per_element2);
    return;
  }
  const [from, to, step] = slice2;
  const len4 = indices_len(from, to, step);
  if (slices.length === 0) {
    for (let i3 = 0; i3 < len4; i3++) {
      out.data.set(value, curr_stride * (from + step * i3) * bytes_per_element2);
    }
    return;
  }
  for (let i3 = 0; i3 < len4; i3++) {
    const data = out.data.subarray(curr_stride * (from + step * i3) * bytes_per_element2);
    set_scalar_binary({ data, stride }, slices, value, bytes_per_element2);
  }
}
function set_from_chunk_binary(dest, src, bytes_per_element2, projections) {
  const [proj, ...projs] = projections;
  const [dstride, ...dstrides] = dest.stride;
  const [sstride, ...sstrides] = src.stride;
  if (proj.from === null) {
    if (projs.length === 0) {
      dest.data.set(src.data.subarray(0, bytes_per_element2), proj.to * bytes_per_element2);
      return;
    }
    set_from_chunk_binary({
      data: dest.data.subarray(dstride * proj.to * bytes_per_element2),
      stride: dstrides
    }, src, bytes_per_element2, projs);
    return;
  }
  if (proj.to === null) {
    if (projs.length === 0) {
      let offset = proj.from * bytes_per_element2;
      dest.data.set(src.data.subarray(offset, offset + bytes_per_element2), 0);
      return;
    }
    set_from_chunk_binary(dest, {
      data: src.data.subarray(sstride * proj.from * bytes_per_element2),
      stride: sstrides
    }, bytes_per_element2, projs);
    return;
  }
  const [from, to, step] = proj.to;
  const [sfrom, _2, sstep] = proj.from;
  const len4 = indices_len(from, to, step);
  if (projs.length === 0) {
    if (step === 1 && sstep === 1 && dstride === 1 && sstride === 1) {
      let offset = sfrom * bytes_per_element2;
      let size = len4 * bytes_per_element2;
      dest.data.set(src.data.subarray(offset, offset + size), from * bytes_per_element2);
      return;
    }
    for (let i3 = 0; i3 < len4; i3++) {
      let offset = sstride * (sfrom + sstep * i3) * bytes_per_element2;
      dest.data.set(src.data.subarray(offset, offset + bytes_per_element2), dstride * (from + step * i3) * bytes_per_element2);
    }
    return;
  }
  for (let i3 = 0; i3 < len4; i3++) {
    set_from_chunk_binary({
      data: dest.data.subarray(dstride * (from + i3 * step) * bytes_per_element2),
      stride: dstrides
    }, {
      data: src.data.subarray(sstride * (sfrom + i3 * sstep) * bytes_per_element2),
      stride: sstrides
    }, bytes_per_element2, projs);
  }
}

// node_modules/zarrita/dist/src/open.js
var VERSION_COUNTER = create_version_counter();
function create_version_counter() {
  let version_counts = /* @__PURE__ */ new WeakMap();
  function get_counts(store) {
    let counts = version_counts.get(store) ?? { v2: 0, v3: 0 };
    version_counts.set(store, counts);
    return counts;
  }
  return {
    increment(store, version2) {
      get_counts(store)[version2] += 1;
    },
    version_max(store) {
      let counts = get_counts(store);
      return counts.v3 > counts.v2 ? "v3" : "v2";
    }
  };
}
async function load_attrs(location) {
  let meta_bytes = await location.store.get(location.resolve(".zattrs").path);
  if (!meta_bytes)
    return {};
  return json_decode_object(meta_bytes);
}
async function open_v2(location, options = {}) {
  let loc = "store" in location ? location : new Location(location);
  let attrs = {};
  if (options.attrs ?? true)
    attrs = await load_attrs(loc);
  if (options.kind === "array")
    return open_array_v2(loc, attrs);
  if (options.kind === "group")
    return open_group_v2(loc, attrs);
  return open_array_v2(loc, attrs).catch((err2) => {
    rethrow_unless(err2, NodeNotFoundError);
    return open_group_v2(loc, attrs);
  });
}
async function open_array_v2(location, attrs) {
  let { path } = location.resolve(".zarray");
  let meta = await location.store.get(path);
  if (!meta) {
    throw new NodeNotFoundError("v2 array", {
      cause: new KeyError(path)
    });
  }
  VERSION_COUNTER.increment(location.store, "v2");
  return new Array2(location.store, location.path, v2_to_v3_array_metadata(json_decode_object(meta), attrs));
}
async function open_group_v2(location, attrs) {
  let { path } = location.resolve(".zgroup");
  let meta = await location.store.get(path);
  if (!meta) {
    throw new NodeNotFoundError("v2 group", {
      cause: new KeyError(path)
    });
  }
  VERSION_COUNTER.increment(location.store, "v2");
  return new Group(location.store, location.path, v2_to_v3_group_metadata(json_decode_object(meta), attrs));
}
async function _open_v3(location) {
  let { store, path } = location.resolve("zarr.json");
  let meta = await location.store.get(path);
  if (!meta) {
    throw new NodeNotFoundError("v3 array or group", {
      cause: new KeyError(path)
    });
  }
  let meta_doc = json_decode_object(meta);
  if (meta_doc.node_type === "array") {
    meta_doc.fill_value = ensure_correct_scalar(meta_doc);
  }
  return meta_doc.node_type === "array" ? new Array2(store, location.path, meta_doc) : new Group(store, location.path, meta_doc);
}
async function open_v3(location, options = {}) {
  let loc = "store" in location ? location : new Location(location);
  let node = await _open_v3(loc);
  VERSION_COUNTER.increment(loc.store, "v3");
  if (options.kind === void 0)
    return node;
  if (options.kind === "array" && node instanceof Array2)
    return node;
  if (options.kind === "group" && node instanceof Group)
    return node;
  let kind = node instanceof Array2 ? "array" : "group";
  throw new Error(`Expected node of kind ${options.kind}, found ${kind}.`);
}
async function open(location, options = {}) {
  let store = "store" in location ? location.store : location;
  let version_max = VERSION_COUNTER.version_max(store);
  let open_primary = version_max === "v2" ? open.v2 : open.v3;
  let open_secondary = version_max === "v2" ? open.v3 : open.v2;
  return open_primary(location, options).catch((err2) => {
    rethrow_unless(err2, NodeNotFoundError);
    return open_secondary(location, options);
  });
}
open.v2 = open_v2;
open.v3 = open_v3;

// node_modules/@vivjs/loaders/dist/index.mjs
var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var LZWDecoder2 = class extends BaseDecoder {
  constructor(fileDirectory) {
    super();
    __publicField$3(this, "maxUncompressedSize");
    const width = fileDirectory.TileWidth || fileDirectory.ImageWidth;
    const height = fileDirectory.TileLength || fileDirectory.ImageLength;
    const nbytes = fileDirectory.BitsPerSample[0] / 8;
    this.maxUncompressedSize = width * height * nbytes;
  }
  async decodeBlock(buffer) {
    const bytes = new Uint8Array(buffer);
    const decoded = await N(bytes, this.maxUncompressedSize);
    return decoded.buffer;
  }
};
function intToRgba(int) {
  if (!Number.isInteger(int)) {
    throw Error("Not an integer.");
  }
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setInt32(0, int, false);
  const bytes = new Uint8Array(buffer);
  return Array.from(bytes);
}
function isInterleaved(shape) {
  const lastDimSize = shape[shape.length - 1];
  return lastDimSize === 3 || lastDimSize === 4;
}
function getImageSize(source3) {
  const interleaved = isInterleaved(source3.shape);
  const [height, width] = source3.shape.slice(interleaved ? -3 : -2);
  return { height, width };
}
function prevPowerOf2(x2) {
  return 2 ** Math.floor(Math.log2(x2));
}
var SIGNAL_ABORTED = "__vivSignalAborted";
var VIV_PROXY_KEY = "__viv";
var OFFSETS_PROXY_KEY = `${VIV_PROXY_KEY}-offsets`;
function flattenAttributes({
  attr,
  ...rest
}) {
  return { ...attr, ...rest };
}
function ensureArray(x2) {
  return Array.isArray(x2) ? x2 : [x2];
}
var DimensionOrderSchema = enumType([
  "XYZCT",
  "XYZTC",
  "XYCTZ",
  "XYCZT",
  "XYTCZ",
  "XYTZC"
]);
var PixelTypeSchema = enumType([
  "int8",
  "int16",
  "int32",
  "uint8",
  "uint16",
  "uint32",
  "float",
  "bit",
  "double",
  "complex",
  "double-complex"
]);
var PhysicalUnitSchema = enumType([
  "Ym",
  "Zm",
  "Em",
  "Pm",
  "Tm",
  "Gm",
  "Mm",
  "km",
  "hm",
  "dam",
  "m",
  "dm",
  "cm",
  "mm",
  "\xB5m",
  "nm",
  "pm",
  "fm",
  "am",
  "zm",
  "ym",
  "\xC5",
  "thou",
  "li",
  "in",
  "ft",
  "yd",
  "mi",
  "ua",
  "ly",
  "pc",
  "pt",
  "pixel",
  "reference frame"
]);
var ChannelSchema = objectType({}).extend({
  attr: objectType({
    ID: stringType(),
    SamplesPerPixel: coerce.number().optional(),
    Name: stringType().optional(),
    Color: coerce.number().transform(intToRgba).optional()
  })
}).transform(flattenAttributes);
var UuidSchema = objectType({}).extend({
  attr: objectType({
    FileName: stringType()
  })
}).transform(flattenAttributes);
var TiffDataSchema = objectType({ UUID: UuidSchema.optional() }).extend({
  attr: objectType({
    IFD: coerce.number().default(0),
    PlaneCount: coerce.number().default(1),
    FirstT: coerce.number().optional(),
    FirstC: coerce.number().optional(),
    FirstZ: coerce.number().optional()
  })
}).transform(flattenAttributes);
var PixelsSchema = objectType({
  Channel: preprocessType(ensureArray, ChannelSchema.array()),
  TiffData: preprocessType(ensureArray, TiffDataSchema.array()).optional()
}).extend({
  attr: objectType({
    ID: stringType(),
    DimensionOrder: DimensionOrderSchema,
    Type: PixelTypeSchema,
    SizeT: coerce.number(),
    SizeC: coerce.number(),
    SizeZ: coerce.number(),
    SizeY: coerce.number(),
    SizeX: coerce.number(),
    PhysicalSizeX: coerce.number().optional(),
    PhysicalSizeY: coerce.number().optional(),
    PhysicalSizeZ: coerce.number().optional(),
    SignificantBits: coerce.number().optional(),
    PhysicalSizeXUnit: PhysicalUnitSchema.optional().default("\xB5m"),
    PhysicalSizeYUnit: PhysicalUnitSchema.optional().default("\xB5m"),
    PhysicalSizeZUnit: PhysicalUnitSchema.optional().default("\xB5m"),
    BigEndian: stringType().transform((v2) => v2.toLowerCase() === "true").optional(),
    Interleaved: stringType().transform((v2) => v2.toLowerCase() === "true").optional()
  })
}).transform(flattenAttributes).transform(({ Channel, ...rest }) => ({ Channels: Channel, ...rest }));
var ImageSchema = objectType({
  AquisitionDate: stringType().optional().default(""),
  Description: unknownType().optional().default(""),
  Pixels: PixelsSchema
}).extend({
  attr: objectType({
    ID: stringType(),
    Name: stringType().optional()
  })
}).transform(flattenAttributes);
var OmeSchema = objectType({
  Image: preprocessType(ensureArray, ImageSchema.array())
});
addDecoder(5, () => LZWDecoder2);
function isAxis(axisOrLabel) {
  return typeof axisOrLabel[0] !== "string";
}
function castLabels(dimnames) {
  return dimnames;
}
async function loadMultiscales(store, path = "") {
  const location = root(store);
  const groupLocation = path ? location.resolve(path) : location;
  const grp = await open(groupLocation, { kind: "group" });
  const unknownAttrs = await grp.attrs;
  const ngff_v0_5_or_later = "ome" in unknownAttrs;
  const rootAttrs = ngff_v0_5_or_later ? unknownAttrs.ome : unknownAttrs;
  let paths = ["0"];
  let labels = castLabels(["t", "c", "z", "y", "x"]);
  if ("multiscales" in rootAttrs) {
    const { datasets, axes } = rootAttrs.multiscales[0];
    paths = datasets.map((d2) => d2.path);
    if (axes) {
      if (isAxis(axes)) {
        labels = castLabels(axes.map((axis) => axis.name));
      } else {
        labels = castLabels(axes);
      }
    }
  }
  const data = await Promise.all(
    paths.map((p2) => open(groupLocation.resolve(p2), { kind: "array" }))
  );
  return {
    data,
    rootAttrs,
    labels
  };
}
function guessTileSize(arr) {
  const interleaved = isInterleaved(arr.shape);
  const [yChunk, xChunk] = arr.chunks.slice(interleaved ? -3 : -2);
  const size = Math.min(yChunk, xChunk);
  return prevPowerOf2(size);
}
function getIndexer(labels) {
  const labelSet = new Set(labels);
  if (labelSet.size !== labels.length) {
    throw new Error("Labels must be unique");
  }
  return (sel) => {
    if (Array.isArray(sel)) {
      return [...sel];
    }
    const selection = Array(labels.length).fill(0);
    for (const [key, value] of Object.entries(sel)) {
      const index = labels.indexOf(key);
      if (index === -1) {
        throw new Error(`Invalid indexer key: ${key}`);
      }
      selection[index] = value;
    }
    return selection;
  };
}
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var DTYPE_LOOKUP = {
  u1: "Uint8",
  u2: "Uint16",
  u4: "Uint32",
  f4: "Float32",
  f8: "Float64",
  i1: "Int8",
  i2: "Int16",
  i4: "Int32"
};
var BoundsCheckError = class extends Error {
};
var ZarrPixelSource = class {
  constructor(data, labels, tileSize) {
    this.labels = labels;
    this.tileSize = tileSize;
    __publicField2(this, "_data");
    __publicField2(this, "_indexer");
    this._indexer = getIndexer(labels);
    this._data = data;
  }
  get shape() {
    return this._data.shape;
  }
  get dtype() {
    const normalized = this._data.dtype.toLowerCase();
    if (normalized.length === 2 && normalized in DTYPE_LOOKUP) {
      return DTYPE_LOOKUP[normalized];
    }
    return normalized.charAt(0).toUpperCase() + normalized.slice(1);
  }
  get _xIndex() {
    const interleave = isInterleaved(this._data.shape);
    return this._data.shape.length - (interleave ? 2 : 1);
  }
  _chunkIndex(selection, { x: x2, y: y2 }) {
    const sel = this._indexer(selection);
    sel[this._xIndex] = x2;
    sel[this._xIndex - 1] = y2;
    return sel;
  }
  /**
   * Converts x, y tile indices to zarr dimension Slices within image bounds.
   */
  _getSlices(x2, y2) {
    const { height, width } = getImageSize(this);
    const [xStart, xStop] = [
      x2 * this.tileSize,
      Math.min((x2 + 1) * this.tileSize, width)
    ];
    const [yStart, yStop] = [
      y2 * this.tileSize,
      Math.min((y2 + 1) * this.tileSize, height)
    ];
    if (xStart === xStop || yStart === yStop) {
      throw new BoundsCheckError("Tile slice is zero-sized.");
    }
    if (xStart < 0 || yStart < 0 || xStop > width || yStop > height) {
      throw new BoundsCheckError("Tile slice is out of bounds.");
    }
    return [slice(xStart, xStop), slice(yStart, yStop)];
  }
  async _getRaw(selection, getOptions) {
    const signal = getOptions?.storeOptions?.signal;
    const result = await get2(this._data, selection, signal);
    if (typeof result !== "object") {
      throw new Error("Expected object from zarr.get");
    }
    return result;
  }
  async getRaster({
    selection,
    signal
  }) {
    const sel = this._chunkIndex(selection, { x: null, y: null });
    const result = await this._getRaw(sel, { storeOptions: { signal } });
    const {
      data,
      shape: [height, width]
    } = result;
    return { data, width, height };
  }
  async getTile(props) {
    const { x: x2, y: y2, selection, signal } = props;
    const [xSlice, ySlice] = this._getSlices(x2, y2);
    const sel = this._chunkIndex(selection, { x: xSlice, y: ySlice });
    const tile = await this._getRaw(sel, { storeOptions: { signal } });
    const {
      data,
      shape: [height, width]
    } = tile;
    return { data, height, width };
  }
  onTileError(err2) {
    if (!(err2 instanceof BoundsCheckError)) {
      throw err2;
    }
  }
};
async function load(store) {
  const { data, rootAttrs, labels } = await loadMultiscales(store);
  const tileSize = guessTileSize(data[0]);
  const pyramid = data.map((arr) => new ZarrPixelSource(arr, labels, tileSize));
  return {
    data: pyramid,
    metadata: rootAttrs
  };
}
async function loadOmeZarr(source3, options = {}) {
  const store = new fetch_default(source3, options.fetchOptions);
  if (options?.type !== "multiscales") {
    throw Error("Only multiscale OME-Zarr is supported.");
  }
  return load(store);
}

// node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
function assert2(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "loader assertion failed.");
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_ = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
var isBrowser = (
  // @ts-ignore process does not exist on browser
  Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
);
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;

// node_modules/@probe.gl/env/dist/lib/globals.js
var window_2 = globalThis;
var document_2 = globalThis.document || {};
var process_ = globalThis.process || {};
var console_ = globalThis.console;
var navigator_ = globalThis.navigator || {};

// node_modules/@probe.gl/env/dist/lib/is-electron.js
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && window.process?.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
  const userAgent2 = mockUserAgent || realUserAgent;
  return Boolean(userAgent2 && userAgent2.indexOf("Electron") >= 0);
}

// node_modules/@probe.gl/env/dist/lib/is-browser.js
function isBrowser2() {
  const isNode = (
    // @ts-expect-error
    typeof process === "object" && String(process) === "[object process]" && !process?.browser
  );
  return !isNode || isElectron();
}

// node_modules/@probe.gl/env/dist/lib/get-browser.js
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !isBrowser2()) {
    return "Node";
  }
  if (isElectron(mockUserAgent)) {
    return "Electron";
  }
  const userAgent2 = mockUserAgent || navigator_.userAgent || "";
  if (userAgent2.indexOf("Edge") > -1) {
    return "Edge";
  }
  if (globalThis.chrome) {
    return "Chrome";
  }
  if (globalThis.safari) {
    return "Safari";
  }
  if (globalThis.mozInnerScreenX) {
    return "Firefox";
  }
  return "Unknown";
}

// node_modules/@probe.gl/env/dist/index.js
var VERSION = true ? "4.1.0" : "untranspiled source";

// node_modules/@probe.gl/log/dist/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x2 = "__storage_test__";
    storage.setItem(x2, x2);
    storage.removeItem(x2);
    return storage;
  } catch (e2) {
    return null;
  }
}
var LocalStorage = class {
  constructor(id, defaultConfig, type = "sessionStorage") {
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
};

// node_modules/@probe.gl/log/dist/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = `${ms.toFixed(2)}ms`;
  } else if (ms < 100) {
    formatted = `${ms.toFixed(1)}ms`;
  } else if (ms < 1e3) {
    formatted = `${ms.toFixed(0)}ms`;
  } else {
    formatted = `${(ms / 1e3).toFixed(2)}s`;
  }
  return formatted;
}
function leftPad(string, length5 = 8) {
  const padLength = Math.max(length5 - string.length, 0);
  return `${" ".repeat(padLength)}${string}`;
}

// node_modules/@probe.gl/log/dist/utils/color.js
var COLOR;
(function(COLOR2) {
  COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
  COLOR2[COLOR2["RED"] = 31] = "RED";
  COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
  COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
  COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
  COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
  COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
  COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
  COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
var BACKGROUND_INCREMENT = 10;
function getColor(color) {
  if (typeof color !== "string") {
    return color;
  }
  color = color.toUpperCase();
  return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
  if (!isBrowser2 && typeof string === "string") {
    if (color) {
      const colorCode = getColor(color);
      string = `\x1B[${colorCode}m${string}\x1B[39m`;
    }
    if (background) {
      const colorCode = getColor(background);
      string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
    }
  }
  return string;
}

// node_modules/@probe.gl/log/dist/utils/autobind.js
function autobind(obj, predefined = ["constructor"]) {
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object = obj;
  for (const key of propNames) {
    const value = object[key];
    if (typeof value === "function") {
      if (!predefined.find((name2) => key === name2)) {
        object[key] = value.bind(obj);
      }
    }
  }
}

// node_modules/@probe.gl/log/dist/utils/assert.js
function assert3(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "Assertion failed");
  }
}

// node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (isBrowser2() && window_2.performance) {
    timestamp = window_2?.performance?.now?.();
  } else if ("hrtime" in process_) {
    const timeParts = process_?.hrtime?.();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/log/dist/log.js
var originalConsole = {
  debug: isBrowser2() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop() {
}
var cache = {};
var ONCE = { once: true };
var Log = class {
  constructor({ id } = { id: "" }) {
    this.VERSION = VERSION;
    this._startTs = getHiResTimestamp();
    this._deltaTs = getHiResTimestamp();
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
    this.timeStamp(`${this.id} started`);
    autobind(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(newPriority) {
    this.level = newPriority;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(enabled = true) {
    this._storage.setConfiguration({ enabled });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({ level });
    return this;
  }
  /** return the current status of the setting */
  get(setting) {
    return this._storage.config[setting];
  }
  // update the status of the setting
  set(setting, value) {
    this._storage.setConfiguration({ [setting]: value });
  }
  /** Logs the current settings as a table */
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  // Unconditional logging
  assert(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }
  warn(message2) {
    return this._getLogFunction(0, message2, originalConsole.warn, arguments, ONCE);
  }
  error(message2) {
    return this._getLogFunction(0, message2, originalConsole.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(oldUsage, newUsage) {
    return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
  }
  /** Print a removal warning */
  removed(oldUsage, newUsage) {
    return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
  }
  probe(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.debug, arguments);
  }
  info(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.info, arguments);
  }
  once(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  /** Logs an object as a table */
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  time(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message2) {
    return this._getLogFunction(logLevel, message2, console.timeStamp || noop);
  }
  group(logLevel, message2, opts = { collapsed: false }) {
    const options = normalizeArguments({ logLevel, message: message2, opts });
    const { collapsed } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message2, opts = {}) {
    return this.group(logLevel, message2, Object.assign({}, opts, { collapsed: true }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop);
  }
  // EXPERIMENTAL
  withGroup(logLevel, message2, func) {
    this.group(logLevel, message2)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message2, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({ logLevel, message: message2, args, opts });
      method = method || opts.method;
      assert3(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache[tag]) {
          cache[tag] = getHiResTimestamp();
        } else {
          return noop;
        }
      }
      message2 = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message2, ...opts.args);
    }
    return noop;
  }
};
Log.VERSION = VERSION;
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert3(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const { logLevel, message: message2 } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message2) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message2 !== void 0) {
        args.unshift(message2);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert3(messageType === "string" || messageType === "object");
  return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message2, opts) {
  if (typeof message2 === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message2 = opts.time ? `${id}: ${time}  ${message2}` : `${id}: ${message2}`;
    message2 = addColor(message2, opts.color, opts.background);
  }
  return message2;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}

// node_modules/@probe.gl/log/dist/init.js
globalThis.probe = {};

// node_modules/@probe.gl/log/dist/index.js
var dist_default = new Log({ id: "@probe.gl/log" });

// node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js
var VERSION2 = true ? "4.3.3" : "latest";
var version = VERSION2[0] >= "0" && VERSION2[0] <= "9" ? `v${VERSION2}` : "";
function createLog() {
  const log3 = new Log({ id: "loaders.gl" });
  globalThis.loaders = globalThis.loaders || {};
  globalThis.loaders.log = log3;
  globalThis.loaders.version = version;
  globalThis.probe = globalThis.probe || {};
  globalThis.probe.loaders = log3;
  return log3;
}
var log = createLog();

// node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
  if (level > 3) {
    return newOptions;
  }
  const options = { ...baseOptions };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
var NPM_TAG = "latest";
function getVersion() {
  if (!globalThis._loadersgl_?.version) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    if (false) {
      console.warn("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
      globalThis._loadersgl_.version = NPM_TAG;
    } else {
      globalThis._loadersgl_.version = "4.3.3";
    }
  }
  return globalThis._loadersgl_.version;
}
var VERSION3 = getVersion();

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
function assert4(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "loaders.gl assertion failed.");
  }
}

// node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_2 = globals2.self || globals2.window || globals2.global || {};
var window_3 = globals2.window || globals2.self || globals2.global || {};
var global_3 = globals2.global || globals2.self || globals2.window || {};
var document_3 = globals2.document || {};
var isBrowser3 = (
  // @ts-ignore process.browser
  typeof process !== "object" || String(process) !== "[object process]" || process.browser
);
var isMobile2 = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
var WorkerJob = class {
  constructor(jobName, workerThread) {
    __publicField(this, "name");
    __publicField(this, "workerThread");
    __publicField(this, "isRunning", true);
    /** Promise that resolves when Job is done */
    __publicField(this, "result");
    __publicField(this, "_resolve", () => {
    });
    __publicField(this, "_reject", () => {
    });
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve3, reject) => {
      this._resolve = resolve3;
      this._reject = reject;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type,
      payload
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(value) {
    assert4(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(error) {
    assert4(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
var NodeWorker = class {
  terminate() {
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
function getLoadableWorkerURL(props) {
  assert4(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert4(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
var NOOP = () => {
};
var WorkerThread = class {
  constructor(props) {
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "url");
    __publicField(this, "terminated", false);
    __publicField(this, "worker");
    __publicField(this, "onMessage");
    __publicField(this, "onError");
    __publicField(this, "_loadableURL", "");
    const { name: name2, source: source3, url } = props;
    assert4(source3 || url);
    this.name = name2;
    this.source = source3;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = (error) => console.log(error);
    this.worker = isBrowser3 ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser3 || typeof NodeWorker !== "undefined" && !isBrowser3;
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(data, transferList) {
    transferList = transferList || getTransferList(data);
    this.worker.postMessage(data, transferList);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(event) {
    let message2 = "Failed to load ";
    message2 += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message2 += `${event.message} in `;
    }
    if (event.lineno) {
      message2 += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message2);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
    const worker = new Worker(this._loadableURL, { name: this.name });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error) => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : `./${this.url}`;
      worker = new NodeWorker(url, { eval: false });
    } else if (this.source) {
      worker = new NodeWorker(this.source, { eval: true });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data) => {
      this.onMessage(data);
    });
    worker.on("error", (error) => {
      this.onError(error);
    });
    worker.on("exit", (code) => {
    });
    return worker;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
var WorkerPool = class {
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(props) {
    __publicField(this, "name", "unnamed");
    __publicField(this, "source");
    // | Function;
    __publicField(this, "url");
    __publicField(this, "maxConcurrency", 1);
    __publicField(this, "maxMobileConcurrency", 1);
    __publicField(this, "onDebug", () => {
    });
    __publicField(this, "reuseWorkers", true);
    __publicField(this, "props", {});
    __publicField(this, "jobQueue", []);
    __publicField(this, "idleQueue", []);
    __publicField(this, "count", 0);
    __publicField(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = { ...this.props, ...props };
    if (props.name !== void 0) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== void 0) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== void 0) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== void 0) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== void 0) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name2, onMessage2 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({ name: name2, onMessage: onMessage2, onError, onStart });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = (error) => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = (
      // Workers on Node.js prevent the process from exiting.
      // Until we figure out how to close them before exit, we always destroy them
      !isBrowser3 || // If the pool is destroyed, there is no reason to keep the worker around
      this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
      !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
      this.count > this._getMaxConcurrency()
    );
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name2 = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new WorkerThread({ name: name2, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile2 ? this.maxMobileConcurrency : this.maxConcurrency;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {
  }
};
var _WorkerFarm = class _WorkerFarm {
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(props) {
    __publicField(this, "props");
    __publicField(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = { ...DEFAULT_PROPS };
    this.setProps(props);
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(props = {}) {
    _WorkerFarm._workerFarm = _WorkerFarm._workerFarm || new _WorkerFarm({});
    _WorkerFarm._workerFarm.setProps(props);
    return _WorkerFarm._workerFarm;
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(props) {
    this.props = { ...this.props, ...props };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(options) {
    const { name: name2, source: source3, url } = options;
    let workerPool = this.workerPools.get(name2);
    if (!workerPool) {
      workerPool = new WorkerPool({
        name: name2,
        source: source3,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name2, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
// singleton
__publicField(_WorkerFarm, "_workerFarm");
var WorkerFarm = _WorkerFarm;

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = isBrowser3 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    if (isBrowser3) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version2 = worker.version;
    if (version2 === "latest") {
      version2 = NPM_TAG;
    }
    const versionTag = version2 ? `@${version2}` : "";
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  assert4(url);
  return url;
}

// node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker, coreVersion = VERSION3) {
  assert4(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser3 && !options?._nodeWorkers) {
    return false;
  }
  return loader.worker && options?.worker;
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name2 = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({ name: name2, url });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob(
    "process-on-worker",
    // @ts-expect-error
    onMessage.bind(null, parseOnMainThread)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  job.postMessage("process", {
    // @ts-ignore
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const { id, input, options } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", { id, result });
      } catch (error) {
        const message2 = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", { id, error: message2 });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i3 = 0; i3 < array1.length; ++i3) {
    if (array1[i3] !== array2[i3]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers(...sources) {
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map((source22) => source22 instanceof ArrayBuffer ? new Uint8Array(source22) : source22);
  const byteLength = sourceArrays.reduce((length5, typedArray) => length5 + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}

// node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
function getHiResTimestamp2() {
  let timestamp;
  if (typeof window !== "undefined" && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== "undefined" && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/stats/dist/lib/stat.js
var Stat = class {
  constructor(name2, type) {
    this.sampleSize = 1;
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    this.name = name2;
    this.type = type;
    this.reset();
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    this.addCount(1);
    return this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  /** Increase count */
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Decrease count */
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  /** Start a timer */
  timeStart() {
    this._startTime = getHiResTimestamp2();
    this._timerPending = true;
    return this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime(getHiResTimestamp2() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
};

// node_modules/@probe.gl/stats/dist/lib/stats.js
var Stats = class {
  constructor(options) {
    this.stats = {};
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(name2, type = "count") {
    return this._getOrCreate({ name: name2, type });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const stat of Object.values(this.stats)) {
      stat.reset();
    }
    return this;
  }
  forEach(fn) {
    for (const stat of Object.values(this.stats)) {
      fn(stat);
    }
  }
  getTable() {
    const table = {};
    this.forEach((stat) => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats(stats = []) {
    stats.forEach((stat) => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    const { name: name2, type } = stat;
    let result = this.stats[name2];
    if (!result) {
      if (stat instanceof Stat) {
        result = stat;
      } else {
        result = new Stat(name2, type);
      }
      this.stats[name2] = result;
    }
    return result;
  }
};

// node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js
var STAT_QUEUED_REQUESTS = "Queued Requests";
var STAT_ACTIVE_REQUESTS = "Active Requests";
var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
var DEFAULT_PROPS2 = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: true,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
var RequestScheduler = class {
  constructor(props = {}) {
    __publicField(this, "props");
    __publicField(this, "stats");
    __publicField(this, "activeRequestCount", 0);
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */
    __publicField(this, "requestQueue", []);
    __publicField(this, "requestMap", /* @__PURE__ */ new Map());
    __publicField(this, "updateTimer", null);
    this.props = { ...DEFAULT_PROPS2, ...props };
    this.stats = new Stats({ id: this.props.id });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(handle, getPriority = () => 0) {
    if (!this.props.throttleRequests) {
      return Promise.resolve({ done: () => {
      } });
    }
    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }
    const request = { handle, priority: 0, getPriority };
    const promise = new Promise((resolve3) => {
      request.resolve = resolve3;
      return request;
    });
    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);
    this._issueNewRequests();
    return promise;
  }
  // PRIVATE
  _issueRequest(request) {
    const { handle, resolve: resolve3 } = request;
    let isDone = false;
    const done = () => {
      if (!isDone) {
        isDone = true;
        this.requestMap.delete(handle);
        this.activeRequestCount--;
        this._issueNewRequests();
      }
    };
    this.activeRequestCount++;
    return resolve3 ? resolve3({ done }) : Promise.resolve({ done });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    if (this.updateTimer !== null) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    if (this.updateTimer !== null) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = null;
    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (freeSlots === 0) {
      return;
    }
    this._updateAllRequests();
    for (let i3 = 0; i3 < freeSlots; ++i3) {
      const request = this.requestQueue.shift();
      if (request) {
        this._issueRequest(request);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i3 = 0; i3 < requestQueue.length; ++i3) {
      const request = requestQueue[i3];
      if (!this._updateRequest(request)) {
        requestQueue.splice(i3, 1);
        this.requestMap.delete(request.handle);
        i3--;
      }
    }
    requestQueue.sort((a2, b2) => a2.priority - b2.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(request) {
    request.priority = request.getPriority(request.handle);
    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }
    return true;
  }
};

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
var pathPrefix = "";
var fileAliases = {};
function resolvePath(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = `${pathPrefix}${filename2}`;
  }
  return filename2;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
function toArrayBuffer(buffer) {
  return buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer2(data) {
  if (isBuffer(data)) {
    return toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
var path_exports = {};
__export(path_exports, {
  dirname: () => dirname,
  filename: () => filename,
  join: () => join,
  resolve: () => resolve2
});

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js
function getCWD() {
  if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
    return process.cwd();
  }
  const pathname = window.location?.pathname;
  return pathname?.slice(0, pathname.lastIndexOf("/") + 1) || "";
}

// node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
function filename(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join(...parts) {
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp(`^${separator}`), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp(`${separator}$`), "");
    }
    return part;
  });
  return parts.join(separator);
}
function resolve2(...components) {
  const paths = [];
  for (let _i = 0; _i < components.length; _i++) {
    paths[_i] = components[_i];
  }
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd;
  for (let i3 = paths.length - 1; i3 >= -1 && !resolvedAbsolute; i3--) {
    let path;
    if (i3 >= 0) {
      path = paths[i3];
    } else {
      if (cwd === void 0) {
        cwd = getCWD();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return `/${resolvedPath}`;
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return ".";
}
var SLASH = 47;
var DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i3 = 0; i3 <= path.length; ++i3) {
    if (i3 < path.length) {
      code = path.charCodeAt(i3);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i3 - 1 || dots === 1) {
      } else if (lastSlash !== i3 - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j2 = start;
            for (; j2 >= 0; --j2) {
              if (res.charCodeAt(j2) === SLASH) {
                break;
              }
            }
            if (j2 !== start) {
              res = j2 === -1 ? "" : res.slice(0, j2);
              lastSlash = i3;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSlash = i3;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          isAboveRoot = true;
        }
      } else {
        const slice2 = path.slice(lastSlash + 1, i3);
        if (res.length > 0) {
          res += `/${slice2}`;
        } else {
          res = slice2;
        }
        isAboveRoot = false;
      }
      lastSlash = i3;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
var isBoolean = (x2) => typeof x2 === "boolean";
var isFunction = (x2) => typeof x2 === "function";
var isObject = (x2) => x2 !== null && typeof x2 === "object";
var isPureObject = (x2) => isObject(x2) && x2.constructor === {}.constructor;
var isIterable = (x2) => Boolean(x2) && typeof x2[Symbol.iterator] === "function";
var isAsyncIterable = (x2) => x2 && typeof x2[Symbol.asyncIterator] === "function";
var isResponse = (x2) => typeof Response !== "undefined" && x2 instanceof Response || x2 && x2.arrayBuffer && x2.text && x2.json;
var isBlob = (x2) => typeof Blob !== "undefined" && x2 instanceof Blob;
var isBuffer2 = (x2) => x2 && typeof x2 === "object" && x2.isBuffer;
var isReadableDOMStream = (x2) => typeof ReadableStream !== "undefined" && x2 instanceof ReadableStream || isObject(x2) && isFunction(x2.tee) && isFunction(x2.cancel) && isFunction(x2.getReader);
var isReadableNodeStream = (x2) => isObject(x2) && isFunction(x2.read) && isFunction(x2.pipe) && isBoolean(x2.readable);
var isReadableStream = (x2) => isReadableDOMStream(x2) || isReadableNodeStream(x2);

// node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js
var FetchError = class extends Error {
  constructor(message2, info) {
    super(message2);
    /** A best effort reason for why the fetch failed */
    __publicField(this, "reason");
    /** The URL that failed to load. Empty string if not available. */
    __publicField(this, "url");
    /** The Response object, if any. */
    __publicField(this, "response");
    this.reason = info.reason;
    this.url = info.url;
    this.response = info.response;
  }
};

// node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function compareMIMETypes(mimeType1, mimeType2) {
  if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
    return true;
  }
  return false;
}
function parseMIMEType(mimeString) {
  const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches3) {
    return matches3[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches3 = DATA_URL_PATTERN.exec(url);
  if (matches3) {
    return matches3[1];
  }
  return "";
}

// node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches3 = url.match(QUERY_STRING_PATTERN);
  return matches3 && matches3[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}
function shortenUrlForDisplay(url) {
  if (url.length < 50) {
    return url;
  }
  const urlEnd = url.slice(url.length - 15);
  const urlStart = url.substr(0, 32);
  return `${urlStart}...${urlEnd}`;
}

// node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
function getResourceUrl(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.url;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.name || "";
  }
  if (typeof resource === "string") {
    return resource;
  }
  return "";
}
function getResourceMIMEType(resource) {
  if (isResponse(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get("content-type") || "";
    const noQueryUrl = stripQueryString(response.url);
    return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.type || "";
  }
  if (typeof resource === "string") {
    return parseMIMETypeFromURL(resource);
  }
  return "";
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}

// node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const url = getResourceUrl(resource);
  const type = getResourceMIMEType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, { headers });
  Object.defineProperty(response, "url", { value: url });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const error = await getResponseError(response);
    throw error;
  }
}
async function getResponseError(response) {
  const shortUrl = shortenUrlForDisplay(response.url);
  let message2 = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
  message2 = message2.length > 100 ? `${message2.slice(0, 100)}...` : message2;
  const info = {
    reason: response.statusText,
    url: response.url,
    response
  };
  try {
    const contentType = response.headers.get("Content-Type");
    info.reason = !response.bodyUsed && contentType?.includes("application/json") ? await response.json() : await response.text();
  } catch (error) {
  }
  return new FetchError(message2, info);
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve3) => {
      const reader = new FileReader();
      reader.onload = (event) => resolve3(event?.target?.result);
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice2 = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice2);
    return `data:base64,${base64}`;
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i3 = 0; i3 < bytes.byteLength; i3++) {
    binary += String.fromCharCode(bytes[i3]);
  }
  return btoa(binary);
}

// node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
function isNodePath(url) {
  return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
  return url.startsWith("http:") || url.startsWith("https:");
}
function isDataURL(url) {
  return url.startsWith("data:");
}
async function fetchFile(urlOrData, fetchOptions) {
  if (typeof urlOrData === "string") {
    const url = resolvePath(urlOrData);
    if (isNodePath(url)) {
      if (globalThis.loaders?.fetchNode) {
        return globalThis.loaders?.fetchNode(url, fetchOptions);
      }
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(urlOrData);
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
var probeLog = new Log({ id: "loaders.gl" });
var NullLog = class {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
};
var ConsoleLog = class {
  constructor() {
    __publicField(this, "console");
    this.console = console;
  }
  log(...args) {
    return this.console.log.bind(this.console, ...args);
  }
  info(...args) {
    return this.console.info.bind(this.console, ...args);
  }
  warn(...args) {
    return this.console.warn.bind(this.console, ...args);
  }
  error(...args) {
    return this.console.error.bind(this.console, ...args);
  }
};

// node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
var DEFAULT_LOADER_OPTIONS = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: false,
  log: new ConsoleLog(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: false,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: true,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: isBrowser,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: false,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: false,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
};
var REMOVED_LOADER_OPTIONS = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};

// node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders } = globalThis;
  if (!loaders._state) {
    loaders._state = {};
  }
  return loaders._state;
}
function getGlobalLoaderOptions() {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
  return state.globalOptions;
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions2, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix = id ? `${id}.` : "";
  for (const key in options) {
    const isSubOptions = !id && isObject(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions2) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' no longer supported, use '${deprecatedOptions[key]}'`)();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' not recognized. ${suggestion}`)();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return `Did you mean '${loader.id}.${key}'?`;
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || `Did you mean '${loader.id}.${key}'?`;
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = { ...loaderDefaultOptions };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray(loader?.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  assert2(loader, "null loader");
  assert2(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: { ...loader.options, ...options }
    };
  }
  if (loader?.parseTextSync || loader?.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}

// node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
var getGlobalLoaderRegistry = () => {
  const state = getGlobalLoaderState();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = normalizeLoader(loader);
    if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

// node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!options?.ignoreRegisteredLoaders) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  const testUrl = stripQueryString(url) || context?.url;
  let loader = null;
  let reason = "";
  if (options?.mimeType) {
    loader = findLoaderByMIMEType(loaders, options?.mimeType);
    reason = `match forced by supplied MIME type ${options?.mimeType}`;
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? `matched url ${testUrl}` : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? `matched MIME type ${type}` : "");
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : "");
  if (options?.fallbackMimeType) {
    loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
    reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
  }
  if (reason) {
    log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  let message2 = "No valid loader found (";
  message2 += url ? `${path_exports.filename(url)}, ` : "no url provided, ";
  message2 += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
  const firstCharacters = data ? getFirstCharacters(data) : "";
  message2 += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
  message2 += ")";
  return message2;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {
      return loader;
    }
    if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === "string") {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data);
    case "string":
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters(data, length5 = 5) {
  if (typeof data === "string") {
    return data.slice(0, length5);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length5);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length5);
  }
  return "";
}
function getMagicString(arrayBuffer2, byteOffset, length5) {
  if (arrayBuffer2.byteLength < byteOffset + length5) {
    return "";
  }
  const dataView = new DataView(arrayBuffer2);
  let magic = "";
  for (let i3 = 0; i3 < length5; i3++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i3));
  }
  return magic;
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer2, options = {}) {
  const { chunkSize = DEFAULT_CHUNK_SIZE2 } = options;
  let byteOffset = 0;
  while (byteOffset < arrayBuffer2.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE3;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
function makeStreamIterator(stream, options) {
  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options?._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const { done, value } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer2(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield toArrayBuffer2(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
function makeIterator(data, options) {
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data, options);
  }
  if (isResponse(data)) {
    const response = data;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (isBuffer2(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer2 = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer2);
    }
    return arrayBuffer2;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data);
    }
    let arrayBuffer2 = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
      arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer2;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if (isBlob(data)) {
    data = await makeResponse(data);
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data)) {
    data = makeIterator(data, options);
  }
  if (isIterable(data) || isAsyncIterable(data)) {
    return concatenateArrayBuffersAsync(data);
  }
  throw new Error(ERR_DATA);
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const loaderOptions = options || globalOptions;
  if (typeof loaderOptions.fetch === "function") {
    return loaderOptions.fetch;
  }
  if (isObject(loaderOptions.fetch)) {
    return (url) => fetchFile(url, loaderOptions.fetch);
  }
  if (context?.fetch) {
    return context?.fetch;
  }
  return fetchFile;
}

// node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = stripQueryString(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = extractQueryString(newContext.url);
    newContext.filename = path_exports.filename(baseUrl);
    newContext.baseUrl = path_exports.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
}

// node_modules/@loaders.gl/core/dist/lib/api/parse.js
async function parse(data, loaders, options, context) {
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data = await data;
  options = options || {};
  const url = getResourceUrl(data);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext(
    // @ts-expect-error
    { url, _parse: parse, loaders: candidateLoaders },
    options,
    context || null
  );
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  validateWorkerVersion(loader);
  options = mergeLoaderOptions(loader.options, options);
  if (isResponse(data)) {
    const response = data;
    const { ok, redirected, status, statusText, type, url } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = { headers, ok, redirected, status, statusText, type, url };
  }
  data = await getArrayBufferOrStringFromData(data, loader, options);
  const loaderWithParser = loader;
  if (loaderWithParser.parseTextSync && typeof data === "string") {
    return loaderWithParser.parseTextSync(data, options, context);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data, options, context, parse);
  }
  if (loaderWithParser.parseText && typeof data === "string") {
    return await loaderWithParser.parseText(data, options, context);
  }
  if (loaderWithParser.parse) {
    return await loaderWithParser.parse(data, options, context);
  }
  assert4(!loaderWithParser.parseSync);
  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}

// node_modules/@loaders.gl/core/dist/lib/api/load.js
async function load2(url, loaders, options, context) {
  let resolvedLoaders;
  let resolvedOptions;
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    resolvedLoaders = [];
    resolvedOptions = loaders;
    context = void 0;
  } else {
    resolvedLoaders = loaders;
    resolvedOptions = options;
  }
  const fetch2 = getFetchFunction(resolvedOptions);
  let data = url;
  if (typeof url === "string") {
    data = await fetch2(url);
  }
  if (isBlob(url)) {
    data = await fetch2(url);
  }
  return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
}

// node_modules/@loaders.gl/images/dist/lib/utils/version.js
var VERSION4 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js
var parseImageNode = globalThis.loaders?.parseImageNode;
var IMAGE_SUPPORTED = typeof Image !== "undefined";
var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
var NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}

// node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas2 = document.createElement("canvas");
      const context = canvas2.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas2.width = image.width;
      canvas2.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}

// node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js
var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer2, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer2);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
    return src;
  }
  return getBlob(arrayBuffer2, url);
}
function getBlob(arrayBuffer2, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer2)]);
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js
async function parseToImage(arrayBuffer2, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
  const URL2 = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL2.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve3, reject) => {
    try {
      image.onload = () => resolve3(image);
      image.onerror = (error) => {
        const message2 = error instanceof Error ? error.message : "error";
        reject(new Error(message2));
      };
    } catch (error) {
      reject(error);
    }
  });
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js
var EMPTY_OBJECT = {};
var imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer2, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer2, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer2, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, "ftyp", 4)) {
    return null;
  }
  if ((buffer[8] & 96) === 0) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
  switch (brandMajor) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function getUTF8String(array, start, end) {
  return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function checkString(buffer, header, offset = 0) {
  const headerBytes = stringToBytes(header);
  for (let i3 = 0; i3 < headerBytes.length; ++i3) {
    if (headerBytes[i3] !== buffer[i3 + offset]) {
      return false;
    }
  }
  return true;
}

// node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = getISOBMFFMediaType(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const { tableMarkers, sofMarkers } = getJpegMarkers();
  let i3 = 2;
  while (i3 + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i3, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i3 + 5, BIG_ENDIAN),
        // Number of lines
        width: dataView.getUint16(i3 + 7, BIG_ENDIAN)
        // Number of pixels per line
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i3 += 2;
    i3 += dataView.getUint16(i3, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i3 = 65504; i3 < 65520; ++i3) {
    tableMarkers.add(i3);
  }
  const sofMarkers = /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]);
  return { tableMarkers, sofMarkers };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js
async function parseToNodeImage(arrayBuffer2, options) {
  const { mimeType } = getBinaryImageMetadata(arrayBuffer2) || {};
  const parseImageNode2 = globalThis.loaders?.parseImageNode;
  assert2(parseImageNode2);
  return await parseImageNode2(arrayBuffer2, mimeType);
}

// node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js
async function parseImage(arrayBuffer2, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const { url } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer2, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer2, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer2, options);
      break;
    default:
      assert2(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}

// node_modules/@loaders.gl/images/dist/image-loader.js
var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
var MIME_TYPES = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
];
var DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: "auto",
    decode: true
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
};
var ImageLoader = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: VERSION4,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: parseImage,
  // TODO: byteOffset, byteLength;
  tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};

// node_modules/@deck.gl/core/dist/utils/log.js
var defaultLogger = new Log({ id: "deck" });
var log_default = defaultLogger;

// node_modules/@deck.gl/core/dist/debug/loggers.js
var logState = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
};
var LOG_LEVEL_MAJOR_UPDATE = 1;
var LOG_LEVEL_MINOR_UPDATE = 2;
var LOG_LEVEL_UPDATE_DETAIL = 3;
var LOG_LEVEL_INFO = 4;
var LOG_LEVEL_DRAW = 2;
var getLoggers = (log3) => ({
  /* Layer events */
  "layer.changeFlag": (layer, key, flags) => {
    log3.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();
  },
  "layer.initialize": (layer) => {
    log3.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();
  },
  "layer.update": (layer, needsUpdate) => {
    if (needsUpdate) {
      const flags = layer.getChangeFlags();
      log3.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layer} because: ${Object.keys(flags).filter((key) => flags[key]).join(", ")}`)();
    } else {
      log3.log(LOG_LEVEL_INFO, `${layer} does not need update`)();
    }
  },
  "layer.matched": (layer, changed) => {
    if (changed) {
      log3.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();
    }
  },
  "layer.finalize": (layer) => {
    log3.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();
  },
  /* CompositeLayer events */
  "compositeLayer.renderLayers": (layer, updated, subLayers) => {
    if (updated) {
      log3.log(LOG_LEVEL_MINOR_UPDATE, `Composite layer rendered new subLayers ${layer}`, subLayers)();
    } else {
      log3.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();
    }
  },
  /* LayerManager events */
  "layerManager.setLayers": (layerManager, updated, layers) => {
    if (updated) {
      log3.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();
    }
  },
  "layerManager.activateViewport": (layerManager, viewport) => {
    log3.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
  },
  /* AttributeManager events */
  "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
    log3.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}` : `invalidated all attributes for ${attributeManager.id}`)();
  },
  "attributeManager.updateStart": (attributeManager) => {
    logState.attributeUpdateMessages.length = 0;
    logState.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (attributeManager, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
    log3.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`)();
    for (const updateMessage of logState.attributeUpdateMessages) {
      log3.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
    }
    log3.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
  },
  /* Attribute events */
  "attribute.updateStart": (attribute) => {
    logState.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (attribute, numInstances) => {
    const message2 = `${attribute.id} allocated ${numInstances}`;
    logState.attributeUpdateMessages.push(message2);
  },
  "attribute.updateEnd": (attribute, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
    const message2 = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;
    logState.attributeUpdateMessages.push(message2);
  },
  /* Render events */
  "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
    const { pass, redrawReason, stats } = opts;
    for (const status of renderStats) {
      const { totalCount, visibleCount, compositeCount, pickableCount } = status;
      const primitiveCount = totalCount - compositeCount;
      const hiddenCount = primitiveCount - visibleCount;
      log3.log(LOG_LEVEL_DRAW, `RENDER #${deckRenderer.renderCount}   ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason}   (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`)();
      if (stats) {
        stats.get("Redraw Layers").add(visibleCount);
      }
    }
  }
});

// node_modules/@deck.gl/core/dist/debug/index.js
var loggers = {};
if (true) {
  loggers = getLoggers(log_default);
}
function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (log_default.level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}

// node_modules/@deck.gl/core/dist/utils/json-loader.js
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var json_loader_default = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: isJSON,
  parseTextSync: JSON.parse
};

// node_modules/@deck.gl/core/dist/lib/init.js
function checkVersion() {
  const version2 = true ? "9.1.15" : globalThis.DECK_VERSION || "untranspiled source";
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;
  if (existingVersion && existingVersion !== version2) {
    throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version2}`);
  }
  if (!existingVersion) {
    log_default.log(1, `deck.gl ${version2}`)();
    globalThis.deck = {
      ...globalThis.deck,
      VERSION: version2,
      version: version2,
      log: log_default,
      // experimental
      _registerLoggers: register
    };
    registerLoaders([
      json_loader_default,
      // @ts-expect-error non-standard Loader format
      [ImageLoader, { imagebitmap: { premultiplyAlpha: "none" } }]
    ]);
  }
  return version2;
}
var VERSION5 = checkVersion();

// node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js
function assert5(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "shadertools: assertion failed.");
  }
}

// node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js
var DEFAULT_PROP_VALIDATORS = {
  number: {
    type: "number",
    validate(value, propType) {
      return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
    }
  },
  array: {
    type: "array",
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};
function makePropValidators(propTypes) {
  const propValidators = {};
  for (const [name2, propType] of Object.entries(propTypes)) {
    propValidators[name2] = makePropValidator(propType);
  }
  return propValidators;
}
function makePropValidator(propType) {
  let type = getTypeOf(propType);
  if (type !== "object") {
    return { value: propType, ...DEFAULT_PROP_VALIDATORS[type], type };
  }
  if (typeof propType === "object") {
    if (!propType) {
      return { type: "object", value: null };
    }
    if (propType.type !== void 0) {
      return { ...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type };
    }
    if (propType.value === void 0) {
      return { type: "object", value: propType };
    }
    type = getTypeOf(propType.value);
    return { ...propType, ...DEFAULT_PROP_VALIDATORS[type], type };
  }
  throw new Error("props");
}
function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return "array";
  }
  return typeof value;
}

// node_modules/@luma.gl/shadertools/dist/module-injectors.js
var MODULE_INJECTORS_VS = (
  /* glsl */
  `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
);
var MODULE_INJECTORS_FS = (
  /* glsl */
  `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
);

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js
var MODULE_INJECTORS = {
  vertex: MODULE_INJECTORS_VS,
  fragment: MODULE_INJECTORS_FS
};
var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
var fragments = [];
var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
function normalizeInjections(injections) {
  const result = { vertex: {}, fragment: {} };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = getHookStage(hook);
    if (typeof injection === "string") {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
function getHookStage(hook) {
  const type = hook.slice(0, 2);
  switch (type) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(type);
  }
}
function injectShader(source3, stage, inject, injectStandardStubs = false) {
  const isVertex = stage === "vertex";
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a2, b2) => a2.order - b2.order);
    fragments.length = fragmentData.length;
    for (let i3 = 0, len4 = fragmentData.length; i3 < len4; ++i3) {
      fragments[i3] = fragmentData[i3].injection;
    }
    const fragmentString = `${fragments.join("\n")}
`;
    switch (key) {
      case "vs:#decl":
        if (isVertex) {
          source3 = source3.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "vs:#main-start":
        if (isVertex) {
          source3 = source3.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "vs:#main-end":
        if (isVertex) {
          source3 = source3.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      case "fs:#decl":
        if (!isVertex) {
          source3 = source3.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "fs:#main-start":
        if (!isVertex) {
          source3 = source3.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "fs:#main-end":
        if (!isVertex) {
          source3 = source3.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      default:
        source3 = source3.replace(key, (match) => match + fragmentString);
    }
  }
  source3 = source3.replace(DECLARATION_INJECT_MARKER, "");
  if (injectStandardStubs) {
    source3 = source3.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
  }
  return source3;
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js
function initializeShaderModules(modules) {
  modules.map((module) => initializeShaderModule(module));
}
function initializeShaderModule(module) {
  if (module.instance) {
    return;
  }
  initializeShaderModules(module.dependencies || []);
  const {
    propTypes = {},
    deprecations = [],
    // defines = {},
    inject = {}
  } = module;
  const instance2 = {
    normalizedInjections: normalizeInjections(inject),
    parsedDeprecations: parseDeprecationDefinitions(deprecations)
  };
  if (propTypes) {
    instance2.propValidators = makePropValidators(propTypes);
  }
  module.instance = instance2;
  let defaultProps17 = {};
  if (propTypes) {
    defaultProps17 = Object.entries(propTypes).reduce((obj, [key, propType]) => {
      const value = propType?.value;
      if (value) {
        obj[key] = value;
      }
      return obj;
    }, {});
  }
  module.defaultUniforms = { ...module.defaultUniforms, ...defaultProps17 };
}
function checkShaderModuleDeprecations(shaderModule, shaderSource, log3) {
  shaderModule.deprecations?.forEach((def) => {
    if (def.regex?.test(shaderSource)) {
      if (def.deprecated) {
        log3.deprecated(def.old, def.new)();
      } else {
        log3.removed(def.old, def.new)();
      }
    }
  });
}
function parseDeprecationDefinitions(deprecations) {
  deprecations.forEach((def) => {
    switch (def.type) {
      case "function":
        def.regex = new RegExp(`\\b${def.old}\\(`);
        break;
      default:
        def.regex = new RegExp(`${def.type} ${def.old};`);
    }
  });
  return deprecations;
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js
function getShaderModuleDependencies(modules) {
  initializeShaderModules(modules);
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({ modules, level: 0, moduleMap, moduleDepth });
  const dependencies = Object.keys(moduleDepth).sort((a2, b2) => moduleDepth[b2] - moduleDepth[a2]).map((name2) => moduleMap[name2]);
  initializeShaderModules(dependencies);
  return dependencies;
}
function getDependencyGraph(options) {
  const { modules, level, moduleMap, moduleDepth } = options;
  if (level >= 5) {
    throw new Error("Possible loop in shader dependency graph");
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({ modules: module.dependencies, level: level + 1, moduleMap, moduleDepth });
    }
  }
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js
function getPlatformShaderDefines(platformInfo) {
  switch (platformInfo?.gpu.toLowerCase()) {
    case "apple":
      return (
        /* glsl */
        `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "nvidia":
      return (
        /* glsl */
        `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
      );
    case "intel":
      return (
        /* glsl */
        `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "amd":
      return (
        /* glsl */
        `#define AMD_GPU
`
      );
    default:
      return (
        /* glsl */
        `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
  }
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js
function transpileGLSLShader(source3, stage) {
  const sourceGLSLVersion = Number(source3.match(/^#version[ \t]+(\d+)/m)?.[1] || 100);
  if (sourceGLSLVersion !== 300) {
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  }
  switch (stage) {
    case "vertex":
      source3 = convertShader(source3, ES300_VERTEX_REPLACEMENTS);
      return source3;
    case "fragment":
      source3 = convertShader(source3, ES300_FRAGMENT_REPLACEMENTS);
      return source3;
    default:
      throw new Error(stage);
  }
}
var ES300_REPLACEMENTS = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
];
var ES300_VERTEX_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `attribute` keyword replaced with `in`
  [makeVariableTextRegExp("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [makeVariableTextRegExp("varying"), "out $1"]
];
var ES300_FRAGMENT_REPLACEMENTS = [
  ...ES300_REPLACEMENTS,
  // `varying` keyword replaced with `in`
  [makeVariableTextRegExp("varying"), "in $1"]
];
function convertShader(source3, replacements) {
  for (const [pattern, replacement] of replacements) {
    source3 = source3.replace(pattern, replacement);
  }
  return source3;
}
function makeVariableTextRegExp(qualifier) {
  return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js
function getShaderHooks(hookFunctions, hookInjections) {
  let result = "";
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += `void ${hookFunction.signature} {
`;
    if (hookFunction.header) {
      result += `  ${hookFunction.header}`;
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a2, b2) => a2.order - b2.order);
      for (const injection of injections) {
        result += `  ${injection.injection}
`;
      }
    }
    if (hookFunction.footer) {
      result += `  ${hookFunction.footer}`;
    }
    result += "}\n";
  }
  return result;
}
function normalizeShaderHooks(hookFunctions) {
  const result = { vertex: {}, fragment: {} };
  for (const hookFunction of hookFunctions) {
    let opts;
    let hook;
    if (typeof hookFunction !== "string") {
      opts = hookFunction;
      hook = opts.hook;
    } else {
      opts = {};
      hook = hookFunction;
    }
    hook = hook.trim();
    const [shaderStage, signature] = hook.split(":");
    const name2 = hook.replace(/\(.+/, "");
    const normalizedHook = Object.assign(opts, { signature });
    switch (shaderStage) {
      case "vs":
        result.vertex[name2] = normalizedHook;
        break;
      case "fs":
        result.fragment[name2] = normalizedHook;
        break;
      default:
        throw new Error(shaderStage);
    }
  }
  return result;
}

// node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js
function getShaderInfo(source3, defaultName) {
  return {
    name: getShaderName(source3, defaultName),
    language: "glsl",
    version: getShaderVersion(source3)
  };
}
function getShaderName(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
  const match = SHADER_NAME_REGEXP.exec(shader);
  return match ? match[1] : defaultName;
}
function getShaderVersion(source3) {
  let version2 = 100;
  const words = source3.match(/[^\s]+/g);
  if (words && words.length >= 2 && words[0] === "#version") {
    const parsedVersion = parseInt(words[1], 10);
    if (Number.isFinite(parsedVersion)) {
      version2 = parsedVersion;
    }
  }
  if (version2 !== 100 && version2 !== 300) {
    throw new Error(`Invalid GLSL version ${version2}`);
  }
  return version2;
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js
var INJECT_SHADER_DECLARATIONS = `

${DECLARATION_INJECT_MARKER}
`;
var FRAGMENT_SHADER_PROLOGUE = (
  /* glsl */
  `precision highp float;
`
);
function assembleWGSLShader(options) {
  const modules = getShaderModuleDependencies(options.modules || []);
  return {
    source: assembleShaderWGSL(options.platformInfo, {
      ...options,
      source: options.source,
      stage: "vertex",
      modules
    }),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleGLSLShaderPair(options) {
  const { vs: vs8, fs: fs7 } = options;
  const modules = getShaderModuleDependencies(options.modules || []);
  return {
    vs: assembleShaderGLSL(options.platformInfo, {
      ...options,
      source: vs8,
      stage: "vertex",
      modules
    }),
    fs: assembleShaderGLSL(options.platformInfo, {
      ...options,
      // @ts-expect-error
      source: fs7,
      stage: "fragment",
      modules
    }),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShaderWGSL(platformInfo, options) {
  const {
    // id,
    source: source3,
    stage,
    modules,
    // defines = {},
    hookFunctions = [],
    inject = {},
    log: log3
  } = options;
  assert5(typeof source3 === "string", "shader source must be a string");
  const coreSource = source3;
  let assembledSource = "";
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? { injection: inject[key], order: 0 } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name2 = match[3];
      if (hash) {
        if (name2 === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  const modulesToInject = modules;
  for (const module of modulesToInject) {
    if (log3) {
      checkShaderModuleDeprecations(module, coreSource, log3);
    }
    const moduleSource = getShaderModuleSource(module, "wgsl");
    assembledSource += moduleSource;
    const injections = module.injections?.[stage] || {};
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name2 = match[2];
        const injectionType = name2 === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  return assembledSource;
}
function assembleShaderGLSL(platformInfo, options) {
  const { id, source: source3, stage, language = "glsl", modules, defines: defines2 = {}, hookFunctions = [], inject = {}, prologue = true, log: log3 } = options;
  assert5(typeof source3 === "string", "shader source must be a string");
  const sourceVersion = language === "glsl" ? getShaderInfo(source3).version : -1;
  const targetVersion = platformInfo.shaderLanguageVersion;
  const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
  const sourceLines = source3.split("\n");
  const coreSource = sourceLines.slice(1).join("\n");
  const allDefines = {};
  modules.forEach((module) => {
    Object.assign(allDefines, module.defines);
  });
  Object.assign(allDefines, defines2);
  let assembledSource = "";
  switch (language) {
    case "wgsl":
      break;
    case "glsl":
      assembledSource = prologue ? `${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({ id, source: source3, stage })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}

${getPlatformShaderDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
      break;
  }
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? { injection: inject[key], order: 0 } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name2 = match[3];
      if (hash) {
        if (name2 === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log3) {
      checkShaderModuleDeprecations(module, coreSource, log3);
    }
    const moduleSource = getShaderModuleSource(module, stage);
    assembledSource += moduleSource;
    const injections = module.instance?.normalizedInjections[stage] || {};
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name2 = match[2];
        const injectionType = name2 === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  if (language === "glsl" && sourceVersion !== targetVersion) {
    assembledSource = transpileGLSLShader(assembledSource, stage);
  }
  return assembledSource.trim();
}
function assembleGetUniforms(modules) {
  return function getUniforms4(opts) {
    const uniforms = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms?.(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}
function getShaderNameDefine(options) {
  const { id, source: source3, stage } = options;
  const injectShaderName = id && source3.indexOf("SHADER_NAME") === -1;
  return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}` : "";
}
function getApplicationDefines(defines2 = {}) {
  let sourceText = "";
  for (const define2 in defines2) {
    const value = defines2[define2];
    if (value || Number.isFinite(value)) {
      sourceText += `#define ${define2.toUpperCase()} ${defines2[define2]}
`;
    }
  }
  return sourceText;
}
function getShaderModuleSource(module, stage) {
  let moduleSource;
  switch (stage) {
    case "vertex":
      moduleSource = module.vs || "";
      break;
    case "fragment":
      moduleSource = module.fs || "";
      break;
    case "wgsl":
      moduleSource = module.source || "";
      break;
    default:
      assert5(false);
  }
  if (!module.name) {
    throw new Error("Shader module must have a name");
  }
  const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
  let source3 = `// ----- MODULE ${module.name} ---------------

`;
  if (stage !== "wgsl") {
    source3 += `#define MODULE_${moduleName}
`;
  }
  source3 += `${moduleSource}
`;
  return source3;
}

// node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js
var IFDEF_REGEXP = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/;
var ENDIF_REGEXP = /^\s*\#\s*endif\s*$/;
function preprocess(source3, options) {
  const lines = source3.split("\n");
  const output = [];
  let conditional = true;
  let currentDefine = null;
  for (const line of lines) {
    const matchIf = line.match(IFDEF_REGEXP);
    const matchEnd = line.match(ENDIF_REGEXP);
    if (matchIf) {
      currentDefine = matchIf[1];
      conditional = Boolean(options?.defines?.[currentDefine]);
    } else if (matchEnd) {
      conditional = true;
    } else if (conditional) {
      output.push(line);
    }
  }
  return output.join("\n");
}

// node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js
var _ShaderAssembler = class _ShaderAssembler {
  constructor() {
    /** Hook functions */
    __publicField(this, "_hookFunctions", []);
    /** Shader modules */
    __publicField(this, "_defaultModules", []);
  }
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    _ShaderAssembler.defaultShaderAssembler = _ShaderAssembler.defaultShaderAssembler || new _ShaderAssembler();
    return _ShaderAssembler.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(module) {
    if (!this._defaultModules.find((m2) => m2.name === (typeof module === "string" ? module : module.name))) {
      this._defaultModules.push(module);
    }
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(module) {
    const moduleName = typeof module === "string" ? module : module.name;
    this._defaultModules = this._defaultModules.filter((m2) => m2.name !== moduleName);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, { hook });
    }
    this._hookFunctions.push(hook);
  }
  /**
   * Assemble a WGSL unified shader
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleWGSLShader(props) {
    const modules = this._getModuleList(props.modules);
    const hookFunctions = this._hookFunctions;
    const { source: source3, getUniforms: getUniforms4 } = assembleWGSLShader({
      ...props,
      // @ts-expect-error
      source: props.source,
      modules,
      hookFunctions
    });
    const preprocessedSource = props.platformInfo.shaderLanguage === "wgsl" ? preprocess(source3) : source3;
    return { source: preprocessedSource, getUniforms: getUniforms4, modules };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleGLSLShaderPair(props) {
    const modules = this._getModuleList(props.modules);
    const hookFunctions = this._hookFunctions;
    const assembled = assembleGLSLShaderPair({
      ...props,
      // @ts-expect-error
      vs: props.vs,
      // @ts-expect-error
      fs: props.fs,
      modules,
      hookFunctions
    });
    return { ...assembled, modules };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(appModules = []) {
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count2 = 0;
    for (let i3 = 0, len4 = this._defaultModules.length; i3 < len4; ++i3) {
      const module = this._defaultModules[i3];
      const name2 = module.name;
      modules[count2++] = module;
      seen[name2] = true;
    }
    for (let i3 = 0, len4 = appModules.length; i3 < len4; ++i3) {
      const module = appModules[i3];
      const name2 = module.name;
      if (!seen[name2]) {
        modules[count2++] = module;
        seen[name2] = true;
      }
    }
    modules.length = count2;
    initializeShaderModules(modules);
    return modules;
  }
};
/** Default ShaderAssembler instance */
__publicField(_ShaderAssembler, "defaultShaderAssembler");
var ShaderAssembler = _ShaderAssembler;

// node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js
var FS_GLES = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
);
var FS300 = `#version 300 es
${FS_GLES}`;
function getPassthroughFS(options) {
  const { input, inputChannels, output } = options || {};
  if (!input) {
    return FS300;
  }
  if (!inputChannels) {
    throw new Error("inputChannels");
  }
  const inputType = channelCountToType(inputChannels);
  const outputValue = convertToVec4(input, inputChannels);
  return `#version 300 es
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
}
function channelCountToType(channels2) {
  switch (channels2) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${channels2}`);
  }
}
function convertToVec4(variable, channels2) {
  switch (channels2) {
    case 1:
      return `vec4(${variable}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${variable}, 0.0, 1.0)`;
    case 3:
      return `vec4(${variable}, 1.0)`;
    case 4:
      return variable;
    default:
      throw new Error(`invalid channels: ${channels2}`);
  }
}

// node_modules/@luma.gl/core/dist/utils/stats-manager.js
var StatsManager = class {
  constructor() {
    __publicField(this, "stats", /* @__PURE__ */ new Map());
  }
  getStats(name2) {
    return this.get(name2);
  }
  get(name2) {
    if (!this.stats.has(name2)) {
      this.stats.set(name2, new Stats({ id: name2 }));
    }
    return this.stats.get(name2);
  }
};
var lumaStats = new StatsManager();

// node_modules/@luma.gl/core/dist/utils/log.js
var log2 = new Log({ id: "luma.gl" });

// node_modules/@luma.gl/core/dist/utils/uid.js
var uidCounters = {};
function uid(id = "id") {
  uidCounters[id] = uidCounters[id] || 1;
  const count2 = uidCounters[id]++;
  return `${id}-${count2}`;
}

// node_modules/@luma.gl/core/dist/adapter/resources/resource.js
var Resource = class {
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(device, props, defaultProps17) {
    /** props.id, for debugging. */
    __publicField(this, "id");
    __publicField(this, "props");
    __publicField(this, "userData", {});
    __publicField(this, "_device");
    /** Whether this resource has been destroyed */
    __publicField(this, "destroyed", false);
    /** For resources that allocate GPU memory */
    __publicField(this, "allocatedBytes", 0);
    /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
    __publicField(this, "_attachedResources", /* @__PURE__ */ new Set());
    if (!device) {
      throw new Error("no device");
    }
    this._device = device;
    this.props = selectivelyMerge(props, defaultProps17);
    const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
    this.props.id = id;
    this.id = id;
    this.userData = this.props.userData || {};
    this.addStats();
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    this.destroy();
    return this;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(resource) {
    this._attachedResources.add(resource);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(resource) {
    this._attachedResources.delete(resource);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(resource) {
    if (this._attachedResources.delete(resource)) {
      resource.destroy();
    }
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const resource of Object.values(this._attachedResources)) {
      resource.destroy();
    }
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources();
    this.removeStats();
    this.destroyed = true;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const stats = this._device.statsManager.getStats("Resource Counts");
    const name2 = this[Symbol.toStringTag];
    stats.get(`${name2}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(bytes, name2 = this[Symbol.toStringTag]) {
    const stats = this._device.statsManager.getStats("Resource Counts");
    stats.get("GPU Memory").addCount(bytes);
    stats.get(`${name2} Memory`).addCount(bytes);
    this.allocatedBytes = bytes;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(name2 = this[Symbol.toStringTag]) {
    const stats = this._device.statsManager.getStats("Resource Counts");
    stats.get("GPU Memory").subtractCount(this.allocatedBytes);
    stats.get(`${name2} Memory`).subtractCount(this.allocatedBytes);
    this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const stats = this._device.statsManager.getStats("Resource Counts");
    const name2 = this[Symbol.toStringTag];
    stats.get("Resources Created").incrementCount();
    stats.get(`${name2}s Created`).incrementCount();
    stats.get(`${name2}s Active`).incrementCount();
  }
};
/** Default properties for resource */
__publicField(Resource, "defaultProps", {
  id: "undefined",
  handle: void 0,
  userData: void 0
});
function selectivelyMerge(props, defaultProps17) {
  const mergedProps = { ...defaultProps17 };
  for (const key in props) {
    if (props[key] !== void 0) {
      mergedProps[key] = props[key];
    }
  }
  return mergedProps;
}

// node_modules/@luma.gl/core/dist/adapter/resources/buffer.js
var _Buffer = class _Buffer extends Resource {
  constructor(device, props) {
    const deducedProps = { ...props };
    if ((props.usage || 0) & _Buffer.INDEX && !props.indexType) {
      if (props.data instanceof Uint32Array) {
        deducedProps.indexType = "uint32";
      } else if (props.data instanceof Uint16Array) {
        deducedProps.indexType = "uint16";
      }
    }
    delete deducedProps.data;
    super(device, deducedProps, _Buffer.defaultProps);
    /** The usage with which this buffer was created */
    __publicField(this, "usage");
    /** For index buffers, whether indices are 16 or 32 bit */
    __publicField(this, "indexType");
    /** "Time" of last update, can be used to check if redraw is needed */
    __publicField(this, "updateTimestamp");
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    __publicField(this, "debugData", new ArrayBuffer(0));
    this.usage = deducedProps.usage || 0;
    this.indexType = deducedProps.indexType;
    this.updateTimestamp = device.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /**
   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
   * @note Does not copy contents of the cloned Buffer.
   */
  clone(props) {
    return this.device.createBuffer({ ...this.props, ...props });
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(byteOffset, byteLength) {
    throw new Error("not implemented");
  }
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(data, byteOffset, byteLength) {
    const arrayBuffer2 = ArrayBuffer.isView(data) ? data.buffer : data;
    const debugDataLength = Math.min(data ? data.byteLength : byteLength, _Buffer.DEBUG_DATA_MAX_LENGTH);
    if (arrayBuffer2 === null) {
      this.debugData = new ArrayBuffer(debugDataLength);
    } else if (byteOffset === 0 && byteLength === arrayBuffer2.byteLength) {
      this.debugData = arrayBuffer2.slice(0, debugDataLength);
    } else {
      this.debugData = arrayBuffer2.slice(byteOffset, byteOffset + debugDataLength);
    }
  }
};
__publicField(_Buffer, "defaultProps", {
  ...Resource.defaultProps,
  usage: 0,
  // Buffer.COPY_DST | Buffer.COPY_SRC
  byteLength: 0,
  byteOffset: 0,
  data: null,
  indexType: "uint16",
  mappedAtCreation: false
});
// Usage Flags
__publicField(_Buffer, "MAP_READ", 1);
__publicField(_Buffer, "MAP_WRITE", 2);
__publicField(_Buffer, "COPY_SRC", 4);
__publicField(_Buffer, "COPY_DST", 8);
/** Index buffer */
__publicField(_Buffer, "INDEX", 16);
/** Vertex buffer */
__publicField(_Buffer, "VERTEX", 32);
/** Uniform buffer */
__publicField(_Buffer, "UNIFORM", 64);
/** Storage buffer */
__publicField(_Buffer, "STORAGE", 128);
__publicField(_Buffer, "INDIRECT", 256);
__publicField(_Buffer, "QUERY_RESOLVE", 512);
// PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
/** Max amount of debug data saved. Two vec4's */
__publicField(_Buffer, "DEBUG_DATA_MAX_LENGTH", 32);
var Buffer2 = _Buffer;

// node_modules/@luma.gl/core/dist/gpu-type-utils/decode-data-type.js
function decodeVertexType(type) {
  const dataType = TYPE_MAP[type];
  const bytes = getDataTypeBytes(dataType);
  const normalized = type.includes("norm");
  const integer = !normalized && !type.startsWith("float");
  const signed = type.startsWith("s");
  return {
    dataType: TYPE_MAP[type],
    byteLength: bytes,
    integer,
    signed,
    normalized
  };
}
function getDataTypeBytes(type) {
  const bytes = TYPE_SIZES[type];
  return bytes;
}
var TYPE_MAP = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
};
var TYPE_SIZES = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
};

// node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-table.js
var texture_compression_bc = "texture-compression-bc";
var texture_compression_astc = "texture-compression-astc";
var texture_compression_etc2 = "texture-compression-etc2";
var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
var texture_compression_atc_webgl = "texture-compression-atc-webgl";
var float32_renderable = "float32-renderable-webgl";
var float16_renderable = "float16-renderable-webgl";
var rgb9e5ufloat_renderable = "rgb9e5ufloat-renderable-webgl";
var snorm8_renderable = "snorm8-renderable-webgl";
var norm16_renderable = "norm16-renderable-webgl";
var snorm16_renderable = "snorm16-renderable-webgl";
var float32_filterable = "float32-filterable";
var float16_filterable = "float16-filterable-webgl";
function getTextureFormatDefinition(format) {
  const info = TEXTURE_FORMAT_TABLE[format];
  if (!info) {
    throw new Error(`Unsupported texture format ${format}`);
  }
  return info;
}
var TEXTURE_FORMAT_TABLE = {
  // 8-bit formats
  "r8unorm": {},
  "r8snorm": { render: snorm8_renderable },
  "r8uint": {},
  "r8sint": {},
  // 16-bit formats
  "rg8unorm": {},
  "rg8snorm": { render: snorm8_renderable },
  "rg8uint": {},
  "rg8sint": {},
  "r16uint": {},
  "r16sint": {},
  "r16float": { render: float16_renderable, filter: "float16-filterable-webgl" },
  "r16unorm-webgl": { f: norm16_renderable },
  "r16snorm-webgl": { f: snorm16_renderable },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { channels: "rgba", bitsPerChannel: [4, 4, 4, 4], packed: true },
  "rgb565unorm-webgl": { channels: "rgb", bitsPerChannel: [5, 6, 5, 0], packed: true },
  "rgb5a1unorm-webgl": { channels: "rgba", bitsPerChannel: [5, 5, 5, 1], packed: true },
  // 24-bit formats
  "rgb8unorm-webgl": {},
  "rgb8snorm-webgl": {},
  // 32-bit formats  
  "rgba8unorm": {},
  "rgba8unorm-srgb": {},
  "rgba8snorm": { render: snorm8_renderable },
  "rgba8uint": {},
  "rgba8sint": {},
  // 32-bit, reverse colors, webgpu only
  "bgra8unorm": {},
  "bgra8unorm-srgb": {},
  "rg16uint": {},
  "rg16sint": {},
  "rg16float": { render: float16_renderable, filter: float16_filterable },
  "rg16unorm-webgl": { render: norm16_renderable },
  "rg16snorm-webgl": { render: snorm16_renderable },
  "r32uint": {},
  "r32sint": {},
  "r32float": { render: float32_renderable, filter: float32_filterable },
  // Packed 32 bit formats
  "rgb9e5ufloat": { channels: "rgb", packed: true, render: rgb9e5ufloat_renderable },
  // , filter: true},
  "rg11b10ufloat": { channels: "rgb", bitsPerChannel: [11, 11, 10, 0], packed: true, p: 1, render: float32_renderable },
  "rgb10a2unorm": { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1 },
  "rgb10a2uint-webgl": { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1, wgpu: false },
  // 48-bit formats
  "rgb16unorm-webgl": { f: norm16_renderable },
  // rgb not renderable
  "rgb16snorm-webgl": { f: norm16_renderable },
  // rgb not renderable
  // 64-bit formats
  "rg32uint": {},
  "rg32sint": {},
  "rg32float": { render: false, filter: float32_filterable },
  "rgba16uint": {},
  "rgba16sint": {},
  "rgba16float": { render: float16_renderable, filter: float16_filterable },
  "rgba16unorm-webgl": { render: norm16_renderable },
  "rgba16snorm-webgl": { render: snorm16_renderable },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": { render: float32_renderable, filter: float32_filterable },
  // 128-bit formats
  "rgba32uint": {},
  "rgba32sint": {},
  "rgba32float": { render: float32_renderable, filter: float32_filterable },
  // Depth/stencil
  // Depth and stencil formats
  stencil8: { attachment: "stencil", bitsPerChannel: [8, 0, 0, 0], dataType: "uint8" },
  "depth16unorm": { attachment: "depth", bitsPerChannel: [16, 0, 0, 0], dataType: "uint16" },
  "depth24plus": { attachment: "depth", bitsPerChannel: [24, 0, 0, 0], dataType: "uint32" },
  "depth32float": { attachment: "depth", bitsPerChannel: [32, 0, 0, 0], dataType: "float32" },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { attachment: "depth-stencil", bitsPerChannel: [24, 8, 0, 0], packed: true },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { attachment: "depth-stencil", bitsPerChannel: [32, 8, 0, 0], packed: true },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { f: texture_compression_bc },
  "bc1-rgb-unorm-srgb-webgl": { f: texture_compression_bc },
  "bc1-rgba-unorm": { f: texture_compression_bc },
  "bc1-rgba-unorm-srgb": { f: texture_compression_bc },
  "bc2-rgba-unorm": { f: texture_compression_bc },
  "bc2-rgba-unorm-srgb": { f: texture_compression_bc },
  "bc3-rgba-unorm": { f: texture_compression_bc },
  "bc3-rgba-unorm-srgb": { f: texture_compression_bc },
  "bc4-r-unorm": { f: texture_compression_bc },
  "bc4-r-snorm": { f: texture_compression_bc },
  "bc5-rg-unorm": { f: texture_compression_bc },
  "bc5-rg-snorm": { f: texture_compression_bc },
  "bc6h-rgb-ufloat": { f: texture_compression_bc },
  "bc6h-rgb-float": { f: texture_compression_bc },
  "bc7-rgba-unorm": { f: texture_compression_bc },
  "bc7-rgba-unorm-srgb": { f: texture_compression_bc },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { f: texture_compression_etc2 },
  "etc2-rgb8unorm-srgb": { f: texture_compression_etc2 },
  "etc2-rgb8a1unorm": { f: texture_compression_etc2 },
  "etc2-rgb8a1unorm-srgb": { f: texture_compression_etc2 },
  "etc2-rgba8unorm": { f: texture_compression_etc2 },
  "etc2-rgba8unorm-srgb": { f: texture_compression_etc2 },
  "eac-r11unorm": { f: texture_compression_etc2 },
  "eac-r11snorm": { f: texture_compression_etc2 },
  "eac-rg11unorm": { f: texture_compression_etc2 },
  "eac-rg11snorm": { f: texture_compression_etc2 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { f: texture_compression_astc },
  "astc-4x4-unorm-srgb": { f: texture_compression_astc },
  "astc-5x4-unorm": { f: texture_compression_astc },
  "astc-5x4-unorm-srgb": { f: texture_compression_astc },
  "astc-5x5-unorm": { f: texture_compression_astc },
  "astc-5x5-unorm-srgb": { f: texture_compression_astc },
  "astc-6x5-unorm": { f: texture_compression_astc },
  "astc-6x5-unorm-srgb": { f: texture_compression_astc },
  "astc-6x6-unorm": { f: texture_compression_astc },
  "astc-6x6-unorm-srgb": { f: texture_compression_astc },
  "astc-8x5-unorm": { f: texture_compression_astc },
  "astc-8x5-unorm-srgb": { f: texture_compression_astc },
  "astc-8x6-unorm": { f: texture_compression_astc },
  "astc-8x6-unorm-srgb": { f: texture_compression_astc },
  "astc-8x8-unorm": { f: texture_compression_astc },
  "astc-8x8-unorm-srgb": { f: texture_compression_astc },
  "astc-10x5-unorm": { f: texture_compression_astc },
  "astc-10x5-unorm-srgb": { f: texture_compression_astc },
  "astc-10x6-unorm": { f: texture_compression_astc },
  "astc-10x6-unorm-srgb": { f: texture_compression_astc },
  "astc-10x8-unorm": { f: texture_compression_astc },
  "astc-10x8-unorm-srgb": { f: texture_compression_astc },
  "astc-10x10-unorm": { f: texture_compression_astc },
  "astc-10x10-unorm-srgb": { f: texture_compression_astc },
  "astc-12x10-unorm": { f: texture_compression_astc },
  "astc-12x10-unorm-srgb": { f: texture_compression_astc },
  "astc-12x12-unorm": { f: texture_compression_astc },
  "astc-12x12-unorm-srgb": { f: texture_compression_astc },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba4unorm-webgl": { f: texture_compression_pvrtc_webgl },
  "pvrtc-rbg2unorm-webgl": { f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba2unorm-webgl": { f: texture_compression_pvrtc_webgl },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { f: texture_compression_etc1_webgl },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { f: texture_compression_atc_webgl },
  "atc-rgba-unorm-webgl": { f: texture_compression_atc_webgl },
  "atc-rgbai-unorm-webgl": { f: texture_compression_atc_webgl }
};

// node_modules/@luma.gl/core/dist/gpu-type-utils/decode-texture-format.js
var COMPRESSED_TEXTURE_FORMAT_PREFIXES = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
];
var RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
function isTextureFormatCompressed(format) {
  return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some((prefix) => format.startsWith(prefix));
}
function decodeTextureFormat(format) {
  let formatInfo = decodeTextureFormatUsingTable(format);
  if (isTextureFormatCompressed(format)) {
    formatInfo.channels = "rgb";
    formatInfo.components = 3;
    formatInfo.bytesPerPixel = 1;
    formatInfo.srgb = false;
    formatInfo.compressed = true;
    const blockSize = getCompressedTextureBlockSize(format);
    if (blockSize) {
      formatInfo.blockWidth = blockSize.blockWidth;
      formatInfo.blockHeight = blockSize.blockHeight;
    }
  }
  const matches3 = RGB_FORMAT_REGEX.exec(format);
  if (matches3) {
    const [, channels2, length5, type, srgb, suffix] = matches3;
    const dataType = `${type}${length5}`;
    const decodedType = decodeVertexType(dataType);
    const bits = decodedType.byteLength * 8;
    const components = channels2.length;
    const bitsPerChannel = [
      bits,
      components >= 2 ? bits : 0,
      components >= 3 ? bits : 0,
      components >= 4 ? bits : 0
    ];
    formatInfo = {
      format,
      attachment: formatInfo.attachment,
      dataType: decodedType.dataType,
      components,
      channels: channels2,
      integer: decodedType.integer,
      signed: decodedType.signed,
      normalized: decodedType.normalized,
      bitsPerChannel,
      bytesPerPixel: decodedType.byteLength * channels2.length,
      packed: formatInfo.packed,
      srgb: formatInfo.srgb
    };
    if (suffix === "-webgl") {
      formatInfo.webgl = true;
    }
    if (srgb === "-srgb") {
      formatInfo.srgb = true;
    }
  }
  if (format.endsWith("-webgl")) {
    formatInfo.webgl = true;
  }
  if (format.endsWith("-srgb")) {
    formatInfo.srgb = true;
  }
  return formatInfo;
}
function decodeTextureFormatUsingTable(format) {
  const info = getTextureFormatDefinition(format);
  const bytesPerPixel = info.bytesPerPixel || 1;
  const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];
  delete info.bitsPerChannel;
  delete info.bytesPerPixel;
  delete info.f;
  delete info.render;
  delete info.filter;
  delete info.blend;
  delete info.store;
  const formatInfo = {
    ...info,
    format,
    attachment: info.attachment || "color",
    channels: info.channels || "r",
    components: info.components || info.channels?.length || 1,
    bytesPerPixel,
    bitsPerChannel,
    dataType: info.dataType || "uint8",
    srgb: info.srgb ?? false,
    packed: info.packed ?? false,
    webgl: info.webgl ?? false,
    integer: info.integer ?? false,
    signed: info.signed ?? false,
    normalized: info.normalized ?? false,
    compressed: info.compressed ?? false
  };
  return formatInfo;
}
function getCompressedTextureBlockSize(format) {
  const REGEX = /.*-(\d+)x(\d+)-.*/;
  const matches3 = REGEX.exec(format);
  if (matches3) {
    const [, blockWidth, blockHeight] = matches3;
    return { blockWidth: Number(blockWidth), blockHeight: Number(blockHeight) };
  }
  return null;
}

// node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-capabilities.js
function getTextureFormatCapabilities(format) {
  const info = getTextureFormatDefinition(format);
  const formatCapabilities = {
    format,
    create: info.f ?? true,
    render: info.render ?? true,
    filter: info.filter ?? true,
    blend: info.blend ?? true,
    store: info.store ?? true
  };
  const formatInfo = decodeTextureFormat(format);
  const isDepthStencil = format.startsWith("depth") || format.startsWith("stencil");
  const isSigned = formatInfo?.signed;
  const isInteger = formatInfo?.integer;
  const isWebGLSpecific = formatInfo?.webgl;
  formatCapabilities.render && (formatCapabilities.render = !isSigned);
  formatCapabilities.filter && (formatCapabilities.filter = !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific);
  return formatCapabilities;
}

// node_modules/@luma.gl/core/dist/adapter/device.js
var DeviceLimits = class {
};
var DeviceFeatures = class {
  constructor(features = [], disabledFeatures) {
    __publicField(this, "features");
    __publicField(this, "disabledFeatures");
    this.features = new Set(features);
    this.disabledFeatures = disabledFeatures || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(feature) {
    return !this.disabledFeatures?.[feature] && this.features.has(feature);
  }
};
var _Device = class _Device {
  constructor(props) {
    /** id of this device, primarily for debugging */
    __publicField(this, "id");
    /** A copy of the device props  */
    __publicField(this, "props");
    /** Available for the application to store data on the device */
    __publicField(this, "userData", {});
    /** stats */
    __publicField(this, "statsManager", lumaStats);
    /** An abstract timestamp used for change tracking */
    __publicField(this, "timestamp", 0);
    /** True if this device has been reused during device creation (app has multiple references) */
    __publicField(this, "_reused", false);
    /** Used by other luma.gl modules to store data on the device */
    __publicField(this, "_lumaData", {});
    this.props = { ..._Device.defaultProps, ...props };
    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
  }
  get [Symbol.toStringTag]() {
    return "Device";
  }
  /** Determines what operations are supported on a texture format, checking against supported device features */
  getTextureFormatCapabilities(format) {
    const genericCapabilities = getTextureFormatCapabilities(format);
    const checkFeature = (featureOrBoolean) => (typeof featureOrBoolean === "string" ? this.features.has(featureOrBoolean) : featureOrBoolean) ?? true;
    const supported = checkFeature(genericCapabilities.create);
    const deviceCapabilities = {
      format,
      create: supported,
      render: supported && checkFeature(genericCapabilities.render),
      filter: supported && checkFeature(genericCapabilities.filter),
      blend: supported && checkFeature(genericCapabilities.blend),
      store: supported && checkFeature(genericCapabilities.store)
    };
    return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);
  }
  /** Check if device supports a specific texture format (creation and `nearest` sampling) */
  isTextureFormatSupported(format, capabilities) {
    return this.getTextureFormatCapabilities(format).create;
  }
  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
  isTextureFormatFilterable(format) {
    return this.getTextureFormatCapabilities(format).filter;
  }
  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
  isTextureFormatRenderable(format) {
    return this.getTextureFormatCapabilities(format).render;
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(format) {
    return isTextureFormatCompressed(format);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return false;
  }
  /** Report error (normally called for unhandled device errors) */
  reportError(error) {
    this.props.onError(error);
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getDefaultCanvasContext() {
    if (!this.canvasContext) {
      throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
    }
    return this.canvasContext;
  }
  createCommandEncoder(props = {}) {
    throw new Error("not implemented");
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(error) {
    this.props.onError(error);
  }
  // DEPRECATED METHODS
  /** @deprecated Use getDefaultCanvasContext() */
  getCanvasContext() {
    return this.getDefaultCanvasContext();
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(source3, options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(source3, options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(parameters) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(parameters) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(parameters, func) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(options) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  // IMPLEMENTATION
  /** Helper to get the canvas context props */
  static _getCanvasContextProps(props) {
    return props.createCanvasContext === true ? {} : props.createCanvasContext;
  }
  /** Subclasses use this to support .createBuffer() overloads */
  _normalizeBufferProps(props) {
    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
      props = { data: props };
    }
    const newProps = { ...props };
    if ((props.usage || 0) & Buffer2.INDEX && !props.indexType) {
      if (props.data instanceof Uint32Array) {
        newProps.indexType = "uint32";
      } else if (props.data instanceof Uint16Array) {
        newProps.indexType = "uint16";
      } else {
        log2.warn("indices buffer content must be of integer type")();
      }
    }
    return newProps;
  }
};
__publicField(_Device, "defaultProps", {
  id: null,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: false,
  createCanvasContext: void 0,
  // Callbacks
  onError: (error) => log2.error(error.message)(),
  // Experimental
  _reuseDevices: false,
  _requestMaxLimits: true,
  _factoryDestroyPolicy: "unused",
  // TODO - Change these after confirming things work as expected
  _initializeFeatures: true,
  _disabledFeatures: {
    "compilation-status-async-webgl": true
  },
  _resourceDefaults: {},
  // WebGL specific
  webgl: {},
  debug: log2.get("debug") || void 0,
  debugShaders: log2.get("debug-shaders") || void 0,
  debugFramebuffers: Boolean(log2.get("debug-framebuffers")),
  debugWebGL: Boolean(log2.get("debug-webgl")),
  debugSpectorJS: void 0,
  // Note: log setting is queried by the spector.js code
  debugSpectorJSUrl: void 0,
  // INTERNAL
  _handle: void 0
});
var Device = _Device;

// node_modules/@luma.gl/core/dist/adapter/luma.js
var isPage = isBrowser2() && typeof document !== "undefined";
var isPageLoaded = () => isPage && document.readyState === "complete";
var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
var ERROR_MESSAGE = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
var _Luma = class _Luma {
  constructor() {
    /** Global stats for all devices */
    __publicField(this, "stats", lumaStats);
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */
    __publicField(this, "log", log2);
    /** Version of luma.gl */
    __publicField(
      this,
      "VERSION",
      // Version detection using build plugin
      // @ts-expect-error no-undef
      true ? "9.1.10" : "running from source"
    );
    __publicField(this, "spector");
    __publicField(this, "preregisteredAdapters", /* @__PURE__ */ new Map());
    if (globalThis.luma) {
      if (globalThis.luma.VERSION !== this.VERSION) {
        log2.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();
        log2.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();
        throw new Error(`luma.gl - multiple versions detected: see console log`);
      }
      log2.error("This version of luma.gl has already been initialized")();
    }
    log2.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();
    globalThis.luma = this;
  }
  registerAdapters(adapters) {
    for (const deviceClass of adapters) {
      this.preregisteredAdapters.set(deviceClass.type, deviceClass);
    }
  }
  /** Get type strings for supported Devices */
  getSupportedAdapters(adapters = []) {
    const adapterMap = this.getAdapterMap(adapters);
    return Array.from(adapterMap).map(([, adapter]) => adapter).filter((adapter) => adapter.isSupported?.()).map((adapter) => adapter.type);
  }
  /** Get type strings for best available Device */
  getBestAvailableAdapter(adapters = []) {
    const adapterMap = this.getAdapterMap(adapters);
    if (adapterMap.get("webgpu")?.isSupported?.()) {
      return "webgpu";
    }
    if (adapterMap.get("webgl")?.isSupported?.()) {
      return "webgl";
    }
    return null;
  }
  setDefaultDeviceProps(props) {
    Object.assign(_Luma.defaultProps, props);
  }
  /** Creates a device. Asynchronously. */
  async createDevice(props = {}) {
    props = { ..._Luma.defaultProps, ...props };
    if (props.waitForPageLoad) {
      await _Luma.pageLoaded;
    }
    const adapterMap = this.getAdapterMap(props.adapters);
    let type = props.type || "";
    if (type === "best-available") {
      type = this.getBestAvailableAdapter(props.adapters) || type;
    }
    const adapters = this.getAdapterMap(props.adapters) || adapterMap;
    const adapter = adapters.get(type);
    const device = await adapter?.create?.(props);
    if (device) {
      return device;
    }
    throw new Error(ERROR_MESSAGE);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  async attachDevice(props) {
    const adapters = this.getAdapterMap(props.adapters);
    let type = "";
    if (props.handle instanceof WebGL2RenderingContext) {
      type = "webgl";
    }
    if (props.createCanvasContext) {
      await _Luma.pageLoaded;
    }
    if (props.handle === null) {
      type = "unknown";
    }
    const adapter = adapters.get(type);
    const device = await adapter?.attach?.(null);
    if (device) {
      return device;
    }
    throw new Error(ERROR_MESSAGE);
  }
  /**
   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
   */
  enforceWebGL2(enforce = true, adapters = []) {
    const adapterMap = this.getAdapterMap(adapters);
    const webgl2Adapter2 = adapterMap.get("webgl");
    if (!webgl2Adapter2) {
      log2.warn("enforceWebGL2: webgl adapter not found")();
    }
    webgl2Adapter2?.enforceWebGL2?.(enforce);
  }
  /** Convert a list of adapters to a map */
  getAdapterMap(adapters = []) {
    const map3 = new Map(this.preregisteredAdapters);
    for (const adapter of adapters) {
      map3.set(adapter.type, adapter);
    }
    return map3;
  }
  // DEPRECATED
  /** @deprecated Use registerAdapters */
  registerDevices(deviceClasses) {
    log2.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");
    for (const deviceClass of deviceClasses) {
      const adapter = deviceClass.adapter;
      if (adapter) {
        this.preregisteredAdapters.set(adapter.type, adapter);
      }
    }
  }
};
__publicField(_Luma, "defaultProps", {
  ...Device.defaultProps,
  type: "best-available",
  adapters: void 0,
  waitForPageLoad: true
});
/**
 * Page load promise
 * Get a 'lazy' promise that resolves when the DOM is loaded.
 * @note Since there may be limitations on number of `load` event listeners,
 * it is recommended avoid calling this function until actually needed.
 * I.e. don't call it until you know that you will be looking up a string in the DOM.
 */
__publicField(_Luma, "pageLoaded", getPageLoadPromise().then(() => {
  log2.probe(2, "DOM is loaded")();
}));
var Luma = _Luma;
var luma = new Luma();
function getPageLoadPromise() {
  if (isPageLoaded() || typeof window === "undefined") {
    return Promise.resolve();
  }
  return new Promise((resolve3) => {
    window.addEventListener("load", () => resolve3());
  });
}

// node_modules/@luma.gl/core/dist/adapter/adapter.js
var Adapter = class {
};

// node_modules/@luma.gl/core/dist/adapter/canvas-context.js
var _CanvasContext = class _CanvasContext {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "props");
    __publicField(this, "canvas");
    __publicField(this, "htmlCanvas");
    __publicField(this, "offscreenCanvas");
    __publicField(this, "type");
    __publicField(this, "width", 1);
    __publicField(this, "height", 1);
    __publicField(this, "resizeObserver");
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    __publicField(this, "_canvasSizeInfo", { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 });
    this.props = { ..._CanvasContext.defaultProps, ...props };
    props = this.props;
    if (!isBrowser2()) {
      this.id = "node-canvas-context";
      this.type = "node";
      this.width = this.props.width;
      this.height = this.props.height;
      this.canvas = null;
      return;
    }
    if (!props.canvas) {
      const canvas2 = createCanvas(props);
      const container = getContainer(props?.container || null);
      container.insertBefore(canvas2, container.firstChild);
      this.canvas = canvas2;
      if (!props?.visible) {
        this.canvas.style.visibility = "hidden";
      }
    } else if (typeof props.canvas === "string") {
      this.canvas = getCanvasFromDOM(props.canvas);
    } else {
      this.canvas = props.canvas;
    }
    if (this.canvas instanceof HTMLCanvasElement) {
      this.id = this.canvas.id;
      this.type = "html-canvas";
      this.htmlCanvas = this.canvas;
    } else {
      this.id = "offscreen-canvas";
      this.type = "offscreen-canvas";
      this.offscreenCanvas = this.canvas;
    }
    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
      this.resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target === this.canvas) {
            this.update();
          }
        }
      });
      this.resizeObserver.observe(this.canvas);
    }
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(useDevicePixels) {
    if (typeof OffscreenCanvas !== "undefined" && this.canvas instanceof OffscreenCanvas) {
      return 1;
    }
    useDevicePixels = useDevicePixels === void 0 ? this.props.useDevicePixels : useDevicePixels;
    if (!useDevicePixels || useDevicePixels <= 0) {
      return 1;
    }
    if (useDevicePixels === true) {
      const dpr = typeof window !== "undefined" && window.devicePixelRatio;
      return dpr || 1;
    }
    return useDevicePixels;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const dpr = this.getDevicePixelRatio();
        const canvas2 = this.canvas;
        return canvas2.parentElement ? [canvas2.clientWidth * dpr, canvas2.clientHeight * dpr] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [width, height] = this.getPixelSize();
    return width / height;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    try {
      const [drawingBufferWidth] = this.getDrawingBufferSize();
      const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;
      return clientWidth ? drawingBufferWidth / clientWidth : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(cssPixel, yInvert = true) {
    const ratio = this.cssToDeviceRatio();
    const [width, height] = this.getDrawingBufferSize();
    return scalePixels(cssPixel, ratio, width, height, yInvert);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(devicePixelRatio, options = {}) {
    if (!this.htmlCanvas) {
      return;
    }
    let clientWidth = "width" in options ? options.width : this.htmlCanvas.clientWidth;
    let clientHeight = "height" in options ? options.height : this.htmlCanvas.clientHeight;
    if (!clientWidth || !clientHeight) {
      log2.log(1, "Canvas clientWidth/clientHeight is 0")();
      devicePixelRatio = 1;
      clientWidth = this.htmlCanvas.width || 1;
      clientHeight = this.htmlCanvas.height || 1;
    }
    const cachedSize = this._canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
      let clampedPixelRatio = devicePixelRatio;
      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
      this.htmlCanvas.width = canvasWidth;
      this.htmlCanvas.height = canvasHeight;
      const gl = this.device.gl;
      if (gl) {
        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
          clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
          log2.warn("Device pixel ratio clamped")();
        }
        this._canvasSizeInfo.clientWidth = clientWidth;
        this._canvasSizeInfo.clientHeight = clientHeight;
        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
      }
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const gl = this.device.gl;
    if (!gl) {
      return this.getPixelSize();
    }
    return [gl.drawingBufferWidth, gl.drawingBufferHeight];
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(id) {
    if (this.htmlCanvas?.id === "lumagl-auto-created-canvas") {
      this.htmlCanvas.id = id;
    }
  }
};
__publicField(_CanvasContext, "defaultProps", {
  canvas: null,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  useDevicePixels: true,
  autoResize: true,
  container: null,
  visible: true,
  alphaMode: "opaque",
  colorSpace: "srgb"
});
var CanvasContext = _CanvasContext;
function getContainer(container) {
  if (typeof container === "string") {
    const element = document.getElementById(container);
    if (!element) {
      throw new Error(`${container} is not an HTML element`);
    }
    return element;
  } else if (container) {
    return container;
  }
  return document.body;
}
function getCanvasFromDOM(canvasId) {
  const canvas2 = document.getElementById(canvasId);
  if (!(canvas2 instanceof HTMLCanvasElement)) {
    throw new Error("Object is not a canvas element");
  }
  return canvas2;
}
function createCanvas(props) {
  const { width, height } = props;
  const targetCanvas = document.createElement("canvas");
  targetCanvas.id = uid("lumagl-auto-created-canvas");
  targetCanvas.width = width || 1;
  targetCanvas.height = height || 1;
  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : "100%";
  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : "100%";
  return targetCanvas;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const point = pixel;
  const x2 = scaleX(point[0], ratio, width);
  let y2 = scaleY(point[1], ratio, height, yInvert);
  let t2 = scaleX(point[0] + 1, ratio, width);
  const xHigh = t2 === width - 1 ? t2 : t2 - 1;
  t2 = scaleY(point[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t2 = t2 === 0 ? t2 : t2 + 1;
    yHigh = y2;
    y2 = t2;
  } else {
    yHigh = t2 === height - 1 ? t2 : t2 - 1;
  }
  return {
    x: x2,
    y: y2,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(xHigh - x2 + 1, 1),
    height: Math.max(yHigh - y2 + 1, 1)
  };
}
function scaleX(x2, ratio, width) {
  const r2 = Math.min(Math.round(x2 * ratio), width - 1);
  return r2;
}
function scaleY(y2, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y2 * ratio)) : Math.min(Math.round(y2 * ratio), height - 1);
}

// node_modules/@luma.gl/core/dist/adapter/resources/texture.js
var _Texture = class _Texture extends Resource {
  /** Do not use directly. Create with device.createTexture() */
  constructor(device, props) {
    props = _Texture.normalizeProps(device, props);
    super(device, props, _Texture.defaultProps);
    /** dimension of this texture */
    __publicField(this, "dimension");
    /** format of this texture */
    __publicField(this, "format");
    /** width in pixels of this texture */
    __publicField(this, "width");
    /** height in pixels of this texture */
    __publicField(this, "height");
    /** depth of this texture */
    __publicField(this, "depth");
    /** mip levels in this texture */
    __publicField(this, "mipLevels");
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
    __publicField(this, "updateTimestamp");
    this.dimension = this.props.dimension;
    this.format = this.props.format;
    this.width = this.props.width;
    this.height = this.props.height;
    this.depth = this.props.depth;
    if (this.props.width === void 0 || this.props.height === void 0) {
      const size = _Texture.getTextureDataSize(this.props.data);
      this.width = size?.width || 1;
      this.height = size?.height || 1;
    }
    if (this.props.mipmaps && this.props.mipLevels === void 0) {
      this.props.mipLevels = "pyramid";
    }
    this.mipLevels = this.props.mipLevels === "pyramid" ? _Texture.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1;
    this.updateTimestamp = device.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  toString() {
    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
  }
  /**
   * Create a new texture with the same parameters and optionally, a different size
   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   */
  clone(size) {
    return this.device.createTexture({ ...this.props, ...size });
  }
  /** Check if data is an external image */
  static isExternalImage(data) {
    return typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement || typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement || typeof VideoFrame !== "undefined" && data instanceof VideoFrame || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas;
  }
  /** Determine size (width and height) of provided image data */
  static getExternalImageSize(data) {
    if (typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas) {
      return { width: data.width, height: data.height };
    }
    if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
      return { width: data.naturalWidth, height: data.naturalHeight };
    }
    if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
      return { width: data.videoWidth, height: data.videoHeight };
    }
    if (typeof VideoFrame !== "undefined" && data instanceof VideoFrame) {
      return { width: data.displayWidth, height: data.displayHeight };
    }
    throw new Error("Unknown image type");
  }
  /** Check if texture data is a typed array */
  static isTextureLevelData(data) {
    const typedArray = data?.data;
    return ArrayBuffer.isView(typedArray);
  }
  /** Get the size of the texture described by the provided TextureData */
  static getTextureDataSize(data) {
    if (!data) {
      return null;
    }
    if (ArrayBuffer.isView(data)) {
      return null;
    }
    if (Array.isArray(data)) {
      return _Texture.getTextureDataSize(data[0]);
    }
    if (_Texture.isExternalImage(data)) {
      return _Texture.getExternalImageSize(data);
    }
    if (data && typeof data === "object" && data.constructor === Object) {
      const textureDataArray = Object.values(data);
      const untypedData = textureDataArray[0];
      return { width: untypedData.width, height: untypedData.height };
    }
    throw new Error("texture size deduction failed");
  }
  /**
   * Normalize TextureData to an array of TextureLevelData / ExternalImages
   * @param data
   * @param options
   * @returns array of TextureLevelData / ExternalImages
   */
  static normalizeTextureData(data, options) {
    let lodArray;
    if (ArrayBuffer.isView(data)) {
      lodArray = [
        {
          // ts-expect-error does data really need to be Uint8ClampedArray?
          data,
          width: options.width,
          height: options.height
          // depth: options.depth
        }
      ];
    } else if (!Array.isArray(data)) {
      lodArray = [data];
    } else {
      lodArray = data;
    }
    return lodArray;
  }
  /** Calculate the number of mip levels for a texture of width and height */
  static getMipLevelCount(width, height) {
    return Math.floor(Math.log2(Math.max(width, height))) + 1;
  }
  /** Convert luma.gl cubemap face constants to depth index */
  static getCubeFaceDepth(face) {
    switch (face) {
      case "+X":
        return 0;
      case "-X":
        return 1;
      case "+Y":
        return 2;
      case "-Y":
        return 3;
      case "+Z":
        return 4;
      case "-Z":
        return 5;
      default:
        throw new Error(face);
    }
  }
  /** Ensure we have integer coordinates */
  static normalizeProps(device, props) {
    const newProps = { ...props };
    const overriddenDefaultProps = device?.props?._resourceDefaults?.texture || {};
    Object.assign(newProps, overriddenDefaultProps);
    const { width, height } = newProps;
    if (typeof width === "number") {
      newProps.width = Math.max(1, Math.ceil(width));
    }
    if (typeof height === "number") {
      newProps.height = Math.max(1, Math.ceil(height));
    }
    return newProps;
  }
};
__publicField(_Texture, "COPY_SRC", 1);
__publicField(_Texture, "COPY_DST", 2);
__publicField(_Texture, "TEXTURE", 4);
__publicField(_Texture, "STORAGE", 8);
__publicField(_Texture, "RENDER_ATTACHMENT", 16);
__publicField(_Texture, "CubeFaces", ["+X", "-X", "+Y", "-Y", "+Z", "-Z"]);
__publicField(_Texture, "defaultProps", {
  ...Resource.defaultProps,
  data: null,
  dimension: "2d",
  format: "rgba8unorm",
  width: void 0,
  height: void 0,
  depth: 1,
  mipmaps: false,
  compressed: false,
  usage: 0,
  mipLevels: void 0,
  samples: void 0,
  sampler: {},
  view: void 0,
  flipY: void 0
});
/** Default options */
__publicField(_Texture, "defaultCopyExternalImageOptions", {
  image: void 0,
  sourceX: 0,
  sourceY: 0,
  width: void 0,
  height: void 0,
  depth: 1,
  mipLevel: 0,
  x: 0,
  y: 0,
  z: 0,
  aspect: "all",
  colorSpace: "srgb",
  premultipliedAlpha: false,
  flipY: false
});
var Texture = _Texture;

// node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js
var _TextureView = class _TextureView extends Resource {
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(device, props) {
    super(device, props, _TextureView.defaultProps);
  }
};
__publicField(_TextureView, "defaultProps", {
  ...Resource.defaultProps,
  format: void 0,
  dimension: void 0,
  aspect: "all",
  baseMipLevel: 0,
  mipLevelCount: void 0,
  baseArrayLayer: 0,
  arrayLayerCount: void 0
});
var TextureView = _TextureView;

// node_modules/@luma.gl/core/dist/adapter-utils/format-compiler-log.js
function formatCompilerLog(shaderLog, source3, options) {
  let formattedLog = "";
  const lines = source3.split(/\r?\n/);
  const log3 = shaderLog.slice().sort((a2, b2) => a2.lineNum - b2.lineNum);
  switch (options?.showSourceCode || "no") {
    case "all":
      let currentMessage = 0;
      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
        while (log3.length > currentMessage && log3[currentMessage].lineNum === lineNum) {
          const message2 = log3[currentMessage++];
          formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
            ...options,
            inlineSource: false
          });
        }
      }
      return formattedLog;
    case "issues":
    case "no":
      for (const message2 of shaderLog) {
        formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
          inlineSource: options?.showSourceCode !== "no"
        });
      }
      return formattedLog;
  }
}
function formatCompilerMessage(message2, lines, lineNum, options) {
  if (options?.inlineSource) {
    const numberedLines = getNumberedLines(lines, lineNum);
    const positionIndicator = message2.linePos > 0 ? `${" ".repeat(message2.linePos + 5)}^^^
` : "";
    return `
${numberedLines}${positionIndicator}${message2.type.toUpperCase()}: ${message2.message}

`;
  }
  const color = message2.type === "error" ? "red" : "#8B4000";
  return options?.html ? `<div class='luma-compiler-log-error' style="color:${color};"><b> ${message2.type.toUpperCase()}: ${message2.message}</b></div>` : `${message2.type.toUpperCase()}: ${message2.message}`;
}
function getNumberedLines(lines, lineNum, options) {
  let numberedLines = "";
  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
    const sourceLine = lines[lineIndex - 1];
    if (sourceLine !== void 0) {
      numberedLines += getNumberedLine(sourceLine, lineNum, options);
    }
  }
  return numberedLines;
}
function getNumberedLine(line, lineNum, options) {
  const escapedLine = options?.html ? escapeHTML(line) : line;
  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? "<br/>" : "\n"}`;
}
function padLeft(string, paddedLength) {
  let result = "";
  for (let i3 = string.length; i3 < paddedLength; ++i3) {
    result += " ";
  }
  return result + string;
}
function escapeHTML(unsafe) {
  return unsafe.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}

// node_modules/@luma.gl/core/dist/adapter/resources/shader.js
var _Shader = class _Shader extends Resource {
  /** Create a new Shader instance */
  constructor(device, props) {
    props = { ...props, debugShaders: props.debugShaders || device.props.debugShaders || "errors" };
    super(device, { id: getShaderIdFromProps(props), ...props }, _Shader.defaultProps);
    /** The stage of this shader */
    __publicField(this, "stage");
    /** The source code of this shader */
    __publicField(this, "source");
    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
    __publicField(this, "compilationStatus", "pending");
    this.stage = this.props.stage;
    this.source = this.props.source;
  }
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader() {
    const trigger = this.props.debugShaders;
    switch (trigger) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success") {
          return;
        }
        break;
      case "warnings":
      case "always":
        break;
    }
    const messages2 = await this.getCompilationInfo();
    if (trigger === "warnings" && messages2?.length === 0) {
      return;
    }
    this._displayShaderLog(messages2);
  }
  // PRIVATE
  /**
   * In-browser UI logging of errors
   * TODO - this HTML formatting code should not be in Device, should be pluggable
   */
  _displayShaderLog(messages2) {
    if (typeof document === "undefined" || !document?.createElement) {
      return;
    }
    const shaderName = getShaderName2(this.source);
    const shaderTitle = `${this.stage} ${shaderName}`;
    let htmlLog = formatCompilerLog(messages2, this.source, { showSourceCode: "all", html: true });
    const translatedSource = this.getTranslatedSource();
    if (translatedSource) {
      htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${translatedSource}</pre></code>`;
    }
    const button = document.createElement("Button");
    button.innerHTML = `
<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
    button.style.top = "10px";
    button.style.left = "10px";
    button.style.position = "absolute";
    button.style.zIndex = "9999";
    button.style.width = "100%";
    button.style.textAlign = "left";
    document.body.appendChild(button);
    const errors = document.getElementsByClassName("luma-compiler-log-error");
    errors[0]?.scrollIntoView();
    button.onclick = () => {
      const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(dataURI);
    };
  }
};
__publicField(_Shader, "defaultProps", {
  ...Resource.defaultProps,
  language: "auto",
  stage: void 0,
  source: "",
  sourceMap: null,
  entryPoint: "main",
  debugShaders: void 0
});
var Shader = _Shader;
function getShaderIdFromProps(props) {
  return getShaderName2(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);
}
function getShaderName2(shader, defaultName = "unnamed") {
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = SHADER_NAME_REGEXP.exec(shader);
  return match ? match[1] : defaultName;
}

// node_modules/@luma.gl/core/dist/adapter/resources/sampler.js
var _Sampler = class _Sampler extends Resource {
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(device, props) {
    props = _Sampler.normalizeProps(device, props);
    super(device, props, _Sampler.defaultProps);
  }
  static normalizeProps(device, props) {
    const overriddenDefaultProps = device?.props?._resourceDefaults?.sampler || {};
    const newProps = { ...props, ...overriddenDefaultProps };
    return newProps;
  }
};
__publicField(_Sampler, "defaultProps", {
  ...Resource.defaultProps,
  type: "color-sampler",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge",
  addressModeW: "clamp-to-edge",
  magFilter: "nearest",
  minFilter: "nearest",
  mipmapFilter: "none",
  lodMinClamp: 0,
  lodMaxClamp: 32,
  // Per WebGPU spec
  compare: "less-equal",
  maxAnisotropy: 1
});
var Sampler = _Sampler;

// node_modules/@luma.gl/core/dist/adapter/resources/framebuffer.js
var _Framebuffer = class _Framebuffer extends Resource {
  constructor(device, props = {}) {
    super(device, props, _Framebuffer.defaultProps);
    /** Width of all attachments in this framebuffer */
    __publicField(this, "width");
    /** Height of all attachments in this framebuffer */
    __publicField(this, "height");
    this.width = this.props.width;
    this.height = this.props.height;
  }
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /**
   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
   * @note Does not copy contents of the attached textures.
   */
  clone(size) {
    const colorAttachments = this.colorAttachments.map((colorAttachment) => colorAttachment.texture.clone(size));
    const depthStencilAttachment = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(size);
    return this.device.createFramebuffer({ ...this.props, colorAttachments, depthStencilAttachment });
  }
  resize(size) {
    let updateSize = !size;
    if (size) {
      const [width, height] = Array.isArray(size) ? size : [size.width, size.height];
      updateSize = updateSize || height !== this.height || width !== this.width;
      this.width = width;
      this.height = height;
    }
    if (updateSize) {
      log2.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
      this.resizeAttachments(this.width, this.height);
    }
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {
      throw new Error("Framebuffer has noattachments");
    }
    this.colorAttachments = this.props.colorAttachments.map((attachment2, index) => {
      if (typeof attachment2 === "string") {
        const texture = this.createColorTexture(attachment2, index);
        this.attachResource(texture);
        return texture.view;
      }
      if (attachment2 instanceof Texture) {
        return attachment2.view;
      }
      return attachment2;
    });
    const attachment = this.props.depthStencilAttachment;
    if (attachment) {
      if (typeof attachment === "string") {
        const texture = this.createDepthStencilTexture(attachment);
        this.attachResource(texture);
        this.depthStencilAttachment = texture.view;
      } else if (attachment instanceof Texture) {
        this.depthStencilAttachment = attachment.view;
      } else {
        this.depthStencilAttachment = attachment;
      }
    }
  }
  /** Create a color texture */
  createColorTexture(format, index) {
    return this.device.createTexture({
      id: `${this.id}-color-attachment-${index}`,
      usage: Texture.RENDER_ATTACHMENT,
      format,
      width: this.width,
      height: this.height,
      // TODO deprecated? - luma.gl v8 compatibility
      sampler: {
        magFilter: "linear",
        minFilter: "linear"
      }
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(format) {
    return this.device.createTexture({
      id: `${this.id}-depth-stencil-attachment`,
      usage: Texture.RENDER_ATTACHMENT,
      format,
      width: this.width,
      height: this.height,
      mipmaps: false
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(width, height) {
    for (let i3 = 0; i3 < this.colorAttachments.length; ++i3) {
      if (this.colorAttachments[i3]) {
        const resizedTexture = this.colorAttachments[i3].texture.clone({
          width,
          height
        });
        this.destroyAttachedResource(this.colorAttachments[i3]);
        this.colorAttachments[i3] = resizedTexture.view;
        this.attachResource(resizedTexture.view);
      }
    }
    if (this.depthStencilAttachment) {
      const resizedTexture = this.depthStencilAttachment.texture.clone({
        width,
        height
      });
      this.destroyAttachedResource(this.depthStencilAttachment);
      this.depthStencilAttachment = resizedTexture.view;
      this.attachResource(resizedTexture);
    }
    this.updateAttachments();
  }
};
__publicField(_Framebuffer, "defaultProps", {
  ...Resource.defaultProps,
  width: 1,
  height: 1,
  colorAttachments: [],
  // ['rgba8unorm'],
  depthStencilAttachment: null
  // 'depth24plus-stencil8'
});
var Framebuffer = _Framebuffer;

// node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js
var _RenderPipeline = class _RenderPipeline extends Resource {
  constructor(device, props) {
    super(device, props, _RenderPipeline.defaultProps);
    /** The merged layout */
    __publicField(this, "shaderLayout");
    /** Buffer map describing buffer interleaving etc */
    __publicField(this, "bufferLayout");
    /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
    __publicField(this, "linkStatus", "pending");
    /** The hash of the pipeline */
    __publicField(this, "hash", "");
    this.shaderLayout = this.props.shaderLayout;
    this.bufferLayout = this.props.bufferLayout || [];
  }
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(uniforms) {
    throw new Error("Use uniform blocks");
  }
};
__publicField(_RenderPipeline, "defaultProps", {
  ...Resource.defaultProps,
  vs: null,
  vertexEntryPoint: "vertexMain",
  vsConstants: {},
  fs: null,
  fragmentEntryPoint: "fragmentMain",
  fsConstants: {},
  shaderLayout: null,
  bufferLayout: [],
  topology: "triangle-list",
  parameters: {},
  // isInstanced: false,
  // instanceCount: 0,
  // vertexCount: 0,
  bindings: {},
  uniforms: {}
});
var RenderPipeline = _RenderPipeline;

// node_modules/@luma.gl/core/dist/adapter/resources/render-pass.js
var _RenderPass = class _RenderPass extends Resource {
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(device, props) {
    props = _RenderPass.normalizeProps(device, props);
    super(device, props, _RenderPass.defaultProps);
  }
  static normalizeProps(device, props) {
    const overriddenDefaultProps = device.props._resourceDefaults?.renderPass;
    const newProps = { ...overriddenDefaultProps, ...props };
    return newProps;
  }
};
/** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
__publicField(_RenderPass, "defaultClearColor", [0, 0, 0, 1]);
/** Depth 1.0 represents the far plance */
__publicField(_RenderPass, "defaultClearDepth", 1);
/** Clears all stencil bits */
__publicField(_RenderPass, "defaultClearStencil", 0);
/** Default properties for RenderPass */
__publicField(_RenderPass, "defaultProps", {
  ...Resource.defaultProps,
  framebuffer: null,
  parameters: void 0,
  clearColor: _RenderPass.defaultClearColor,
  clearColors: void 0,
  clearDepth: _RenderPass.defaultClearDepth,
  clearStencil: _RenderPass.defaultClearStencil,
  depthReadOnly: false,
  stencilReadOnly: false,
  discard: false,
  occlusionQuerySet: void 0,
  timestampQuerySet: void 0,
  beginTimestampIndex: void 0,
  endTimestampIndex: void 0
});
var RenderPass = _RenderPass;

// node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js
var _ComputePipeline = class _ComputePipeline extends Resource {
  constructor(device, props) {
    super(device, props, _ComputePipeline.defaultProps);
    __publicField(this, "hash", "");
    /** The merged shader layout */
    __publicField(this, "shaderLayout");
    this.shaderLayout = props.shaderLayout;
  }
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
};
__publicField(_ComputePipeline, "defaultProps", {
  ...Resource.defaultProps,
  shader: void 0,
  entryPoint: void 0,
  constants: {},
  shaderLayout: void 0
});
var ComputePipeline = _ComputePipeline;

// node_modules/@luma.gl/core/dist/adapter/resources/command-encoder.js
var _CommandEncoder = class _CommandEncoder extends Resource {
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(device, props) {
    super(device, props, _CommandEncoder.defaultProps);
  }
};
__publicField(_CommandEncoder, "defaultProps", {
  ...Resource.defaultProps,
  measureExecutionTime: void 0
});
var CommandEncoder = _CommandEncoder;

// node_modules/@luma.gl/core/dist/adapter/resources/command-buffer.js
var _CommandBuffer = class _CommandBuffer extends Resource {
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(device, props) {
    super(device, props, _CommandBuffer.defaultProps);
  }
};
__publicField(_CommandBuffer, "defaultProps", {
  ...Resource.defaultProps
});
var CommandBuffer = _CommandBuffer;

// node_modules/@luma.gl/core/dist/gpu-type-utils/decode-attribute-type.js
function decodeShaderAttributeType(attributeType) {
  const [dataType, components] = TYPE_INFO[attributeType];
  const integer = dataType === "i32" || dataType === "u32";
  const signed = dataType !== "u32";
  const byteLength = TYPE_SIZES2[dataType] * components;
  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
  return {
    dataType,
    components,
    defaultVertexFormat,
    byteLength,
    integer,
    signed
  };
}
function getCompatibleVertexFormat(dataType, components) {
  let vertexType;
  switch (dataType) {
    case "f32":
      vertexType = "float32";
      break;
    case "i32":
      vertexType = "sint32";
      break;
    case "u32":
      vertexType = "uint32";
      break;
    case "f16":
      return components <= 2 ? "float16x2" : "float16x4";
  }
  if (components === 1) {
    return vertexType;
  }
  return `${vertexType}x${components}`;
}
var TYPE_INFO = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
};
var TYPE_SIZES2 = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};

// node_modules/@luma.gl/core/dist/gpu-type-utils/decode-vertex-format.js
function decodeVertexFormat(format) {
  let webglOnly;
  if (format.endsWith("-webgl")) {
    format.replace("-webgl", "");
    webglOnly = true;
  }
  const [type_, count2] = format.split("x");
  const type = type_;
  const components = count2 ? parseInt(count2) : 1;
  const decodedType = decodeVertexType(type);
  const result = {
    type,
    components,
    byteLength: decodedType.byteLength * components,
    integer: decodedType.integer,
    signed: decodedType.signed,
    normalized: decodedType.normalized
  };
  if (webglOnly) {
    result.webglOnly = true;
  }
  return result;
}

// node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js
function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
  const attributeInfos = {};
  for (const attribute of shaderLayout.attributes) {
    const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
    if (attributeInfo) {
      attributeInfos[attribute.name] = attributeInfo;
    }
  }
  return attributeInfos;
}
function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
  const locationInfos = new Array(maxVertexAttributes).fill(null);
  for (const attributeInfo of Object.values(attributeInfos)) {
    locationInfos[attributeInfo.location] = attributeInfo;
  }
  return locationInfos;
}
function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name2) {
  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name2);
  const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name2);
  if (!shaderDeclaration) {
    return null;
  }
  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
  const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
  const vertexFormatInfo = decodeVertexFormat(vertexFormat);
  return {
    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
    location: shaderDeclaration.location,
    shaderType: shaderDeclaration.type,
    shaderDataType: attributeTypeInfo.dataType,
    shaderComponents: attributeTypeInfo.components,
    vertexFormat,
    bufferDataType: vertexFormatInfo.type,
    bufferComponents: vertexFormatInfo.components,
    // normalized is a property of the buffer's vertex format
    normalized: vertexFormatInfo.normalized,
    // integer is a property of the shader declaration
    integer: attributeTypeInfo.integer,
    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || "vertex",
    byteOffset: bufferMapping?.byteOffset || 0,
    byteStride: bufferMapping?.byteStride || 0
  };
}
function getAttributeFromShaderLayout(shaderLayout, name2) {
  const attribute = shaderLayout.attributes.find((attr) => attr.name === name2);
  if (!attribute) {
    log2.warn(`shader layout attribute "${name2}" not present in shader`);
  }
  return attribute || null;
}
function getAttributeFromBufferLayout(bufferLayouts, name2) {
  checkBufferLayouts(bufferLayouts);
  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name2);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name2);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  log2.warn(`layout for attribute "${name2}" not present in buffer layout`);
  return null;
}
function checkBufferLayouts(bufferLayouts) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
      log2.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
    }
  }
}
function getAttributeFromShortHand(bufferLayouts, name2) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.format && bufferLayout.name === name2) {
      return {
        attributeName: bufferLayout.name,
        bufferName: name2,
        stepMode: bufferLayout.stepMode,
        vertexFormat: bufferLayout.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: bufferLayout.byteStride || 0
      };
    }
  }
  return null;
}
function getAttributeFromAttributesList(bufferLayouts, name2) {
  for (const bufferLayout of bufferLayouts) {
    let byteStride = bufferLayout.byteStride;
    if (typeof bufferLayout.byteStride !== "number") {
      for (const attributeMapping2 of bufferLayout.attributes || []) {
        const info = decodeVertexFormat(attributeMapping2.format);
        byteStride += info.byteLength;
      }
    }
    const attributeMapping = bufferLayout.attributes?.find((mapping) => mapping.attribute === name2);
    if (attributeMapping) {
      return {
        attributeName: attributeMapping.attribute,
        bufferName: bufferLayout.name,
        stepMode: bufferLayout.stepMode,
        vertexFormat: attributeMapping.format,
        byteOffset: attributeMapping.byteOffset,
        // @ts-ignore
        byteStride
      };
    }
  }
  return null;
}

// node_modules/@luma.gl/core/dist/adapter/resources/vertex-array.js
var _VertexArray = class _VertexArray extends Resource {
  constructor(device, props) {
    super(device, props, _VertexArray.defaultProps);
    /** Max number of vertex attributes */
    __publicField(this, "maxVertexAttributes");
    /** Attribute infos indexed by location - TODO only needed by webgl module? */
    __publicField(this, "attributeInfos");
    /** Index buffer */
    __publicField(this, "indexBuffer", null);
    /** Attributes indexed by buffer slot */
    __publicField(this, "attributes");
    this.maxVertexAttributes = device.limits.maxVertexAttributes;
    this.attributes = new Array(this.maxVertexAttributes).fill(null);
    const { shaderLayout, bufferLayout } = props.renderPipeline || {};
    if (!shaderLayout || !bufferLayout) {
      throw new Error("VertexArray");
    }
    this.attributeInfos = getAttributeInfosByLocation(shaderLayout, bufferLayout, this.maxVertexAttributes);
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(location, value) {
    this.device.reportError(new Error("constant attributes not supported"));
  }
};
__publicField(_VertexArray, "defaultProps", {
  ...Resource.defaultProps,
  renderPipeline: null
});
var VertexArray = _VertexArray;

// node_modules/@luma.gl/core/dist/adapter/resources/transform-feedback.js
var _TransformFeedback = class _TransformFeedback extends Resource {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(device, props) {
    super(device, props, _TransformFeedback.defaultProps);
  }
};
__publicField(_TransformFeedback, "defaultProps", {
  ...Resource.defaultProps,
  layout: void 0,
  buffers: {}
});
var TransformFeedback = _TransformFeedback;

// node_modules/@luma.gl/core/dist/adapter/resources/query-set.js
var _QuerySet = class _QuerySet extends Resource {
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(device, props) {
    super(device, props, _QuerySet.defaultProps);
  }
};
__publicField(_QuerySet, "defaultProps", {
  ...Resource.defaultProps,
  type: void 0,
  count: void 0
});
var QuerySet = _QuerySet;

// node_modules/@luma.gl/core/dist/gpu-type-utils/decode-shader-types.js
var UNIFORM_FORMATS = {
  f32: { type: "f32", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 }
};
function decodeShaderUniformType(format) {
  const decoded = UNIFORM_FORMATS[format];
  return decoded;
}
function alignTo(size, count2) {
  switch (count2) {
    case 1:
      return size;
    case 2:
      return size + size % 2;
    default:
      return size + (4 - size % 4) % 4;
  }
}

// node_modules/@luma.gl/core/dist/utils/array-utils-flat.js
var arrayBuffer;
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type, length5) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length5);
  return new Type(scratchArrayBuffer, 0, length5);
}

// node_modules/@luma.gl/core/dist/utils/is-array.js
function isTypedArray(value) {
  return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function isNumberArray(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || typeof value[0] === "number";
  }
  return isTypedArray(value);
}

// node_modules/@luma.gl/core/dist/portable/uniform-buffer-layout.js
var minBufferSize = 1024;
var UniformBufferLayout = class {
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(uniformTypes) {
    __publicField(this, "layout", {});
    /** number of bytes needed for buffer allocation */
    __publicField(this, "byteLength");
    let size = 0;
    for (const [key, uniformType] of Object.entries(uniformTypes)) {
      const typeAndComponents = decodeShaderUniformType(uniformType);
      const { type, components: count2 } = typeAndComponents;
      size = alignTo(size, count2);
      const offset = size;
      size += count2;
      this.layout[key] = { type, size: count2, offset };
    }
    size += (4 - size % 4) % 4;
    const actualByteLength = size * 4;
    this.byteLength = Math.max(actualByteLength, minBufferSize);
  }
  /** Get the data for the complete buffer */
  getData(uniformValues) {
    const bufferSize = Math.max(this.byteLength, minBufferSize);
    const arrayBuffer2 = getScratchArrayBuffer(bufferSize);
    const typedArrays = {
      i32: new Int32Array(arrayBuffer2),
      u32: new Uint32Array(arrayBuffer2),
      f32: new Float32Array(arrayBuffer2),
      // TODO not implemented
      f16: new Uint16Array(arrayBuffer2)
    };
    for (const [name2, value] of Object.entries(uniformValues)) {
      const uniformLayout = this.layout[name2];
      if (!uniformLayout) {
        log2.warn(`Supplied uniform value ${name2} not present in uniform block layout`)();
        continue;
      }
      const { type, size, offset } = uniformLayout;
      const typedArray = typedArrays[type];
      if (size === 1) {
        if (typeof value !== "number" && typeof value !== "boolean") {
          log2.warn(`Supplied value for single component uniform ${name2} is not a number: ${value}`)();
          continue;
        }
        typedArray[offset] = Number(value);
      } else {
        if (!isNumberArray(value)) {
          log2.warn(`Supplied value for multi component / array uniform ${name2} is not a numeric array: ${value}`)();
          continue;
        }
        typedArray.set(value, offset);
      }
    }
    return new Uint8Array(arrayBuffer2);
  }
  /** Does this layout have a field with specified name */
  has(name2) {
    return Boolean(this.layout[name2]);
  }
  /** Get offset and size for a field with specified name */
  get(name2) {
    const layout = this.layout[name2];
    return layout;
  }
};

// node_modules/@luma.gl/core/dist/utils/array-equal.js
function arrayEqual(a2, b2, limit = 16) {
  if (a2 !== b2) {
    return false;
  }
  const arrayA = a2;
  const arrayB = b2;
  if (!isNumberArray(arrayA)) {
    return false;
  }
  if (isNumberArray(arrayB) && arrayA.length === arrayB.length) {
    for (let i3 = 0; i3 < arrayA.length; ++i3) {
      if (arrayB[i3] !== arrayA[i3]) {
        return false;
      }
    }
  }
  return true;
}
function arrayCopy(a2) {
  if (isNumberArray(a2)) {
    return a2.slice();
  }
  return a2;
}

// node_modules/@luma.gl/core/dist/portable/uniform-block.js
var UniformBlock = class {
  constructor(props) {
    __publicField(this, "name");
    __publicField(this, "uniforms", {});
    __publicField(this, "modifiedUniforms", {});
    __publicField(this, "modified", true);
    __publicField(this, "bindingLayout", {});
    __publicField(this, "needsRedraw", "initialized");
    this.name = props?.name || "unnamed";
    if (props?.name && props?.shaderLayout) {
      const binding = props?.shaderLayout.bindings?.find((binding_) => binding_.type === "uniform" && binding_.name === props?.name);
      if (!binding) {
        throw new Error(props?.name);
      }
      const uniformBlock11 = binding;
      for (const uniform of uniformBlock11.uniforms || []) {
        this.bindingLayout[uniform.name] = uniform;
      }
    }
  }
  /** Set a map of uniforms */
  setUniforms(uniforms) {
    for (const [key, value] of Object.entries(uniforms)) {
      this._setUniform(key, value);
      if (!this.needsRedraw) {
        this.setNeedsRedraw(`${this.name}.${key}=${value}`);
      }
    }
  }
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    this.modifiedUniforms = {};
    this.needsRedraw = false;
    return this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(key, value) {
    if (arrayEqual(this.uniforms[key], value)) {
      return;
    }
    this.uniforms[key] = arrayCopy(value);
    this.modifiedUniforms[key] = true;
    this.modified = true;
  }
};

// node_modules/@luma.gl/core/dist/portable/uniform-store.js
var UniformStore = class {
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(blocks) {
    /** Stores the uniform values for each uniform block */
    __publicField(this, "uniformBlocks", /* @__PURE__ */ new Map());
    /** Can generate data for a uniform buffer for each block from data */
    __publicField(this, "uniformBufferLayouts", /* @__PURE__ */ new Map());
    /** Actual buffer for the blocks */
    __publicField(this, "uniformBuffers", /* @__PURE__ */ new Map());
    for (const [bufferName, block] of Object.entries(blocks)) {
      const uniformBufferName = bufferName;
      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});
      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
      const uniformBlock11 = new UniformBlock({ name: bufferName });
      uniformBlock11.setUniforms(block.defaultUniforms || {});
      this.uniformBlocks.set(uniformBufferName, uniformBlock11);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const uniformBuffer of this.uniformBuffers.values()) {
      uniformBuffer.destroy();
    }
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(uniforms) {
    for (const [blockName, uniformValues] of Object.entries(uniforms)) {
      this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);
    }
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(uniformBufferName) {
    return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(uniformBufferName) {
    const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};
    return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(device, uniformBufferName, uniforms) {
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    const byteLength = this.getUniformBufferByteLength(uniformBufferName);
    const uniformBuffer = device.createBuffer({
      usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
      byteLength
    });
    const uniformBufferData = this.getUniformBufferData(uniformBufferName);
    uniformBuffer.write(uniformBufferData);
    return uniformBuffer;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(device, uniformBufferName) {
    if (!this.uniformBuffers.get(uniformBufferName)) {
      const byteLength = this.getUniformBufferByteLength(uniformBufferName);
      const uniformBuffer = device.createBuffer({
        usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
        byteLength
      });
      this.uniformBuffers.set(uniformBufferName, uniformBuffer);
    }
    return this.uniformBuffers.get(uniformBufferName);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let reason = false;
    for (const uniformBufferName of this.uniformBlocks.keys()) {
      const bufferReason = this.updateUniformBuffer(uniformBufferName);
      reason || (reason = bufferReason);
    }
    if (reason) {
      log2.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
    }
    return reason;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(uniformBufferName) {
    const uniformBlock11 = this.uniformBlocks.get(uniformBufferName);
    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);
    let reason = false;
    if (uniformBuffer && uniformBlock11?.needsRedraw) {
      reason || (reason = uniformBlock11.needsRedraw);
      const uniformBufferData = this.getUniformBufferData(uniformBufferName);
      uniformBuffer = this.uniformBuffers.get(uniformBufferName);
      uniformBuffer?.write(uniformBufferData);
      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();
      log2.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
    }
    return reason;
  }
};

// node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js
function getDataTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(type.constructor.name);
  }
}
function getTypedArrayFromDataType(dataType) {
  switch (dataType) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(dataType);
  }
}
function getVertexFormatFromAttribute(typedArray, size, normalized) {
  if (!size || size > 4) {
    throw new Error(`size ${size}`);
  }
  const components = size;
  let dataType = getDataTypeFromTypedArray(typedArray);
  if (dataType === "uint8" && normalized && components === 1) {
    return "unorm8-webgl";
  }
  if (dataType === "uint8" && normalized && components === 3) {
    return "unorm8x3-webgl";
  }
  if (dataType === "uint8" || dataType === "sint8") {
    if (components === 1 || components === 3) {
      throw new Error(`size: ${size}`);
    }
    if (normalized) {
      dataType = dataType.replace("int", "norm");
    }
    return `${dataType}x${components}`;
  }
  if (dataType === "uint16" || dataType === "sint16") {
    if (components === 1 || components === 3) {
      throw new Error(`size: ${size}`);
    }
    if (normalized) {
      dataType = dataType.replace("int", "norm");
    }
    return `${dataType}x${components}`;
  }
  if (components === 1) {
    return dataType;
  }
  return `${dataType}x${components}`;
}

// node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js
var BufferLayoutHelper = class {
  constructor(bufferLayouts) {
    __publicField(this, "bufferLayouts");
    this.bufferLayouts = bufferLayouts;
  }
  getBufferLayout(name2) {
    return this.bufferLayouts.find((layout) => layout.name === name2) || null;
  }
  /** Get attribute names from a BufferLayout */
  getAttributeNamesForBuffer(bufferLayout) {
    return bufferLayout.attributes ? bufferLayout.attributes?.map((layout) => layout.attribute) : [bufferLayout.name];
  }
  mergeBufferLayouts(bufferLayouts1, bufferLayouts2) {
    const mergedLayouts = [...bufferLayouts1];
    for (const attribute of bufferLayouts2) {
      const index = mergedLayouts.findIndex((attribute2) => attribute2.name === attribute.name);
      if (index < 0) {
        mergedLayouts.push(attribute);
      } else {
        mergedLayouts[index] = attribute;
      }
    }
    return mergedLayouts;
  }
  getBufferIndex(bufferName) {
    const bufferIndex = this.bufferLayouts.findIndex((layout) => layout.name === bufferName);
    if (bufferIndex === -1) {
      log2.warn(`BufferLayout: Missing buffer for "${bufferName}".`)();
    }
    return bufferIndex;
  }
};

// node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-order.js
function sortedBufferLayoutByShaderSourceLocations(shaderLayout, bufferLayout) {
  const shaderLayoutMap = Object.fromEntries(shaderLayout.attributes.map((attr) => [attr.name, attr.location]));
  const sortedLayout = bufferLayout.slice();
  sortedLayout.sort((a2, b2) => {
    const attributeNamesA = a2.attributes ? a2.attributes.map((attr) => attr.attribute) : [a2.name];
    const attributeNamesB = b2.attributes ? b2.attributes.map((attr) => attr.attribute) : [b2.name];
    const minLocationA = Math.min(...attributeNamesA.map((name2) => shaderLayoutMap[name2]));
    const minLocationB = Math.min(...attributeNamesB.map((name2) => shaderLayoutMap[name2]));
    return minLocationA - minLocationB;
  });
  return sortedLayout;
}

// node_modules/wgsl_reflect/wgsl_reflect.module.js
var e = class {
  constructor(e2, t2) {
    this.name = e2, this.attributes = t2, this.size = 0;
  }
  get isArray() {
    return false;
  }
  get isStruct() {
    return false;
  }
  get isTemplate() {
    return false;
  }
  get isPointer() {
    return false;
  }
  getTypeName() {
    return this.name;
  }
};
var t = class {
  constructor(e2, t2, n2) {
    this.name = e2, this.type = t2, this.attributes = n2, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
};
var n = class extends e {
  constructor(e2, t2) {
    super(e2, t2), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = false;
  }
  get isStruct() {
    return true;
  }
};
var s = class extends e {
  constructor(e2, t2) {
    super(e2, t2), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return true;
  }
  getTypeName() {
    return `array<${this.format.getTypeName()}, ${this.count}>`;
  }
};
var r = class extends e {
  constructor(e2, t2, n2) {
    super(e2, n2), this.format = t2;
  }
  get isPointer() {
    return true;
  }
  getTypeName() {
    return `&${this.format.getTypeName()}`;
  }
};
var a = class extends e {
  constructor(e2, t2, n2, s2) {
    super(e2, n2), this.format = t2, this.access = s2;
  }
  get isTemplate() {
    return true;
  }
  getTypeName() {
    let e2 = this.name;
    if (null !== this.format) {
      if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2 || "mat2x2" === e2 || "mat2x3" === e2 || "mat2x4" === e2 || "mat3x2" === e2 || "mat3x3" === e2 || "mat3x4" === e2 || "mat4x2" === e2 || "mat4x3" === e2 || "mat4x4" === e2) {
        if ("f32" === this.format.name)
          return e2 += "f", e2;
        if ("i32" === this.format.name)
          return e2 += "i", e2;
        if ("u32" === this.format.name)
          return e2 += "u", e2;
        if ("bool" === this.format.name)
          return e2 += "b", e2;
        if ("f16" === this.format.name)
          return e2 += "h", e2;
      }
      e2 += `<${this.format.name}>`;
    } else if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2)
      return e2;
    return e2;
  }
};
var i2;
((e2) => {
  e2[e2.Uniform = 0] = "Uniform", e2[e2.Storage = 1] = "Storage", e2[e2.Texture = 2] = "Texture", e2[e2.Sampler = 3] = "Sampler", e2[e2.StorageTexture = 4] = "StorageTexture";
})(i2 || (i2 = {}));
var o2 = class {
  constructor(e2, t2, n2, s2, r2, a2, i3) {
    this.name = e2, this.type = t2, this.group = n2, this.binding = s2, this.attributes = r2, this.resourceType = a2, this.access = i3;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
};
var c = class {
  constructor(e2, t2) {
    this.name = e2, this.type = t2;
  }
};
var l = class {
  constructor(e2, t2, n2, s2) {
    this.name = e2, this.type = t2, this.locationType = n2, this.location = s2, this.interpolation = null;
  }
};
var u = class {
  constructor(e2, t2, n2, s2) {
    this.name = e2, this.type = t2, this.locationType = n2, this.location = s2;
  }
};
var h = class {
  constructor(e2, t2, n2, s2) {
    this.name = e2, this.type = t2, this.attributes = n2, this.id = s2;
  }
};
var f = class {
  constructor(e2, t2, n2) {
    this.name = e2, this.type = t2, this.attributes = n2;
  }
};
var p = class {
  constructor(e2, t2 = null, n2) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = false, this.calls = /* @__PURE__ */ new Set(), this.name = e2, this.stage = t2, this.attributes = n2;
  }
};
var d = class {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
};
function m(e2) {
  var t2 = (32768 & e2) >> 15, n2 = (31744 & e2) >> 10, s2 = 1023 & e2;
  return 0 == n2 ? (t2 ? -1 : 1) * Math.pow(2, -14) * (s2 / Math.pow(2, 10)) : 31 == n2 ? s2 ? NaN : 1 / 0 * (t2 ? -1 : 1) : (t2 ? -1 : 1) * Math.pow(2, n2 - 15) * (1 + s2 / Math.pow(2, 10));
}
var g2 = new Float32Array(1);
var _ = new Int32Array(g2.buffer);
var x = new Uint16Array(1);
function y(e2) {
  g2[0] = e2;
  const t2 = _[0], n2 = t2 >> 31 & 1;
  let s2 = t2 >> 23 & 255, r2 = 8388607 & t2;
  if (255 === s2)
    return x[0] = n2 << 15 | 31744 | (0 !== r2 ? 512 : 0), x[0];
  if (0 === s2) {
    if (0 === r2)
      return x[0] = n2 << 15, x[0];
    r2 |= 8388608;
    let e3 = 113;
    for (; !(8388608 & r2); )
      r2 <<= 1, e3--;
    return s2 = 127 - e3, r2 &= 8388607, s2 > 0 ? (r2 = (r2 >> 126 - s2) + (r2 >> 127 - s2 & 1), x[0] = n2 << 15 | s2 << 10 | r2 >> 13, x[0]) : (x[0] = n2 << 15, x[0]);
  }
  return s2 = s2 - 127 + 15, s2 >= 31 ? (x[0] = n2 << 15 | 31744, x[0]) : s2 <= 0 ? s2 < -10 ? (x[0] = n2 << 15, x[0]) : (r2 = (8388608 | r2) >> 1 - s2, x[0] = n2 << 15 | r2 >> 13, x[0]) : (r2 >>= 13, x[0] = n2 << 15 | s2 << 10 | r2, x[0]);
}
var b = new Uint32Array(1);
var v = new Float32Array(b.buffer, 0, 1);
function w2(e2) {
  const t2 = 112 + (e2 >> 6 & 31) << 23 | (63 & e2) << 17;
  return b[0] = t2, v[0];
}
function k(e2, t2, n2, s2, r2, a2, i3, o3, c2) {
  const l2 = s2 * (i3 >>= r2) * (a2 >>= r2) + n2 * i3 + t2 * o3;
  switch (c2) {
    case "r8unorm":
      return [I2(e2, l2, "8unorm", 1)[0]];
    case "r8snorm":
      return [I2(e2, l2, "8snorm", 1)[0]];
    case "r8uint":
      return [I2(e2, l2, "8uint", 1)[0]];
    case "r8sint":
      return [I2(e2, l2, "8sint", 1)[0]];
    case "rg8unorm": {
      const t3 = I2(e2, l2, "8unorm", 2);
      return [t3[0], t3[1]];
    }
    case "rg8snorm": {
      const t3 = I2(e2, l2, "8snorm", 2);
      return [t3[0], t3[1]];
    }
    case "rg8uint": {
      const t3 = I2(e2, l2, "8uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg8sint": {
      const t3 = I2(e2, l2, "8sint", 2);
      return [t3[0], t3[1]];
    }
    case "rgba8unorm-srgb":
    case "rgba8unorm": {
      const t3 = I2(e2, l2, "8unorm", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8snorm": {
      const t3 = I2(e2, l2, "8snorm", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8uint": {
      const t3 = I2(e2, l2, "8uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba8sint": {
      const t3 = I2(e2, l2, "8sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "bgra8unorm-srgb":
    case "bgra8unorm": {
      const t3 = I2(e2, l2, "8unorm", 4);
      return [t3[2], t3[1], t3[0], t3[3]];
    }
    case "r16uint":
      return [I2(e2, l2, "16uint", 1)[0]];
    case "r16sint":
      return [I2(e2, l2, "16sint", 1)[0]];
    case "r16float":
      return [I2(e2, l2, "16float", 1)[0]];
    case "rg16uint": {
      const t3 = I2(e2, l2, "16uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg16sint": {
      const t3 = I2(e2, l2, "16sint", 2);
      return [t3[0], t3[1]];
    }
    case "rg16float": {
      const t3 = I2(e2, l2, "16float", 2);
      return [t3[0], t3[1]];
    }
    case "rgba16uint": {
      const t3 = I2(e2, l2, "16uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba16sint": {
      const t3 = I2(e2, l2, "16sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba16float": {
      const t3 = I2(e2, l2, "16float", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "r32uint":
      return [I2(e2, l2, "32uint", 1)[0]];
    case "r32sint":
      return [I2(e2, l2, "32sint", 1)[0]];
    case "depth16unorm":
    case "depth24plus":
    case "depth24plus-stencil8":
    case "depth32float":
    case "depth32float-stencil8":
    case "r32float":
      return [I2(e2, l2, "32float", 1)[0]];
    case "rg32uint": {
      const t3 = I2(e2, l2, "32uint", 2);
      return [t3[0], t3[1]];
    }
    case "rg32sint": {
      const t3 = I2(e2, l2, "32sint", 2);
      return [t3[0], t3[1]];
    }
    case "rg32float": {
      const t3 = I2(e2, l2, "32float", 2);
      return [t3[0], t3[1]];
    }
    case "rgba32uint": {
      const t3 = I2(e2, l2, "32uint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba32sint": {
      const t3 = I2(e2, l2, "32sint", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rgba32float": {
      const t3 = I2(e2, l2, "32float", 4);
      return [t3[0], t3[1], t3[2], t3[3]];
    }
    case "rg11b10ufloat": {
      const t3 = new Uint32Array(e2.buffer, l2, 1)[0], n3 = (4192256 & t3) >> 11, s3 = (4290772992 & t3) >> 22;
      return [w2(2047 & t3), w2(n3), function(e3) {
        const t4 = 112 + (e3 >> 5 & 31) << 23 | (31 & e3) << 18;
        return b[0] = t4, v[0];
      }(s3), 1];
    }
  }
  return null;
}
function I2(e2, t2, n2, s2) {
  const r2 = [0, 0, 0, 0];
  for (let a2 = 0; a2 < s2; ++a2)
    switch (n2) {
      case "8unorm":
        r2[a2] = e2[t2] / 255, t2++;
        break;
      case "8snorm":
        r2[a2] = e2[t2] / 255 * 2 - 1, t2++;
        break;
      case "8uint":
        r2[a2] = e2[t2], t2++;
        break;
      case "8sint":
        r2[a2] = e2[t2] - 127, t2++;
        break;
      case "16uint":
        r2[a2] = e2[t2] | e2[t2 + 1] << 8, t2 += 2;
        break;
      case "16sint":
        r2[a2] = (e2[t2] | e2[t2 + 1] << 8) - 32768, t2 += 2;
        break;
      case "16float":
        r2[a2] = m(e2[t2] | e2[t2 + 1] << 8), t2 += 2;
        break;
      case "32uint":
      case "32sint":
        r2[a2] = e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24, t2 += 4;
        break;
      case "32float":
        r2[a2] = new Float32Array(e2.buffer, t2, 1)[0], t2 += 4;
    }
  return r2;
}
function T(e2, t2, n2, s2, r2) {
  for (let a2 = 0; a2 < s2; ++a2)
    switch (n2) {
      case "8unorm":
        e2[t2] = 255 * r2[a2], t2++;
        break;
      case "8snorm":
        e2[t2] = 0.5 * (r2[a2] + 1) * 255, t2++;
        break;
      case "8uint":
        e2[t2] = r2[a2], t2++;
        break;
      case "8sint":
        e2[t2] = r2[a2] + 127, t2++;
        break;
      case "16uint":
        new Uint16Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 2;
        break;
      case "16sint":
        new Int16Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 2;
        break;
      case "16float": {
        const n3 = y(r2[a2]);
        new Uint16Array(e2.buffer, t2, 1)[0] = n3, t2 += 2;
        break;
      }
      case "32uint":
        new Uint32Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 4;
        break;
      case "32sint":
        new Int32Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 4;
        break;
      case "32float":
        new Float32Array(e2.buffer, t2, 1)[0] = r2[a2], t2 += 4;
    }
  return r2;
}
var S = { r8unorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8snorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8uint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r8sint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg8unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8snorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg8sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "rgba8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8snorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba8sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, bgra8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "bgra8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, r16uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r16sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r16float: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg16uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg16sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg16float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba16uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba16sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba16float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, r32uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r32sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, r32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 1 }, rg32uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg32sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rg32float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 2 }, rgba32uint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba32sint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgba32float: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgb10a2uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rgb10a2unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, rg11b10ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, stencil8: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: false, hasStencil: true, channels: 1 }, depth16unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, channels: 1 }, depth24plus: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, depthOnlyFormat: "depth32float", channels: 1 }, "depth24plus-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: true, depthOnlyFormat: "depth32float", channels: 1 }, depth32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: false, channels: 1 }, "depth32float-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: false, isDepthStencil: true, hasDepth: true, hasStencil: true, stencilOnlyFormat: "depth32float", channels: 1 }, rgb9e5ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: false, channels: 4 }, "bc1-rgba-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc1-rgba-unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc2-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc2-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc3-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc3-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc4-r-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 1 }, "bc4-r-snorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 1 }, "bc5-rg-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 2 }, "bc5-rg-snorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 2 }, "bc6h-rgb-ufloat": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc6h-rgb-float": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc7-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "bc7-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8a1unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgb8a1unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgba8unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "etc2-rgba8unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "eac-r11unorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 1 }, "eac-r11snorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 1 }, "eac-rg11unorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 2 }, "eac-rg11snorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: true, channels: 2 }, "astc-4x4-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-4x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x4-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: true, channels: 4 }, "astc-5x5-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-5x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x5-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-6x6-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-6x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x5-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-8x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-8x6-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-8x8-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-8x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x5-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-10x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: true, channels: 4 }, "astc-10x6-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-10x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: true, channels: 4 }, "astc-10x8-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: true, channels: 4 }, "astc-10x10-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-10x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x10-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: true, channels: 4 }, "astc-12x12-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: true, channels: 4 }, "astc-12x12-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: true, channels: 4 } };
var A2 = class _A {
  constructor() {
    this.id = _A._id++, this.line = 0;
  }
  get isAstNode() {
    return true;
  }
  get astNodeType() {
    return "";
  }
  search(e2) {
    e2(this);
  }
  searchBlock(e2, t2) {
    if (e2) {
      t2(E2.instance);
      for (const n2 of e2)
        n2 instanceof Array ? this.searchBlock(n2, t2) : n2.search(t2);
      t2($.instance);
    }
  }
  constEvaluate(e2, t2) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(e2) {
    return this.constEvaluate(e2).toString();
  }
};
A2._id = 0;
var E2 = class extends A2 {
};
E2.instance = new E2();
var $ = class extends A2 {
};
$.instance = new $();
var L = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
var C2 = class extends A2 {
  constructor() {
    super();
  }
};
var D2 = class extends C2 {
  constructor(e2, t2, n2, s2, r2, a2) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e2, this.args = t2, this.returnType = n2, this.body = s2, this.startLine = r2, this.endLine = a2;
  }
  get astNodeType() {
    return "function";
  }
  search(e2) {
    if (this.attributes)
      for (const t2 of this.attributes)
        e2(t2);
    e2(this);
    for (const t2 of this.args)
      e2(t2);
    this.searchBlock(this.body, e2);
  }
};
var N2 = class extends C2 {
  constructor(e2) {
    super(), this.expression = e2;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e2) {
    this.expression.search(e2);
  }
};
var V = class extends C2 {
  constructor(e2, t2) {
    super(), this.condition = e2, this.body = t2;
  }
  get astNodeType() {
    return "while";
  }
  search(e2) {
    this.condition.search(e2), this.searchBlock(this.body, e2);
  }
};
var O = class extends C2 {
  constructor(e2, t2) {
    super(), this.body = e2, this.loopId = t2;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e2) {
    this.searchBlock(this.body, e2);
  }
};
var B2 = class extends C2 {
  constructor(e2, t2, n2, s2) {
    super(), this.init = e2, this.condition = t2, this.increment = n2, this.body = s2;
  }
  get astNodeType() {
    return "for";
  }
  search(e2) {
    var t2, n2, s2;
    null === (t2 = this.init) || void 0 === t2 || t2.search(e2), null === (n2 = this.condition) || void 0 === n2 || n2.search(e2), null === (s2 = this.increment) || void 0 === s2 || s2.search(e2), this.searchBlock(this.body, e2);
  }
};
var F = class extends C2 {
  constructor(e2, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "var";
  }
  search(e2) {
    var t2;
    e2(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var M = class extends C2 {
  constructor(e2, t2, n2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.value = n2;
  }
  get astNodeType() {
    return "override";
  }
  search(e2) {
    var t2;
    null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var U = class extends C2 {
  constructor(e2, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "let";
  }
  search(e2) {
    var t2;
    e2(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var P = class extends C2 {
  constructor(e2, t2, n2, s2, r2) {
    super(), this.attributes = null, this.name = e2, this.type = t2, this.storage = n2, this.access = s2, this.value = r2;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(e2, t2) {
    return this.value.constEvaluate(e2, t2);
  }
  search(e2) {
    var t2;
    e2(this), null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var W;
var q;
var H;
var z;
((e2) => {
  e2.increment = "++", e2.decrement = "--";
})(W || (W = {})), ((e2) => {
  e2.parse = function(t2) {
    const n2 = t2;
    if ("parse" == n2)
      throw new Error("Invalid value for IncrementOperator");
    return e2[n2];
  };
})(W || (W = {}));
var R = class extends C2 {
  constructor(e2, t2) {
    super(), this.operator = e2, this.variable = t2;
  }
  get astNodeType() {
    return "increment";
  }
  search(e2) {
    this.variable.search(e2);
  }
};
((e2) => {
  e2.assign = "=", e2.addAssign = "+=", e2.subtractAssin = "-=", e2.multiplyAssign = "*=", e2.divideAssign = "/=", e2.moduloAssign = "%=", e2.andAssign = "&=", e2.orAssign = "|=", e2.xorAssign = "^=", e2.shiftLeftAssign = "<<=", e2.shiftRightAssign = ">>=";
})(q || (q = {})), ((e2) => {
  e2.parse = function(e3) {
    const t2 = e3;
    if ("parse" == t2)
      throw new Error("Invalid value for AssignOperator");
    return t2;
  };
})(q || (q = {}));
var G2 = class extends C2 {
  constructor(e2, t2, n2) {
    super(), this.operator = e2, this.variable = t2, this.value = n2;
  }
  get astNodeType() {
    return "assign";
  }
  search(e2) {
    this.variable.search(e2), this.value.search(e2);
  }
};
var X = class extends C2 {
  constructor(e2, t2) {
    super(), this.name = e2, this.args = t2;
  }
  get astNodeType() {
    return "call";
  }
  isBuiltin() {
    return L.has(this.name);
  }
  search(e2) {
    for (const t2 of this.args)
      t2.search(e2);
    e2(this);
  }
};
var j = class extends C2 {
  constructor(e2, t2) {
    super(), this.body = e2, this.continuing = t2;
  }
  get astNodeType() {
    return "loop";
  }
  search(e2) {
    var t2;
    this.searchBlock(this.body, e2), null === (t2 = this.continuing) || void 0 === t2 || t2.search(e2);
  }
};
var Z = class extends C2 {
  constructor(e2, t2) {
    super(), this.condition = e2, this.cases = t2;
  }
  get astNodeType() {
    return "switch";
  }
  search(e2) {
    e2(this);
    for (const t2 of this.cases)
      t2.search(e2);
  }
};
var Q2 = class extends C2 {
  constructor(e2, t2, n2, s2) {
    super(), this.condition = e2, this.body = t2, this.elseif = n2, this.else = s2;
  }
  get astNodeType() {
    return "if";
  }
  search(e2) {
    this.condition.search(e2), this.searchBlock(this.body, e2), this.searchBlock(this.elseif, e2), this.searchBlock(this.else, e2);
  }
};
var Y = class extends C2 {
  constructor(e2) {
    super(), this.value = e2;
  }
  get astNodeType() {
    return "return";
  }
  search(e2) {
    var t2;
    null === (t2 = this.value) || void 0 === t2 || t2.search(e2);
  }
};
var K = class extends C2 {
  constructor(e2) {
    super(), this.name = e2;
  }
  get astNodeType() {
    return "enable";
  }
};
var J = class extends C2 {
  constructor(e2) {
    super(), this.extensions = e2;
  }
  get astNodeType() {
    return "requires";
  }
};
var ee = class extends C2 {
  constructor(e2, t2) {
    super(), this.severity = e2, this.rule = t2;
  }
  get astNodeType() {
    return "diagnostic";
  }
};
var te = class extends C2 {
  constructor(e2, t2) {
    super(), this.name = e2, this.type = t2;
  }
  get astNodeType() {
    return "alias";
  }
};
var ne = class extends C2 {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
};
var se = class extends C2 {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
};
var re = class extends C2 {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
};
var ae = class _ae extends C2 {
  constructor(e2) {
    super(), this.attributes = null, this.name = e2;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return false;
  }
  get isArray() {
    return false;
  }
  static maxFormatType(e2) {
    let t2 = e2[0];
    if ("f32" === t2.name)
      return t2;
    for (let n2 = 1; n2 < e2.length; ++n2) {
      const s2 = _ae._priority.get(t2.name);
      _ae._priority.get(e2[n2].name) < s2 && (t2 = e2[n2]);
    }
    return "x32" === t2.name ? _ae.i32 : t2;
  }
  getTypeName() {
    return this.name;
  }
};
ae.x32 = new ae("x32"), ae.f32 = new ae("f32"), ae.i32 = new ae("i32"), ae.u32 = new ae("u32"), ae.f16 = new ae("f16"), ae.bool = new ae("bool"), ae.void = new ae("void"), ae._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
var ie = class extends ae {
  constructor(e2) {
    super(e2);
  }
};
var oe = class extends ae {
  constructor(e2, t2, n2, s2) {
    super(e2), this.members = t2, this.startLine = n2, this.endLine = s2;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return true;
  }
  getMemberIndex(e2) {
    for (let t2 = 0; t2 < this.members.length; t2++)
      if (this.members[t2].name == e2)
        return t2;
    return -1;
  }
  search(e2) {
    for (const t2 of this.members)
      e2(t2);
  }
};
var ce = class extends ae {
  constructor(e2, t2, n2) {
    super(e2), this.format = t2, this.access = n2;
  }
  get astNodeType() {
    return "template";
  }
  getTypeName() {
    let e2 = this.name;
    if (null !== this.format) {
      if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2 || "mat2x2" === e2 || "mat2x3" === e2 || "mat2x4" === e2 || "mat3x2" === e2 || "mat3x3" === e2 || "mat3x4" === e2 || "mat4x2" === e2 || "mat4x3" === e2 || "mat4x4" === e2) {
        if ("f32" === this.format.name)
          return e2 += "f", e2;
        if ("i32" === this.format.name)
          return e2 += "i", e2;
        if ("u32" === this.format.name)
          return e2 += "u", e2;
        if ("bool" === this.format.name)
          return e2 += "b", e2;
        if ("f16" === this.format.name)
          return e2 += "h", e2;
      }
      e2 += `<${this.format.name}>`;
    } else if ("vec2" === e2 || "vec3" === e2 || "vec4" === e2)
      return e2;
    return e2;
  }
};
ce.vec2f = new ce("vec2", ae.f32, null), ce.vec3f = new ce("vec3", ae.f32, null), ce.vec4f = new ce("vec4", ae.f32, null), ce.vec2i = new ce("vec2", ae.i32, null), ce.vec3i = new ce("vec3", ae.i32, null), ce.vec4i = new ce("vec4", ae.i32, null), ce.vec2u = new ce("vec2", ae.u32, null), ce.vec3u = new ce("vec3", ae.u32, null), ce.vec4u = new ce("vec4", ae.u32, null), ce.vec2h = new ce("vec2", ae.f16, null), ce.vec3h = new ce("vec3", ae.f16, null), ce.vec4h = new ce("vec4", ae.f16, null), ce.vec2b = new ce("vec2", ae.bool, null), ce.vec3b = new ce("vec3", ae.bool, null), ce.vec4b = new ce("vec4", ae.bool, null), ce.mat2x2f = new ce("mat2x2", ae.f32, null), ce.mat2x3f = new ce("mat2x3", ae.f32, null), ce.mat2x4f = new ce("mat2x4", ae.f32, null), ce.mat3x2f = new ce("mat3x2", ae.f32, null), ce.mat3x3f = new ce("mat3x3", ae.f32, null), ce.mat3x4f = new ce("mat3x4", ae.f32, null), ce.mat4x2f = new ce("mat4x2", ae.f32, null), ce.mat4x3f = new ce("mat4x3", ae.f32, null), ce.mat4x4f = new ce("mat4x4", ae.f32, null), ce.mat2x2h = new ce("mat2x2", ae.f16, null), ce.mat2x3h = new ce("mat2x3", ae.f16, null), ce.mat2x4h = new ce("mat2x4", ae.f16, null), ce.mat3x2h = new ce("mat3x2", ae.f16, null), ce.mat3x3h = new ce("mat3x3", ae.f16, null), ce.mat3x4h = new ce("mat3x4", ae.f16, null), ce.mat4x2h = new ce("mat4x2", ae.f16, null), ce.mat4x3h = new ce("mat4x3", ae.f16, null), ce.mat4x4h = new ce("mat4x4", ae.f16, null), ce.mat2x2i = new ce("mat2x2", ae.i32, null), ce.mat2x3i = new ce("mat2x3", ae.i32, null), ce.mat2x4i = new ce("mat2x4", ae.i32, null), ce.mat3x2i = new ce("mat3x2", ae.i32, null), ce.mat3x3i = new ce("mat3x3", ae.i32, null), ce.mat3x4i = new ce("mat3x4", ae.i32, null), ce.mat4x2i = new ce("mat4x2", ae.i32, null), ce.mat4x3i = new ce("mat4x3", ae.i32, null), ce.mat4x4i = new ce("mat4x4", ae.i32, null), ce.mat2x2u = new ce("mat2x2", ae.u32, null), ce.mat2x3u = new ce("mat2x3", ae.u32, null), ce.mat2x4u = new ce("mat2x4", ae.u32, null), ce.mat3x2u = new ce("mat3x2", ae.u32, null), ce.mat3x3u = new ce("mat3x3", ae.u32, null), ce.mat3x4u = new ce("mat3x4", ae.u32, null), ce.mat4x2u = new ce("mat4x2", ae.u32, null), ce.mat4x3u = new ce("mat4x3", ae.u32, null), ce.mat4x4u = new ce("mat4x4", ae.u32, null);
var le = class extends ae {
  constructor(e2, t2, n2, s2) {
    super(e2), this.storage = t2, this.type = n2, this.access = s2;
  }
  get astNodeType() {
    return "pointer";
  }
};
var ue = class extends ae {
  constructor(e2, t2, n2, s2) {
    super(e2), this.attributes = t2, this.format = n2, this.count = s2;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return true;
  }
};
var he = class extends ae {
  constructor(e2, t2, n2) {
    super(e2), this.format = t2, this.access = n2;
  }
  get astNodeType() {
    return "sampler";
  }
};
var fe = class extends A2 {
  constructor() {
    super(), this.postfix = null;
  }
};
var pe = class extends fe {
  constructor(e2) {
    super(), this.value = e2;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
};
var de = class extends fe {
  constructor(e2, t2) {
    super(), this.type = e2, this.args = t2;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e2) {
    if (e2(this), this.args)
      for (const t2 of this.args)
        t2.search(e2);
  }
  constEvaluate(e2, t2) {
    return t2 && (t2[0] = this.type), e2.evalExpression(this, e2.context);
  }
};
var me = class extends fe {
  constructor(e2, t2) {
    super(), this.cachedReturnValue = null, this.name = e2, this.args = t2;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(e2) {
    this.cachedReturnValue = e2;
  }
  get isBuiltin() {
    return L.has(this.name);
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
  search(e2) {
    for (const t2 of this.args)
      t2.search(e2);
    e2(this);
  }
};
var ge = class extends fe {
  constructor(e2) {
    super(), this.name = e2;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e2) {
    e2(this), this.postfix && this.postfix.search(e2);
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
};
var _e = class extends fe {
  constructor(e2, t2) {
    super(), this.name = e2, this.initializer = t2;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(e2, t2) {
    if (this.initializer) {
      const t3 = e2.evalExpression(this.initializer, e2.context);
      return null !== t3 && this.postfix ? t3.getSubData(e2, this.postfix, e2.context) : t3;
    }
    return null;
  }
  search(e2) {
    this.initializer.search(e2);
  }
};
var xe = class extends fe {
  constructor(e2, t2) {
    super(), this.value = e2, this.type = t2;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(e2, t2) {
    return void 0 !== t2 && (t2[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof Be;
  }
  get isVector() {
    return this.value instanceof Me || this.value instanceof Ue;
  }
  get scalarValue() {
    return this.value instanceof Be ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof Me || this.value instanceof Ue ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
  }
};
var ye = class extends fe {
  constructor(e2, t2) {
    super(), this.type = e2, this.value = t2;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e2) {
    this.value.search(e2);
  }
};
var ve = class extends fe {
  constructor(e2) {
    super(), this.index = e2;
  }
  search(e2) {
    this.index.search(e2);
  }
};
var we = class extends fe {
  constructor() {
    super();
  }
};
var ke = class extends we {
  constructor(e2, t2) {
    super(), this.operator = e2, this.right = t2;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
  search(e2) {
    this.right.search(e2);
  }
};
var Ie = class extends we {
  constructor(e2, t2, n2) {
    super(), this.operator = e2, this.left = t2, this.right = n2;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(e2, t2) {
    return e2.name === t2.name ? e2 : "f32" === e2.name || "f32" === t2.name ? ae.f32 : "u32" === e2.name || "u32" === t2.name ? ae.u32 : ae.i32;
  }
  constEvaluate(e2, t2) {
    return e2.evalExpression(this, e2.context);
  }
  search(e2) {
    this.left.search(e2), this.right.search(e2);
  }
};
var Te = class extends A2 {
  constructor(e2) {
    super(), this.body = e2;
  }
  search(e2) {
    e2(this), this.searchBlock(this.body, e2);
  }
};
var Se = class extends fe {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
};
var Ae = class extends Te {
  constructor(e2, t2) {
    super(t2), this.selectors = e2;
  }
  get astNodeType() {
    return "case";
  }
  search(e2) {
    this.searchBlock(this.body, e2);
  }
};
var Ee = class extends Te {
  constructor(e2) {
    super(e2);
  }
  get astNodeType() {
    return "default";
  }
  search(e2) {
    this.searchBlock(this.body, e2);
  }
};
var $e = class extends A2 {
  constructor(e2, t2, n2) {
    super(), this.name = e2, this.type = t2, this.attributes = n2;
  }
  get astNodeType() {
    return "argument";
  }
};
var Le = class extends A2 {
  constructor(e2, t2) {
    super(), this.condition = e2, this.body = t2;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e2) {
    this.condition.search(e2), this.searchBlock(this.body, e2);
  }
};
var Ce = class extends A2 {
  constructor(e2, t2, n2) {
    super(), this.name = e2, this.type = t2, this.attributes = n2;
  }
  get astNodeType() {
    return "member";
  }
};
var De = class extends A2 {
  constructor(e2, t2) {
    super(), this.name = e2, this.value = t2;
  }
  get astNodeType() {
    return "attribute";
  }
};
var Ne = class _Ne {
  constructor(e2, t2) {
    this.parent = null, this.typeInfo = e2, this.parent = t2, this.id = _Ne._id++;
  }
  clone() {
    throw `Clone: Not implemented for ${this.constructor.name}`;
  }
  setDataValue(e2, t2, n2, s2) {
    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
  }
  getSubData(e2, t2, n2) {
    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
  }
  toString() {
    return `<${this.typeInfo.getTypeName()}>`;
  }
};
Ne._id = 0;
var Ve = class extends Ne {
  constructor() {
    super(new e("void", null), null);
  }
  toString() {
    return "void";
  }
};
Ve.void = new Ve();
var Oe = class extends Ne {
  constructor(e2) {
    super(new r("pointer", e2.typeInfo, null), null), this.reference = e2;
  }
  clone() {
    return this;
  }
  setDataValue(e2, t2, n2, s2) {
    this.reference.setDataValue(e2, t2, n2, s2);
  }
  getSubData(e2, t2, n2) {
    return t2 ? this.reference.getSubData(e2, t2, n2) : this;
  }
  toString() {
    return `&${this.reference.toString()}`;
  }
};
var Be = class _Be extends Ne {
  constructor(e2, t2, n2 = null) {
    super(t2, n2), e2 instanceof Int32Array || e2 instanceof Uint32Array || e2 instanceof Float32Array ? this.data = e2 : "x32" === this.typeInfo.name ? e2 - Math.floor(e2) !== 0 ? this.data = new Float32Array([e2]) : this.data = e2 >= 0 ? new Uint32Array([e2]) : new Int32Array([e2]) : "i32" === this.typeInfo.name || "bool" === this.typeInfo.name ? this.data = new Int32Array([e2]) : "u32" === this.typeInfo.name ? this.data = new Uint32Array([e2]) : "f32" === this.typeInfo.name || "f16" === this.typeInfo.name ? this.data = new Float32Array([e2]) : console.error("ScalarData2: Invalid type", t2);
  }
  clone() {
    if (this.data instanceof Float32Array)
      return new _Be(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array)
      return new _Be(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array)
      return new _Be(new Uint32Array(this.data), this.typeInfo, null);
    throw "ScalarData: Invalid data type";
  }
  get value() {
    return this.data[0];
  }
  set value(e2) {
    this.data[0] = e2;
  }
  setDataValue(e2, t2, n2, s2) {
    if (n2)
      return void console.error("SetDataValue: Scalar data does not support postfix", n2);
    if (!(t2 instanceof _Be))
      return void console.error("SetDataValue: Invalid value", t2);
    let r2 = t2.data[0];
    "i32" === this.typeInfo.name || "u32" === this.typeInfo.name ? r2 = Math.floor(r2) : "bool" === this.typeInfo.name && (r2 = r2 ? 1 : 0), this.data[0] = r2;
  }
  getSubData(e2, t2, n2) {
    return t2 ? (console.error("getSubData: Scalar data does not support postfix", t2), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
};
function Fe(e2, t2, n2) {
  const s2 = t2.length;
  return 2 === s2 ? "f32" === n2 ? new Me(new Float32Array(t2), e2.getTypeInfo("vec2f")) : "i32" === n2 || "bool" === n2 ? new Me(new Int32Array(t2), e2.getTypeInfo("vec2i")) : "u32" === n2 ? new Me(new Uint32Array(t2), e2.getTypeInfo("vec2u")) : "f16" === n2 ? new Me(new Float32Array(t2), e2.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : 3 === s2 ? "f32" === n2 ? new Me(new Float32Array(t2), e2.getTypeInfo("vec3f")) : "i32" === n2 || "bool" === n2 ? new Me(new Int32Array(t2), e2.getTypeInfo("vec3i")) : "u32" === n2 ? new Me(new Uint32Array(t2), e2.getTypeInfo("vec3u")) : "f16" === n2 ? new Me(new Float32Array(t2), e2.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : 4 === s2 ? "f32" === n2 ? new Me(new Float32Array(t2), e2.getTypeInfo("vec4f")) : "i32" === n2 || "bool" === n2 ? new Me(new Int32Array(t2), e2.getTypeInfo("vec4i")) : "u32" === n2 ? new Me(new Uint32Array(t2), e2.getTypeInfo("vec4u")) : "f16" === n2 ? new Me(new Float32Array(t2), e2.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${n2}`), null) : (console.error(`getSubData: Invalid vector size ${t2.length}`), null);
}
var Me = class _Me extends Ne {
  constructor(e2, t2, n2 = null) {
    if (super(t2, n2), e2 instanceof Float32Array || e2 instanceof Uint32Array || e2 instanceof Int32Array)
      this.data = e2;
    else {
      const t3 = this.typeInfo.name;
      "vec2f" === t3 || "vec3f" === t3 || "vec4f" === t3 ? this.data = new Float32Array(e2) : "vec2i" === t3 || "vec3i" === t3 || "vec4i" === t3 ? this.data = new Int32Array(e2) : "vec2u" === t3 || "vec3u" === t3 || "vec4u" === t3 ? this.data = new Uint32Array(e2) : "vec2h" === t3 || "vec3h" === t3 || "vec4h" === t3 ? this.data = new Float32Array(e2) : "vec2b" === t3 || "vec3b" === t3 || "vec4b" === t3 ? this.data = new Int32Array(e2) : "vec2" === t3 || "vec3" === t3 || "vec4" === t3 ? this.data = new Float32Array(e2) : console.error(`VectorData: Invalid type ${t3}`);
    }
  }
  clone() {
    if (this.data instanceof Float32Array)
      return new _Me(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array)
      return new _Me(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array)
      return new _Me(new Uint32Array(this.data), this.typeInfo, null);
    throw "VectorData: Invalid data type";
  }
  setDataValue(e2, t2, n2, s2) {
    n2 instanceof pe ? console.error("TODO: Set vector postfix") : t2 instanceof _Me ? this.data = t2.data : console.error("SetDataValue: Invalid value", t2);
  }
  getSubData(e2, t2, n2) {
    if (null === t2)
      return this;
    let s2 = e2.getTypeInfo("f32");
    if (this.typeInfo instanceof a)
      s2 = this.typeInfo.format || s2;
    else {
      const t3 = this.typeInfo.name;
      "vec2f" === t3 || "vec3f" === t3 || "vec4f" === t3 ? s2 = e2.getTypeInfo("f32") : "vec2i" === t3 || "vec3i" === t3 || "vec4i" === t3 ? s2 = e2.getTypeInfo("i32") : "vec2b" === t3 || "vec3b" === t3 || "vec4b" === t3 ? s2 = e2.getTypeInfo("bool") : "vec2u" === t3 || "vec3u" === t3 || "vec4u" === t3 ? s2 = e2.getTypeInfo("u32") : "vec2h" === t3 || "vec3h" === t3 || "vec4h" === t3 ? s2 = e2.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${t3}`);
    }
    let r2 = this;
    for (; null !== t2 && null !== r2; ) {
      if (t2 instanceof ve) {
        const a2 = t2.index;
        let i3 = -1;
        if (a2 instanceof xe) {
          if (!(a2.value instanceof Be))
            return console.error(`GetSubData: Invalid array index ${a2.value}`), null;
          i3 = a2.value.value;
        } else {
          const t3 = e2.evalExpression(a2, n2);
          if (!(t3 instanceof Be))
            return console.error("GetSubData: Unknown index type", a2), null;
          i3 = t3.value;
        }
        if (i3 < 0 || i3 >= r2.data.length)
          return console.error("GetSubData: Index out of range", i3), null;
        if (r2.data instanceof Float32Array) {
          const e3 = new Float32Array(r2.data.buffer, r2.data.byteOffset + 4 * i3, 1);
          return new Be(e3, s2);
        }
        if (r2.data instanceof Int32Array) {
          const e3 = new Int32Array(r2.data.buffer, r2.data.byteOffset + 4 * i3, 1);
          return new Be(e3, s2);
        }
        if (r2.data instanceof Uint32Array) {
          const e3 = new Uint32Array(r2.data.buffer, r2.data.byteOffset + 4 * i3, 1);
          return new Be(e3, s2);
        }
        throw "GetSubData: Invalid data type";
      }
      if (!(t2 instanceof pe))
        return console.error("GetSubData: Unknown postfix", t2), null;
      {
        const n3 = t2.value.toLowerCase();
        if (1 === n3.length) {
          let e3 = 0;
          if ("x" === n3 || "r" === n3)
            e3 = 0;
          else if ("y" === n3 || "g" === n3)
            e3 = 1;
          else if ("z" === n3 || "b" === n3)
            e3 = 2;
          else {
            if ("w" !== n3 && "a" !== n3)
              return console.error(`GetSubData: Unknown member ${n3}`), null;
            e3 = 3;
          }
          if (this.data instanceof Float32Array) {
            let t3 = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * e3, 1);
            return new Be(t3, s2, this);
          }
          if (this.data instanceof Int32Array) {
            let t3 = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * e3, 1);
            return new Be(t3, s2, this);
          }
          if (this.data instanceof Uint32Array) {
            let t3 = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * e3, 1);
            return new Be(t3, s2, this);
          }
        }
        const a2 = [];
        for (const e3 of n3)
          "x" === e3 || "r" === e3 ? a2.push(this.data[0]) : "y" === e3 || "g" === e3 ? a2.push(this.data[1]) : "z" === e3 || "b" === e3 ? a2.push(this.data[2]) : "w" === e3 || "a" === e3 ? a2.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${e3}`);
        r2 = Fe(e2, a2, s2.name);
      }
      t2 = t2.postfix;
    }
    return r2;
  }
  toString() {
    let e2 = `${this.data[0]}`;
    for (let t2 = 1; t2 < this.data.length; ++t2)
      e2 += `, ${this.data[t2]}`;
    return e2;
  }
};
var Ue = class _Ue extends Ne {
  constructor(e2, t2, n2 = null) {
    super(t2, n2), e2 instanceof Float32Array ? this.data = e2 : this.data = new Float32Array(e2);
  }
  clone() {
    return new _Ue(new Float32Array(this.data), this.typeInfo, null);
  }
  setDataValue(e2, t2, n2, s2) {
    n2 instanceof pe ? console.error("TODO: Set matrix postfix") : t2 instanceof _Ue ? this.data = t2.data : console.error("SetDataValue: Invalid value", t2);
  }
  getSubData(e2, t2, n2) {
    if (null === t2)
      return this;
    const s2 = this.typeInfo.name;
    if (e2.getTypeInfo("f32"), this.typeInfo instanceof a)
      this.typeInfo.format;
    else if (s2.endsWith("f"))
      e2.getTypeInfo("f32");
    else if (s2.endsWith("i"))
      e2.getTypeInfo("i32");
    else if (s2.endsWith("u"))
      e2.getTypeInfo("u32");
    else {
      if (!s2.endsWith("h"))
        return console.error(`GetDataValue: Unknown type ${s2}`), null;
      e2.getTypeInfo("f16");
    }
    if (t2 instanceof ve) {
      const r2 = t2.index;
      let a2 = -1;
      if (r2 instanceof xe) {
        if (!(r2.value instanceof Be))
          return console.error(`GetDataValue: Invalid array index ${r2.value}`), null;
        a2 = r2.value.value;
      } else {
        const t3 = e2.evalExpression(r2, n2);
        if (!(t3 instanceof Be))
          return console.error("GetDataValue: Unknown index type", r2), null;
        a2 = t3.value;
      }
      if (a2 < 0 || a2 >= this.data.length)
        return console.error("GetDataValue: Index out of range", a2), null;
      const i3 = s2.endsWith("h") ? "h" : "f";
      let o3;
      if ("mat2x2" === s2 || "mat2x2f" === s2 || "mat2x2h" === s2 || "mat3x2" === s2 || "mat3x2f" === s2 || "mat3x2h" === s2 || "mat4x2" === s2 || "mat4x2f" === s2 || "mat4x2h" === s2)
        o3 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * a2 * 4, 2), e2.getTypeInfo(`vec2${i3}`));
      else if ("mat2x3" === s2 || "mat2x3f" === s2 || "mat2x3h" === s2 || "mat3x3" === s2 || "mat3x3f" === s2 || "mat3x3h" === s2 || "mat4x3" === s2 || "mat4x3f" === s2 || "mat4x3h" === s2)
        o3 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * a2 * 4, 3), e2.getTypeInfo(`vec3${i3}`));
      else {
        if ("mat2x4" !== s2 && "mat2x4f" !== s2 && "mat2x4h" !== s2 && "mat3x4" !== s2 && "mat3x4f" !== s2 && "mat3x4h" !== s2 && "mat4x4" !== s2 && "mat4x4f" !== s2 && "mat4x4h" !== s2)
          return console.error(`GetDataValue: Unknown type ${s2}`), null;
        o3 = new Me(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * a2 * 4, 4), e2.getTypeInfo(`vec4${i3}`));
      }
      return t2.postfix ? o3.getSubData(e2, t2.postfix, n2) : o3;
    }
    return console.error("GetDataValue: Invalid postfix", t2), null;
  }
  toString() {
    let e2 = `${this.data[0]}`;
    for (let t2 = 1; t2 < this.data.length; ++t2)
      e2 += `, ${this.data[t2]}`;
    return e2;
  }
};
var Pe = class _Pe extends Ne {
  constructor(e2, t2, n2 = 0, s2 = null) {
    super(t2, s2), this.buffer = e2 instanceof ArrayBuffer ? e2 : e2.buffer, this.offset = n2;
  }
  clone() {
    const e2 = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
    return new _Pe(e2.buffer, this.typeInfo, 0, null);
  }
  setDataValue(t2, r2, a2, i3) {
    if (null === r2)
      return void console.log("setDataValue: NULL data.");
    let o3 = this.offset, c2 = this.typeInfo;
    for (; a2; ) {
      if (a2 instanceof ve)
        if (c2 instanceof s) {
          const e2 = a2.index;
          if (e2 instanceof xe) {
            if (!(e2.value instanceof Be))
              return void console.error(`SetDataValue: Invalid index type ${e2.value}`);
            o3 += e2.value.value * c2.stride;
          } else {
            const n2 = t2.evalExpression(e2, i3);
            if (!(n2 instanceof Be))
              return void console.error("SetDataValue: Unknown index type", e2);
            o3 += n2.value * c2.stride;
          }
          c2 = c2.format;
        } else
          console.error(`SetDataValue: Type ${c2.getTypeName()} is not an array`);
      else {
        if (!(a2 instanceof pe))
          return void console.error("SetDataValue: Unknown postfix type", a2);
        {
          const t3 = a2.value;
          if (c2 instanceof n) {
            let e2 = false;
            for (const n2 of c2.members)
              if (n2.name === t3) {
                o3 += n2.offset, c2 = n2.type, e2 = true;
                break;
              }
            if (!e2)
              return void console.error(`SetDataValue: Member ${t3} not found`);
          } else if (c2 instanceof e) {
            const e2 = c2.getTypeName();
            let n2 = 0;
            if ("x" === t3 || "r" === t3)
              n2 = 0;
            else if ("y" === t3 || "g" === t3)
              n2 = 1;
            else if ("z" === t3 || "b" === t3)
              n2 = 2;
            else {
              if ("w" !== t3 && "a" !== t3)
                return void console.error(`SetDataValue: Unknown member ${t3}`);
              n2 = 3;
            }
            if (!(r2 instanceof Be))
              return void console.error("SetDataValue: Invalid value", r2);
            const s2 = r2.value;
            return "vec2f" === e2 ? void (new Float32Array(this.buffer, o3, 2)[n2] = s2) : "vec3f" === e2 ? void (new Float32Array(this.buffer, o3, 3)[n2] = s2) : "vec4f" === e2 ? void (new Float32Array(this.buffer, o3, 4)[n2] = s2) : "vec2i" === e2 ? void (new Int32Array(this.buffer, o3, 2)[n2] = s2) : "vec3i" === e2 ? void (new Int32Array(this.buffer, o3, 3)[n2] = s2) : "vec4i" === e2 ? void (new Int32Array(this.buffer, o3, 4)[n2] = s2) : "vec2u" === e2 ? void (new Uint32Array(this.buffer, o3, 2)[n2] = s2) : "vec3u" === e2 ? void (new Uint32Array(this.buffer, o3, 3)[n2] = s2) : "vec4u" === e2 ? void (new Uint32Array(this.buffer, o3, 4)[n2] = s2) : void console.error(`SetDataValue: Type ${e2} is not a struct`);
          }
        }
      }
      a2 = a2.postfix;
    }
    this.setData(t2, r2, c2, o3, i3);
  }
  setData(e2, t2, n2, s2, r2) {
    const a2 = n2.getTypeName();
    if ("f32" !== a2 && "f16" !== a2)
      if ("i32" !== a2 && "atomic<i32>" !== a2 && "x32" !== a2)
        if ("u32" !== a2 && "atomic<u32>" !== a2)
          if ("bool" !== a2) {
            if ("vec2f" === a2 || "vec2h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 2);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]));
            }
            if ("vec3f" === a2 || "vec3h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 3);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]));
            }
            if ("vec4f" === a2 || "vec4h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 4);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]));
            }
            if ("vec2i" === a2) {
              const e3 = new Int32Array(this.buffer, s2, 2);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]));
            }
            if ("vec3i" === a2) {
              const e3 = new Int32Array(this.buffer, s2, 3);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]));
            }
            if ("vec4i" === a2) {
              const e3 = new Int32Array(this.buffer, s2, 4);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]));
            }
            if ("vec2u" === a2) {
              const e3 = new Uint32Array(this.buffer, s2, 2);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]));
            }
            if ("vec3u" === a2) {
              const e3 = new Uint32Array(this.buffer, s2, 3);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]));
            }
            if ("vec4u" === a2) {
              const e3 = new Uint32Array(this.buffer, s2, 4);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]));
            }
            if ("vec2b" === a2) {
              const e3 = new Uint32Array(this.buffer, s2, 2);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1]) : (e3[0] = t2[0], e3[1] = t2[1]));
            }
            if ("vec3b" === a2) {
              const e3 = new Uint32Array(this.buffer, s2, 3);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2]));
            }
            if ("vec4b" === a2) {
              const e3 = new Uint32Array(this.buffer, s2, 4);
              return void (t2 instanceof Me ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]));
            }
            if ("mat2x2f" === a2 || "mat2x2h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 4);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3]));
            }
            if ("mat2x3f" === a2 || "mat2x3h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 6);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5]));
            }
            if ("mat2x4f" === a2 || "mat2x4h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 8);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7]));
            }
            if ("mat3x2f" === a2 || "mat3x2h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 6);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5]));
            }
            if ("mat3x3f" === a2 || "mat3x3h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 9);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8]));
            }
            if ("mat3x4f" === a2 || "mat3x4h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 12);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8], e3[9] = t2.data[9], e3[10] = t2.data[10], e3[11] = t2.data[11]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11]));
            }
            if ("mat4x2f" === a2 || "mat4x2h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 8);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7]));
            }
            if ("mat4x3f" === a2 || "mat4x3h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 12);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8], e3[9] = t2.data[9], e3[10] = t2.data[10], e3[11] = t2.data[11]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11]));
            }
            if ("mat4x4f" === a2 || "mat4x4h" === a2) {
              const e3 = new Float32Array(this.buffer, s2, 16);
              return void (t2 instanceof Ue ? (e3[0] = t2.data[0], e3[1] = t2.data[1], e3[2] = t2.data[2], e3[3] = t2.data[3], e3[4] = t2.data[4], e3[5] = t2.data[5], e3[6] = t2.data[6], e3[7] = t2.data[7], e3[8] = t2.data[8], e3[9] = t2.data[9], e3[10] = t2.data[10], e3[11] = t2.data[11], e3[12] = t2.data[12], e3[13] = t2.data[13], e3[14] = t2.data[14], e3[15] = t2.data[15]) : (e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11], e3[12] = t2[12], e3[13] = t2[13], e3[14] = t2[14], e3[15] = t2[15]));
            }
            if (t2 instanceof _Pe) {
              if (n2 === t2.typeInfo) {
                return void new Uint8Array(this.buffer, s2, t2.buffer.byteLength).set(new Uint8Array(t2.buffer));
              }
              console.error("SetDataValue: Type mismatch", a2, t2.typeInfo.getTypeName());
            } else
              console.error(`SetData: Unknown type ${a2}`);
          } else
            t2 instanceof Be && (new Int32Array(this.buffer, s2, 1)[0] = t2.value);
        else
          t2 instanceof Be && (new Uint32Array(this.buffer, s2, 1)[0] = t2.value);
      else
        t2 instanceof Be && (new Int32Array(this.buffer, s2, 1)[0] = t2.value);
    else
      t2 instanceof Be && (new Float32Array(this.buffer, s2, 1)[0] = t2.value);
  }
  getSubData(t2, r2, i3) {
    var o3, c2, l2;
    if (null === r2)
      return this;
    let u2 = this.offset, h2 = this.typeInfo;
    for (; r2; ) {
      if (r2 instanceof ve) {
        const e2 = r2.index, n2 = e2 instanceof fe ? t2.evalExpression(e2, i3) : e2;
        let a2 = 0;
        if (n2 instanceof Be ? a2 = n2.value : "number" == typeof n2 ? a2 = n2 : console.error("GetDataValue: Invalid index type", e2), h2 instanceof s)
          u2 += a2 * h2.stride, h2 = h2.format;
        else {
          const e3 = h2.getTypeName();
          "mat4x4" === e3 || "mat4x4f" === e3 || "mat4x4h" === e3 ? (u2 += 16 * a2, h2 = t2.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${h2.getTypeName()} is not an array`);
        }
      } else {
        if (!(r2 instanceof pe))
          return console.error("GetDataValue: Unknown postfix type", r2), null;
        {
          const s2 = r2.value;
          if (h2 instanceof n) {
            let e2 = false;
            for (const t3 of h2.members)
              if (t3.name === s2) {
                u2 += t3.offset, h2 = t3.type, e2 = true;
                break;
              }
            if (!e2)
              return console.error(`GetDataValue: Member ${s2} not found`), null;
          } else if (h2 instanceof e) {
            const e2 = h2.getTypeName();
            if ("vec2f" === e2 || "vec3f" === e2 || "vec4f" === e2 || "vec2i" === e2 || "vec3i" === e2 || "vec4i" === e2 || "vec2u" === e2 || "vec3u" === e2 || "vec4u" === e2 || "vec2b" === e2 || "vec3b" === e2 || "vec4b" === e2 || "vec2h" === e2 || "vec3h" === e2 || "vec4h" === e2 || "vec2" === e2 || "vec3" === e2 || "vec4" === e2) {
              if (s2.length > 0 && s2.length < 5) {
                let n2 = "f";
                const r3 = [];
                for (let a2 = 0; a2 < s2.length; ++a2) {
                  const i4 = s2[a2].toLowerCase();
                  let o4 = 0;
                  if ("x" === i4 || "r" === i4)
                    o4 = 0;
                  else if ("y" === i4 || "g" === i4)
                    o4 = 1;
                  else if ("z" === i4 || "b" === i4)
                    o4 = 2;
                  else {
                    if ("w" !== i4 && "a" !== i4)
                      return console.error(`Unknown member ${s2}`), null;
                    o4 = 3;
                  }
                  if (1 === s2.length) {
                    if (e2.endsWith("f"))
                      return this.buffer.byteLength < u2 + 4 * o4 + 4 ? (console.log("Insufficient buffer data"), null) : new Be(new Float32Array(this.buffer, u2 + 4 * o4, 1), t2.getTypeInfo("f32"), this);
                    if (e2.endsWith("h"))
                      return new Be(new Float32Array(this.buffer, u2 + 4 * o4, 1), t2.getTypeInfo("f16"), this);
                    if (e2.endsWith("i"))
                      return new Be(new Int32Array(this.buffer, u2 + 4 * o4, 1), t2.getTypeInfo("i32"), this);
                    if (e2.endsWith("b"))
                      return new Be(new Int32Array(this.buffer, u2 + 4 * o4, 1), t2.getTypeInfo("bool"), this);
                    if (e2.endsWith("u"))
                      return new Be(new Uint32Array(this.buffer, u2 + 4 * o4, 1), t2.getTypeInfo("i32"), this);
                  }
                  if ("vec2f" === e2)
                    r3.push(new Float32Array(this.buffer, u2, 2)[o4]);
                  else if ("vec3f" === e2) {
                    if (u2 + 12 >= this.buffer.byteLength)
                      return console.log("Insufficient buffer data"), null;
                    const e3 = new Float32Array(this.buffer, u2, 3);
                    r3.push(e3[o4]);
                  } else if ("vec4f" === e2)
                    r3.push(new Float32Array(this.buffer, u2, 4)[o4]);
                  else if ("vec2i" === e2)
                    n2 = "i", r3.push(new Int32Array(this.buffer, u2, 2)[o4]);
                  else if ("vec3i" === e2)
                    n2 = "i", r3.push(new Int32Array(this.buffer, u2, 3)[o4]);
                  else if ("vec4i" === e2)
                    n2 = "i", r3.push(new Int32Array(this.buffer, u2, 4)[o4]);
                  else if ("vec2u" === e2) {
                    n2 = "u";
                    const e3 = new Uint32Array(this.buffer, u2, 2);
                    r3.push(e3[o4]);
                  } else
                    "vec3u" === e2 ? (n2 = "u", r3.push(new Uint32Array(this.buffer, u2, 3)[o4])) : "vec4u" === e2 && (n2 = "u", r3.push(new Uint32Array(this.buffer, u2, 4)[o4]));
                }
                return 2 === r3.length ? h2 = t2.getTypeInfo(`vec2${n2}`) : 3 === r3.length ? h2 = t2.getTypeInfo(`vec3${n2}`) : 4 === r3.length ? h2 = t2.getTypeInfo(`vec4${n2}`) : console.error(`GetDataValue: Invalid vector length ${r3.length}`), new Me(r3, h2, null);
              }
              return console.error(`GetDataValue: Unknown member ${s2}`), null;
            }
            return console.error(`GetDataValue: Type ${e2} is not a struct`), null;
          }
        }
      }
      r2 = r2.postfix;
    }
    const f2 = h2.getTypeName();
    return "f32" === f2 ? new Be(new Float32Array(this.buffer, u2, 1), h2, this) : "i32" === f2 ? new Be(new Int32Array(this.buffer, u2, 1), h2, this) : "u32" === f2 ? new Be(new Uint32Array(this.buffer, u2, 1), h2, this) : "vec2f" === f2 ? new Me(new Float32Array(this.buffer, u2, 2), h2, this) : "vec3f" === f2 ? new Me(new Float32Array(this.buffer, u2, 3), h2, this) : "vec4f" === f2 ? new Me(new Float32Array(this.buffer, u2, 4), h2, this) : "vec2i" === f2 ? new Me(new Int32Array(this.buffer, u2, 2), h2, this) : "vec3i" === f2 ? new Me(new Int32Array(this.buffer, u2, 3), h2, this) : "vec4i" === f2 ? new Me(new Int32Array(this.buffer, u2, 4), h2, this) : "vec2u" === f2 ? new Me(new Uint32Array(this.buffer, u2, 2), h2, this) : "vec3u" === f2 ? new Me(new Uint32Array(this.buffer, u2, 3), h2, this) : "vec4u" === f2 ? new Me(new Uint32Array(this.buffer, u2, 4), h2, this) : h2 instanceof a && "atomic" === h2.name ? "u32" === (null === (o3 = h2.format) || void 0 === o3 ? void 0 : o3.name) ? new Be(new Uint32Array(this.buffer, u2, 1)[0], h2.format, this) : "i32" === (null === (c2 = h2.format) || void 0 === c2 ? void 0 : c2.name) ? new Be(new Int32Array(this.buffer, u2, 1)[0], h2.format, this) : (console.error(`GetDataValue: Invalid atomic format ${null === (l2 = h2.format) || void 0 === l2 ? void 0 : l2.name}`), null) : new _Pe(this.buffer, h2, u2, this);
  }
  toString() {
    let e2 = "";
    if (this.typeInfo instanceof s)
      if ("f32" === this.typeInfo.format.name) {
        const t2 = new Float32Array(this.buffer, this.offset);
        e2 = `[${t2[0]}`;
        for (let n2 = 1; n2 < t2.length; ++n2)
          e2 += `, ${t2[n2]}`;
      } else if ("i32" === this.typeInfo.format.name) {
        const t2 = new Int32Array(this.buffer, this.offset);
        e2 = `[${t2[0]}`;
        for (let n2 = 1; n2 < t2.length; ++n2)
          e2 += `, ${t2[n2]}`;
      } else if ("u32" === this.typeInfo.format.name) {
        const t2 = new Uint32Array(this.buffer, this.offset);
        e2 = `[${t2[0]}`;
        for (let n2 = 1; n2 < t2.length; ++n2)
          e2 += `, ${t2[n2]}`;
      } else if ("vec2f" === this.typeInfo.format.name) {
        const t2 = new Float32Array(this.buffer, this.offset);
        e2 = `[${t2[0]}, ${t2[1]}]`;
        for (let n2 = 1; n2 < t2.length / 2; ++n2)
          e2 += `, [${t2[2 * n2]}, ${t2[2 * n2 + 1]}]`;
      } else if ("vec3f" === this.typeInfo.format.name) {
        const t2 = new Float32Array(this.buffer, this.offset);
        e2 = `[${t2[0]}, ${t2[1]}, ${t2[2]}]`;
        for (let n2 = 4; n2 < t2.length; n2 += 4)
          e2 += `, [${t2[n2]}, ${t2[n2 + 1]}, ${t2[n2 + 2]}]`;
      } else if ("vec4f" === this.typeInfo.format.name) {
        const t2 = new Float32Array(this.buffer, this.offset);
        e2 = `[${t2[0]}, ${t2[1]}, ${t2[2]}, ${t2[3]}]`;
        for (let n2 = 4; n2 < t2.length; n2 += 4)
          e2 += `, [${t2[n2]}, ${t2[n2 + 1]}, ${t2[n2 + 2]}, ${t2[n2 + 3]}]`;
      } else
        e2 = "[...]";
    else
      this.typeInfo instanceof n ? e2 += "{...}" : e2 = "[...]";
    return e2;
  }
};
var We = class _We extends Ne {
  constructor(e2, t2, n2, s2) {
    super(t2, null), this.data = e2, this.descriptor = n2, this.view = s2;
  }
  clone() {
    return new _We(this.data, this.typeInfo, this.descriptor, this.view);
  }
  get width() {
    var e2, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 0 ? null !== (e2 = n2[0]) && void 0 !== e2 ? e2 : 0 : n2 instanceof Object && null !== (t2 = n2.width) && void 0 !== t2 ? t2 : 0;
  }
  get height() {
    var e2, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 1 ? null !== (e2 = n2[1]) && void 0 !== e2 ? e2 : 0 : n2 instanceof Object && null !== (t2 = n2.height) && void 0 !== t2 ? t2 : 0;
  }
  get depthOrArrayLayers() {
    var e2, t2;
    const n2 = this.descriptor.size;
    return n2 instanceof Array && n2.length > 2 ? null !== (e2 = n2[2]) && void 0 !== e2 ? e2 : 0 : n2 instanceof Object && null !== (t2 = n2.depthOrArrayLayers) && void 0 !== t2 ? t2 : 0;
  }
  get format() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.format) && void 0 !== e2 ? e2 : "rgba8unorm";
  }
  get sampleCount() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.sampleCount) && void 0 !== e2 ? e2 : 1;
  }
  get mipLevelCount() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.mipLevelCount) && void 0 !== e2 ? e2 : 1;
  }
  get dimension() {
    var e2;
    return this.descriptor && null !== (e2 = this.descriptor.dimension) && void 0 !== e2 ? e2 : "2d";
  }
  getMipLevelSize(e2) {
    if (e2 >= this.mipLevelCount)
      return [0, 0, 0];
    const t2 = [this.width, this.height, this.depthOrArrayLayers];
    for (let n2 = 0; n2 < t2.length; ++n2)
      t2[n2] = Math.max(1, t2[n2] >> e2);
    return t2;
  }
  get texelByteSize() {
    const e2 = this.format, t2 = S[e2];
    return t2 ? t2.isDepthStencil ? 4 : t2.bytesPerBlock : 0;
  }
  get bytesPerRow() {
    return this.width * this.texelByteSize;
  }
  get isDepthStencil() {
    const e2 = this.format, t2 = S[e2];
    return !!t2 && t2.isDepthStencil;
  }
  getGpuSize() {
    const e2 = this.format, t2 = S[e2], n2 = this.width;
    if (!e2 || n2 <= 0 || !t2)
      return -1;
    const s2 = this.height, r2 = this.depthOrArrayLayers, a2 = this.dimension;
    return n2 / t2.blockWidth * ("1d" === a2 ? 1 : s2 / t2.blockHeight) * t2.bytesPerBlock * r2;
  }
  getPixel(e2, t2, n2 = 0, s2 = 0) {
    const r2 = this.texelByteSize, a2 = this.bytesPerRow, i3 = this.height, o3 = this.data[s2];
    return k(new Uint8Array(o3), e2, t2, n2, s2, i3, a2, r2, this.format);
  }
  setPixel(e2, t2, n2, s2, r2) {
    const a2 = this.texelByteSize, i3 = this.bytesPerRow, o3 = this.height, c2 = this.data[s2];
    !function(e3, t3, n3, s3, r3, a3, i4, o4, c3, l2) {
      const u2 = s3 * (i4 >>= r3) * (a3 >>= r3) + n3 * i4 + t3 * o4;
      switch (c3) {
        case "r8unorm":
          return void T(e3, u2, "8unorm", 1, l2);
        case "r8snorm":
          return void T(e3, u2, "8snorm", 1, l2);
        case "r8uint":
          return void T(e3, u2, "8uint", 1, l2);
        case "r8sint":
          return void T(e3, u2, "8sint", 1, l2);
        case "rg8unorm":
          return void T(e3, u2, "8unorm", 2, l2);
        case "rg8snorm":
          return void T(e3, u2, "8snorm", 2, l2);
        case "rg8uint":
          return void T(e3, u2, "8uint", 2, l2);
        case "rg8sint":
          return void T(e3, u2, "8sint", 2, l2);
        case "rgba8unorm-srgb":
        case "rgba8unorm":
        case "bgra8unorm-srgb":
        case "bgra8unorm":
          return void T(e3, u2, "8unorm", 4, l2);
        case "rgba8snorm":
          return void T(e3, u2, "8snorm", 4, l2);
        case "rgba8uint":
          return void T(e3, u2, "8uint", 4, l2);
        case "rgba8sint":
          return void T(e3, u2, "8sint", 4, l2);
        case "r16uint":
          return void T(e3, u2, "16uint", 1, l2);
        case "r16sint":
          return void T(e3, u2, "16sint", 1, l2);
        case "r16float":
          return void T(e3, u2, "16float", 1, l2);
        case "rg16uint":
          return void T(e3, u2, "16uint", 2, l2);
        case "rg16sint":
          return void T(e3, u2, "16sint", 2, l2);
        case "rg16float":
          return void T(e3, u2, "16float", 2, l2);
        case "rgba16uint":
          return void T(e3, u2, "16uint", 4, l2);
        case "rgba16sint":
          return void T(e3, u2, "16sint", 4, l2);
        case "rgba16float":
          return void T(e3, u2, "16float", 4, l2);
        case "r32uint":
          return void T(e3, u2, "32uint", 1, l2);
        case "r32sint":
          return void T(e3, u2, "32sint", 1, l2);
        case "depth16unorm":
        case "depth24plus":
        case "depth24plus-stencil8":
        case "depth32float":
        case "depth32float-stencil8":
        case "r32float":
          return void T(e3, u2, "32float", 1, l2);
        case "rg32uint":
          return void T(e3, u2, "32uint", 2, l2);
        case "rg32sint":
          return void T(e3, u2, "32sint", 2, l2);
        case "rg32float":
          return void T(e3, u2, "32float", 2, l2);
        case "rgba32uint":
          return void T(e3, u2, "32uint", 4, l2);
        case "rgba32sint":
          return void T(e3, u2, "32sint", 4, l2);
        case "rgba32float":
          return void T(e3, u2, "32float", 4, l2);
        case "rg11b10ufloat":
          console.error("TODO: rg11b10ufloat not supported for writing");
      }
    }(new Uint8Array(c2), e2, t2, n2, s2, o3, i3, a2, this.format, r2);
  }
};
((e2) => {
  e2[e2.token = 0] = "token", e2[e2.keyword = 1] = "keyword", e2[e2.reserved = 2] = "reserved";
})(z || (z = {}));
var qe = class {
  constructor(e2, t2, n2) {
    this.name = e2, this.type = t2, this.rule = n2;
  }
  toString() {
    return this.name;
  }
};
var He = class {
};
H = He, He.none = new qe("", z.reserved, ""), He.eof = new qe("EOF", z.token, ""), He.reserved = { asm: new qe("asm", z.reserved, "asm"), bf16: new qe("bf16", z.reserved, "bf16"), do: new qe("do", z.reserved, "do"), enum: new qe("enum", z.reserved, "enum"), f16: new qe("f16", z.reserved, "f16"), f64: new qe("f64", z.reserved, "f64"), handle: new qe("handle", z.reserved, "handle"), i8: new qe("i8", z.reserved, "i8"), i16: new qe("i16", z.reserved, "i16"), i64: new qe("i64", z.reserved, "i64"), mat: new qe("mat", z.reserved, "mat"), premerge: new qe("premerge", z.reserved, "premerge"), regardless: new qe("regardless", z.reserved, "regardless"), typedef: new qe("typedef", z.reserved, "typedef"), u8: new qe("u8", z.reserved, "u8"), u16: new qe("u16", z.reserved, "u16"), u64: new qe("u64", z.reserved, "u64"), unless: new qe("unless", z.reserved, "unless"), using: new qe("using", z.reserved, "using"), vec: new qe("vec", z.reserved, "vec"), void: new qe("void", z.reserved, "void") }, He.keywords = { array: new qe("array", z.keyword, "array"), atomic: new qe("atomic", z.keyword, "atomic"), bool: new qe("bool", z.keyword, "bool"), f32: new qe("f32", z.keyword, "f32"), i32: new qe("i32", z.keyword, "i32"), mat2x2: new qe("mat2x2", z.keyword, "mat2x2"), mat2x3: new qe("mat2x3", z.keyword, "mat2x3"), mat2x4: new qe("mat2x4", z.keyword, "mat2x4"), mat3x2: new qe("mat3x2", z.keyword, "mat3x2"), mat3x3: new qe("mat3x3", z.keyword, "mat3x3"), mat3x4: new qe("mat3x4", z.keyword, "mat3x4"), mat4x2: new qe("mat4x2", z.keyword, "mat4x2"), mat4x3: new qe("mat4x3", z.keyword, "mat4x3"), mat4x4: new qe("mat4x4", z.keyword, "mat4x4"), ptr: new qe("ptr", z.keyword, "ptr"), sampler: new qe("sampler", z.keyword, "sampler"), sampler_comparison: new qe("sampler_comparison", z.keyword, "sampler_comparison"), struct: new qe("struct", z.keyword, "struct"), texture_1d: new qe("texture_1d", z.keyword, "texture_1d"), texture_2d: new qe("texture_2d", z.keyword, "texture_2d"), texture_2d_array: new qe("texture_2d_array", z.keyword, "texture_2d_array"), texture_3d: new qe("texture_3d", z.keyword, "texture_3d"), texture_cube: new qe("texture_cube", z.keyword, "texture_cube"), texture_cube_array: new qe("texture_cube_array", z.keyword, "texture_cube_array"), texture_multisampled_2d: new qe("texture_multisampled_2d", z.keyword, "texture_multisampled_2d"), texture_storage_1d: new qe("texture_storage_1d", z.keyword, "texture_storage_1d"), texture_storage_2d: new qe("texture_storage_2d", z.keyword, "texture_storage_2d"), texture_storage_2d_array: new qe("texture_storage_2d_array", z.keyword, "texture_storage_2d_array"), texture_storage_3d: new qe("texture_storage_3d", z.keyword, "texture_storage_3d"), texture_depth_2d: new qe("texture_depth_2d", z.keyword, "texture_depth_2d"), texture_depth_2d_array: new qe("texture_depth_2d_array", z.keyword, "texture_depth_2d_array"), texture_depth_cube: new qe("texture_depth_cube", z.keyword, "texture_depth_cube"), texture_depth_cube_array: new qe("texture_depth_cube_array", z.keyword, "texture_depth_cube_array"), texture_depth_multisampled_2d: new qe("texture_depth_multisampled_2d", z.keyword, "texture_depth_multisampled_2d"), texture_external: new qe("texture_external", z.keyword, "texture_external"), u32: new qe("u32", z.keyword, "u32"), vec2: new qe("vec2", z.keyword, "vec2"), vec3: new qe("vec3", z.keyword, "vec3"), vec4: new qe("vec4", z.keyword, "vec4"), bitcast: new qe("bitcast", z.keyword, "bitcast"), block: new qe("block", z.keyword, "block"), break: new qe("break", z.keyword, "break"), case: new qe("case", z.keyword, "case"), continue: new qe("continue", z.keyword, "continue"), continuing: new qe("continuing", z.keyword, "continuing"), default: new qe("default", z.keyword, "default"), diagnostic: new qe("diagnostic", z.keyword, "diagnostic"), discard: new qe("discard", z.keyword, "discard"), else: new qe("else", z.keyword, "else"), enable: new qe("enable", z.keyword, "enable"), fallthrough: new qe("fallthrough", z.keyword, "fallthrough"), false: new qe("false", z.keyword, "false"), fn: new qe("fn", z.keyword, "fn"), for: new qe("for", z.keyword, "for"), function: new qe("function", z.keyword, "function"), if: new qe("if", z.keyword, "if"), let: new qe("let", z.keyword, "let"), const: new qe("const", z.keyword, "const"), loop: new qe("loop", z.keyword, "loop"), while: new qe("while", z.keyword, "while"), private: new qe("private", z.keyword, "private"), read: new qe("read", z.keyword, "read"), read_write: new qe("read_write", z.keyword, "read_write"), return: new qe("return", z.keyword, "return"), requires: new qe("requires", z.keyword, "requires"), storage: new qe("storage", z.keyword, "storage"), switch: new qe("switch", z.keyword, "switch"), true: new qe("true", z.keyword, "true"), alias: new qe("alias", z.keyword, "alias"), type: new qe("type", z.keyword, "type"), uniform: new qe("uniform", z.keyword, "uniform"), var: new qe("var", z.keyword, "var"), override: new qe("override", z.keyword, "override"), workgroup: new qe("workgroup", z.keyword, "workgroup"), write: new qe("write", z.keyword, "write"), r8unorm: new qe("r8unorm", z.keyword, "r8unorm"), r8snorm: new qe("r8snorm", z.keyword, "r8snorm"), r8uint: new qe("r8uint", z.keyword, "r8uint"), r8sint: new qe("r8sint", z.keyword, "r8sint"), r16uint: new qe("r16uint", z.keyword, "r16uint"), r16sint: new qe("r16sint", z.keyword, "r16sint"), r16float: new qe("r16float", z.keyword, "r16float"), rg8unorm: new qe("rg8unorm", z.keyword, "rg8unorm"), rg8snorm: new qe("rg8snorm", z.keyword, "rg8snorm"), rg8uint: new qe("rg8uint", z.keyword, "rg8uint"), rg8sint: new qe("rg8sint", z.keyword, "rg8sint"), r32uint: new qe("r32uint", z.keyword, "r32uint"), r32sint: new qe("r32sint", z.keyword, "r32sint"), r32float: new qe("r32float", z.keyword, "r32float"), rg16uint: new qe("rg16uint", z.keyword, "rg16uint"), rg16sint: new qe("rg16sint", z.keyword, "rg16sint"), rg16float: new qe("rg16float", z.keyword, "rg16float"), rgba8unorm: new qe("rgba8unorm", z.keyword, "rgba8unorm"), rgba8unorm_srgb: new qe("rgba8unorm_srgb", z.keyword, "rgba8unorm_srgb"), rgba8snorm: new qe("rgba8snorm", z.keyword, "rgba8snorm"), rgba8uint: new qe("rgba8uint", z.keyword, "rgba8uint"), rgba8sint: new qe("rgba8sint", z.keyword, "rgba8sint"), bgra8unorm: new qe("bgra8unorm", z.keyword, "bgra8unorm"), bgra8unorm_srgb: new qe("bgra8unorm_srgb", z.keyword, "bgra8unorm_srgb"), rgb10a2unorm: new qe("rgb10a2unorm", z.keyword, "rgb10a2unorm"), rg11b10float: new qe("rg11b10float", z.keyword, "rg11b10float"), rg32uint: new qe("rg32uint", z.keyword, "rg32uint"), rg32sint: new qe("rg32sint", z.keyword, "rg32sint"), rg32float: new qe("rg32float", z.keyword, "rg32float"), rgba16uint: new qe("rgba16uint", z.keyword, "rgba16uint"), rgba16sint: new qe("rgba16sint", z.keyword, "rgba16sint"), rgba16float: new qe("rgba16float", z.keyword, "rgba16float"), rgba32uint: new qe("rgba32uint", z.keyword, "rgba32uint"), rgba32sint: new qe("rgba32sint", z.keyword, "rgba32sint"), rgba32float: new qe("rgba32float", z.keyword, "rgba32float"), static_assert: new qe("static_assert", z.keyword, "static_assert") }, He.tokens = { decimal_float_literal: new qe("decimal_float_literal", z.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/), hex_float_literal: new qe("hex_float_literal", z.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/), int_literal: new qe("int_literal", z.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/), uint_literal: new qe("uint_literal", z.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/), name: new qe("name", z.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u), ident: new qe("ident", z.token, /[_a-zA-Z][0-9a-zA-Z_]*/), and: new qe("and", z.token, "&"), and_and: new qe("and_and", z.token, "&&"), arrow: new qe("arrow ", z.token, "->"), attr: new qe("attr", z.token, "@"), forward_slash: new qe("forward_slash", z.token, "/"), bang: new qe("bang", z.token, "!"), bracket_left: new qe("bracket_left", z.token, "["), bracket_right: new qe("bracket_right", z.token, "]"), brace_left: new qe("brace_left", z.token, "{"), brace_right: new qe("brace_right", z.token, "}"), colon: new qe("colon", z.token, ":"), comma: new qe("comma", z.token, ","), equal: new qe("equal", z.token, "="), equal_equal: new qe("equal_equal", z.token, "=="), not_equal: new qe("not_equal", z.token, "!="), greater_than: new qe("greater_than", z.token, ">"), greater_than_equal: new qe("greater_than_equal", z.token, ">="), shift_right: new qe("shift_right", z.token, ">>"), less_than: new qe("less_than", z.token, "<"), less_than_equal: new qe("less_than_equal", z.token, "<="), shift_left: new qe("shift_left", z.token, "<<"), modulo: new qe("modulo", z.token, "%"), minus: new qe("minus", z.token, "-"), minus_minus: new qe("minus_minus", z.token, "--"), period: new qe("period", z.token, "."), plus: new qe("plus", z.token, "+"), plus_plus: new qe("plus_plus", z.token, "++"), or: new qe("or", z.token, "|"), or_or: new qe("or_or", z.token, "||"), paren_left: new qe("paren_left", z.token, "("), paren_right: new qe("paren_right", z.token, ")"), semicolon: new qe("semicolon", z.token, ";"), star: new qe("star", z.token, "*"), tilde: new qe("tilde", z.token, "~"), underscore: new qe("underscore", z.token, "_"), xor: new qe("xor", z.token, "^"), plus_equal: new qe("plus_equal", z.token, "+="), minus_equal: new qe("minus_equal", z.token, "-="), times_equal: new qe("times_equal", z.token, "*="), division_equal: new qe("division_equal", z.token, "/="), modulo_equal: new qe("modulo_equal", z.token, "%="), and_equal: new qe("and_equal", z.token, "&="), or_equal: new qe("or_equal", z.token, "|="), xor_equal: new qe("xor_equal", z.token, "^="), shift_right_equal: new qe("shift_right_equal", z.token, ">>="), shift_left_equal: new qe("shift_left_equal", z.token, "<<=") }, He.simpleTokens = { "@": H.tokens.attr, "{": H.tokens.brace_left, "}": H.tokens.brace_right, ":": H.tokens.colon, ",": H.tokens.comma, "(": H.tokens.paren_left, ")": H.tokens.paren_right, ";": H.tokens.semicolon }, He.literalTokens = { "&": H.tokens.and, "&&": H.tokens.and_and, "->": H.tokens.arrow, "/": H.tokens.forward_slash, "!": H.tokens.bang, "[": H.tokens.bracket_left, "]": H.tokens.bracket_right, "=": H.tokens.equal, "==": H.tokens.equal_equal, "!=": H.tokens.not_equal, ">": H.tokens.greater_than, ">=": H.tokens.greater_than_equal, ">>": H.tokens.shift_right, "<": H.tokens.less_than, "<=": H.tokens.less_than_equal, "<<": H.tokens.shift_left, "%": H.tokens.modulo, "-": H.tokens.minus, "--": H.tokens.minus_minus, ".": H.tokens.period, "+": H.tokens.plus, "++": H.tokens.plus_plus, "|": H.tokens.or, "||": H.tokens.or_or, "*": H.tokens.star, "~": H.tokens.tilde, _: H.tokens.underscore, "^": H.tokens.xor, "+=": H.tokens.plus_equal, "-=": H.tokens.minus_equal, "*=": H.tokens.times_equal, "/=": H.tokens.division_equal, "%=": H.tokens.modulo_equal, "&=": H.tokens.and_equal, "|=": H.tokens.or_equal, "^=": H.tokens.xor_equal, ">>=": H.tokens.shift_right_equal, "<<=": H.tokens.shift_left_equal }, He.regexTokens = { decimal_float_literal: H.tokens.decimal_float_literal, hex_float_literal: H.tokens.hex_float_literal, int_literal: H.tokens.int_literal, uint_literal: H.tokens.uint_literal, ident: H.tokens.ident }, He.storage_class = [H.keywords.function, H.keywords.private, H.keywords.workgroup, H.keywords.uniform, H.keywords.storage], He.access_mode = [H.keywords.read, H.keywords.write, H.keywords.read_write], He.sampler_type = [H.keywords.sampler, H.keywords.sampler_comparison], He.sampled_texture_type = [H.keywords.texture_1d, H.keywords.texture_2d, H.keywords.texture_2d_array, H.keywords.texture_3d, H.keywords.texture_cube, H.keywords.texture_cube_array], He.multisampled_texture_type = [H.keywords.texture_multisampled_2d], He.storage_texture_type = [H.keywords.texture_storage_1d, H.keywords.texture_storage_2d, H.keywords.texture_storage_2d_array, H.keywords.texture_storage_3d], He.depth_texture_type = [H.keywords.texture_depth_2d, H.keywords.texture_depth_2d_array, H.keywords.texture_depth_cube, H.keywords.texture_depth_cube_array, H.keywords.texture_depth_multisampled_2d], He.texture_external_type = [H.keywords.texture_external], He.any_texture_type = [...H.sampled_texture_type, ...H.multisampled_texture_type, ...H.storage_texture_type, ...H.depth_texture_type, ...H.texture_external_type], He.texel_format = [H.keywords.r8unorm, H.keywords.r8snorm, H.keywords.r8uint, H.keywords.r8sint, H.keywords.r16uint, H.keywords.r16sint, H.keywords.r16float, H.keywords.rg8unorm, H.keywords.rg8snorm, H.keywords.rg8uint, H.keywords.rg8sint, H.keywords.r32uint, H.keywords.r32sint, H.keywords.r32float, H.keywords.rg16uint, H.keywords.rg16sint, H.keywords.rg16float, H.keywords.rgba8unorm, H.keywords.rgba8unorm_srgb, H.keywords.rgba8snorm, H.keywords.rgba8uint, H.keywords.rgba8sint, H.keywords.bgra8unorm, H.keywords.bgra8unorm_srgb, H.keywords.rgb10a2unorm, H.keywords.rg11b10float, H.keywords.rg32uint, H.keywords.rg32sint, H.keywords.rg32float, H.keywords.rgba16uint, H.keywords.rgba16sint, H.keywords.rgba16float, H.keywords.rgba32uint, H.keywords.rgba32sint, H.keywords.rgba32float], He.const_literal = [H.tokens.int_literal, H.tokens.uint_literal, H.tokens.decimal_float_literal, H.tokens.hex_float_literal, H.keywords.true, H.keywords.false], He.literal_or_ident = [H.tokens.ident, H.tokens.int_literal, H.tokens.uint_literal, H.tokens.decimal_float_literal, H.tokens.hex_float_literal, H.tokens.name], He.element_count_expression = [H.tokens.int_literal, H.tokens.uint_literal, H.tokens.ident], He.template_types = [H.keywords.vec2, H.keywords.vec3, H.keywords.vec4, H.keywords.mat2x2, H.keywords.mat2x3, H.keywords.mat2x4, H.keywords.mat3x2, H.keywords.mat3x3, H.keywords.mat3x4, H.keywords.mat4x2, H.keywords.mat4x3, H.keywords.mat4x4, H.keywords.atomic, H.keywords.bitcast, ...H.any_texture_type], He.attribute_name = [H.tokens.ident, H.keywords.block, H.keywords.diagnostic], He.assignment_operators = [H.tokens.equal, H.tokens.plus_equal, H.tokens.minus_equal, H.tokens.times_equal, H.tokens.division_equal, H.tokens.modulo_equal, H.tokens.and_equal, H.tokens.or_equal, H.tokens.xor_equal, H.tokens.shift_right_equal, H.tokens.shift_left_equal], He.increment_operators = [H.tokens.plus_plus, H.tokens.minus_minus];
var ze = class {
  constructor(e2, t2, n2, s2, r2) {
    this.type = e2, this.lexeme = t2, this.line = n2, this.start = s2, this.end = r2;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return -1 != He.template_types.indexOf(this.type);
  }
  isArrayType() {
    return this.type == He.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
};
var Re = class {
  constructor(e2) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = null != e2 ? e2 : "";
  }
  scanTokens() {
    for (; !this._isAtEnd(); )
      if (this._start = this._current, !this.scanToken())
        throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new ze(He.eof, "", this._line, this._current, this._current)), this._tokens;
  }
  scanToken() {
    let e2 = this._advance();
    if ("\n" == e2)
      return this._line++, true;
    if (this._isWhitespace(e2))
      return true;
    if ("/" == e2) {
      if ("/" == this._peekAhead()) {
        for (; "\n" != e2; ) {
          if (this._isAtEnd())
            return true;
          e2 = this._advance();
        }
        return this._line++, true;
      }
      if ("*" == this._peekAhead()) {
        this._advance();
        let t3 = 1;
        for (; t3 > 0; ) {
          if (this._isAtEnd())
            return true;
          if (e2 = this._advance(), "\n" == e2)
            this._line++;
          else if ("*" == e2) {
            if ("/" == this._peekAhead() && (this._advance(), t3--, 0 == t3))
              return true;
          } else
            "/" == e2 && "*" == this._peekAhead() && (this._advance(), t3++);
        }
        return true;
      }
    }
    const t2 = He.simpleTokens[e2];
    if (t2)
      return this._addToken(t2), true;
    let n2 = He.none;
    const s2 = this._isAlpha(e2), r2 = "_" === e2;
    if (this._isAlphaNumeric(e2)) {
      let t3 = this._peekAhead();
      for (; this._isAlphaNumeric(t3); )
        e2 += this._advance(), t3 = this._peekAhead();
    }
    if (s2) {
      const t3 = He.keywords[e2];
      if (t3)
        return this._addToken(t3), true;
    }
    if (s2 || r2)
      return this._addToken(He.tokens.ident), true;
    for (; ; ) {
      let t3 = this._findType(e2);
      const s3 = this._peekAhead();
      if ("-" == e2 && this._tokens.length > 0) {
        if ("=" == s3)
          return this._current++, e2 += s3, this._addToken(He.tokens.minus_equal), true;
        if ("-" == s3)
          return this._current++, e2 += s3, this._addToken(He.tokens.minus_minus), true;
        const n3 = this._tokens.length - 1;
        if ((-1 != He.literal_or_ident.indexOf(this._tokens[n3].type) || this._tokens[n3].type == He.tokens.paren_right) && ">" != s3)
          return this._addToken(t3), true;
      }
      if (">" == e2 && (">" == s3 || "=" == s3)) {
        let e3 = false, n3 = this._tokens.length - 1;
        for (let t4 = 0; t4 < 5 && n3 >= 0 && -1 === He.assignment_operators.indexOf(this._tokens[n3].type); ++t4, --n3)
          if (this._tokens[n3].type === He.tokens.less_than) {
            n3 > 0 && this._tokens[n3 - 1].isArrayOrTemplateType() && (e3 = true);
            break;
          }
        if (e3)
          return this._addToken(t3), true;
      }
      if (t3 === He.none) {
        let s4 = e2, r3 = 0;
        const a2 = 2;
        for (let e3 = 0; e3 < a2; ++e3)
          if (s4 += this._peekAhead(e3), t3 = this._findType(s4), t3 !== He.none) {
            r3 = e3;
            break;
          }
        if (t3 === He.none)
          return n2 !== He.none && (this._current--, this._addToken(n2), true);
        e2 = s4, this._current += r3 + 1;
      }
      if (n2 = t3, this._isAtEnd())
        break;
      e2 += this._advance();
    }
    return n2 !== He.none && (this._addToken(n2), true);
  }
  _findType(e2) {
    for (const t3 in He.regexTokens) {
      const n2 = He.regexTokens[t3];
      if (this._match(e2, n2.rule))
        return n2;
    }
    const t2 = He.literalTokens[e2];
    return t2 || He.none;
  }
  _match(e2, t2) {
    const n2 = t2.exec(e2);
    return n2 && 0 == n2.index && n2[0] == e2;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e2) {
    return !this._isNumeric(e2) && !this._isWhitespace(e2) && "_" !== e2 && "." !== e2 && "(" !== e2 && ")" !== e2 && "[" !== e2 && "]" !== e2 && "{" !== e2 && "}" !== e2 && "," !== e2 && ";" !== e2 && ":" !== e2 && "=" !== e2 && "!" !== e2 && "<" !== e2 && ">" !== e2 && "+" !== e2 && "-" !== e2 && "*" !== e2 && "/" !== e2 && "%" !== e2 && "&" !== e2 && "|" !== e2 && "^" !== e2 && "~" !== e2 && "@" !== e2 && "#" !== e2 && "?" !== e2 && "'" !== e2 && "`" !== e2 && '"' !== e2 && "\\" !== e2 && "\n" !== e2 && "\r" !== e2 && "	" !== e2 && "\0" !== e2;
  }
  _isNumeric(e2) {
    return e2 >= "0" && e2 <= "9";
  }
  _isAlphaNumeric(e2) {
    return this._isAlpha(e2) || this._isNumeric(e2) || "_" === e2;
  }
  _isWhitespace(e2) {
    return " " == e2 || "	" == e2 || "\r" == e2;
  }
  _advance(e2 = 0) {
    let t2 = this._source[this._current];
    return e2 = e2 || 0, e2++, this._current += e2, t2;
  }
  _peekAhead(e2 = 0) {
    return e2 = e2 || 0, this._current + e2 >= this._source.length ? "\0" : this._source[this._current + e2];
  }
  _addToken(e2) {
    const t2 = this._source.substring(this._start, this._current);
    this._tokens.push(new ze(e2, t2, this._line, this._start, this._current));
  }
};
function Ge(e2) {
  return Array.isArray(e2) || (null == e2 ? void 0 : e2.buffer) instanceof ArrayBuffer;
}
var Xe = new Float32Array(1);
var je = new Uint32Array(Xe.buffer);
var Ze = new Uint32Array(Xe.buffer);
var Qe = new Int32Array(1);
var Ye = new Float32Array(Qe.buffer);
var Ke = new Uint32Array(Qe.buffer);
var Je = new Uint32Array(1);
var et = new Float32Array(Je.buffer);
var tt = new Int32Array(Je.buffer);
function nt(e2, t2, n2) {
  if (t2 === n2)
    return e2;
  if ("f32" === t2) {
    if ("i32" === n2 || "x32" === n2)
      return Xe[0] = e2, je[0];
    if ("u32" === n2)
      return Xe[0] = e2, Ze[0];
  } else if ("i32" === t2 || "x32" === t2) {
    if ("f32" === n2)
      return Qe[0] = e2, Ye[0];
    if ("u32" === n2)
      return Qe[0] = e2, Ke[0];
  } else if ("u32" === t2) {
    if ("f32" === n2)
      return Je[0] = e2, et[0];
    if ("i32" === n2 || "x32" === n2)
      return Je[0] = e2, tt[0];
  }
  return console.error(`Unsupported cast from ${t2} to ${n2}`), e2;
}
var st = class {
  constructor(e2) {
    this.resources = null, this.inUse = false, this.info = null, this.node = e2;
  }
};
var rt = class {
  constructor(e2, t2) {
    this.align = e2, this.size = t2;
  }
};
var at = class _at {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new d(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(e2) {
    return "texture_storage_1d" == e2.name || "texture_storage_2d" == e2.name || "texture_storage_2d_array" == e2.name || "texture_storage_3d" == e2.name;
  }
  updateAST(e2) {
    for (const t2 of e2)
      t2 instanceof D2 && this._functions.set(t2.name, new st(t2));
    for (const t2 of e2)
      if (t2 instanceof oe) {
        const e3 = this.getTypeInfo(t2, null);
        e3 instanceof n && this.structs.push(e3);
      }
    for (const t2 of e2)
      if (t2 instanceof te)
        this.aliases.push(this._getAliasInfo(t2));
      else {
        if (t2 instanceof M) {
          const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "id", 0), s2 = null != e3.type ? this.getTypeInfo(e3.type, e3.attributes) : null;
          this.overrides.push(new h(e3.name, s2, e3.attributes, n2));
          continue;
        }
        if (this._isUniformVar(t2)) {
          const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = new o2(e3.name, r2, n2, s2, e3.attributes, i2.Uniform, e3.access);
          a2.access || (a2.access = "read"), this.uniforms.push(a2);
          continue;
        }
        if (this._isStorageVar(t2)) {
          const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = this._isStorageTexture(r2), c2 = new o2(e3.name, r2, n2, s2, e3.attributes, a2 ? i2.StorageTexture : i2.Storage, e3.access);
          c2.access || (c2.access = "read"), this.storage.push(c2);
          continue;
        }
        if (this._isTextureVar(t2)) {
          const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = this._isStorageTexture(r2), c2 = new o2(e3.name, r2, n2, s2, e3.attributes, a2 ? i2.StorageTexture : i2.Texture, e3.access);
          c2.access || (c2.access = "read"), a2 ? this.storage.push(c2) : this.textures.push(c2);
          continue;
        }
        if (this._isSamplerVar(t2)) {
          const e3 = t2, n2 = this._getAttributeNum(e3.attributes, "group", 0), s2 = this._getAttributeNum(e3.attributes, "binding", 0), r2 = this.getTypeInfo(e3.type, e3.attributes), a2 = new o2(e3.name, r2, n2, s2, e3.attributes, i2.Sampler, e3.access);
          this.samplers.push(a2);
          continue;
        }
      }
    for (const t2 of e2)
      if (t2 instanceof D2) {
        const e3 = this._getAttribute(t2, "vertex"), n2 = this._getAttribute(t2, "fragment"), s2 = this._getAttribute(t2, "compute"), r2 = e3 || n2 || s2, a2 = new p(t2.name, null == r2 ? void 0 : r2.name, t2.attributes);
        a2.attributes = t2.attributes, a2.startLine = t2.startLine, a2.endLine = t2.endLine, this.functions.push(a2), this._functions.get(t2.name).info = a2, r2 && (this._functions.get(t2.name).inUse = true, a2.inUse = true, a2.resources = this._findResources(t2, !!r2), a2.inputs = this._getInputs(t2.args), a2.outputs = this._getOutputs(t2.returnType), this.entry[r2.name].push(a2)), a2.arguments = t2.args.map((e4) => new f(e4.name, this.getTypeInfo(e4.type, e4.attributes), e4.attributes)), a2.returnType = t2.returnType ? this.getTypeInfo(t2.returnType, t2.attributes) : null;
        continue;
      }
    for (const e3 of this._functions.values())
      e3.info && (e3.info.inUse = e3.inUse, this._addCalls(e3.node, e3.info.calls));
    for (const e3 of this._functions.values())
      e3.node.search((t2) => {
        var n2, s2, r2;
        if (t2 instanceof De) {
          if (t2.value)
            if (Ge(t2.value))
              for (const s3 of t2.value)
                for (const t3 of this.overrides)
                  s3 === t3.name && (null === (n2 = e3.info) || void 0 === n2 || n2.overrides.push(t3));
            else
              for (const n3 of this.overrides)
                t2.value === n3.name && (null === (s2 = e3.info) || void 0 === s2 || s2.overrides.push(n3));
        } else if (t2 instanceof ge)
          for (const n3 of this.overrides)
            t2.name === n3.name && (null === (r2 = e3.info) || void 0 === r2 || r2.overrides.push(n3));
      });
    for (const e3 of this.uniforms)
      this._markStructsInUse(e3.type);
    for (const e3 of this.storage)
      this._markStructsInUse(e3.type);
  }
  getFunctionInfo(e2) {
    for (const t2 of this.functions)
      if (t2.name == e2)
        return t2;
    return null;
  }
  getStructInfo(e2) {
    for (const t2 of this.structs)
      if (t2.name == e2)
        return t2;
    return null;
  }
  getOverrideInfo(e2) {
    for (const t2 of this.overrides)
      if (t2.name == e2)
        return t2;
    return null;
  }
  _markStructsInUse(e2) {
    if (e2)
      if (e2.isStruct) {
        if (e2.inUse = true, e2.members)
          for (const t2 of e2.members)
            this._markStructsInUse(t2.type);
      } else if (e2.isArray)
        this._markStructsInUse(e2.format);
      else if (e2.isTemplate)
        e2.format && this._markStructsInUse(e2.format);
      else {
        const t2 = this._getAlias(e2.name);
        t2 && this._markStructsInUse(t2);
      }
  }
  _addCalls(e2, t2) {
    var n2;
    for (const s2 of e2.calls) {
      const e3 = null === (n2 = this._functions.get(s2.name)) || void 0 === n2 ? void 0 : n2.info;
      e3 && t2.add(e3);
    }
  }
  findResource(e2, t2, n2) {
    if (n2) {
      for (const s2 of this.entry.compute)
        if (s2.name === n2) {
          for (const n3 of s2.resources)
            if (n3.group == e2 && n3.binding == t2)
              return n3;
        }
      for (const s2 of this.entry.vertex)
        if (s2.name === n2) {
          for (const n3 of s2.resources)
            if (n3.group == e2 && n3.binding == t2)
              return n3;
        }
      for (const s2 of this.entry.fragment)
        if (s2.name === n2) {
          for (const n3 of s2.resources)
            if (n3.group == e2 && n3.binding == t2)
              return n3;
        }
    }
    for (const n3 of this.uniforms)
      if (n3.group == e2 && n3.binding == t2)
        return n3;
    for (const n3 of this.storage)
      if (n3.group == e2 && n3.binding == t2)
        return n3;
    for (const n3 of this.textures)
      if (n3.group == e2 && n3.binding == t2)
        return n3;
    for (const n3 of this.samplers)
      if (n3.group == e2 && n3.binding == t2)
        return n3;
    return null;
  }
  _findResource(e2) {
    for (const t2 of this.uniforms)
      if (t2.name == e2)
        return t2;
    for (const t2 of this.storage)
      if (t2.name == e2)
        return t2;
    for (const t2 of this.textures)
      if (t2.name == e2)
        return t2;
    for (const t2 of this.samplers)
      if (t2.name == e2)
        return t2;
    return null;
  }
  _markStructsFromAST(e2) {
    const t2 = this.getTypeInfo(e2, null);
    this._markStructsInUse(t2);
  }
  _findResources(e2, t2) {
    const n2 = [], s2 = this, r2 = [];
    return e2.search((a2) => {
      if (a2 instanceof E2)
        r2.push({});
      else if (a2 instanceof $)
        r2.pop();
      else if (a2 instanceof F) {
        const e3 = a2;
        t2 && null !== e3.type && this._markStructsFromAST(e3.type), r2.length > 0 && (r2[r2.length - 1][e3.name] = e3);
      } else if (a2 instanceof de) {
        const e3 = a2;
        t2 && null !== e3.type && this._markStructsFromAST(e3.type);
      } else if (a2 instanceof U) {
        const e3 = a2;
        t2 && null !== e3.type && this._markStructsFromAST(e3.type), r2.length > 0 && (r2[r2.length - 1][e3.name] = e3);
      } else if (a2 instanceof ge) {
        const e3 = a2;
        if (r2.length > 0) {
          if (r2[r2.length - 1][e3.name])
            return;
        }
        const t3 = s2._findResource(e3.name);
        t3 && n2.push(t3);
      } else if (a2 instanceof me) {
        const r3 = a2, i3 = s2._functions.get(r3.name);
        i3 && (t2 && (i3.inUse = true), e2.calls.add(i3.node), null === i3.resources && (i3.resources = s2._findResources(i3.node, t2)), n2.push(...i3.resources));
      } else if (a2 instanceof X) {
        const r3 = a2, i3 = s2._functions.get(r3.name);
        i3 && (t2 && (i3.inUse = true), e2.calls.add(i3.node), null === i3.resources && (i3.resources = s2._findResources(i3.node, t2)), n2.push(...i3.resources));
      }
    }), [...new Map(n2.map((e3) => [e3.name, e3])).values()];
  }
  getBindGroups() {
    const e2 = [];
    function t2(t3, n2) {
      t3 >= e2.length && (e2.length = t3 + 1), void 0 === e2[t3] && (e2[t3] = []), n2 >= e2[t3].length && (e2[t3].length = n2 + 1);
    }
    for (const n2 of this.uniforms) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.storage) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.textures) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    for (const n2 of this.samplers) {
      t2(n2.group, n2.binding);
      e2[n2.group][n2.binding] = n2;
    }
    return e2;
  }
  _getOutputs(e2, t2 = void 0) {
    if (void 0 === t2 && (t2 = []), e2 instanceof oe)
      this._getStructOutputs(e2, t2);
    else {
      const n2 = this._getOutputInfo(e2);
      null !== n2 && t2.push(n2);
    }
    return t2;
  }
  _getStructOutputs(e2, t2) {
    for (const n2 of e2.members)
      if (n2.type instanceof oe)
        this._getStructOutputs(n2.type, t2);
      else {
        const e3 = this._getAttribute(n2, "location") || this._getAttribute(n2, "builtin");
        if (null !== e3) {
          const s2 = this.getTypeInfo(n2.type, n2.type.attributes), r2 = this._parseInt(e3.value), a2 = new u(n2.name, s2, e3.name, r2);
          t2.push(a2);
        }
      }
  }
  _getOutputInfo(e2) {
    const t2 = this._getAttribute(e2, "location") || this._getAttribute(e2, "builtin");
    if (null !== t2) {
      const n2 = this.getTypeInfo(e2, e2.attributes), s2 = this._parseInt(t2.value);
      return new u("", n2, t2.name, s2);
    }
    return null;
  }
  _getInputs(e2, t2 = void 0) {
    void 0 === t2 && (t2 = []);
    for (const n2 of e2)
      if (n2.type instanceof oe)
        this._getStructInputs(n2.type, t2);
      else {
        const e3 = this._getInputInfo(n2);
        null !== e3 && t2.push(e3);
      }
    return t2;
  }
  _getStructInputs(e2, t2) {
    for (const n2 of e2.members)
      if (n2.type instanceof oe)
        this._getStructInputs(n2.type, t2);
      else {
        const e3 = this._getInputInfo(n2);
        null !== e3 && t2.push(e3);
      }
  }
  _getInputInfo(e2) {
    const t2 = this._getAttribute(e2, "location") || this._getAttribute(e2, "builtin");
    if (null !== t2) {
      const n2 = this._getAttribute(e2, "interpolation"), s2 = this.getTypeInfo(e2.type, e2.attributes), r2 = this._parseInt(t2.value), a2 = new l(e2.name, s2, t2.name, r2);
      return null !== n2 && (a2.interpolation = this._parseString(n2.value)), a2;
    }
    return null;
  }
  _parseString(e2) {
    return e2 instanceof Array && (e2 = e2[0]), e2;
  }
  _parseInt(e2) {
    e2 instanceof Array && (e2 = e2[0]);
    const t2 = parseInt(e2);
    return isNaN(t2) ? e2 : t2;
  }
  _getAlias(e2) {
    for (const t2 of this.aliases)
      if (t2.name == e2)
        return t2.type;
    return null;
  }
  _getAliasInfo(e2) {
    return new c(e2.name, this.getTypeInfo(e2.type, null));
  }
  getTypeInfoByName(e2) {
    for (const t2 of this.structs)
      if (t2.name == e2)
        return t2;
    for (const t2 of this.aliases)
      if (t2.name == e2)
        return t2.type;
    return null;
  }
  getTypeInfo(i3, o3 = null) {
    if (this._types.has(i3))
      return this._types.get(i3);
    if (i3 instanceof le) {
      const e2 = i3.type ? this.getTypeInfo(i3.type, i3.attributes) : null, t2 = new r(i3.name, e2, o3);
      return this._types.set(i3, t2), this._updateTypeInfo(t2), t2;
    }
    if (i3 instanceof ue) {
      const e2 = i3, t2 = e2.format ? this.getTypeInfo(e2.format, e2.attributes) : null, n2 = new s(e2.name, o3);
      return n2.format = t2, n2.count = e2.count, this._types.set(i3, n2), this._updateTypeInfo(n2), n2;
    }
    if (i3 instanceof oe) {
      const e2 = i3, s2 = new n(e2.name, o3);
      s2.startLine = e2.startLine, s2.endLine = e2.endLine;
      for (const n2 of e2.members) {
        const e3 = this.getTypeInfo(n2.type, n2.attributes);
        s2.members.push(new t(n2.name, e3, n2.attributes));
      }
      return this._types.set(i3, s2), this._updateTypeInfo(s2), s2;
    }
    if (i3 instanceof he) {
      const t2 = i3, n2 = t2.format instanceof ae, s2 = t2.format ? n2 ? this.getTypeInfo(t2.format, null) : new e(t2.format, null) : null, r2 = new a(t2.name, s2, o3, t2.access);
      return this._types.set(i3, r2), this._updateTypeInfo(r2), r2;
    }
    if (i3 instanceof ce) {
      const e2 = i3, t2 = e2.format ? this.getTypeInfo(e2.format, null) : null, n2 = new a(e2.name, t2, o3, e2.access);
      return this._types.set(i3, n2), this._updateTypeInfo(n2), n2;
    }
    const c2 = new e(i3.name, o3);
    return this._types.set(i3, c2), this._updateTypeInfo(c2), c2;
  }
  _updateTypeInfo(e2) {
    var t2, a2, i3;
    const o3 = this._getTypeSize(e2);
    if (e2.size = null !== (t2 = null == o3 ? void 0 : o3.size) && void 0 !== t2 ? t2 : 0, e2 instanceof s && e2.format) {
      const t3 = this._getTypeSize(e2.format);
      e2.stride = Math.max(null !== (a2 = null == t3 ? void 0 : t3.size) && void 0 !== a2 ? a2 : 0, null !== (i3 = null == t3 ? void 0 : t3.align) && void 0 !== i3 ? i3 : 0), this._updateTypeInfo(e2.format);
    }
    e2 instanceof r && this._updateTypeInfo(e2.format), e2 instanceof n && this._updateStructInfo(e2);
  }
  _updateStructInfo(e2) {
    var t2;
    let n2 = 0, s2 = 0, r2 = 0, a2 = 0;
    for (let i3 = 0, o3 = e2.members.length; i3 < o3; ++i3) {
      const o4 = e2.members[i3], c2 = this._getTypeSize(o4);
      if (!c2)
        continue;
      null !== (t2 = this._getAlias(o4.type.name)) && void 0 !== t2 || o4.type;
      const l2 = c2.align, u2 = c2.size;
      n2 = this._roundUp(l2, n2 + s2), s2 = u2, r2 = n2, a2 = Math.max(a2, l2), o4.offset = n2, o4.size = u2, this._updateTypeInfo(o4.type);
    }
    e2.size = this._roundUp(a2, r2 + s2), e2.align = a2;
  }
  _getTypeSize(r2) {
    var a2, i3;
    if (null == r2)
      return null;
    const o3 = this._getAttributeNum(r2.attributes, "size", 0), c2 = this._getAttributeNum(r2.attributes, "align", 0);
    if (r2 instanceof t && (r2 = r2.type), r2 instanceof e) {
      const e2 = this._getAlias(r2.name);
      null !== e2 && (r2 = e2);
    }
    {
      const e2 = _at._typeInfo[r2.name];
      if (void 0 !== e2) {
        const t2 = "f16" === (null === (a2 = r2.format) || void 0 === a2 ? void 0 : a2.name) ? 2 : 1;
        return new rt(Math.max(c2, e2.align / t2), Math.max(o3, e2.size / t2));
      }
    }
    {
      const e2 = _at._typeInfo[r2.name.substring(0, r2.name.length - 1)];
      if (e2) {
        const t2 = "h" === r2.name[r2.name.length - 1] ? 2 : 1;
        return new rt(Math.max(c2, e2.align / t2), Math.max(o3, e2.size / t2));
      }
    }
    if (r2 instanceof s) {
      let e2 = r2, t2 = 8, n2 = 8;
      const s2 = this._getTypeSize(e2.format);
      null !== s2 && (n2 = s2.size, t2 = s2.align);
      return n2 = e2.count * this._getAttributeNum(null !== (i3 = null == r2 ? void 0 : r2.attributes) && void 0 !== i3 ? i3 : null, "stride", this._roundUp(t2, n2)), o3 && (n2 = o3), new rt(Math.max(c2, t2), Math.max(o3, n2));
    }
    if (r2 instanceof n) {
      let e2 = 0, t2 = 0, n2 = 0, s2 = 0, a3 = 0;
      for (const t3 of r2.members) {
        const r3 = this._getTypeSize(t3.type);
        null !== r3 && (e2 = Math.max(r3.align, e2), n2 = this._roundUp(r3.align, n2 + s2), s2 = r3.size, a3 = n2);
      }
      return t2 = this._roundUp(e2, a3 + s2), new rt(Math.max(c2, e2), Math.max(o3, t2));
    }
    return null;
  }
  _isUniformVar(e2) {
    return e2 instanceof F && "uniform" == e2.storage;
  }
  _isStorageVar(e2) {
    return e2 instanceof F && "storage" == e2.storage;
  }
  _isTextureVar(e2) {
    return e2 instanceof F && null !== e2.type && -1 != _at._textureTypes.indexOf(e2.type.name);
  }
  _isSamplerVar(e2) {
    return e2 instanceof F && null !== e2.type && -1 != _at._samplerTypes.indexOf(e2.type.name);
  }
  _getAttribute(e2, t2) {
    const n2 = e2;
    if (!n2 || !n2.attributes)
      return null;
    const s2 = n2.attributes;
    for (let e3 of s2)
      if (e3.name == t2)
        return e3;
    return null;
  }
  _getAttributeNum(e2, t2, n2) {
    if (null === e2)
      return n2;
    for (let s2 of e2)
      if (s2.name == t2) {
        let e3 = null !== s2 && null !== s2.value ? s2.value : n2;
        return e3 instanceof Array && (e3 = e3[0]), "number" == typeof e3 ? e3 : "string" == typeof e3 ? parseInt(e3) : n2;
      }
    return n2;
  }
  _roundUp(e2, t2) {
    return Math.ceil(t2 / e2) * e2;
  }
};
at._typeInfo = { f16: { align: 2, size: 2 }, i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, atomic: { align: 4, size: 4 }, vec2: { align: 8, size: 8 }, vec3: { align: 16, size: 12 }, vec4: { align: 16, size: 16 }, mat2x2: { align: 8, size: 16 }, mat3x2: { align: 8, size: 24 }, mat4x2: { align: 8, size: 32 }, mat2x3: { align: 16, size: 32 }, mat3x3: { align: 16, size: 48 }, mat4x3: { align: 16, size: 64 }, mat2x4: { align: 16, size: 32 }, mat3x4: { align: 16, size: 48 }, mat4x4: { align: 16, size: 64 } }, at._textureTypes = He.any_texture_type.map((e2) => e2.name), at._samplerTypes = He.sampler_type.map((e2) => e2.name);
var it = 0;
var ot = class _ot {
  constructor(e2, t2, n2) {
    this.id = it++, this.name = e2, this.value = t2, this.node = n2;
  }
  clone() {
    return new _ot(this.name, this.value, this.node);
  }
};
var ct = class _ct {
  constructor(e2) {
    this.id = it++, this.name = e2.name, this.node = e2;
  }
  clone() {
    return new _ct(this.node);
  }
};
var lt = class _lt {
  constructor(e2) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = it++, e2 && (this.parent = e2, this.currentFunctionName = e2.currentFunctionName);
  }
  getVariable(e2) {
    var t2;
    return this.variables.has(e2) ? null !== (t2 = this.variables.get(e2)) && void 0 !== t2 ? t2 : null : this.parent ? this.parent.getVariable(e2) : null;
  }
  getFunction(e2) {
    var t2;
    return this.functions.has(e2) ? null !== (t2 = this.functions.get(e2)) && void 0 !== t2 ? t2 : null : this.parent ? this.parent.getFunction(e2) : null;
  }
  createVariable(e2, t2, n2) {
    this.variables.set(e2, new ot(e2, t2, null != n2 ? n2 : null));
  }
  setVariable(e2, t2, n2) {
    const s2 = this.getVariable(e2);
    null !== s2 ? s2.value = t2 : this.createVariable(e2, t2, n2);
  }
  getVariableValue(e2) {
    var t2;
    const n2 = this.getVariable(e2);
    return null !== (t2 = null == n2 ? void 0 : n2.value) && void 0 !== t2 ? t2 : null;
  }
  clone() {
    return new _lt(this);
  }
};
var ut = class {
  evalExpression(e2, t2) {
    return null;
  }
  getTypeInfo(e2) {
    return null;
  }
  getVariableName(e2, t2) {
    return "";
  }
};
var ht = class {
  constructor(e2) {
    this.exec = e2;
  }
  getTypeInfo(e2) {
    return this.exec.getTypeInfo(e2);
  }
  All(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    let s2 = true;
    if (n2 instanceof Me)
      return n2.data.forEach((e3) => {
        e3 || (s2 = false);
      }), new Be(s2 ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${e2.line}`);
  }
  Any(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me) {
      const e3 = n2.data.some((e4) => e4);
      return new Be(e3 ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${e2.line}`);
  }
  Select(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[2], t2);
    if (!(n2 instanceof Be))
      throw new Error(`Select() expects a bool condition. Line ${e2.line}`);
    return n2.value ? this.exec.evalExpression(e2.args[1], t2) : this.exec.evalExpression(e2.args[0], t2);
  }
  ArrayLength(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.evalExpression(n2, t2);
    if (s2 instanceof Pe && 0 === s2.typeInfo.size) {
      const e3 = s2.typeInfo, t3 = s2.buffer.byteLength / e3.stride;
      return new Be(t3, this.getTypeInfo("u32"));
    }
    return new Be(s2.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.abs(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.abs(s2.value), s2.typeInfo);
  }
  Acos(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.acos(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.acos(s2.value), n2.typeInfo);
  }
  Acosh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.acosh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.acosh(s2.value), n2.typeInfo);
  }
  Asin(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.asin(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.asin(s2.value), n2.typeInfo);
  }
  Asinh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.asinh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.asinh(s2.value), n2.typeInfo);
  }
  Atan(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.atan(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.atan(s2.value), n2.typeInfo);
  }
  Atanh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.atanh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.atanh(s2.value), n2.typeInfo);
  }
  Atan2(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => Math.atan2(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.atan2(r2.value, a2.value), n2.typeInfo);
  }
  Ceil(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.ceil(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.ceil(s2.value), n2.typeInfo);
  }
  _clamp(e2, t2, n2) {
    return Math.min(Math.max(e2, t2), n2);
  }
  Clamp(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => this._clamp(e3, s2.data[t3], r2.data[t3])), n2.typeInfo);
    const a2 = n2, i3 = s2, o3 = r2;
    return new Be(this._clamp(a2.value, i3.value, o3.value), n2.typeInfo);
  }
  Cos(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.cos(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.cos(s2.value), n2.typeInfo);
  }
  Cosh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.cosh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.cos(s2.value), n2.typeInfo);
  }
  CountLeadingZeros(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.clz32(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.clz32(s2.value), n2.typeInfo);
  }
  _countOneBits(e2) {
    let t2 = 0;
    for (; 0 !== e2; )
      1 & e2 && t2++, e2 >>= 1;
    return t2;
  }
  CountOneBits(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => this._countOneBits(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._countOneBits(s2.value), n2.typeInfo);
  }
  _countTrailingZeros(e2) {
    if (0 === e2)
      return 32;
    let t2 = 0;
    for (; !(1 & e2); )
      e2 >>= 1, t2++;
    return t2;
  }
  CountTrailingZeros(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => this._countTrailingZeros(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._countTrailingZeros(s2.value), n2.typeInfo);
  }
  Cross(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) {
      if (3 !== n2.data.length || 3 !== s2.data.length)
        return console.error(`Cross() expects 3D vectors. Line ${e2.line}`), null;
      const t3 = n2.data, r2 = s2.data;
      return new Me([t3[1] * r2[2] - r2[1] * t3[2], t3[2] * r2[0] - r2[2] * t3[0], t3[0] * r2[1] - r2[0] * t3[1]], n2.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${e2.line}`), null;
  }
  Degrees(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = 180 / Math.PI;
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => e3 * s2), n2.typeInfo);
    return new Be(n2.value * s2, this.getTypeInfo("f32"));
  }
  Determinant(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Ue) {
      const e3 = n2.data, t3 = n2.typeInfo.getTypeName(), s2 = t3.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if ("mat2x2" === t3 || "mat2x2f" === t3 || "mat2x2h" === t3)
        return new Be(e3[0] * e3[3] - e3[1] * e3[2], s2);
      if ("mat2x3" === t3 || "mat2x3f" === t3 || "mat2x3h" === t3)
        return new Be(e3[0] * (e3[4] * e3[8] - e3[5] * e3[7]) - e3[1] * (e3[3] * e3[8] - e3[5] * e3[6]) + e3[2] * (e3[3] * e3[7] - e3[4] * e3[6]), s2);
      if ("mat2x4" === t3 || "mat2x4f" === t3 || "mat2x4h" === t3)
        console.error(`TODO: Determinant for ${t3}`);
      else if ("mat3x2" === t3 || "mat3x2f" === t3 || "mat3x2h" === t3)
        console.error(`TODO: Determinant for ${t3}`);
      else {
        if ("mat3x3" === t3 || "mat3x3f" === t3 || "mat3x3h" === t3)
          return new Be(e3[0] * (e3[4] * e3[8] - e3[5] * e3[7]) - e3[1] * (e3[3] * e3[8] - e3[5] * e3[6]) + e3[2] * (e3[3] * e3[7] - e3[4] * e3[6]), s2);
        "mat3x4" === t3 || "mat3x4f" === t3 || "mat3x4h" === t3 || "mat4x2" === t3 || "mat4x2f" === t3 || "mat4x2h" === t3 || "mat4x3" === t3 || "mat4x3f" === t3 || "mat4x3h" === t3 ? console.error(`TODO: Determinant for ${t3}`) : "mat4x4" !== t3 && "mat4x4f" !== t3 && "mat4x4h" !== t3 || console.error(`TODO: Determinant for ${t3}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${e2.line}`), null;
  }
  Distance(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) {
      let e3 = 0;
      for (let t3 = 0; t3 < n2.data.length; ++t3)
        e3 += (n2.data[t3] - s2.data[t3]) * (n2.data[t3] - s2.data[t3]);
      return new Be(Math.sqrt(e3), this.getTypeInfo("f32"));
    }
    const r2 = n2, a2 = s2;
    return new Be(Math.abs(r2.value - a2.value), n2.typeInfo);
  }
  _dot(e2, t2) {
    let n2 = 0;
    for (let s2 = 0; s2 < e2.length; ++s2)
      n2 += t2[s2] * e2[s2];
    return n2;
  }
  Dot(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    return n2 instanceof Me && s2 instanceof Me ? new Be(this._dot(n2.data, s2.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e2.line}`), null);
  }
  Dot4U8Packed(e2, t2) {
    return console.error(`TODO: dot4U8Packed. Line ${e2.line}`), null;
  }
  Dot4I8Packed(e2, t2) {
    return console.error(`TODO: dot4I8Packed. Line ${e2.line}`), null;
  }
  Exp(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.exp(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.exp(s2.value), n2.typeInfo);
  }
  Exp2(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.pow(2, e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.pow(2, s2.value), n2.typeInfo);
  }
  ExtractBits(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if ("u32" !== s2.typeInfo.name && "x32" !== s2.typeInfo.name)
      return console.error(`ExtractBits() expects an i32 offset argument. Line ${e2.line}`), null;
    if ("u32" !== r2.typeInfo.name && "x32" !== r2.typeInfo.name)
      return console.error(`ExtractBits() expects an i32 count argument. Line ${e2.line}`), null;
    const a2 = s2.value, i3 = r2.value;
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => e3 >> a2 & (1 << i3) - 1), n2.typeInfo);
    if ("i32" !== n2.typeInfo.name && "x32" !== n2.typeInfo.name)
      return console.error(`ExtractBits() expects an i32 argument. Line ${e2.line}`), null;
    const o3 = n2.value;
    return new Be(o3 >> a2 & (1 << i3) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me) {
      const e3 = this._dot(s2.data, r2.data);
      return new Me(e3 < 0 ? Array.from(n2.data) : n2.data.map((e4) => -e4), n2.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${e2.line}`), null;
  }
  _firstLeadingBit(e2) {
    return 0 === e2 ? -1 : 31 - Math.clz32(e2);
  }
  FirstLeadingBit(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => this._firstLeadingBit(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._firstLeadingBit(s2.value), n2.typeInfo);
  }
  _firstTrailingBit(e2) {
    return 0 === e2 ? -1 : Math.log2(e2 & -e2);
  }
  FirstTrailingBit(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => this._firstTrailingBit(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(this._firstTrailingBit(s2.value), n2.typeInfo);
  }
  Floor(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.floor(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.floor(s2.value), n2.typeInfo);
  }
  Fma(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me)
      return n2.data.length !== s2.data.length || n2.data.length !== r2.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e2.line}`), null) : new Me(n2.data.map((e3, t3) => e3 * s2.data[t3] + r2.data[t3]), n2.typeInfo);
    const a2 = n2, i3 = s2, o3 = r2;
    return new Be(a2.value * i3.value + o3.value, a2.typeInfo);
  }
  Fract(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => e3 - Math.floor(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(s2.value - Math.floor(s2.value), n2.typeInfo);
  }
  Frexp(e2, t2) {
    return console.error(`TODO: frexp. Line ${e2.line}`), null;
  }
  InsertBits(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2), a2 = this.exec.evalExpression(e2.args[3], t2);
    if ("u32" !== r2.typeInfo.name && "x32" !== r2.typeInfo.name)
      return console.error(`InsertBits() expects an i32 offset argument. Line ${e2.line}`), null;
    const i3 = r2.value, o3 = (1 << a2.value) - 1 << i3, c2 = ~o3;
    if (n2 instanceof Me && s2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => e3 & c2 | s2.data[t3] << i3 & o3), n2.typeInfo);
    const l2 = n2.value, u2 = s2.value;
    return new Be(l2 & c2 | u2 << i3 & o3, n2.typeInfo);
  }
  InverseSqrt(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => 1 / Math.sqrt(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(1 / Math.sqrt(s2.value), n2.typeInfo);
  }
  Ldexp(e2, t2) {
    return console.error(`TODO: ldexp. Line ${e2.line}`), null;
  }
  Length(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me) {
      let e3 = 0;
      return n2.data.forEach((t3) => {
        e3 += t3 * t3;
      }), new Be(Math.sqrt(e3), this.getTypeInfo("f32"));
    }
    const s2 = n2;
    return new Be(Math.abs(s2.value), n2.typeInfo);
  }
  Log(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.log(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.log(s2.value), n2.typeInfo);
  }
  Log2(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.log2(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.log2(s2.value), n2.typeInfo);
  }
  Max(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => Math.max(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.max(r2.value, a2.value), n2.typeInfo);
  }
  Min(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => Math.min(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.min(r2.value, a2.value), n2.typeInfo);
  }
  Mix(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => n2.data[t3] * (1 - r2.data[t3]) + s2.data[t3] * r2.data[t3]), n2.typeInfo);
    const a2 = s2, i3 = r2;
    return new Be(n2.value * (1 - i3.value) + a2.value * i3.value, n2.typeInfo);
  }
  Modf(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => e3 % s2.data[t3]), n2.typeInfo);
    const r2 = s2;
    return new Be(n2.value % r2.value, n2.typeInfo);
  }
  Normalize(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me) {
      const s2 = this.Length(e2, t2).value;
      return new Me(n2.data.map((e3) => e3 / s2), n2.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${e2.line}`), null;
  }
  Pow(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me)
      return new Me(n2.data.map((e3, t3) => Math.pow(e3, s2.data[t3])), n2.typeInfo);
    const r2 = n2, a2 = s2;
    return new Be(Math.pow(r2.value, a2.value), n2.typeInfo);
  }
  QuantizeToF16(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => e3), n2.typeInfo);
    return new Be(n2.value, n2.typeInfo);
  }
  Radians(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => e3 * Math.PI / 180), n2.typeInfo);
    return new Be(n2.value * Math.PI / 180, this.getTypeInfo("f32"));
  }
  Reflect(e2, t2) {
    let n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (n2 instanceof Me && s2 instanceof Me) {
      const e3 = this._dot(n2.data, s2.data);
      return new Me(n2.data.map((t3, n3) => t3 - 2 * e3 * s2.data[n3]), n2.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${e2.line}`), null;
  }
  Refract(e2, t2) {
    let n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (n2 instanceof Me && s2 instanceof Me && r2 instanceof Be) {
      const e3 = this._dot(s2.data, n2.data);
      return new Me(n2.data.map((t3, n3) => {
        const a2 = 1 - r2.value * r2.value * (1 - e3 * e3);
        if (a2 < 0)
          return 0;
        const i3 = Math.sqrt(a2);
        return r2.value * t3 - (r2.value * e3 + i3) * s2.data[n3];
      }), n2.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e2.line}`), null;
  }
  ReverseBits(e2, t2) {
    return console.error(`TODO: reverseBits. Line ${e2.line}`), null;
  }
  Round(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.round(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.round(s2.value), n2.typeInfo);
  }
  Saturate(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.min(Math.max(e3, 0), 1)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.min(Math.max(s2.value, 0), 1), n2.typeInfo);
  }
  Sign(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.sign(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sign(s2.value), n2.typeInfo);
  }
  Sin(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.sin(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sin(s2.value), n2.typeInfo);
  }
  Sinh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.sinh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sinh(s2.value), n2.typeInfo);
  }
  _smoothstep(e2, t2, n2) {
    const s2 = Math.min(Math.max((n2 - e2) / (t2 - e2), 0), 1);
    return s2 * s2 * (3 - 2 * s2);
  }
  SmoothStep(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2), r2 = this.exec.evalExpression(e2.args[2], t2);
    if (r2 instanceof Me && n2 instanceof Me && s2 instanceof Me)
      return new Me(r2.data.map((e3, t3) => this._smoothstep(n2.data[t3], s2.data[t3], e3)), r2.typeInfo);
    const a2 = n2, i3 = s2, o3 = r2;
    return new Be(this._smoothstep(a2.value, i3.value, o3.value), r2.typeInfo);
  }
  Sqrt(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.sqrt(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.sqrt(s2.value), n2.typeInfo);
  }
  Step(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2), s2 = this.exec.evalExpression(e2.args[1], t2);
    if (s2 instanceof Me && n2 instanceof Me)
      return new Me(s2.data.map((e3, t3) => e3 < n2.data[t3] ? 0 : 1), s2.typeInfo);
    const r2 = n2;
    return new Be(s2.value < r2.value ? 0 : 1, r2.typeInfo);
  }
  Tan(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.tan(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.tan(s2.value), n2.typeInfo);
  }
  Tanh(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.tanh(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.tanh(s2.value), n2.typeInfo);
  }
  _getTransposeType(e2) {
    const t2 = e2.getTypeName();
    return "mat2x2f" === t2 || "mat2x2h" === t2 ? e2 : "mat2x3f" === t2 ? this.getTypeInfo("mat3x2f") : "mat2x3h" === t2 ? this.getTypeInfo("mat3x2h") : "mat2x4f" === t2 ? this.getTypeInfo("mat4x2f") : "mat2x4h" === t2 ? this.getTypeInfo("mat4x2h") : "mat3x2f" === t2 ? this.getTypeInfo("mat2x3f") : "mat3x2h" === t2 ? this.getTypeInfo("mat2x3h") : "mat3x3f" === t2 || "mat3x3h" === t2 ? e2 : "mat3x4f" === t2 ? this.getTypeInfo("mat4x3f") : "mat3x4h" === t2 ? this.getTypeInfo("mat4x3h") : "mat4x2f" === t2 ? this.getTypeInfo("mat2x4f") : "mat4x2h" === t2 ? this.getTypeInfo("mat2x4h") : "mat4x3f" === t2 ? this.getTypeInfo("mat3x4f") : "mat4x3h" === t2 ? this.getTypeInfo("mat3x4h") : ("mat4x4f" === t2 || "mat4x4h" === t2 || console.error(`Invalid matrix type ${t2}`), e2);
  }
  Transpose(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (!(n2 instanceof Ue))
      return console.error(`Transpose() expects a matrix argument. Line ${e2.line}`), null;
    const s2 = this._getTransposeType(n2.typeInfo);
    if ("mat2x2" === n2.typeInfo.name || "mat2x2f" === n2.typeInfo.name || "mat2x2h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[2], e3[1], e3[3]], s2);
    }
    if ("mat2x3" === n2.typeInfo.name || "mat2x3f" === n2.typeInfo.name || "mat2x3h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[3], e3[6], e3[1], e3[4], e3[7]], s2);
    }
    if ("mat2x4" === n2.typeInfo.name || "mat2x4f" === n2.typeInfo.name || "mat2x4h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[4], e3[8], e3[12], e3[1], e3[5], e3[9], e3[13]], s2);
    }
    if ("mat3x2" === n2.typeInfo.name || "mat3x2f" === n2.typeInfo.name || "mat3x2h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[3], e3[1], e3[4], e3[2], e3[5]], s2);
    }
    if ("mat3x3" === n2.typeInfo.name || "mat3x3f" === n2.typeInfo.name || "mat3x3h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[3], e3[6], e3[1], e3[4], e3[7], e3[2], e3[5], e3[8]], s2);
    }
    if ("mat3x4" === n2.typeInfo.name || "mat3x4f" === n2.typeInfo.name || "mat3x4h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[4], e3[8], e3[12], e3[1], e3[5], e3[9], e3[13], e3[2], e3[6], e3[10], e3[14]], s2);
    }
    if ("mat4x2" === n2.typeInfo.name || "mat4x2f" === n2.typeInfo.name || "mat4x2h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[4], e3[1], e3[5], e3[2], e3[6]], s2);
    }
    if ("mat4x3" === n2.typeInfo.name || "mat4x3f" === n2.typeInfo.name || "mat4x3h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[4], e3[8], e3[1], e3[5], e3[9], e3[2], e3[6], e3[10]], s2);
    }
    if ("mat4x4" === n2.typeInfo.name || "mat4x4f" === n2.typeInfo.name || "mat4x4h" === n2.typeInfo.name) {
      const e3 = n2.data;
      return new Ue([e3[0], e3[4], e3[8], e3[12], e3[1], e3[5], e3[9], e3[13], e3[2], e3[6], e3[10], e3[14], e3[3], e3[7], e3[11], e3[15]], s2);
    }
    return console.error(`Invalid matrix type ${n2.typeInfo.name}`), null;
  }
  Trunc(e2, t2) {
    const n2 = this.exec.evalExpression(e2.args[0], t2);
    if (n2 instanceof Me)
      return new Me(n2.data.map((e3) => Math.trunc(e3)), n2.typeInfo);
    const s2 = n2;
    return new Be(Math.trunc(s2.value), n2.typeInfo);
  }
  Dpdx(e2, t2) {
    return console.error(`TODO: dpdx. Line ${e2.line}`), null;
  }
  DpdxCoarse(e2, t2) {
    return console.error(`TODO: dpdxCoarse. Line ${e2.line}`), null;
  }
  DpdxFine(e2, t2) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(e2, t2) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(e2, t2) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(e2, t2) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(e2, t2) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(e2, t2) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(e2, t2) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(e2, t2) {
    const n2 = e2.args[0], s2 = e2.args.length > 1 ? this.exec.evalExpression(e2.args[1], t2).value : 0;
    if (n2 instanceof ge) {
      const r2 = n2.name, a2 = t2.getVariableValue(r2);
      if (a2 instanceof We) {
        if (s2 < 0 || s2 >= a2.mipLevelCount)
          return console.error(`Invalid mip level for textureDimensions. Line ${e2.line}`), null;
        const t3 = a2.getMipLevelSize(s2), n3 = a2.dimension;
        return "1d" === n3 ? new Be(t3[0], this.getTypeInfo("u32")) : "3d" === n3 ? new Me(t3, this.getTypeInfo("vec3u")) : "2d" === n3 ? new Me(t3.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${n3} not found. Line ${e2.line}`), null);
      }
      return console.error(`Texture ${r2} not found. Line ${e2.line}`), null;
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${e2.line}`), null;
  }
  TextureGather(e2, t2) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(e2, t2) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(e2, t2) {
    const n2 = e2.args[0], s2 = this.exec.evalExpression(e2.args[1], t2), r2 = e2.args.length > 2 ? this.exec.evalExpression(e2.args[2], t2).value : 0;
    if (!(s2 instanceof Me) || 2 !== s2.data.length)
      return console.error(`Invalid UV argument for textureLoad. Line ${e2.line}`), null;
    if (n2 instanceof ge) {
      const a2 = n2.name, i3 = t2.getVariableValue(a2);
      if (i3 instanceof We) {
        const t3 = Math.floor(s2.data[0]), n3 = Math.floor(s2.data[1]);
        if (t3 < 0 || t3 >= i3.width || n3 < 0 || n3 >= i3.height)
          return console.error(`Texture ${a2} out of bounds. Line ${e2.line}`), null;
        const o3 = i3.getPixel(t3, n3, 0, r2);
        return null === o3 ? (console.error(`Invalid texture format for textureLoad. Line ${e2.line}`), null) : new Me(o3, this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${a2} not found. Line ${e2.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${e2.line}`), null;
  }
  TextureNumLayers(e2, t2) {
    const n2 = e2.args[0];
    if (n2 instanceof ge) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof We ? new Be(r2.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e2.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLayers. Line ${e2.line}`), null;
  }
  TextureNumLevels(e2, t2) {
    const n2 = e2.args[0];
    if (n2 instanceof ge) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof We ? new Be(r2.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e2.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLevels. Line ${e2.line}`), null;
  }
  TextureNumSamples(e2, t2) {
    const n2 = e2.args[0];
    if (n2 instanceof ge) {
      const s2 = n2.name, r2 = t2.getVariableValue(s2);
      return r2 instanceof We ? new Be(r2.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s2} not found. Line ${e2.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumSamples. Line ${e2.line}`), null;
  }
  TextureSample(e2, t2) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(e2, t2) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(e2, t2) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(e2, t2) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(e2, t2) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(e2, t2) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(e2, t2) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(e2, t2) {
    const n2 = e2.args[0], s2 = this.exec.evalExpression(e2.args[1], t2), r2 = 4 === e2.args.length ? this.exec.evalExpression(e2.args[2], t2).value : 0, a2 = 4 === e2.args.length ? this.exec.evalExpression(e2.args[3], t2).data : this.exec.evalExpression(e2.args[2], t2).data;
    if (4 !== a2.length)
      return console.error(`Invalid value argument for textureStore. Line ${e2.line}`), null;
    if (!(s2 instanceof Me) || 2 !== s2.data.length)
      return console.error(`Invalid UV argument for textureStore. Line ${e2.line}`), null;
    if (n2 instanceof ge) {
      const i3 = n2.name, o3 = t2.getVariableValue(i3);
      if (o3 instanceof We) {
        const t3 = o3.getMipLevelSize(0), n3 = Math.floor(s2.data[0]), c2 = Math.floor(s2.data[1]);
        return n3 < 0 || n3 >= t3[0] || c2 < 0 || c2 >= t3[1] ? (console.error(`Texture ${i3} out of bounds. Line ${e2.line}`), null) : (o3.setPixel(n3, c2, 0, r2, Array.from(a2)), null);
      }
      return console.error(`Texture ${i3} not found. Line ${e2.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${e2.line}`), null;
  }
  AtomicLoad(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2);
    return t2.getVariable(s2).value.getSubData(this.exec, n2.postfix, t2);
  }
  AtomicStore(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2);
    return o3 instanceof Be && i3 instanceof Be && (o3.value = i3.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), null;
  }
  AtomicAdd(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value += i3.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicSub(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value -= i3.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicMax(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value = Math.max(o3.value, i3.value)), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicMin(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value = Math.min(o3.value, i3.value)), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicAnd(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value = o3.value & i3.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicOr(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value = o3.value | i3.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicXor(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value = o3.value ^ i3.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicExchange(e2, t2) {
    let n2 = e2.args[0];
    n2 instanceof ke && (n2 = n2.right);
    const s2 = this.exec.getVariableName(n2, t2), r2 = t2.getVariable(s2);
    let a2 = e2.args[1];
    const i3 = this.exec.evalExpression(a2, t2), o3 = r2.value.getSubData(this.exec, n2.postfix, t2), c2 = new Be(o3.value, o3.typeInfo);
    return o3 instanceof Be && i3 instanceof Be && (o3.value = i3.value), r2.value instanceof Pe && r2.value.setDataValue(this.exec, o3, n2.postfix, t2), c2;
  }
  AtomicCompareExchangeWeak(e2, t2) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(e2, t2) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(e2, t2) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(e2, t2) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(e2, t2) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(e2, t2) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(e2, t2) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(e2, t2) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(e2, t2) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(e2, t2) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(e2, t2) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(e2, t2) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(e2, t2) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(e2, t2) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(e2, t2) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(e2, t2) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(e2, t2) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(e2, t2) {
    return null;
  }
  TextureBarrier(e2, t2) {
    return null;
  }
  WorkgroupBarrier(e2, t2) {
    return null;
  }
  WorkgroupUniformLoad(e2, t2) {
    return null;
  }
  SubgroupAdd(e2, t2) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(e2, t2) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(e2, t2) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(e2, t2) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(e2, t2) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(e2, t2) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(e2, t2) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(e2, t2) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(e2, t2) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(e2, t2) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(e2, t2) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(e2, t2) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(e2, t2) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(e2, t2) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(e2, t2) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(e2, t2) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(e2, t2) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(e2, t2) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(e2, t2) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(e2, t2) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(e2, t2) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(e2, t2) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(e2, t2) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(e2, t2) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(e2, t2) {
    return console.error("TODO: quadSwapY"), null;
  }
};
var ft = { vec2: 2, vec2f: 2, vec2i: 2, vec2u: 2, vec2b: 2, vec2h: 2, vec3: 3, vec3f: 3, vec3i: 3, vec3u: 3, vec3b: 3, vec3h: 3, vec4: 4, vec4f: 4, vec4i: 4, vec4u: 4, vec4b: 4, vec4h: 4 };
var pt = { mat2x2: [2, 2, 4], mat2x2f: [2, 2, 4], mat2x2h: [2, 2, 4], mat2x3: [2, 3, 6], mat2x3f: [2, 3, 6], mat2x3h: [2, 3, 6], mat2x4: [2, 4, 8], mat2x4f: [2, 4, 8], mat2x4h: [2, 4, 8], mat3x2: [3, 2, 6], mat3x2f: [3, 2, 6], mat3x2h: [3, 2, 6], mat3x3: [3, 3, 9], mat3x3f: [3, 3, 9], mat3x3h: [3, 3, 9], mat3x4: [3, 4, 12], mat3x4f: [3, 4, 12], mat3x4h: [3, 4, 12], mat4x2: [4, 2, 8], mat4x2f: [4, 2, 8], mat4x2h: [4, 2, 8], mat4x3: [4, 3, 12], mat4x3f: [4, 3, 12], mat4x3h: [4, 3, 12], mat4x4: [4, 4, 16], mat4x4f: [4, 4, 16], mat4x4h: [4, 4, 16] };
var dt = class _dt extends ut {
  constructor(e2, t2) {
    var n2;
    super(), this.ast = null != e2 ? e2 : [], this.reflection = new at(), this.reflection.updateAST(this.ast), this.context = null !== (n2 = null == t2 ? void 0 : t2.clone()) && void 0 !== n2 ? n2 : new lt(), this.builtins = new ht(this), this.typeInfo = { bool: this.getTypeInfo(ae.bool), i32: this.getTypeInfo(ae.i32), u32: this.getTypeInfo(ae.u32), f32: this.getTypeInfo(ae.f32), f16: this.getTypeInfo(ae.f16), vec2f: this.getTypeInfo(ce.vec2f), vec2u: this.getTypeInfo(ce.vec2u), vec2i: this.getTypeInfo(ce.vec2i), vec2h: this.getTypeInfo(ce.vec2h), vec3f: this.getTypeInfo(ce.vec3f), vec3u: this.getTypeInfo(ce.vec3u), vec3i: this.getTypeInfo(ce.vec3i), vec3h: this.getTypeInfo(ce.vec3h), vec4f: this.getTypeInfo(ce.vec4f), vec4u: this.getTypeInfo(ce.vec4u), vec4i: this.getTypeInfo(ce.vec4i), vec4h: this.getTypeInfo(ce.vec4h), mat2x2f: this.getTypeInfo(ce.mat2x2f), mat2x3f: this.getTypeInfo(ce.mat2x3f), mat2x4f: this.getTypeInfo(ce.mat2x4f), mat3x2f: this.getTypeInfo(ce.mat3x2f), mat3x3f: this.getTypeInfo(ce.mat3x3f), mat3x4f: this.getTypeInfo(ce.mat3x4f), mat4x2f: this.getTypeInfo(ce.mat4x2f), mat4x3f: this.getTypeInfo(ce.mat4x3f), mat4x4f: this.getTypeInfo(ce.mat4x4f) };
  }
  getVariableValue(e2) {
    var t2, n2;
    const r2 = null !== (n2 = null === (t2 = this.context.getVariable(e2)) || void 0 === t2 ? void 0 : t2.value) && void 0 !== n2 ? n2 : null;
    if (null === r2)
      return null;
    if (r2 instanceof Be)
      return r2.value;
    if (r2 instanceof Me)
      return Array.from(r2.data);
    if (r2 instanceof Ue)
      return Array.from(r2.data);
    if (r2 instanceof Pe && r2.typeInfo instanceof s) {
      if ("u32" === r2.typeInfo.format.name)
        return Array.from(new Uint32Array(r2.buffer, r2.offset, r2.typeInfo.count));
      if ("i32" === r2.typeInfo.format.name)
        return Array.from(new Int32Array(r2.buffer, r2.offset, r2.typeInfo.count));
      if ("f32" === r2.typeInfo.format.name)
        return Array.from(new Float32Array(r2.buffer, r2.offset, r2.typeInfo.count));
    }
    return console.error(`Unsupported return variable type ${r2.typeInfo.name}`), null;
  }
  execute(e2) {
    (e2 = null != e2 ? e2 : {}).constants && this._setOverrides(e2.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(e2, t2, n2, s2) {
    const r2 = this.context.clone();
    (s2 = null != s2 ? s2 : {}).constants && this._setOverrides(s2.constants, r2), this._execStatements(this.ast, r2);
    const a2 = r2.getFunction(e2);
    if (!a2)
      return void console.error(`Function ${e2} not found`);
    if ("number" == typeof t2)
      t2 = [t2, 1, 1];
    else {
      if (0 === t2.length)
        return void console.error("Invalid dispatch count");
      1 === t2.length ? t2 = [t2[0], 1, 1] : 2 === t2.length ? t2 = [t2[0], t2[1], 1] : t2.length > 3 && (t2 = [t2[0], t2[1], t2[2]]);
    }
    const i3 = t2[0], o3 = t2[1], c2 = t2[2], l2 = this.getTypeInfo("vec3u");
    r2.setVariable("@num_workgroups", new Me(t2, l2));
    const u2 = this.reflection.getFunctionInfo(e2);
    null === u2 && console.error(`Function ${e2} not found in reflection data`);
    for (const e3 in n2)
      for (const t3 in n2[e3]) {
        const s3 = n2[e3][t3];
        r2.variables.forEach((n3) => {
          var r3;
          const a3 = n3.node;
          if (null == a3 ? void 0 : a3.attributes) {
            let i4 = null, o4 = null;
            for (const e4 of a3.attributes)
              "binding" === e4.name ? i4 = e4.value : "group" === e4.name && (o4 = e4.value);
            if (t3 == i4 && e3 == o4) {
              let i5 = false;
              for (const s4 of u2.resources)
                if (s4.name === n3.name && s4.group === parseInt(e3) && s4.binding === parseInt(t3)) {
                  i5 = true;
                  break;
                }
              if (i5)
                if (void 0 !== s3.texture && void 0 !== s3.descriptor) {
                  const e4 = new We(s3.texture, this.getTypeInfo(a3.type), s3.descriptor, null !== (r3 = s3.texture.view) && void 0 !== r3 ? r3 : null);
                  n3.value = e4;
                } else
                  void 0 !== s3.uniform ? n3.value = new Pe(s3.uniform, this.getTypeInfo(a3.type)) : n3.value = new Pe(s3, this.getTypeInfo(a3.type));
            }
          }
        });
      }
    for (let e3 = 0; e3 < c2; ++e3)
      for (let t3 = 0; t3 < o3; ++t3)
        for (let n3 = 0; n3 < i3; ++n3)
          r2.setVariable("@workgroup_id", new Me([n3, t3, e3], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(a2, [n3, t3, e3], r2);
  }
  execStatement(e2, t2) {
    if (e2 instanceof Y)
      return this.evalExpression(e2.value, t2);
    if (e2 instanceof se) {
      if (e2.condition) {
        const n2 = this.evalExpression(e2.condition, t2);
        if (!(n2 instanceof Be))
          throw new Error("Invalid break-if condition");
        if (!n2.value)
          return null;
      }
      return _dt._breakObj;
    }
    if (e2 instanceof re)
      return _dt._continueObj;
    if (e2 instanceof U)
      this._let(e2, t2);
    else if (e2 instanceof F)
      this._var(e2, t2);
    else if (e2 instanceof P)
      this._const(e2, t2);
    else if (e2 instanceof D2)
      this._function(e2, t2);
    else {
      if (e2 instanceof Q2)
        return this._if(e2, t2);
      if (e2 instanceof Z)
        return this._switch(e2, t2);
      if (e2 instanceof B2)
        return this._for(e2, t2);
      if (e2 instanceof V)
        return this._while(e2, t2);
      if (e2 instanceof j)
        return this._loop(e2, t2);
      if (e2 instanceof O) {
        const n2 = t2.clone();
        return n2.currentFunctionName = t2.currentFunctionName, this._execStatements(e2.body, n2);
      }
      if (e2 instanceof G2)
        this._assign(e2, t2);
      else if (e2 instanceof R)
        this._increment(e2, t2);
      else {
        if (e2 instanceof oe)
          return null;
        if (e2 instanceof M) {
          const n2 = e2.name;
          null === t2.getVariable(n2) && t2.setVariable(n2, new Be(0, this.getTypeInfo("u32")));
        } else if (e2 instanceof X)
          this._call(e2, t2);
        else {
          if (e2 instanceof ee)
            return null;
          if (e2 instanceof te)
            return null;
          console.error("Invalid statement type.", e2, `Line ${e2.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(e2, t2) {
    return e2 instanceof Ie ? this._evalBinaryOp(e2, t2) : e2 instanceof xe ? this._evalLiteral(e2, t2) : e2 instanceof ge ? this._evalVariable(e2, t2) : e2 instanceof me ? this._evalCall(e2, t2) : e2 instanceof de ? this._evalCreate(e2, t2) : e2 instanceof _e ? this._evalConst(e2, t2) : e2 instanceof ye ? this._evalBitcast(e2, t2) : e2 instanceof ke ? this._evalUnaryOp(e2, t2) : (console.error("Invalid expression type", e2, `Line ${e2.line}`), null);
  }
  getTypeInfo(e2) {
    var t2;
    if (e2 instanceof ae) {
      const t3 = this.reflection.getTypeInfo(e2);
      if (null !== t3)
        return t3;
    }
    let n2 = null !== (t2 = this.typeInfo[e2]) && void 0 !== t2 ? t2 : null;
    return null !== n2 || (n2 = this.reflection.getTypeInfoByName(e2)), n2;
  }
  _setOverrides(e2, t2) {
    for (const n2 in e2) {
      const s2 = e2[n2], r2 = this.reflection.getOverrideInfo(n2);
      null !== r2 ? (null === r2.type && (r2.type = this.getTypeInfo("u32")), "u32" === r2.type.name || "i32" === r2.type.name || "f32" === r2.type.name || "f16" === r2.type.name ? t2.setVariable(n2, new Be(s2, r2.type)) : "bool" === r2.type.name ? t2.setVariable(n2, new Be(s2 ? 1 : 0, r2.type)) : "vec2" === r2.type.name || "vec3" === r2.type.name || "vec4" === r2.type.name || "vec2f" === r2.type.name || "vec3f" === r2.type.name || "vec4f" === r2.type.name || "vec2i" === r2.type.name || "vec3i" === r2.type.name || "vec4i" === r2.type.name || "vec2u" === r2.type.name || "vec3u" === r2.type.name || "vec4u" === r2.type.name || "vec2h" === r2.type.name || "vec3h" === r2.type.name || "vec4h" === r2.type.name ? t2.setVariable(n2, new Me(s2, r2.type)) : console.error(`Invalid constant type for ${n2}`)) : console.error(`Override ${n2} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(e2, t2, n2) {
    const s2 = [1, 1, 1];
    for (const t3 of e2.node.attributes)
      if ("workgroup_size" === t3.name) {
        if (t3.value.length > 0) {
          const e3 = n2.getVariableValue(t3.value[0]);
          s2[0] = e3 instanceof Be ? e3.value : parseInt(t3.value[0]);
        }
        if (t3.value.length > 1) {
          const e3 = n2.getVariableValue(t3.value[1]);
          s2[1] = e3 instanceof Be ? e3.value : parseInt(t3.value[1]);
        }
        if (t3.value.length > 2) {
          const e3 = n2.getVariableValue(t3.value[2]);
          s2[2] = e3 instanceof Be ? e3.value : parseInt(t3.value[2]);
        }
      }
    const r2 = this.getTypeInfo("vec3u"), a2 = this.getTypeInfo("u32");
    n2.setVariable("@workgroup_size", new Me(s2, r2));
    const i3 = s2[0], o3 = s2[1], c2 = s2[2];
    for (let l2 = 0, u2 = 0; l2 < c2; ++l2)
      for (let c3 = 0; c3 < o3; ++c3)
        for (let o4 = 0; o4 < i3; ++o4, ++u2) {
          const i4 = [o4, c3, l2], h2 = [o4 + t2[0] * s2[0], c3 + t2[1] * s2[1], l2 + t2[2] * s2[2]];
          n2.setVariable("@local_invocation_id", new Me(i4, r2)), n2.setVariable("@global_invocation_id", new Me(h2, r2)), n2.setVariable("@local_invocation_index", new Be(u2, a2)), this._dispatchExec(e2, n2);
        }
  }
  _dispatchExec(e2, t2) {
    for (const n2 of e2.node.args)
      for (const e3 of n2.attributes)
        if ("builtin" === e3.name) {
          const s2 = `@${e3.value}`, r2 = t2.getVariable(s2);
          void 0 !== r2 && t2.variables.set(n2.name, r2);
        }
    this._execStatements(e2.node.body, t2);
  }
  getVariableName(e2, t2) {
    for (; e2 instanceof ke; )
      e2 = e2.right;
    return e2 instanceof ge ? e2.name : (console.error("Unknown variable type", e2, "Line", e2.line), null);
  }
  _execStatements(e2, t2) {
    for (const n2 of e2) {
      if (n2 instanceof Array) {
        const e4 = t2.clone(), s2 = this._execStatements(n2, e4);
        if (s2)
          return s2;
        continue;
      }
      const e3 = this.execStatement(n2, t2);
      if (e3)
        return e3;
    }
    return null;
  }
  _call(e2, t2) {
    const n2 = t2.clone();
    n2.currentFunctionName = e2.name;
    const s2 = t2.getFunction(e2.name);
    if (s2) {
      for (let t3 = 0; t3 < s2.node.args.length; ++t3) {
        const r2 = s2.node.args[t3], a2 = this.evalExpression(e2.args[t3], n2);
        n2.setVariable(r2.name, a2, r2);
      }
      this._execStatements(s2.node.body, n2);
    } else if (e2.isBuiltin)
      this._callBuiltinFunction(e2, n2);
    else {
      this.getTypeInfo(e2.name) && this._evalCreate(e2, t2);
    }
  }
  _increment(e2, t2) {
    const n2 = this.getVariableName(e2.variable, t2), s2 = t2.getVariable(n2);
    s2 ? "++" === e2.operator ? s2.value instanceof Be ? s2.value.value++ : console.error(`Variable ${n2} is not a scalar. Line ${e2.line}`) : "--" === e2.operator ? s2.value instanceof Be ? s2.value.value-- : console.error(`Variable ${n2} is not a scalar. Line ${e2.line}`) : console.error(`Unknown increment operator ${e2.operator}. Line ${e2.line}`) : console.error(`Variable ${n2} not found. Line ${e2.line}`);
  }
  _getVariableData(e2, t2) {
    if (e2 instanceof ge) {
      const n2 = this.getVariableName(e2, t2), s2 = t2.getVariable(n2);
      return null === s2 ? (console.error(`Variable ${n2} not found. Line ${e2.line}`), null) : s2.value.getSubData(this, e2.postfix, t2);
    }
    if (e2 instanceof ke) {
      if ("*" === e2.operator) {
        const n2 = this._getVariableData(e2.right, t2);
        return n2 instanceof Oe ? n2.reference.getSubData(this, e2.postfix, t2) : (console.error(`Variable ${e2.right} is not a pointer. Line ${e2.line}`), null);
      }
      if ("&" === e2.operator) {
        const n2 = this._getVariableData(e2.right, t2);
        return new Oe(n2);
      }
    }
    return null;
  }
  _assign(e2, t2) {
    let n2 = null, s2 = "<var>", r2 = null;
    if (e2.variable instanceof ke) {
      const n3 = this._getVariableData(e2.variable, t2), s3 = this.evalExpression(e2.value, t2), r3 = e2.operator;
      if ("=" === r3) {
        if (n3 instanceof Be || n3 instanceof Me || n3 instanceof Ue) {
          if (s3 instanceof Be || s3 instanceof Me || s3 instanceof Ue && n3.data.length === s3.data.length)
            return void n3.data.set(s3.data);
          console.error(`Invalid assignment. Line ${e2.line}`);
        } else if (n3 instanceof Pe && s3 instanceof Pe && n3.buffer.byteLength - n3.offset >= s3.buffer.byteLength - s3.offset)
          return void (n3.buffer.byteLength % 4 == 0 ? new Uint32Array(n3.buffer, n3.offset, n3.typeInfo.size / 4).set(new Uint32Array(s3.buffer, s3.offset, s3.typeInfo.size / 4)) : new Uint8Array(n3.buffer, n3.offset, n3.typeInfo.size).set(new Uint8Array(s3.buffer, s3.offset, s3.typeInfo.size)));
        return console.error(`Invalid assignment. Line ${e2.line}`), null;
      }
      if ("+=" === r3)
        return n3 instanceof Be || n3 instanceof Me || n3 instanceof Ue ? s3 instanceof Be || s3 instanceof Me || s3 instanceof Ue ? void n3.data.set(s3.data.map((e3, t3) => n3.data[t3] + e3)) : void console.error(`Invalid assignment . Line ${e2.line}`) : void console.error(`Invalid assignment. Line ${e2.line}`);
      if ("-=" === r3)
        return (n3 instanceof Be || n3 instanceof Me || n3 instanceof Ue) && (s3 instanceof Be || s3 instanceof Me || s3 instanceof Ue) ? void n3.data.set(s3.data.map((e3, t3) => n3.data[t3] - e3)) : void console.error(`Invalid assignment. Line ${e2.line}`);
    }
    if (e2.variable instanceof ke) {
      if ("*" === e2.variable.operator) {
        s2 = this.getVariableName(e2.variable.right, t2);
        const r3 = t2.getVariable(s2);
        if (!(r3 && r3.value instanceof Oe))
          return void console.error(`Variable ${s2} is not a pointer. Line ${e2.line}`);
        n2 = r3.value.reference;
        let a3 = e2.variable.postfix;
        if (!a3) {
          let t3 = e2.variable.right;
          for (; t3 instanceof ke; ) {
            if (t3.postfix) {
              a3 = t3.postfix;
              break;
            }
            t3 = t3.right;
          }
        }
        a3 && (n2 = n2.getSubData(this, a3, t2));
      }
    } else {
      r2 = e2.variable.postfix, s2 = this.getVariableName(e2.variable, t2);
      const a3 = t2.getVariable(s2);
      if (null === a3)
        return void console.error(`Variable ${s2} not found. Line ${e2.line}`);
      n2 = a3.value;
    }
    if (n2 instanceof Oe && (n2 = n2.reference), null === n2)
      return void console.error(`Variable ${s2} not found. Line ${e2.line}`);
    const a2 = this.evalExpression(e2.value, t2), i3 = e2.operator;
    if ("=" !== i3) {
      const s3 = n2.getSubData(this, r2, t2);
      if (s3 instanceof Me && a2 instanceof Be) {
        const t3 = s3.data, n3 = a2.value;
        if ("+=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] += n3;
        else if ("-=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] -= n3;
        else if ("*=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] *= n3;
        else if ("/=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] /= n3;
        else if ("%=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] %= n3;
        else if ("&=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] &= n3;
        else if ("|=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] |= n3;
        else if ("^=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] ^= n3;
        else if ("<<=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] <<= n3;
        else if (">>=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] >>= n3;
        else
          console.error(`Invalid operator ${i3}. Line ${e2.line}`);
      } else if (s3 instanceof Me && a2 instanceof Me) {
        const t3 = s3.data, n3 = a2.data;
        if (t3.length !== n3.length)
          return void console.error(`Vector length mismatch. Line ${e2.line}`);
        if ("+=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] += n3[e3];
        else if ("-=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] -= n3[e3];
        else if ("*=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] *= n3[e3];
        else if ("/=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] /= n3[e3];
        else if ("%=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] %= n3[e3];
        else if ("&=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] &= n3[e3];
        else if ("|=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] |= n3[e3];
        else if ("^=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] ^= n3[e3];
        else if ("<<=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] <<= n3[e3];
        else if (">>=" === i3)
          for (let e3 = 0; e3 < t3.length; ++e3)
            t3[e3] >>= n3[e3];
        else
          console.error(`Invalid operator ${i3}. Line ${e2.line}`);
      } else {
        if (!(s3 instanceof Be && a2 instanceof Be))
          return void console.error(`Invalid type for ${e2.operator} operator. Line ${e2.line}`);
        "+=" === i3 ? s3.value += a2.value : "-=" === i3 ? s3.value -= a2.value : "*=" === i3 ? s3.value *= a2.value : "/=" === i3 ? s3.value /= a2.value : "%=" === i3 ? s3.value %= a2.value : "&=" === i3 ? s3.value &= a2.value : "|=" === i3 ? s3.value |= a2.value : "^=" === i3 ? s3.value ^= a2.value : "<<=" === i3 ? s3.value <<= a2.value : ">>=" === i3 ? s3.value >>= a2.value : console.error(`Invalid operator ${i3}. Line ${e2.line}`);
      }
      return void (n2 instanceof Pe && n2.setDataValue(this, s3, r2, t2));
    }
    if (n2 instanceof Pe)
      n2.setDataValue(this, a2, r2, t2);
    else if (r2) {
      if (!(n2 instanceof Me || n2 instanceof Ue))
        return void console.error(`Variable ${s2} is not a vector or matrix. Line ${e2.line}`);
      if (r2 instanceof ve) {
        const i4 = this.evalExpression(r2.index, t2).value;
        if (n2 instanceof Me) {
          if (!(a2 instanceof Be))
            return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
          n2.data[i4] = a2.value;
        } else {
          if (!(n2 instanceof Ue))
            return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
          {
            const i5 = this.evalExpression(r2.index, t2).value;
            if (i5 < 0)
              return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
            if (!(a2 instanceof Me))
              return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
            {
              const t3 = n2.typeInfo.getTypeName();
              if ("mat2x2" === t3 || "mat2x2f" === t3 || "mat2x2h" === t3) {
                if (!(i5 < 2 && 2 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[2 * i5] = a2.data[0], n2.data[2 * i5 + 1] = a2.data[1];
              } else if ("mat2x3" === t3 || "mat2x3f" === t3 || "mat2x3h" === t3) {
                if (!(i5 < 2 && 3 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[3 * i5] = a2.data[0], n2.data[3 * i5 + 1] = a2.data[1], n2.data[3 * i5 + 2] = a2.data[2];
              } else if ("mat2x4" === t3 || "mat2x4f" === t3 || "mat2x4h" === t3) {
                if (!(i5 < 2 && 4 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[4 * i5] = a2.data[0], n2.data[4 * i5 + 1] = a2.data[1], n2.data[4 * i5 + 2] = a2.data[2], n2.data[4 * i5 + 3] = a2.data[3];
              } else if ("mat3x2" === t3 || "mat3x2f" === t3 || "mat3x2h" === t3) {
                if (!(i5 < 3 && 2 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[2 * i5] = a2.data[0], n2.data[2 * i5 + 1] = a2.data[1];
              } else if ("mat3x3" === t3 || "mat3x3f" === t3 || "mat3x3h" === t3) {
                if (!(i5 < 3 && 3 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[3 * i5] = a2.data[0], n2.data[3 * i5 + 1] = a2.data[1], n2.data[3 * i5 + 2] = a2.data[2];
              } else if ("mat3x4" === t3 || "mat3x4f" === t3 || "mat3x4h" === t3) {
                if (!(i5 < 3 && 4 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[4 * i5] = a2.data[0], n2.data[4 * i5 + 1] = a2.data[1], n2.data[4 * i5 + 2] = a2.data[2], n2.data[4 * i5 + 3] = a2.data[3];
              } else if ("mat4x2" === t3 || "mat4x2f" === t3 || "mat4x2h" === t3) {
                if (!(i5 < 4 && 2 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[2 * i5] = a2.data[0], n2.data[2 * i5 + 1] = a2.data[1];
              } else if ("mat4x3" === t3 || "mat4x3f" === t3 || "mat4x3h" === t3) {
                if (!(i5 < 4 && 3 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[3 * i5] = a2.data[0], n2.data[3 * i5 + 1] = a2.data[1], n2.data[3 * i5 + 2] = a2.data[2];
              } else {
                if ("mat4x4" !== t3 && "mat4x4f" !== t3 && "mat4x4h" !== t3)
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                if (!(i5 < 4 && 4 === a2.data.length))
                  return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
                n2.data[4 * i5] = a2.data[0], n2.data[4 * i5 + 1] = a2.data[1], n2.data[4 * i5 + 2] = a2.data[2], n2.data[4 * i5 + 3] = a2.data[3];
              }
            }
          }
        }
      } else if (r2 instanceof pe) {
        const t3 = r2.value;
        if (!(n2 instanceof Me))
          return void console.error(`Invalid assignment to ${t3}. Variable ${s2} is not a vector. Line ${e2.line}`);
        if (a2 instanceof Be) {
          if (t3.length > 1)
            return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
          if ("x" === t3)
            n2.data[0] = a2.value;
          else if ("y" === t3) {
            if (n2.data.length < 2)
              return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
            n2.data[1] = a2.value;
          } else if ("z" === t3) {
            if (n2.data.length < 3)
              return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
            n2.data[2] = a2.value;
          } else if ("w" === t3) {
            if (n2.data.length < 4)
              return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
            n2.data[3] = a2.value;
          }
        } else {
          if (!(a2 instanceof Me))
            return void console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
          if (t3.length !== a2.data.length)
            return void console.error(`Invalid assignment to ${t3} for variable ${s2}. Line ${e2.line}`);
          for (let r3 = 0; r3 < t3.length; ++r3) {
            const i4 = t3[r3];
            if ("x" === i4 || "r" === i4)
              n2.data[0] = a2.data[r3];
            else if ("y" === i4 || "g" === i4) {
              if (a2.data.length < 2)
                return void console.error(`Invalid assignment to ${i4} for variable ${s2}. Line ${e2.line}`);
              n2.data[1] = a2.data[r3];
            } else if ("z" === i4 || "b" === i4) {
              if (a2.data.length < 3)
                return void console.error(`Invalid assignment to ${i4} for variable ${s2}. Line ${e2.line}`);
              n2.data[2] = a2.data[r3];
            } else {
              if ("w" !== i4 && "a" !== i4)
                return void console.error(`Invalid assignment to ${i4} for variable ${s2}. Line ${e2.line}`);
              if (a2.data.length < 4)
                return void console.error(`Invalid assignment to ${i4} for variable ${s2}. Line ${e2.line}`);
              n2.data[3] = a2.data[r3];
            }
          }
        }
      }
    } else
      n2 instanceof Be && a2 instanceof Be ? n2.value = a2.value : n2 instanceof Me && a2 instanceof Me || n2 instanceof Ue && a2 instanceof Ue ? n2.data.set(a2.data) : console.error(`Invalid assignment to ${s2}. Line ${e2.line}`);
  }
  _function(e2, t2) {
    const n2 = new ct(e2);
    t2.functions.set(e2.name, n2);
  }
  _const(e2, t2) {
    let n2 = null;
    null !== e2.value && (n2 = this.evalExpression(e2.value, t2)), t2.createVariable(e2.name, n2, e2);
  }
  _let(e2, t2) {
    let n2 = null;
    if (null !== e2.value) {
      if (n2 = this.evalExpression(e2.value, t2), null === n2)
        return void console.error(`Invalid value for variable ${e2.name}. Line ${e2.line}`);
      e2.value instanceof ke || (n2 = n2.clone());
    } else {
      const s2 = e2.type.name;
      if ("f32" === s2 || "i32" === s2 || "u32" === s2 || "bool" === s2 || "f16" === s2 || "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2b" === s2 || "vec3b" === s2 || "vec4b" === s2 || "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 || "array" === s2) {
        const s3 = new de(e2.type, []);
        n2 = this._evalCreate(s3, t2);
      }
    }
    t2.createVariable(e2.name, n2, e2);
  }
  _var(e2, t2) {
    let n2 = null;
    if (null !== e2.value) {
      if (n2 = this.evalExpression(e2.value, t2), null === n2)
        return void console.error(`Invalid value for variable ${e2.name}. Line ${e2.line}`);
      e2.value instanceof ke || (n2 = n2.clone());
    } else {
      if (null === e2.type)
        return void console.error(`Variable ${e2.name} has no type. Line ${e2.line}`);
      const s2 = e2.type.name;
      if ("f32" === s2 || "i32" === s2 || "u32" === s2 || "bool" === s2 || "f16" === s2 || "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2b" === s2 || "vec3b" === s2 || "vec4b" === s2 || "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 || e2.type instanceof ue || e2.type instanceof oe || e2.type instanceof ce) {
        const s3 = new de(e2.type, []);
        n2 = this._evalCreate(s3, t2);
      }
    }
    t2.createVariable(e2.name, n2, e2);
  }
  _switch(e2, t2) {
    t2 = t2.clone();
    const n2 = this.evalExpression(e2.condition, t2);
    if (!(n2 instanceof Be))
      return console.error(`Invalid if condition. Line ${e2.line}`), null;
    let s2 = null;
    for (const r2 of e2.cases)
      if (r2 instanceof Ae)
        for (const a2 of r2.selectors) {
          if (a2 instanceof Se) {
            s2 = r2;
            continue;
          }
          const i3 = this.evalExpression(a2, t2);
          if (!(i3 instanceof Be))
            return console.error(`Invalid case selector. Line ${e2.line}`), null;
          if (i3.value === n2.value)
            return this._execStatements(r2.body, t2);
        }
      else
        r2 instanceof Ee && (s2 = r2);
    return s2 ? this._execStatements(s2.body, t2) : null;
  }
  _if(e2, t2) {
    t2 = t2.clone();
    const n2 = this.evalExpression(e2.condition, t2);
    if (!(n2 instanceof Be))
      return console.error(`Invalid if condition. Line ${e2.line}`), null;
    if (n2.value)
      return this._execStatements(e2.body, t2);
    for (const n3 of e2.elseif) {
      const s2 = this.evalExpression(n3.condition, t2);
      if (!(s2 instanceof Be))
        return console.error(`Invalid if condition. Line ${e2.line}`), null;
      if (s2.value)
        return this._execStatements(n3.body, t2);
    }
    return e2.else ? this._execStatements(e2.else, t2) : null;
  }
  _getScalarValue(e2) {
    return e2 instanceof Be ? e2.value : (console.error("Expected scalar value.", e2), 0);
  }
  _for(e2, t2) {
    for (t2 = t2.clone(), this.execStatement(e2.init, t2); this._getScalarValue(this.evalExpression(e2.condition, t2)); ) {
      const n2 = this._execStatements(e2.body, t2);
      if (n2 === _dt._breakObj)
        break;
      if (null !== n2 && n2 !== _dt._continueObj)
        return n2;
      this.execStatement(e2.increment, t2);
    }
    return null;
  }
  _loop(e2, t2) {
    for (t2 = t2.clone(); ; ) {
      const n2 = this._execStatements(e2.body, t2);
      if (n2 === _dt._breakObj)
        break;
      if (n2 === _dt._continueObj) {
        if (e2.continuing) {
          if (this._execStatements(e2.continuing.body, t2) === _dt._breakObj)
            break;
        }
      } else if (null !== n2)
        return n2;
    }
    return null;
  }
  _while(e2, t2) {
    for (t2 = t2.clone(); this._getScalarValue(this.evalExpression(e2.condition, t2)); ) {
      const n2 = this._execStatements(e2.body, t2);
      if (n2 === _dt._breakObj)
        break;
      if (n2 !== _dt._continueObj && null !== n2)
        return n2;
    }
    return null;
  }
  _evalBitcast(e2, t2) {
    const n2 = this.evalExpression(e2.value, t2), s2 = e2.type;
    if (n2 instanceof Be) {
      const e3 = nt(n2.value, n2.typeInfo.name, s2.name);
      return new Be(e3, this.getTypeInfo(s2));
    }
    if (n2 instanceof Me) {
      const t3 = n2.typeInfo.getTypeName();
      let r2 = "";
      if (t3.endsWith("f"))
        r2 = "f32";
      else if (t3.endsWith("i"))
        r2 = "i32";
      else if (t3.endsWith("u"))
        r2 = "u32";
      else if (t3.endsWith("b"))
        r2 = "bool";
      else {
        if (!t3.endsWith("h"))
          return console.error(`Unknown vector type ${t3}. Line ${e2.line}`), null;
        r2 = "f16";
      }
      const a2 = s2.getTypeName();
      let i3 = "";
      if (a2.endsWith("f"))
        i3 = "f32";
      else if (a2.endsWith("i"))
        i3 = "i32";
      else if (a2.endsWith("u"))
        i3 = "u32";
      else if (a2.endsWith("b"))
        i3 = "bool";
      else {
        if (!a2.endsWith("h"))
          return console.error(`Unknown vector type ${i3}. Line ${e2.line}`), null;
        i3 = "f16";
      }
      const o3 = function(e3, t4, n3) {
        if (t4 === n3)
          return e3;
        const s3 = new Array(e3.length);
        for (let r3 = 0; r3 < e3.length; r3++)
          s3[r3] = nt(e3[r3], t4, n3);
        return s3;
      }(Array.from(n2.data), r2, i3);
      return new Me(o3, this.getTypeInfo(s2));
    }
    return console.error(`TODO: bitcast for ${n2.typeInfo.name}. Line ${e2.line}`), null;
  }
  _evalConst(e2, t2) {
    return t2.getVariableValue(e2.name).clone().getSubData(this, e2.postfix, t2);
  }
  _evalCreate(e2, t2) {
    var r2;
    if (e2 instanceof de) {
      if (null === e2.type)
        return Ve.void;
      switch (e2.type.getTypeName()) {
        case "bool":
        case "i32":
        case "u32":
        case "f32":
        case "f16":
          return this._callConstructorValue(e2, t2);
        case "vec2":
        case "vec3":
        case "vec4":
        case "vec2f":
        case "vec3f":
        case "vec4f":
        case "vec2h":
        case "vec3h":
        case "vec4h":
        case "vec2i":
        case "vec3i":
        case "vec4i":
        case "vec2u":
        case "vec3u":
        case "vec4u":
        case "vec2b":
        case "vec3b":
        case "vec4b":
          return this._callConstructorVec(e2, t2);
        case "mat2x2":
        case "mat2x2f":
        case "mat2x2h":
        case "mat2x3":
        case "mat2x3f":
        case "mat2x3h":
        case "mat2x4":
        case "mat2x4f":
        case "mat2x4h":
        case "mat3x2":
        case "mat3x2f":
        case "mat3x2h":
        case "mat3x3":
        case "mat3x3f":
        case "mat3x3h":
        case "mat3x4":
        case "mat3x4f":
        case "mat3x4h":
        case "mat4x2":
        case "mat4x2f":
        case "mat4x2h":
        case "mat4x3":
        case "mat4x3f":
        case "mat4x3h":
        case "mat4x4":
        case "mat4x4f":
        case "mat4x4h":
          return this._callConstructorMatrix(e2, t2);
      }
    }
    const a2 = e2 instanceof de ? e2.type.name : e2.name, i3 = e2 instanceof de ? this.getTypeInfo(e2.type) : this.getTypeInfo(e2.name);
    if (null === i3)
      return console.error(`Unknown type ${a2}. Line ${e2.line}`), null;
    if (0 === i3.size)
      return null;
    const o3 = new Pe(new ArrayBuffer(i3.size), i3, 0);
    if (i3 instanceof n) {
      if (e2.args)
        for (let n2 = 0; n2 < e2.args.length; ++n2) {
          const s2 = i3.members[n2], r3 = e2.args[n2], a3 = this.evalExpression(r3, t2);
          o3.setData(this, a3, s2.type, s2.offset, t2);
        }
    } else if (i3 instanceof s) {
      let n2 = 0;
      if (e2.args)
        for (let s2 = 0; s2 < e2.args.length; ++s2) {
          const a3 = e2.args[s2], c2 = this.evalExpression(a3, t2);
          null === i3.format && ("x32" === (null === (r2 = c2.typeInfo) || void 0 === r2 ? void 0 : r2.name) ? i3.format = this.getTypeInfo("i32") : i3.format = c2.typeInfo), o3.setData(this, c2, i3.format, n2, t2), n2 += i3.stride;
        }
    } else
      console.error(`Unknown type "${a2}". Line ${e2.line}`);
    return e2 instanceof de ? o3.getSubData(this, e2.postfix, t2) : o3;
  }
  _evalLiteral(e2, t2) {
    const n2 = this.getTypeInfo(e2.type), s2 = n2.name;
    if ("x32" === s2 || "u32" === s2 || "f32" === s2 || "f16" === s2 || "i32" === s2 || "bool" === s2) {
      return new Be(e2.scalarValue, n2);
    }
    return "vec2" === s2 || "vec3" === s2 || "vec4" === s2 || "vec2f" === s2 || "vec3f" === s2 || "vec4f" === s2 || "vec2h" === s2 || "vec3h" === s2 || "vec4h" === s2 || "vec2i" === s2 || "vec3i" === s2 || "vec4i" === s2 || "vec2u" === s2 || "vec3u" === s2 || "vec4u" === s2 ? this._callConstructorVec(e2, t2) : "mat2x2" === s2 || "mat2x3" === s2 || "mat2x4" === s2 || "mat3x2" === s2 || "mat3x3" === s2 || "mat3x4" === s2 || "mat4x2" === s2 || "mat4x3" === s2 || "mat4x4" === s2 || "mat2x2f" === s2 || "mat2x3f" === s2 || "mat2x4f" === s2 || "mat3x2f" === s2 || "mat3x3f" === s2 || "mat3x4f" === s2 || "mat4x2f" === s2 || "mat4x3f" === s2 || "mat4x4f" === s2 || "mat2x2h" === s2 || "mat2x3h" === s2 || "mat2x4h" === s2 || "mat3x2h" === s2 || "mat3x3h" === s2 || "mat3x4h" === s2 || "mat4x2h" === s2 || "mat4x3h" === s2 || "mat4x4h" === s2 ? this._callConstructorMatrix(e2, t2) : e2.value;
  }
  _evalVariable(e2, t2) {
    const n2 = t2.getVariableValue(e2.name);
    return null === n2 ? n2 : n2.getSubData(this, e2.postfix, t2);
  }
  _maxFormatTypeInfo(e2) {
    let t2 = e2[0];
    if ("f32" === t2.name)
      return t2;
    for (let n2 = 1; n2 < e2.length; ++n2) {
      const s2 = _dt._priority.get(t2.name);
      _dt._priority.get(e2[n2].name) < s2 && (t2 = e2[n2]);
    }
    return "x32" === t2.name ? this.getTypeInfo("i32") : t2;
  }
  _evalUnaryOp(e2, t2) {
    const n2 = this.evalExpression(e2.right, t2);
    if ("&" === e2.operator)
      return new Oe(n2);
    if ("*" === e2.operator)
      return n2 instanceof Oe ? n2.reference.getSubData(this, e2.postfix, t2) : (console.error(`Invalid dereference. Line ${e2.line}`), null);
    const s2 = n2 instanceof Be ? n2.value : n2 instanceof Me ? Array.from(n2.data) : null;
    switch (e2.operator) {
      case "+": {
        if (Ge(s2)) {
          const e4 = s2.map((e5, t4) => +e5);
          return new Me(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(+e3, t3);
      }
      case "-": {
        if (Ge(s2)) {
          const e4 = s2.map((e5, t4) => -e5);
          return new Me(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(-e3, t3);
      }
      case "!": {
        if (Ge(s2)) {
          const e4 = s2.map((e5, t4) => e5 ? 0 : 1);
          return new Me(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(e3 ? 0 : 1, t3);
      }
      case "~": {
        if (Ge(s2)) {
          const e4 = s2.map((e5, t4) => ~e5);
          return new Me(e4, n2.typeInfo);
        }
        const e3 = s2, t3 = this._maxFormatTypeInfo([n2.typeInfo, n2.typeInfo]);
        return new Be(~e3, t3);
      }
    }
    return console.error(`Invalid unary operator ${e2.operator}. Line ${e2.line}`), null;
  }
  _evalBinaryOp(e2, t2) {
    const n2 = this.evalExpression(e2.left, t2), s2 = this.evalExpression(e2.right, t2), r2 = n2 instanceof Be ? n2.value : n2 instanceof Me || n2 instanceof Ue ? Array.from(n2.data) : null, a2 = s2 instanceof Be ? s2.value : s2 instanceof Me || s2 instanceof Ue ? Array.from(s2.data) : null;
    switch (e2.operator) {
      case "+": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 + s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 + e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 + t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 + i3, o3);
      }
      case "-": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 - s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 - e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 - t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 - i3, o3);
      }
      case "*": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, i4 = a2;
          if (n2 instanceof Ue && s2 instanceof Ue) {
            const r3 = function(e3, t5, n3, s3) {
              if (void 0 === pt[t5.name] || void 0 === pt[s3.name])
                return null;
              const r4 = pt[t5.name][0], a4 = pt[t5.name][1], i5 = pt[s3.name][0];
              if (r4 !== pt[s3.name][1])
                return null;
              const o5 = new Array(i5 * a4);
              for (let t6 = 0; t6 < a4; t6++)
                for (let s4 = 0; s4 < i5; s4++) {
                  let c3 = 0;
                  for (let i6 = 0; i6 < r4; i6++)
                    c3 += e3[i6 * a4 + t6] * n3[s4 * r4 + i6];
                  o5[t6 * i5 + s4] = c3;
                }
              return o5;
            }(t4, n2.typeInfo, i4, s2.typeInfo);
            if (null === r3)
              return console.error(`Matrix multiplication failed. Line ${e2.line}.`), null;
            const a3 = pt[s2.typeInfo.name][0], o4 = pt[n2.typeInfo.name][1], c2 = this.getTypeInfo(`mat${a3}x${o4}f`);
            return new Ue(r3, c2);
          }
          if (n2 instanceof Ue && s2 instanceof Me) {
            const r3 = function(e3, t5, n3, s3) {
              if (void 0 === pt[t5.name] || void 0 === ft[s3.name])
                return null;
              const r4 = pt[t5.name][0], a3 = pt[t5.name][1];
              if (r4 !== n3.length)
                return null;
              const i5 = new Array(a3);
              for (let t6 = 0; t6 < a3; t6++) {
                let s4 = 0;
                for (let i6 = 0; i6 < r4; i6++)
                  s4 += e3[i6 * a3 + t6] * n3[i6];
                i5[t6] = s4;
              }
              return i5;
            }(t4, n2.typeInfo, i4, s2.typeInfo);
            return null === r3 ? (console.error(`Matrix vector multiplication failed. Line ${e2.line}.`), null) : new Me(r3, s2.typeInfo);
          }
          if (n2 instanceof Me && s2 instanceof Ue) {
            const r3 = function(e3, t5, n3, s3) {
              if (void 0 === ft[t5.name] || void 0 === pt[s3.name])
                return null;
              const r4 = pt[s3.name][0], a3 = pt[s3.name][1];
              if (a3 !== e3.length)
                return null;
              const i5 = [];
              for (let t6 = 0; t6 < r4; t6++) {
                let s4 = 0;
                for (let i6 = 0; i6 < a3; i6++)
                  s4 += e3[i6] * n3[i6 * r4 + t6];
                i5[t6] = s4;
              }
              return i5;
            }(t4, n2.typeInfo, i4, s2.typeInfo);
            return null === r3 ? (console.error(`Matrix vector multiplication failed. Line ${e2.line}.`), null) : new Me(r3, n2.typeInfo);
          }
          {
            if (t4.length !== i4.length)
              return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
            const s3 = t4.map((e3, t5) => e3 * i4[t5]);
            return new Me(s3, n2.typeInfo);
          }
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 * e3);
          return n2 instanceof Ue ? new Ue(t4, n2.typeInfo) : new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 * t5);
          return s2 instanceof Ue ? new Ue(t4, s2.typeInfo) : new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 * i3, o3);
      }
      case "%": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 % s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 % e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 % t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 % i3, o3);
      }
      case "/": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 / s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 / e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 / t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 / i3, o3);
      }
      case "&": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 & s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 & e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 & t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 & i3, o3);
      }
      case "|": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 | s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 | e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 | t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 | i3, o3);
      }
      case "^": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 ^ s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 ^ e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 ^ t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 ^ i3, o3);
      }
      case "<<": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 << s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 << e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 << t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 << i3, o3);
      }
      case ">>": {
        if (Ge(r2) && Ge(a2)) {
          const t4 = r2, s3 = a2;
          if (t4.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i4 = t4.map((e3, t5) => e3 >> s3[t5]);
          return new Me(i4, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t4 = r2.map((t5, n3) => t5 >> e3);
          return new Me(t4, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t4 = a2.map((t5, n3) => e3 >> t5);
          return new Me(t4, s2.typeInfo);
        }
        const t3 = r2, i3 = a2, o3 = this._maxFormatTypeInfo([n2.typeInfo, s2.typeInfo]);
        return new Be(t3 >> i3, o3);
      }
      case ">":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 > s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 > e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 > t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 > a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 < s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 < e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 < t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 < a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 === s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 == e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 == t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 === a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 !== s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 !== e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 !== t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 !== a2 ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 >= s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 >= e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 >= t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 >= a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 <= s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 <= e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 <= t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 <= a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 && s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 && e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 && t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 && a2 ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (Ge(r2) && Ge(a2)) {
          const t3 = r2, s3 = a2;
          if (t3.length !== s3.length)
            return console.error(`Vector length mismatch. Line ${e2.line}.`), null;
          const i3 = t3.map((e3, t4) => e3 || s3[t4] ? 1 : 0);
          return new Me(i3, n2.typeInfo);
        }
        if (Ge(r2)) {
          const e3 = a2, t3 = r2.map((t4, n3) => t4 || e3 ? 1 : 0);
          return new Me(t3, n2.typeInfo);
        }
        if (Ge(a2)) {
          const e3 = r2, t3 = a2.map((t4, n3) => e3 || t4 ? 1 : 0);
          return new Me(t3, s2.typeInfo);
        }
        return new Be(r2 || a2 ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${e2.operator}. Line ${e2.line}`), null;
  }
  _evalCall(e2, t2) {
    if (null !== e2.cachedReturnValue)
      return e2.cachedReturnValue;
    const n2 = t2.clone();
    n2.currentFunctionName = e2.name;
    const s2 = t2.getFunction(e2.name);
    if (!s2) {
      if (e2.isBuiltin)
        return this._callBuiltinFunction(e2, n2);
      return this.getTypeInfo(e2.name) ? this._evalCreate(e2, t2) : (console.error(`Unknown function "${e2.name}". Line ${e2.line}`), null);
    }
    for (let t3 = 0; t3 < s2.node.args.length; ++t3) {
      const r2 = s2.node.args[t3], a2 = this.evalExpression(e2.args[t3], n2);
      n2.createVariable(r2.name, a2, r2);
    }
    return this._execStatements(s2.node.body, n2);
  }
  _callBuiltinFunction(e2, t2) {
    switch (e2.name) {
      case "all":
        return this.builtins.All(e2, t2);
      case "any":
        return this.builtins.Any(e2, t2);
      case "select":
        return this.builtins.Select(e2, t2);
      case "arrayLength":
        return this.builtins.ArrayLength(e2, t2);
      case "abs":
        return this.builtins.Abs(e2, t2);
      case "acos":
        return this.builtins.Acos(e2, t2);
      case "acosh":
        return this.builtins.Acosh(e2, t2);
      case "asin":
        return this.builtins.Asin(e2, t2);
      case "asinh":
        return this.builtins.Asinh(e2, t2);
      case "atan":
        return this.builtins.Atan(e2, t2);
      case "atanh":
        return this.builtins.Atanh(e2, t2);
      case "atan2":
        return this.builtins.Atan2(e2, t2);
      case "ceil":
        return this.builtins.Ceil(e2, t2);
      case "clamp":
        return this.builtins.Clamp(e2, t2);
      case "cos":
        return this.builtins.Cos(e2, t2);
      case "cosh":
        return this.builtins.Cosh(e2, t2);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(e2, t2);
      case "countOneBits":
        return this.builtins.CountOneBits(e2, t2);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(e2, t2);
      case "cross":
        return this.builtins.Cross(e2, t2);
      case "degrees":
        return this.builtins.Degrees(e2, t2);
      case "determinant":
        return this.builtins.Determinant(e2, t2);
      case "distance":
        return this.builtins.Distance(e2, t2);
      case "dot":
        return this.builtins.Dot(e2, t2);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(e2, t2);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(e2, t2);
      case "exp":
        return this.builtins.Exp(e2, t2);
      case "exp2":
        return this.builtins.Exp2(e2, t2);
      case "extractBits":
        return this.builtins.ExtractBits(e2, t2);
      case "faceForward":
        return this.builtins.FaceForward(e2, t2);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(e2, t2);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(e2, t2);
      case "floor":
        return this.builtins.Floor(e2, t2);
      case "fma":
        return this.builtins.Fma(e2, t2);
      case "fract":
        return this.builtins.Fract(e2, t2);
      case "frexp":
        return this.builtins.Frexp(e2, t2);
      case "insertBits":
        return this.builtins.InsertBits(e2, t2);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(e2, t2);
      case "ldexp":
        return this.builtins.Ldexp(e2, t2);
      case "length":
        return this.builtins.Length(e2, t2);
      case "log":
        return this.builtins.Log(e2, t2);
      case "log2":
        return this.builtins.Log2(e2, t2);
      case "max":
        return this.builtins.Max(e2, t2);
      case "min":
        return this.builtins.Min(e2, t2);
      case "mix":
        return this.builtins.Mix(e2, t2);
      case "modf":
        return this.builtins.Modf(e2, t2);
      case "normalize":
        return this.builtins.Normalize(e2, t2);
      case "pow":
        return this.builtins.Pow(e2, t2);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(e2, t2);
      case "radians":
        return this.builtins.Radians(e2, t2);
      case "reflect":
        return this.builtins.Reflect(e2, t2);
      case "refract":
        return this.builtins.Refract(e2, t2);
      case "reverseBits":
        return this.builtins.ReverseBits(e2, t2);
      case "round":
        return this.builtins.Round(e2, t2);
      case "saturate":
        return this.builtins.Saturate(e2, t2);
      case "sign":
        return this.builtins.Sign(e2, t2);
      case "sin":
        return this.builtins.Sin(e2, t2);
      case "sinh":
        return this.builtins.Sinh(e2, t2);
      case "smoothstep":
        return this.builtins.SmoothStep(e2, t2);
      case "sqrt":
        return this.builtins.Sqrt(e2, t2);
      case "step":
        return this.builtins.Step(e2, t2);
      case "tan":
        return this.builtins.Tan(e2, t2);
      case "tanh":
        return this.builtins.Tanh(e2, t2);
      case "transpose":
        return this.builtins.Transpose(e2, t2);
      case "trunc":
        return this.builtins.Trunc(e2, t2);
      case "dpdx":
        return this.builtins.Dpdx(e2, t2);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(e2, t2);
      case "dpdxFine":
        return this.builtins.DpdxFine(e2, t2);
      case "dpdy":
        return this.builtins.Dpdy(e2, t2);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(e2, t2);
      case "dpdyFine":
        return this.builtins.DpdyFine(e2, t2);
      case "fwidth":
        return this.builtins.Fwidth(e2, t2);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(e2, t2);
      case "fwidthFine":
        return this.builtins.FwidthFine(e2, t2);
      case "textureDimensions":
        return this.builtins.TextureDimensions(e2, t2);
      case "textureGather":
        return this.builtins.TextureGather(e2, t2);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(e2, t2);
      case "textureLoad":
        return this.builtins.TextureLoad(e2, t2);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(e2, t2);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(e2, t2);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(e2, t2);
      case "textureSample":
        return this.builtins.TextureSample(e2, t2);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(e2, t2);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(e2, t2);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(e2, t2);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(e2, t2);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(e2, t2);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(e2, t2);
      case "textureStore":
        return this.builtins.TextureStore(e2, t2);
      case "atomicLoad":
        return this.builtins.AtomicLoad(e2, t2);
      case "atomicStore":
        return this.builtins.AtomicStore(e2, t2);
      case "atomicAdd":
        return this.builtins.AtomicAdd(e2, t2);
      case "atomicSub":
        return this.builtins.AtomicSub(e2, t2);
      case "atomicMax":
        return this.builtins.AtomicMax(e2, t2);
      case "atomicMin":
        return this.builtins.AtomicMin(e2, t2);
      case "atomicAnd":
        return this.builtins.AtomicAnd(e2, t2);
      case "atomicOr":
        return this.builtins.AtomicOr(e2, t2);
      case "atomicXor":
        return this.builtins.AtomicXor(e2, t2);
      case "atomicExchange":
        return this.builtins.AtomicExchange(e2, t2);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(e2, t2);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(e2, t2);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(e2, t2);
      case "pack4xI8":
        return this.builtins.Pack4xI8(e2, t2);
      case "pack4xU8":
        return this.builtins.Pack4xU8(e2, t2);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(e2, t2);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(e2, t2);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(e2, t2);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(e2, t2);
      case "pack2x16float":
        return this.builtins.Pack2x16float(e2, t2);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(e2, t2);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(e2, t2);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(e2, t2);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(e2, t2);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(e2, t2);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(e2, t2);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(e2, t2);
      case "storageBarrier":
        return this.builtins.StorageBarrier(e2, t2);
      case "textureBarrier":
        return this.builtins.TextureBarrier(e2, t2);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(e2, t2);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(e2, t2);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(e2, t2);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(e2, t2);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(e2, t2);
      case "subgroupAll":
        return this.builtins.SubgroupAll(e2, t2);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(e2, t2);
      case "subgroupAny":
        return this.builtins.SubgroupAny(e2, t2);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(e2, t2);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(e2, t2);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(e2, t2);
      case "subgroupElect":
        return this.builtins.SubgroupElect(e2, t2);
      case "subgroupMax":
        return this.builtins.SubgroupMax(e2, t2);
      case "subgroupMin":
        return this.builtins.SubgroupMin(e2, t2);
      case "subgroupMul":
        return this.builtins.SubgroupMul(e2, t2);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(e2, t2);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(e2, t2);
      case "subgroupOr":
        return this.builtins.SubgroupOr(e2, t2);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(e2, t2);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(e2, t2);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(e2, t2);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(e2, t2);
      case "subgroupXor":
        return this.builtins.SubgroupXor(e2, t2);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(e2, t2);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(e2, t2);
      case "quadSwapX":
        return this.builtins.QuadSwapX(e2, t2);
      case "quadSwapY":
        return this.builtins.QuadSwapY(e2, t2);
    }
    const n2 = t2.getFunction(e2.name);
    if (n2) {
      const s2 = t2.clone();
      for (let t3 = 0; t3 < n2.node.args.length; ++t3) {
        const r2 = n2.node.args[t3], a2 = this.evalExpression(e2.args[t3], s2);
        s2.setVariable(r2.name, a2, r2);
      }
      return this._execStatements(n2.node.body, s2);
    }
    return null;
  }
  _callConstructorValue(e2, t2) {
    if (!e2.args || 0 === e2.args.length)
      return new Be(0, this.getTypeInfo(e2.type));
    const n2 = this.evalExpression(e2.args[0], t2);
    return n2.typeInfo = this.getTypeInfo(e2.type), n2.getSubData(this, e2.postfix, t2).clone();
  }
  _callConstructorVec(e2, t2) {
    const n2 = this.getTypeInfo(e2.type), s2 = e2.type.getTypeName(), r2 = ft[s2];
    if (void 0 === r2)
      return console.error(`Invalid vec constructor ${s2}. Line ${e2.line}`), null;
    const a2 = [];
    if (e2 instanceof xe)
      if (e2.isVector) {
        const t3 = e2.vectorValue;
        for (const e3 of t3)
          a2.push(e3);
      } else
        a2.push(e2.scalarValue);
    else if (e2.args)
      for (const n3 of e2.args) {
        const e3 = this.evalExpression(n3, t2);
        if (e3 instanceof Me) {
          const t3 = e3.data;
          for (let e4 = 0; e4 < t3.length; ++e4) {
            let n4 = t3[e4];
            a2.push(n4);
          }
        } else if (e3 instanceof Be) {
          let t3 = e3.value;
          a2.push(t3);
        }
      }
    if (e2.type instanceof ce && null === e2.type.format && (e2.type.format = ce.f32), 0 === a2.length) {
      const s3 = new Array(r2).fill(0);
      return new Me(s3, n2).getSubData(this, e2.postfix, t2);
    }
    if (1 === a2.length)
      for (; a2.length < r2; )
        a2.push(a2[0]);
    if (a2.length < r2)
      return console.error(`Invalid vec constructor. Line ${e2.line}`), null;
    return new Me(a2.length > r2 ? a2.slice(0, r2) : a2, n2).getSubData(this, e2.postfix, t2);
  }
  _callConstructorMatrix(e2, t2) {
    const n2 = this.getTypeInfo(e2.type), s2 = e2.type.getTypeName(), r2 = pt[s2];
    if (void 0 === r2)
      return console.error(`Invalid matrix constructor ${s2}. Line ${e2.line}`), null;
    const i3 = [];
    if (e2 instanceof xe)
      if (e2.isVector) {
        const t3 = e2.vectorValue;
        for (const e3 of t3)
          i3.push(e3);
      } else
        i3.push(e2.scalarValue);
    else if (e2.args)
      for (const n3 of e2.args) {
        const e3 = this.evalExpression(n3, t2);
        e3 instanceof Me ? i3.push(...e3.data) : e3 instanceof Be ? i3.push(e3.value) : e3 instanceof Ue && i3.push(...e3.data);
      }
    if (n2 instanceof a && null === n2.format && (n2.format = this.getTypeInfo("f32")), 0 === i3.length) {
      const s3 = new Array(r2[2]).fill(0);
      return new Ue(s3, n2).getSubData(this, e2.postfix, t2);
    }
    return i3.length !== r2[2] ? (console.error(`Invalid matrix constructor. Line ${e2.line}`), null) : new Ue(i3, n2).getSubData(this, e2.postfix, t2);
  }
};
dt._breakObj = new Ne(new e("BREAK", null), null), dt._continueObj = new Ne(new e("CONTINUE", null), null), dt._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
var mt = class {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
};
var gt = class {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new mt(), this._exec = new dt(), this._forwardTypeCount = 0;
  }
  parse(e2) {
    this._initialize(e2), this._deferArrayCountEval.length = 0;
    const t2 = [];
    for (; !this._isAtEnd(); ) {
      const e3 = this._global_decl_or_directive();
      if (!e3)
        break;
      t2.push(e3);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const e3 of this._deferArrayCountEval) {
        const t3 = e3.arrayType, n2 = e3.countNode;
        if (n2 instanceof ge) {
          const e4 = n2.name, s2 = this._context.constants.get(e4);
          if (s2)
            try {
              const e5 = s2.constEvaluate(this._exec);
              t3.count = e5;
            } catch (e5) {
            }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    if (this._forwardTypeCount > 0)
      for (const e3 of t2)
        e3.search((e4) => {
          e4 instanceof Ce || e4 instanceof le ? e4.type = this._forwardType(e4.type) : e4 instanceof ue ? e4.format = this._forwardType(e4.format) : e4 instanceof F || e4 instanceof U || e4 instanceof P ? e4.type = this._forwardType(e4.type) : e4 instanceof D2 ? e4.returnType = this._forwardType(e4.returnType) : e4 instanceof $e && (e4.type = this._forwardType(e4.type));
        });
    return t2;
  }
  _forwardType(e2) {
    if (e2 instanceof ie) {
      const t2 = this._getType(e2.name);
      if (t2)
        return t2;
    } else
      e2 instanceof le ? e2.type = this._forwardType(e2.type) : e2 instanceof ue && (e2.format = this._forwardType(e2.format));
    return e2;
  }
  _initialize(e2) {
    if (e2)
      if ("string" == typeof e2) {
        const t2 = new Re(e2);
        this._tokens = t2.scanTokens();
      } else
        this._tokens = e2;
    else
      this._tokens = [];
    this._current = 0;
  }
  _updateNode(e2, t2) {
    return e2.line = null != t2 ? t2 : this._currentLine, e2;
  }
  _error(e2, t2) {
    return { token: e2, message: t2, toString: () => `${t2}` };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == He.eof;
  }
  _match(e2) {
    if (e2 instanceof qe)
      return !!this._check(e2) && (this._advance(), true);
    for (let t2 = 0, n2 = e2.length; t2 < n2; ++t2) {
      const n3 = e2[t2];
      if (this._check(n3))
        return this._advance(), true;
    }
    return false;
  }
  _consume(e2, t2) {
    if (this._check(e2))
      return this._advance();
    throw this._error(this._peek(), `${t2}. Line:${this._currentLine}`);
  }
  _check(e2) {
    if (this._isAtEnd())
      return false;
    const t2 = this._peek();
    if (e2 instanceof Array) {
      const n2 = t2.type;
      let s2 = false;
      for (const t3 of e2) {
        if (n2 === t3)
          return true;
        t3 === He.tokens.name && (s2 = true);
      }
      if (s2) {
        const e3 = He.tokens.name.rule.exec(t2.lexeme);
        if (e3 && 0 == e3.index && e3[0] == t2.lexeme)
          return true;
      }
      return false;
    }
    if (t2.type === e2)
      return true;
    if (e2 === He.tokens.name) {
      const e3 = He.tokens.name.rule.exec(t2.lexeme);
      return e3 && 0 == e3.index && e3[0] == t2.lexeme;
    }
    return false;
  }
  _advance() {
    var e2, t2;
    return this._currentLine = null !== (t2 = null === (e2 = this._peek()) || void 0 === e2 ? void 0 : e2.line) && void 0 !== t2 ? t2 : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(He.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._match(He.keywords.alias)) {
      const e3 = this._type_alias();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e3]), e3;
    }
    if (this._match(He.keywords.diagnostic)) {
      const e3 = this._diagnostic();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e3]), e3;
    }
    if (this._match(He.keywords.requires)) {
      const e3 = this._requires_directive();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e3]), e3;
    }
    if (this._match(He.keywords.enable)) {
      const e3 = this._enable_directive();
      return this._consume(He.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([e3]), e3;
    }
    const e2 = this._attribute();
    if (this._check(He.keywords.var)) {
      const t2 = this._global_variable_decl();
      return null != t2 && (t2.attributes = e2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.override)) {
      const t2 = this._override_variable_decl();
      return null != t2 && (t2.attributes = e2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.let)) {
      const t2 = this._global_let_decl();
      return null != t2 && (t2.attributes = e2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.const)) {
      const t2 = this._global_const_decl();
      return null != t2 && (t2.attributes = e2), this._consume(He.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.struct)) {
      const t2 = this._struct_decl();
      return null != t2 && (t2.attributes = e2), this._exec.reflection.updateAST([t2]), t2;
    }
    if (this._check(He.keywords.fn)) {
      const t2 = this._function_decl();
      return null != t2 && (t2.attributes = e2), this._exec.reflection.updateAST([t2]), t2;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(He.keywords.fn))
      return null;
    const e2 = this._currentLine, t2 = this._consume(He.tokens.ident, "Expected function name.").toString();
    this._consume(He.tokens.paren_left, "Expected '(' for function arguments.");
    const n2 = [];
    if (!this._check(He.tokens.paren_right))
      do {
        if (this._check(He.tokens.paren_right))
          break;
        const e3 = this._attribute(), t3 = this._consume(He.tokens.name, "Expected argument name.").toString();
        this._consume(He.tokens.colon, "Expected ':' for argument type.");
        const s3 = this._attribute(), r3 = this._type_decl();
        null != r3 && (r3.attributes = s3, n2.push(this._updateNode(new $e(t3, r3, e3))));
      } while (this._match(He.tokens.comma));
    this._consume(He.tokens.paren_right, "Expected ')' after function arguments.");
    let s2 = null;
    if (this._match(He.tokens.arrow)) {
      const e3 = this._attribute();
      s2 = this._type_decl(), null != s2 && (s2.attributes = e3);
    }
    const r2 = this._compound_statement(), a2 = this._currentLine;
    return this._updateNode(new D2(t2, n2, s2, r2, e2, a2), e2);
  }
  _compound_statement() {
    const e2 = [];
    for (this._consume(He.tokens.brace_left, "Expected '{' for block."); !this._check(He.tokens.brace_right); ) {
      const t2 = this._statement();
      null !== t2 && e2.push(t2);
    }
    return this._consume(He.tokens.brace_right, "Expected '}' for block."), e2;
  }
  _statement() {
    for (; this._match(He.tokens.semicolon) && !this._isAtEnd(); )
      ;
    if (this._check(He.tokens.attr) && this._attribute(), this._check(He.keywords.if))
      return this._if_statement();
    if (this._check(He.keywords.switch))
      return this._switch_statement();
    if (this._check(He.keywords.loop))
      return this._loop_statement();
    if (this._check(He.keywords.for))
      return this._for_statement();
    if (this._check(He.keywords.while))
      return this._while_statement();
    if (this._check(He.keywords.continuing))
      return this._continuing_statement();
    if (this._check(He.keywords.static_assert))
      return this._static_assert_statement();
    if (this._check(He.tokens.brace_left))
      return this._compound_statement();
    let e2 = null;
    if (this._check(He.keywords.return))
      e2 = this._return_statement();
    else if (this._check([He.keywords.var, He.keywords.let, He.keywords.const]))
      e2 = this._variable_statement();
    else if (this._match(He.keywords.discard))
      e2 = this._updateNode(new ne());
    else if (this._match(He.keywords.break)) {
      const t2 = this._updateNode(new se());
      if (this._currentLoop.length > 0) {
        const e3 = this._currentLoop[this._currentLoop.length - 1];
        t2.loopId = e3.id;
      }
      e2 = t2, this._check(He.keywords.if) && (this._advance(), t2.condition = this._optional_paren_expression());
    } else if (this._match(He.keywords.continue)) {
      const t2 = this._updateNode(new re());
      if (!(this._currentLoop.length > 0))
        throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t2.line}`);
      {
        const e3 = this._currentLoop[this._currentLoop.length - 1];
        t2.loopId = e3.id;
      }
      e2 = t2;
    } else
      e2 = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    return null != e2 && this._consume(He.tokens.semicolon, "Expected ';' after statement."), e2;
  }
  _static_assert_statement() {
    if (!this._match(He.keywords.static_assert))
      return null;
    const e2 = this._currentLine, t2 = this._optional_paren_expression();
    return this._updateNode(new N2(t2), e2);
  }
  _while_statement() {
    if (!this._match(He.keywords.while))
      return null;
    const e2 = this._updateNode(new V(null, null));
    return this._currentLoop.push(e2), e2.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), e2.body = this._compound_statement(), this._currentLoop.pop(), e2;
  }
  _continuing_statement() {
    const e2 = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
    if (!this._match(He.keywords.continuing))
      return null;
    const t2 = this._currentLine, n2 = this._compound_statement();
    return this._updateNode(new O(n2, e2), t2);
  }
  _for_statement() {
    if (!this._match(He.keywords.for))
      return null;
    this._consume(He.tokens.paren_left, "Expected '('.");
    const e2 = this._updateNode(new B2(null, null, null, null));
    return this._currentLoop.push(e2), e2.init = this._check(He.tokens.semicolon) ? null : this._for_init(), this._consume(He.tokens.semicolon, "Expected ';'."), e2.condition = this._check(He.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(He.tokens.semicolon, "Expected ';'."), e2.increment = this._check(He.tokens.paren_right) ? null : this._for_increment(), this._consume(He.tokens.paren_right, "Expected ')'."), this._check(He.tokens.attr) && this._attribute(), e2.body = this._compound_statement(), this._currentLoop.pop(), e2;
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(He.keywords.var)) {
      const e2 = this._variable_decl();
      if (null === e2)
        throw this._error(this._peek(), "Variable declaration expected.");
      let t2 = null;
      return this._match(He.tokens.equal) && (t2 = this._short_circuit_or_expression()), this._updateNode(new F(e2.name, e2.type, e2.storage, e2.access, t2), e2.line);
    }
    if (this._match(He.keywords.let)) {
      const e2 = this._currentLine, t2 = this._consume(He.tokens.name, "Expected name for let.").toString();
      let n2 = null;
      if (this._match(He.tokens.colon)) {
        const e3 = this._attribute();
        n2 = this._type_decl(), null != n2 && (n2.attributes = e3);
      }
      this._consume(He.tokens.equal, "Expected '=' for let.");
      const s2 = this._short_circuit_or_expression();
      return this._updateNode(new U(t2, n2, null, null, s2), e2);
    }
    if (this._match(He.keywords.const)) {
      const e2 = this._currentLine, t2 = this._consume(He.tokens.name, "Expected name for const.").toString();
      let n2 = null;
      if (this._match(He.tokens.colon)) {
        const e3 = this._attribute();
        n2 = this._type_decl(), null != n2 && (n2.attributes = e3);
      }
      this._consume(He.tokens.equal, "Expected '=' for const.");
      const s2 = this._short_circuit_or_expression();
      return null === n2 && s2 instanceof xe && (n2 = s2.type), this._updateNode(new P(t2, n2, null, null, s2), e2);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e2 = this._current, t2 = this._unary_expression();
    if (null == t2)
      return null;
    if (!this._check(He.increment_operators))
      return this._current = e2, null;
    const n2 = this._consume(He.increment_operators, "Expected increment operator");
    return this._updateNode(new R(n2.type === He.tokens.plus_plus ? W.increment : W.decrement, t2));
  }
  _assignment_statement() {
    let e2 = null;
    const t2 = this._currentLine;
    if (this._check(He.tokens.brace_right))
      return null;
    let n2 = this._match(He.tokens.underscore);
    if (n2 || (e2 = this._unary_expression()), !n2 && null == e2)
      return null;
    const s2 = this._consume(He.assignment_operators, "Expected assignment operator."), r2 = this._short_circuit_or_expression();
    return this._updateNode(new G2(q.parse(s2.lexeme), e2, r2), t2);
  }
  _func_call_statement() {
    if (!this._check(He.tokens.ident))
      return null;
    const e2 = this._currentLine, t2 = this._current, n2 = this._consume(He.tokens.ident, "Expected function name."), s2 = this._argument_expression_list();
    return null === s2 ? (this._current = t2, null) : this._updateNode(new X(n2.lexeme, s2), e2);
  }
  _loop_statement() {
    if (!this._match(He.keywords.loop))
      return null;
    this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for loop.");
    const e2 = this._updateNode(new j([], null));
    this._currentLoop.push(e2);
    let t2 = this._statement();
    for (; null !== t2; ) {
      if (Array.isArray(t2))
        for (let n2 of t2)
          e2.body.push(n2);
      else
        e2.body.push(t2);
      if (t2 instanceof O) {
        e2.continuing = t2;
        break;
      }
      t2 = this._statement();
    }
    return this._currentLoop.pop(), this._consume(He.tokens.brace_right, "Expected '}' for loop."), e2;
  }
  _switch_statement() {
    if (!this._match(He.keywords.switch))
      return null;
    const e2 = this._updateNode(new Z(null, []));
    if (this._currentLoop.push(e2), e2.condition = this._optional_paren_expression(), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Expected '{' for switch."), e2.cases = this._switch_body(), null == e2.cases || 0 == e2.cases.length)
      throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(He.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e2;
  }
  _switch_body() {
    const e2 = [];
    let t2 = false;
    for (; this._check([He.keywords.default, He.keywords.case]); ) {
      if (this._match(He.keywords.case)) {
        const n2 = this._case_selectors();
        for (const e3 of n2)
          if (e3 instanceof Se) {
            if (t2)
              throw this._error(this._previous(), "Multiple default cases in switch statement.");
            t2 = true;
            break;
          }
        this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch case.");
        const s2 = this._case_body();
        this._consume(He.tokens.brace_right, "Exected '}' for switch case."), e2.push(this._updateNode(new Ae(n2, s2)));
      }
      if (this._match(He.keywords.default)) {
        if (t2)
          throw this._error(this._previous(), "Multiple default cases in switch statement.");
        this._match(He.tokens.colon), this._check(He.tokens.attr) && this._attribute(), this._consume(He.tokens.brace_left, "Exected '{' for switch default.");
        const n2 = this._case_body();
        this._consume(He.tokens.brace_right, "Exected '}' for switch default."), e2.push(this._updateNode(new Ee(n2)));
      }
    }
    return e2;
  }
  _case_selectors() {
    const e2 = [];
    for (this._match(He.keywords.default) ? e2.push(this._updateNode(new Se())) : e2.push(this._shift_expression()); this._match(He.tokens.comma); )
      this._match(He.keywords.default) ? e2.push(this._updateNode(new Se())) : e2.push(this._shift_expression());
    return e2;
  }
  _case_body() {
    if (this._match(He.keywords.fallthrough))
      return this._consume(He.tokens.semicolon, "Expected ';'"), [];
    let e2 = this._statement();
    if (null == e2)
      return [];
    e2 instanceof Array || (e2 = [e2]);
    const t2 = this._case_body();
    return 0 == t2.length ? e2 : [...e2, t2[0]];
  }
  _if_statement() {
    if (!this._match(He.keywords.if))
      return null;
    const e2 = this._currentLine, t2 = this._optional_paren_expression();
    this._check(He.tokens.attr) && this._attribute();
    const n2 = this._compound_statement();
    let s2 = [];
    this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), s2 = this._elseif_statement(s2));
    let r2 = null;
    return this._match(He.keywords.else) && (this._check(He.tokens.attr) && this._attribute(), r2 = this._compound_statement()), this._updateNode(new Q2(t2, n2, s2, r2), e2);
  }
  _match_elseif() {
    return this._tokens[this._current].type === He.keywords.else && this._tokens[this._current + 1].type === He.keywords.if && (this._advance(), this._advance(), true);
  }
  _elseif_statement(e2 = []) {
    const t2 = this._optional_paren_expression(), n2 = this._compound_statement();
    return e2.push(this._updateNode(new Le(t2, n2))), this._match_elseif() && (this._check(He.tokens.attr) && this._attribute(), this._elseif_statement(e2)), e2;
  }
  _return_statement() {
    if (!this._match(He.keywords.return))
      return null;
    const e2 = this._short_circuit_or_expression();
    return this._updateNode(new Y(e2));
  }
  _short_circuit_or_expression() {
    let e2 = this._short_circuit_and_expr();
    for (; this._match(He.tokens.or_or); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._short_circuit_and_expr()));
    return e2;
  }
  _short_circuit_and_expr() {
    let e2 = this._inclusive_or_expression();
    for (; this._match(He.tokens.and_and); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._inclusive_or_expression()));
    return e2;
  }
  _inclusive_or_expression() {
    let e2 = this._exclusive_or_expression();
    for (; this._match(He.tokens.or); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._exclusive_or_expression()));
    return e2;
  }
  _exclusive_or_expression() {
    let e2 = this._and_expression();
    for (; this._match(He.tokens.xor); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._and_expression()));
    return e2;
  }
  _and_expression() {
    let e2 = this._equality_expression();
    for (; this._match(He.tokens.and); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._equality_expression()));
    return e2;
  }
  _equality_expression() {
    const e2 = this._relational_expression();
    return this._match([He.tokens.equal_equal, He.tokens.not_equal]) ? this._updateNode(new Ie(this._previous().toString(), e2, this._relational_expression())) : e2;
  }
  _relational_expression() {
    let e2 = this._shift_expression();
    for (; this._match([He.tokens.less_than, He.tokens.greater_than, He.tokens.less_than_equal, He.tokens.greater_than_equal]); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._shift_expression()));
    return e2;
  }
  _shift_expression() {
    let e2 = this._additive_expression();
    for (; this._match([He.tokens.shift_left, He.tokens.shift_right]); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._additive_expression()));
    return e2;
  }
  _additive_expression() {
    let e2 = this._multiplicative_expression();
    for (; this._match([He.tokens.plus, He.tokens.minus]); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._multiplicative_expression()));
    return e2;
  }
  _multiplicative_expression() {
    let e2 = this._unary_expression();
    for (; this._match([He.tokens.star, He.tokens.forward_slash, He.tokens.modulo]); )
      e2 = this._updateNode(new Ie(this._previous().toString(), e2, this._unary_expression()));
    return e2;
  }
  _unary_expression() {
    return this._match([He.tokens.minus, He.tokens.bang, He.tokens.tilde, He.tokens.star, He.tokens.and]) ? this._updateNode(new ke(this._previous().toString(), this._unary_expression())) : this._singular_expression();
  }
  _singular_expression() {
    const e2 = this._primary_expression(), t2 = this._postfix_expression();
    return t2 && (e2.postfix = t2), e2;
  }
  _postfix_expression() {
    if (this._match(He.tokens.bracket_left)) {
      const e2 = this._short_circuit_or_expression();
      this._consume(He.tokens.bracket_right, "Expected ']'.");
      const t2 = this._updateNode(new ve(e2)), n2 = this._postfix_expression();
      return n2 && (t2.postfix = n2), t2;
    }
    if (this._match(He.tokens.period)) {
      const e2 = this._consume(He.tokens.name, "Expected member name."), t2 = this._postfix_expression(), n2 = this._updateNode(new pe(e2.lexeme));
      return t2 && (n2.postfix = t2), n2;
    }
    return null;
  }
  _getStruct(e2) {
    if (this._context.aliases.has(e2)) {
      return this._context.aliases.get(e2).type;
    }
    if (this._context.structs.has(e2)) {
      return this._context.structs.get(e2);
    }
    return null;
  }
  _getType(e2) {
    const t2 = this._getStruct(e2);
    if (null !== t2)
      return t2;
    switch (e2) {
      case "void":
        return ae.void;
      case "bool":
        return ae.bool;
      case "i32":
        return ae.i32;
      case "u32":
        return ae.u32;
      case "f32":
        return ae.f32;
      case "f16":
        return ae.f16;
      case "vec2f":
        return ce.vec2f;
      case "vec3f":
        return ce.vec3f;
      case "vec4f":
        return ce.vec4f;
      case "vec2i":
        return ce.vec2i;
      case "vec3i":
        return ce.vec3i;
      case "vec4i":
        return ce.vec4i;
      case "vec2u":
        return ce.vec2u;
      case "vec3u":
        return ce.vec3u;
      case "vec4u":
        return ce.vec4u;
      case "vec2h":
        return ce.vec2h;
      case "vec3h":
        return ce.vec3h;
      case "vec4h":
        return ce.vec4h;
      case "mat2x2f":
        return ce.mat2x2f;
      case "mat2x3f":
        return ce.mat2x3f;
      case "mat2x4f":
        return ce.mat2x4f;
      case "mat3x2f":
        return ce.mat3x2f;
      case "mat3x3f":
        return ce.mat3x3f;
      case "mat3x4f":
        return ce.mat3x4f;
      case "mat4x2f":
        return ce.mat4x2f;
      case "mat4x3f":
        return ce.mat4x3f;
      case "mat4x4f":
        return ce.mat4x4f;
      case "mat2x2h":
        return ce.mat2x2h;
      case "mat2x3h":
        return ce.mat2x3h;
      case "mat2x4h":
        return ce.mat2x4h;
      case "mat3x2h":
        return ce.mat3x2h;
      case "mat3x3h":
        return ce.mat3x3h;
      case "mat3x4h":
        return ce.mat3x4h;
      case "mat4x2h":
        return ce.mat4x2h;
      case "mat4x3h":
        return ce.mat4x3h;
      case "mat4x4h":
        return ce.mat4x4h;
      case "mat2x2i":
        return ce.mat2x2i;
      case "mat2x3i":
        return ce.mat2x3i;
      case "mat2x4i":
        return ce.mat2x4i;
      case "mat3x2i":
        return ce.mat3x2i;
      case "mat3x3i":
        return ce.mat3x3i;
      case "mat3x4i":
        return ce.mat3x4i;
      case "mat4x2i":
        return ce.mat4x2i;
      case "mat4x3i":
        return ce.mat4x3i;
      case "mat4x4i":
        return ce.mat4x4i;
      case "mat2x2u":
        return ce.mat2x2u;
      case "mat2x3u":
        return ce.mat2x3u;
      case "mat2x4u":
        return ce.mat2x4u;
      case "mat3x2u":
        return ce.mat3x2u;
      case "mat3x3u":
        return ce.mat3x3u;
      case "mat3x4u":
        return ce.mat3x4u;
      case "mat4x2u":
        return ce.mat4x2u;
      case "mat4x3u":
        return ce.mat4x3u;
      case "mat4x4u":
        return ce.mat4x4u;
    }
    return null;
  }
  _validateTypeRange(e2, t2) {
    if ("i32" === t2.name) {
      if (e2 < -2147483648 || e2 > 2147483647)
        throw this._error(this._previous(), `Value out of range for i32: ${e2}. Line: ${this._currentLine}.`);
    } else if ("u32" === t2.name && (e2 < 0 || e2 > 4294967295))
      throw this._error(this._previous(), `Value out of range for u32: ${e2}. Line: ${this._currentLine}.`);
  }
  _primary_expression() {
    if (this._match(He.tokens.ident)) {
      const e3 = this._previous().toString();
      if (this._check(He.tokens.paren_left)) {
        const t3 = this._argument_expression_list(), n2 = this._getType(e3);
        return null !== n2 ? this._updateNode(new de(n2, t3)) : this._updateNode(new me(e3, t3));
      }
      if (this._context.constants.has(e3)) {
        const t3 = this._context.constants.get(e3);
        return this._updateNode(new _e(e3, t3.value));
      }
      return this._updateNode(new ge(e3));
    }
    if (this._match(He.tokens.int_literal)) {
      const e3 = this._previous().toString();
      let t3 = e3.endsWith("i") || e3.endsWith("i") ? ae.i32 : e3.endsWith("u") || e3.endsWith("U") ? ae.u32 : ae.x32;
      const n2 = parseInt(e3);
      return this._validateTypeRange(n2, t3), this._updateNode(new xe(new Be(n2, this._exec.getTypeInfo(t3)), t3));
    }
    if (this._match(He.tokens.uint_literal)) {
      const e3 = parseInt(this._previous().toString());
      return this._validateTypeRange(e3, ae.u32), this._updateNode(new xe(new Be(e3, this._exec.getTypeInfo(ae.u32)), ae.u32));
    }
    if (this._match([He.tokens.decimal_float_literal, He.tokens.hex_float_literal])) {
      let e3 = this._previous().toString(), t3 = e3.endsWith("h");
      t3 && (e3 = e3.substring(0, e3.length - 1));
      const n2 = parseFloat(e3);
      this._validateTypeRange(n2, t3 ? ae.f16 : ae.f32);
      const s2 = t3 ? ae.f16 : ae.f32;
      return this._updateNode(new xe(new Be(n2, this._exec.getTypeInfo(s2)), s2));
    }
    if (this._match([He.keywords.true, He.keywords.false])) {
      let e3 = this._previous().toString() === He.keywords.true.rule;
      return this._updateNode(new xe(new Be(e3 ? 1 : 0, this._exec.getTypeInfo(ae.bool)), ae.bool));
    }
    if (this._check(He.tokens.paren_left))
      return this._paren_expression();
    if (this._match(He.keywords.bitcast)) {
      this._consume(He.tokens.less_than, "Expected '<'.");
      const e3 = this._type_decl();
      this._consume(He.tokens.greater_than, "Expected '>'.");
      const t3 = this._paren_expression();
      return this._updateNode(new ye(e3, t3));
    }
    const e2 = this._type_decl(), t2 = this._argument_expression_list();
    return this._updateNode(new de(e2, t2));
  }
  _argument_expression_list() {
    if (!this._match(He.tokens.paren_left))
      return null;
    const e2 = [];
    do {
      if (this._check(He.tokens.paren_right))
        break;
      const t2 = this._short_circuit_or_expression();
      e2.push(t2);
    } while (this._match(He.tokens.comma));
    return this._consume(He.tokens.paren_right, "Expected ')' for agument list"), e2;
  }
  _optional_paren_expression() {
    this._match(He.tokens.paren_left);
    const e2 = this._short_circuit_or_expression();
    return this._match(He.tokens.paren_right), e2;
  }
  _paren_expression() {
    this._consume(He.tokens.paren_left, "Expected '('.");
    const e2 = this._short_circuit_or_expression();
    return this._consume(He.tokens.paren_right, "Expected ')'."), e2;
  }
  _struct_decl() {
    if (!this._match(He.keywords.struct))
      return null;
    const e2 = this._currentLine, t2 = this._consume(He.tokens.ident, "Expected name for struct.").toString();
    this._consume(He.tokens.brace_left, "Expected '{' for struct body.");
    const n2 = [];
    for (; !this._check(He.tokens.brace_right); ) {
      const e3 = this._attribute(), t3 = this._consume(He.tokens.name, "Expected variable name.").toString();
      this._consume(He.tokens.colon, "Expected ':' for struct member type.");
      const s3 = this._attribute(), r3 = this._type_decl();
      null != r3 && (r3.attributes = s3), this._check(He.tokens.brace_right) ? this._match(He.tokens.comma) : this._consume(He.tokens.comma, "Expected ',' for struct member."), n2.push(this._updateNode(new Ce(t3, r3, e3)));
    }
    this._consume(He.tokens.brace_right, "Expected '}' after struct body.");
    const s2 = this._currentLine, r2 = this._updateNode(new oe(t2, n2, e2, s2), e2);
    return this._context.structs.set(t2, r2), r2;
  }
  _global_variable_decl() {
    const e2 = this._variable_decl();
    if (!e2)
      return null;
    if (this._match(He.tokens.equal)) {
      const t2 = this._const_expression();
      e2.value = t2;
    }
    if (null !== e2.type && e2.value instanceof xe) {
      if ("x32" !== e2.value.type.name) {
        if (e2.type.getTypeName() !== e2.value.type.getTypeName())
          throw this._error(this._peek(), `Invalid cast from ${e2.value.type.name} to ${e2.type.name}. Line:${this._currentLine}`);
      }
      e2.value.isScalar && this._validateTypeRange(e2.value.scalarValue, e2.type), e2.value.type = e2.type;
    } else
      null === e2.type && e2.value instanceof xe && (e2.type = "x32" === e2.value.type.name ? ae.i32 : e2.value.type, e2.value.isScalar && this._validateTypeRange(e2.value.scalarValue, e2.type));
    return e2;
  }
  _override_variable_decl() {
    const e2 = this._override_decl();
    return e2 && this._match(He.tokens.equal) && (e2.value = this._const_expression()), e2;
  }
  _global_const_decl() {
    var e2;
    if (!this._match(He.keywords.const))
      return null;
    const t2 = this._consume(He.tokens.name, "Expected variable name"), n2 = this._currentLine;
    let s2 = null;
    if (this._match(He.tokens.colon)) {
      const e3 = this._attribute();
      s2 = this._type_decl(), null != s2 && (s2.attributes = e3);
    }
    let r2 = null;
    this._consume(He.tokens.equal, "const declarations require an assignment");
    const i3 = this._short_circuit_or_expression();
    try {
      let e3 = [ae.f32], n3 = i3.constEvaluate(this._exec, e3);
      n3 instanceof Be && this._validateTypeRange(n3.value, e3[0]), e3[0] instanceof ce && null === e3[0].format && n3.typeInfo instanceof a && null !== n3.typeInfo.format && ("f16" === n3.typeInfo.format.name ? e3[0].format = ae.f16 : "f32" === n3.typeInfo.format.name ? e3[0].format = ae.f32 : "i32" === n3.typeInfo.format.name ? e3[0].format = ae.i32 : "u32" === n3.typeInfo.format.name ? e3[0].format = ae.u32 : "bool" === n3.typeInfo.format.name ? e3[0].format = ae.bool : console.error(`TODO: impelement template format type ${n3.typeInfo.format.name}`)), r2 = this._updateNode(new xe(n3, e3[0])), this._exec.context.setVariable(t2.toString(), n3);
    } catch (e3) {
      r2 = i3;
    }
    if (null !== s2 && r2 instanceof xe) {
      if ("x32" !== r2.type.name) {
        if (s2.getTypeName() !== r2.type.getTypeName())
          throw this._error(this._peek(), `Invalid cast from ${r2.type.name} to ${s2.name}. Line:${this._currentLine}`);
      }
      r2.type = s2, r2.isScalar && this._validateTypeRange(r2.scalarValue, r2.type);
    } else
      null === s2 && r2 instanceof xe && (s2 = null !== (e2 = null == r2 ? void 0 : r2.type) && void 0 !== e2 ? e2 : ae.f32, s2 === ae.x32 && (s2 = ae.i32));
    const o3 = this._updateNode(new P(t2.toString(), s2, "", "", r2), n2);
    return this._context.constants.set(o3.name, o3), o3;
  }
  _global_let_decl() {
    if (!this._match(He.keywords.let))
      return null;
    const e2 = this._currentLine, t2 = this._consume(He.tokens.name, "Expected variable name");
    let n2 = null;
    if (this._match(He.tokens.colon)) {
      const e3 = this._attribute();
      n2 = this._type_decl(), null != n2 && (n2.attributes = e3);
    }
    let s2 = null;
    if (this._match(He.tokens.equal) && (s2 = this._const_expression()), null !== n2 && s2 instanceof xe) {
      if ("x32" !== s2.type.name) {
        if (n2.getTypeName() !== s2.type.getTypeName())
          throw this._error(this._peek(), `Invalid cast from ${s2.type.name} to ${n2.name}. Line:${this._currentLine}`);
      }
      s2.type = n2;
    } else
      null === n2 && s2 instanceof xe && (n2 = "x32" === s2.type.name ? ae.i32 : s2.type);
    return s2 instanceof xe && s2.isScalar && this._validateTypeRange(s2.scalarValue, n2), this._updateNode(new U(t2.toString(), n2, "", "", s2), e2);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(He.keywords.var))
      return null;
    const e2 = this._currentLine;
    let t2 = "", n2 = "";
    this._match(He.tokens.less_than) && (t2 = this._consume(He.storage_class, "Expected storage_class.").toString(), this._match(He.tokens.comma) && (n2 = this._consume(He.access_mode, "Expected access_mode.").toString()), this._consume(He.tokens.greater_than, "Expected '>'."));
    const s2 = this._consume(He.tokens.name, "Expected variable name");
    let r2 = null;
    if (this._match(He.tokens.colon)) {
      const e3 = this._attribute();
      r2 = this._type_decl(), null != r2 && (r2.attributes = e3);
    }
    return this._updateNode(new F(s2.toString(), r2, t2, n2, null), e2);
  }
  _override_decl() {
    if (!this._match(He.keywords.override))
      return null;
    const e2 = this._consume(He.tokens.name, "Expected variable name");
    let t2 = null;
    if (this._match(He.tokens.colon)) {
      const e3 = this._attribute();
      t2 = this._type_decl(), null != t2 && (t2.attributes = e3);
    }
    return this._updateNode(new M(e2.toString(), t2, null));
  }
  _diagnostic() {
    this._consume(He.tokens.paren_left, "Expected '('");
    const e2 = this._consume(He.tokens.ident, "Expected severity control name.");
    this._consume(He.tokens.comma, "Expected ','");
    let t2 = this._consume(He.tokens.ident, "Expected diagnostic rule name.").toString();
    if (this._match(He.tokens.period)) {
      t2 += `.${this._consume(He.tokens.ident, "Expected diagnostic message.").toString()}`;
    }
    return this._consume(He.tokens.paren_right, "Expected ')'"), this._updateNode(new ee(e2.toString(), t2));
  }
  _enable_directive() {
    const e2 = this._consume(He.tokens.ident, "identity expected.");
    return this._updateNode(new K(e2.toString()));
  }
  _requires_directive() {
    const e2 = [this._consume(He.tokens.ident, "identity expected.").toString()];
    for (; this._match(He.tokens.comma); ) {
      const t2 = this._consume(He.tokens.ident, "identity expected.");
      e2.push(t2.toString());
    }
    return this._updateNode(new J(e2));
  }
  _type_alias() {
    const e2 = this._consume(He.tokens.ident, "identity expected.");
    this._consume(He.tokens.equal, "Expected '=' for type alias.");
    let t2 = this._type_decl();
    if (null === t2)
      throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(t2.name) && (t2 = this._context.aliases.get(t2.name).type);
    const n2 = this._updateNode(new te(e2.toString(), t2));
    return this._context.aliases.set(n2.name, n2), n2;
  }
  _type_decl() {
    if (this._check([He.tokens.ident, ...He.texel_format, He.keywords.bool, He.keywords.f32, He.keywords.i32, He.keywords.u32])) {
      const e3 = this._advance().toString();
      if (this._context.structs.has(e3))
        return this._context.structs.get(e3);
      if (this._context.aliases.has(e3))
        return this._context.aliases.get(e3).type;
      if (!this._getType(e3)) {
        const t3 = this._updateNode(new ie(e3));
        return this._forwardTypeCount++, t3;
      }
      return this._updateNode(new ae(e3));
    }
    let e2 = this._texture_sampler_types();
    if (e2)
      return e2;
    if (this._check(He.template_types)) {
      let e3 = this._advance().toString(), t3 = null, n2 = null;
      this._match(He.tokens.less_than) && (t3 = this._type_decl(), n2 = null, this._match(He.tokens.comma) && (n2 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for type."));
      return this._updateNode(new ce(e3, t3, n2));
    }
    if (this._match(He.keywords.ptr)) {
      let e3 = this._previous().toString();
      this._consume(He.tokens.less_than, "Expected '<' for pointer.");
      const t3 = this._consume(He.storage_class, "Expected storage_class for pointer");
      this._consume(He.tokens.comma, "Expected ',' for pointer.");
      const n2 = this._type_decl();
      let s2 = null;
      this._match(He.tokens.comma) && (s2 = this._consume(He.access_mode, "Expected access_mode for pointer").toString()), this._consume(He.tokens.greater_than, "Expected '>' for pointer.");
      return this._updateNode(new le(e3, t3.toString(), n2, s2));
    }
    const t2 = this._attribute();
    if (this._match(He.keywords.array)) {
      let e3 = null, n2 = -1;
      const s2 = this._previous();
      let r2 = null;
      if (this._match(He.tokens.less_than)) {
        e3 = this._type_decl(), this._context.aliases.has(e3.name) && (e3 = this._context.aliases.get(e3.name).type);
        let t3 = "";
        if (this._match(He.tokens.comma)) {
          r2 = this._shift_expression();
          try {
            t3 = r2.constEvaluate(this._exec).toString(), r2 = null;
          } catch (e4) {
            t3 = "1";
          }
        }
        this._consume(He.tokens.greater_than, "Expected '>' for array."), n2 = t3 ? parseInt(t3) : 0;
      }
      const a2 = this._updateNode(new ue(s2.toString(), t2, e3, n2));
      return r2 && this._deferArrayCountEval.push({ arrayType: a2, countNode: r2 }), a2;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(He.sampler_type))
      return this._updateNode(new he(this._previous().toString(), null, null));
    if (this._match(He.depth_texture_type))
      return this._updateNode(new he(this._previous().toString(), null, null));
    if (this._match(He.sampled_texture_type) || this._match(He.multisampled_texture_type)) {
      const e2 = this._previous();
      this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
      const t2 = this._type_decl();
      return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e2.toString(), t2, null));
    }
    if (this._match(He.storage_texture_type)) {
      const e2 = this._previous();
      this._consume(He.tokens.less_than, "Expected '<' for sampler type.");
      const t2 = this._consume(He.texel_format, "Invalid texel format.").toString();
      this._consume(He.tokens.comma, "Expected ',' after texel format.");
      const n2 = this._consume(He.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(He.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new he(e2.toString(), t2, n2));
    }
    return null;
  }
  _attribute() {
    let e2 = [];
    for (; this._match(He.tokens.attr); ) {
      const t2 = this._consume(He.attribute_name, "Expected attribute name"), n2 = this._updateNode(new De(t2.toString(), null));
      if (this._match(He.tokens.paren_left)) {
        if (n2.value = this._consume(He.literal_or_ident, "Expected attribute value").toString(), this._check(He.tokens.comma)) {
          this._advance();
          do {
            const e3 = this._consume(He.literal_or_ident, "Expected attribute value").toString();
            n2.value instanceof Array || (n2.value = [n2.value]), n2.value.push(e3);
          } while (this._match(He.tokens.comma));
        }
        this._consume(He.tokens.paren_right, "Expected ')'");
      }
      e2.push(n2);
    }
    return 0 == e2.length ? null : e2;
  }
};
var _t = class extends at {
  constructor(e2) {
    super(), e2 && this.update(e2);
  }
  update(e2) {
    const t2 = new gt().parse(e2);
    this.updateAST(t2);
  }
};

// node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js
function getShaderLayoutFromWGSL(source3) {
  const shaderLayout = { attributes: [], bindings: [] };
  let parsedWGSL;
  try {
    parsedWGSL = parseWGSL(source3);
  } catch (error) {
    log2.error(error.message)();
    return shaderLayout;
  }
  for (const uniform of parsedWGSL.uniforms) {
    const members = [];
    for (const attribute of uniform.type?.members || []) {
      members.push({
        name: attribute.name,
        type: getType(attribute.type)
      });
    }
    shaderLayout.bindings.push({
      type: "uniform",
      name: uniform.name,
      group: uniform.group,
      location: uniform.binding,
      // @ts-expect-error TODO - unused for now but needs fixing
      members
    });
  }
  for (const texture of parsedWGSL.textures) {
    shaderLayout.bindings.push({
      type: "texture",
      name: texture.name,
      group: texture.group,
      location: texture.binding
    });
  }
  for (const sampler of parsedWGSL.samplers) {
    shaderLayout.bindings.push({
      type: "sampler",
      name: sampler.name,
      group: sampler.group,
      location: sampler.binding
    });
  }
  const vertex2 = parsedWGSL.entry.vertex[0];
  const attributeCount = vertex2?.inputs.length || 0;
  for (let i3 = 0; i3 < attributeCount; i3++) {
    const wgslAttribute = vertex2.inputs[i3];
    if (wgslAttribute.locationType === "location") {
      const type = getType(wgslAttribute.type);
      shaderLayout.attributes.push({
        name: wgslAttribute.name,
        location: Number(wgslAttribute.location),
        type
      });
    }
  }
  return shaderLayout;
}
function getType(type) {
  return type.format ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source3) {
  try {
    return new _t(source3);
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    let message2 = "WGSL parse error";
    if (typeof error === "object" && error?.message) {
      message2 += `: ${error.message} `;
    }
    if (typeof error === "object" && error?.token) {
      message2 += error.token.line || "";
    }
    throw new Error(message2, { cause: error });
  }
}

// node_modules/@math.gl/core/dist/lib/common.js
var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var DEFAULT_CONFIG = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true,
  _cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
var config = globalThis.mathgl.config;
function formatValue(value, { precision = config.precision } = {}) {
  value = round(value);
  return `${parseFloat(value.toPrecision(precision))}`;
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function clamp(value, min4, max4) {
  return map(value, (value2) => Math.max(min4, Math.min(max4, value2)));
}
function lerp(a2, b2, t2) {
  if (isArray(a2)) {
    return a2.map((ai, i3) => lerp(ai, b2[i3], t2));
  }
  return t2 * b2 + (1 - t2) * a2;
}
function equals(a2, b2, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a2 === b2) {
      return true;
    }
    if (isArray(a2) && isArray(b2)) {
      if (a2.length !== b2.length) {
        return false;
      }
      for (let i3 = 0; i3 < a2.length; ++i3) {
        if (!equals(a2[i3], b2[i3])) {
          return false;
        }
      }
      return true;
    }
    if (a2 && a2.equals) {
      return a2.equals(b2);
    }
    if (b2 && b2.equals) {
      return b2.equals(a2);
    }
    if (typeof a2 === "number" && typeof b2 === "number") {
      return Math.abs(a2 - b2) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
  if (isArray(value)) {
    const array = value;
    result = result || duplicateArray(array);
    for (let i3 = 0; i3 < result.length && i3 < array.length; ++i3) {
      const val = typeof value === "number" ? value : value[i3];
      result[i3] = func(val, i3, result);
    }
    return result;
  }
  return func(value);
}

// node_modules/@math.gl/core/dist/classes/base/math-array.js
var MathArray = class extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] = array[i3 + offset];
    }
    return this.check();
  }
  toArray(targetArray = [], offset = 0) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      targetArray[offset + i3] = this[i3];
    }
    return targetArray;
  }
  toObject(targetObject) {
    return targetObject;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
      // @ts-ignore
      this.fromObject(arrayOrObject)
    );
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target2) {
    return target2 ? this.to(target2) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(config);
  }
  /** Formats string according to options */
  formatString(opts) {
    let string = "";
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      string += (i3 > 0 ? ", " : "") + formatValue(this[i3], opts);
    }
    return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
  }
  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      if (!equals(this[i3], array[i3])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      if (this[i3] !== array[i3]) {
        return false;
      }
    }
    return true;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] = -this[i3];
    }
    return this.check();
  }
  lerp(a2, b2, t2) {
    if (t2 === void 0) {
      return this.lerp(this, a2, b2);
    }
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      const ai = a2[i3];
      const endValue = typeof b2 === "number" ? b2 : b2[i3];
      this[i3] = ai + t2 * (endValue - ai);
    }
    return this.check();
  }
  /** Minimal */
  min(vector) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] = Math.min(vector[i3], this[i3]);
    }
    return this.check();
  }
  /** Maximal */
  max(vector) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] = Math.max(vector[i3], this[i3]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] = Math.min(Math.max(this[i3], minVector[i3]), maxVector[i3]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] += vector[i3];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] -= vector[i3];
      }
    }
    return this.check();
  }
  scale(scale7) {
    if (typeof scale7 === "number") {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] *= scale7;
      }
    } else {
      for (let i3 = 0; i3 < this.ELEMENTS && i3 < scale7.length; ++i3) {
        this[i3] *= scale7[i3];
      }
    }
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(scalar) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] *= scalar;
    }
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (config.debug && !this.validate()) {
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    }
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      valid = valid && Number.isFinite(this[i3]);
    }
    return valid;
  }
  // three.js compatibility
  /** @deprecated */
  sub(a2) {
    return this.subtract(a2);
  }
  /** @deprecated */
  setScalar(a2) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] = a2;
    }
    return this.check();
  }
  /** @deprecated */
  addScalar(a2) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] += a2;
    }
    return this.check();
  }
  /** @deprecated */
  subScalar(a2) {
    return this.addScalar(-a2);
  }
  /** @deprecated */
  multiplyScalar(scalar) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] *= scalar;
    }
    return this.check();
  }
  /** @deprecated */
  divideScalar(a2) {
    return this.multiplyByScalar(1 / a2);
  }
  /** @deprecated */
  clampScalar(min4, max4) {
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      this[i3] = Math.min(Math.max(this[i3], min4), max4);
    }
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
};

// node_modules/@math.gl/core/dist/lib/validators.js
function validateVector(v2, length5) {
  if (v2.length !== length5) {
    return false;
  }
  for (let i3 = 0; i3 < v2.length; ++i3) {
    if (!Number.isFinite(v2[i3])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error(`Invalid number ${JSON.stringify(value)}`);
  }
  return value;
}
function checkVector(v2, length5, callerName = "") {
  if (config.debug && !validateVector(v2, length5)) {
    throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
  }
  return v2;
}

// node_modules/@math.gl/core/dist/lib/assert.js
function assert6(condition, message2) {
  if (!condition) {
    throw new Error(`math.gl assertion ${message2}`);
  }
}

// node_modules/@math.gl/core/dist/classes/base/vector.js
var Vector = class extends MathArray {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = checkNumber(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = checkNumber(value);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let length5 = 0;
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      length5 += this[i3] * this[i3];
    }
    return length5;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length5 = 0;
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      const dist4 = this[i3] - mathArray[i3];
      length5 += dist4 * dist4;
    }
    return checkNumber(length5);
  }
  dot(mathArray) {
    let product2 = 0;
    for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
      product2 += this[i3] * mathArray[i3];
    }
    return checkNumber(product2);
  }
  // MODIFIERS
  normalize() {
    const length5 = this.magnitude();
    if (length5 !== 0) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] /= length5;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] *= vector[i3];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] /= vector[i3];
      }
    }
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i3) {
    assert6(i3 >= 0 && i3 < this.ELEMENTS, "index is out of range");
    return checkNumber(this[i3]);
  }
  setComponent(i3, value) {
    assert6(i3 >= 0 && i3 < this.ELEMENTS, "index is out of range");
    this[i3] = value;
    return this.check();
  }
  addVectors(a2, b2) {
    return this.copy(a2).add(b2);
  }
  subVectors(a2, b2) {
    return this.copy(a2).subtract(b2);
  }
  multiplyVectors(a2, b2) {
    return this.copy(a2).multiply(b2);
  }
  addScaledVector(a2, b2) {
    return this.add(new this.constructor(a2).multiplyScalar(b2));
  }
};

// node_modules/@math.gl/core/dist/gl-matrix/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add,
  angle: () => angle,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach2,
  fromValues: () => fromValues,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp2,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotate: () => rotate,
  round: () => round3,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  zero: () => zero2
});

// node_modules/@math.gl/core/dist/gl-matrix/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function round2(a2) {
  if (a2 >= 0)
    return Math.round(a2);
  return a2 % 0.5 === 0 ? Math.floor(a2) : Math.round(a2);
}
var degree = Math.PI / 180;

// node_modules/@math.gl/core/dist/gl-matrix/vec2.js
function create() {
  const out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone(a2) {
  const out = new ARRAY_TYPE(2);
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function fromValues(x2, y2) {
  const out = new ARRAY_TYPE(2);
  out[0] = x2;
  out[1] = y2;
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function set2(out, x2, y2) {
  out[0] = x2;
  out[1] = y2;
  return out;
}
function add(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  return out;
}
function subtract(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  return out;
}
function multiply(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  return out;
}
function divide(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  return out;
}
function min(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  return out;
}
function max(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  return out;
}
function round3(out, a2) {
  out[0] = round2(a2[0]);
  out[1] = round2(a2[1]);
  return out;
}
function scale(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  return out;
}
function scaleAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  return out;
}
function distance(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function squaredDistance(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  return x2 * x2 + y2 * y2;
}
function length(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function squaredLength(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  return x2 * x2 + y2 * y2;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  return out;
}
function normalize(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  let len4 = x2 * x2 + y2 * y2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a2[0] * len4;
  out[1] = a2[1] * len4;
  return out;
}
function dot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1];
}
function cross(out, a2, b2) {
  const z2 = a2[0] * b2[1] - a2[1] * b2[0];
  out[0] = out[1] = 0;
  out[2] = z2;
  return out;
}
function lerp2(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  return out;
}
function random(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  const r2 = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r2) * scale7;
  out[1] = Math.sin(r2) * scale7;
  return out;
}
function transformMat2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  return out;
}
function transformMat2d(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
  out[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
  return out;
}
function transformMat3(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
  return out;
}
function transformMat4(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[12];
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[13];
  return out;
}
function rotate(out, a2, b2, rad) {
  const p0 = a2[0] - b2[0];
  const p1 = a2[1] - b2[1];
  const sinC = Math.sin(rad);
  const cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b2[0];
  out[1] = p0 * sinC + p1 * cosC + b2[1];
  return out;
}
function angle(a2, b2) {
  const x1 = a2[0];
  const y1 = a2[1];
  const x2 = b2[0];
  const y2 = b2[1];
  const mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));
  const cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str(a2) {
  return `vec2(${a2[0]}, ${a2[1]})`;
}
function exactEquals(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1];
}
function equals2(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const b0 = b2[0];
  const b1 = b2[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len = length;
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach2 = function() {
  const vec = create();
  return function(a2, stride, offset, count2, fn, arg) {
    let i3;
    let l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i3 = offset; i3 < l2; i3 += stride) {
      vec[0] = a2[i3];
      vec[1] = a2[i3 + 1];
      fn(vec, vec, arg);
      a2[i3] = vec[0];
      a2[i3 + 1] = vec[1];
    }
    return a2;
  };
}();

// node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
function vec2_transformMat4AsVector(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const w3 = m2[3] * x2 + m2[7] * y2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2) / w3;
  out[1] = (m2[1] * x2 + m2[5] * y2) / w3;
  return out;
}
function vec3_transformMat4AsVector(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w3 = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2) / w3;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2) / w3;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2) / w3;
  return out;
}
function vec3_transformMat2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  out[2] = a2[2];
  return out;
}
function vec4_transformMat2(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function vec4_transformMat3(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6] * z2;
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7] * z2;
  out[2] = m2[2] * x2 + m2[5] * y2 + m2[8] * z2;
  out[3] = a2[3];
  return out;
}

// node_modules/@math.gl/core/dist/gl-matrix/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle2,
  bezier: () => bezier,
  ceil: () => ceil2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  floor: () => floor2,
  forEach: () => forEach3,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp3,
  max: () => max2,
  min: () => min2,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round4,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set3,
  slerp: () => slerp,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat,
  zero: () => zero3
});
function create2() {
  const out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a2) {
  const out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length2(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function fromValues2(x2, y2, z2) {
  const out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function copy2(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set3(out, x2, y2, z2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function add2(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  return out;
}
function subtract2(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  return out;
}
function multiply2(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  return out;
}
function divide2(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  out[2] = a2[2] / b2[2];
  return out;
}
function ceil2(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor2(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min2(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  return out;
}
function max2(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  return out;
}
function round4(out, a2) {
  out[0] = round2(a2[0]);
  out[1] = round2(a2[1]);
  out[2] = round2(a2[2]);
  return out;
}
function scale2(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  return out;
}
function scaleAndAdd2(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  return out;
}
function distance2(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
}
function squaredDistance2(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function squaredLength2(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function negate2(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse2(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize2(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let len4 = x2 * x2 + y2 * y2 + z2 * z2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a2[0] * len4;
  out[1] = a2[1] * len4;
  out[2] = a2[2] * len4;
  return out;
}
function dot2(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cross2(out, a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp3(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  out[2] = az + t2 * (b2[2] - az);
  return out;
}
function slerp(out, a2, b2, t2) {
  const angle3 = Math.acos(Math.min(Math.max(dot2(a2, b2), -1), 1));
  const sinTotal = Math.sin(angle3);
  const ratioA = Math.sin((1 - t2) * angle3) / sinTotal;
  const ratioB = Math.sin(t2 * angle3) / sinTotal;
  out[0] = ratioA * a2[0] + ratioB * b2[0];
  out[1] = ratioA * a2[1] + ratioB * b2[1];
  out[2] = ratioA * a2[2] + ratioB * b2[2];
  return out;
}
function hermite(out, a2, b2, c2, d2, t2) {
  const factorTimes2 = t2 * t2;
  const factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  const factor2 = factorTimes2 * (t2 - 2) + t2;
  const factor3 = factorTimes2 * (t2 - 1);
  const factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a2, b2, c2, d2, t2) {
  const inverseFactor = 1 - t2;
  const inverseFactorTimesTwo = inverseFactor * inverseFactor;
  const factorTimes2 = t2 * t2;
  const factor1 = inverseFactorTimesTwo * inverseFactor;
  const factor2 = 3 * t2 * inverseFactorTimesTwo;
  const factor3 = 3 * factorTimes2 * inverseFactor;
  const factor4 = factorTimes2 * t2;
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function random2(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  const r2 = RANDOM() * 2 * Math.PI;
  const z2 = RANDOM() * 2 - 1;
  const zScale = Math.sqrt(1 - z2 * z2) * scale7;
  out[0] = Math.cos(r2) * zScale;
  out[1] = Math.sin(r2) * zScale;
  out[2] = z2 * scale7;
  return out;
}
function transformMat42(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let w3 = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15];
  w3 = w3 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12]) / w3;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13]) / w3;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14]) / w3;
  return out;
}
function transformMat32(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  out[0] = x2 * m2[0] + y2 * m2[3] + z2 * m2[6];
  out[1] = x2 * m2[1] + y2 * m2[4] + z2 * m2[7];
  out[2] = x2 * m2[2] + y2 * m2[5] + z2 * m2[8];
  return out;
}
function transformQuat(out, a2, q2) {
  const qx = q2[0];
  const qy = q2[1];
  const qz = q2[2];
  const qw = q2[3];
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  let uvx = qy * z2 - qz * y2;
  let uvy = qz * x2 - qx * z2;
  let uvz = qx * y2 - qy * x2;
  let uuvx = qy * uvz - qz * uvy;
  let uuvy = qz * uvx - qx * uvz;
  let uuvz = qx * uvy - qy * uvx;
  const w22 = qw * 2;
  uvx *= w22;
  uvy *= w22;
  uvz *= w22;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x2 + uvx + uuvx;
  out[1] = y2 + uvy + uuvy;
  out[2] = z2 + uvz + uuvz;
  return out;
}
function rotateX(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[0];
  r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function rotateY(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r2[1] = p2[1];
  r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function rotateZ(out, a2, b2, rad) {
  const p2 = [];
  const r2 = [];
  p2[0] = a2[0] - b2[0];
  p2[1] = a2[1] - b2[1];
  p2[2] = a2[2] - b2[2];
  r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r2[2] = p2[2];
  out[0] = r2[0] + b2[0];
  out[1] = r2[1] + b2[1];
  out[2] = r2[2] + b2[2];
  return out;
}
function angle2(a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
  const cosine = mag && dot2(a2, b2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a2) {
  return `vec3(${a2[0]}, ${a2[1]}, ${a2[2]})`;
}
function exactEquals2(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2];
}
function equals3(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach3 = function() {
  const vec = create2();
  return function(a2, stride, offset, count2, fn, arg) {
    let i3;
    let l2;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i3 = offset; i3 < l2; i3 += stride) {
      vec[0] = a2[i3];
      vec[1] = a2[i3 + 1];
      vec[2] = a2[i3 + 2];
      fn(vec, vec, arg);
      a2[i3] = vec[0];
      a2[i3 + 1] = vec[1];
      a2[i3 + 2] = vec[2];
    }
    return a2;
  };
}();

// node_modules/@math.gl/core/dist/classes/vector3.js
var ORIGIN = [0, 0, 0];
var ZERO;
var Vector3 = class _Vector3 extends Vector {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new _Vector3(0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && isArray(x2)) {
      this.copy(x2);
    } else {
      if (config.debug) {
        checkNumber(x2);
        checkNumber(y2);
        checkNumber(z2);
      }
      this[0] = x2;
      this[1] = y2;
      this[2] = z2;
    }
  }
  set(x2, y2, z2) {
    this[0] = x2;
    this[1] = y2;
    this[2] = z2;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }
  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
      checkNumber(object.z);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  // ACCESSORS
  angle(vector) {
    return angle2(this, vector);
  }
  // MODIFIERS
  cross(vector) {
    cross2(this, this, vector);
    return this.check();
  }
  rotateX({ radians: radians2, origin = ORIGIN }) {
    rotateX(this, this, origin, radians2);
    return this.check();
  }
  rotateY({ radians: radians2, origin = ORIGIN }) {
    rotateY(this, this, origin, radians2);
    return this.check();
  }
  rotateZ({ radians: radians2, origin = ORIGIN }) {
    rotateZ(this, this, origin, radians2);
    return this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(matrix4) {
    transformMat42(this, this, matrix4);
    return this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(matrix4) {
    vec3_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    transformMat32(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec3_transformMat2(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    transformQuat(this, this, quaternion);
    return this.check();
  }
};

// node_modules/@math.gl/core/dist/classes/vector4.js
var ZERO2;
var Vector4 = class _Vector4 extends Vector {
  static get ZERO() {
    if (!ZERO2) {
      ZERO2 = new _Vector4(0, 0, 0, 0);
      Object.freeze(ZERO2);
    }
    return ZERO2;
  }
  constructor(x2 = 0, y2 = 0, z2 = 0, w3 = 0) {
    super(-0, -0, -0, -0);
    if (isArray(x2) && arguments.length === 1) {
      this.copy(x2);
    } else {
      if (config.debug) {
        checkNumber(x2);
        checkNumber(y2);
        checkNumber(z2);
        checkNumber(w3);
      }
      this[0] = x2;
      this[1] = y2;
      this[2] = z2;
      this[3] = w3;
    }
  }
  set(x2, y2, z2, w3) {
    this[0] = x2;
    this[1] = y2;
    this[2] = z2;
    this[3] = w3;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }
  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
      checkNumber(object.z);
      checkNumber(object.w);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this;
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    object.w = this[3];
    return object;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  get w() {
    return this[3];
  }
  set w(value) {
    this[3] = checkNumber(value);
  }
  transform(matrix4) {
    transformMat42(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    vec4_transformMat3(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec4_transformMat2(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    transformQuat(this, this, quaternion);
    return this.check();
  }
  // three.js compatibility
  applyMatrix4(m2) {
    m2.transform(this, this);
    return this;
  }
};

// node_modules/@math.gl/core/dist/classes/base/matrix.js
var Matrix = class extends MathArray {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let string = "[";
    if (config.printRowMajor) {
      string += "row-major:";
      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += ` ${this[col * this.RANK + row]}`;
        }
      }
    } else {
      string += "column-major:";
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        string += ` ${this[i3]}`;
      }
    }
    string += "]";
    return string;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  // By default assumes row major indices
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  // By default assumes row major indices
  setElement(row, col, value) {
    this[col * this.RANK + row] = checkNumber(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i3 = 0; i3 < this.RANK; ++i3) {
      result[i3] = this[firstIndex + i3];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i3 = 0; i3 < this.RANK; ++i3) {
      this[firstIndex + i3] = columnVector[i3];
    }
    return this;
  }
};

// node_modules/@math.gl/core/dist/gl-matrix/mat3.js
function create3() {
  const out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a12 = a2[5];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a01;
    out[5] = a2[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a2[0];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a2[1];
    out[4] = a2[4];
    out[5] = a2[7];
    out[6] = a2[2];
    out[7] = a2[5];
    out[8] = a2[8];
  }
  return out;
}
function invert(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b01 = a22 * a11 - a12 * a21;
  const b11 = -a22 * a10 + a12 * a20;
  const b21 = a21 * a10 - a11 * a20;
  let det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function determinant(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply3(out, a2, b2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b00 = b2[0];
  const b01 = b2[1];
  const b02 = b2[2];
  const b10 = b2[3];
  const b11 = b2[4];
  const b12 = b2[5];
  const b20 = b2[6];
  const b21 = b2[7];
  const b22 = b2[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a2, v2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const x2 = v2[0];
  const y2 = v2[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x2 * a00 + y2 * a10 + a20;
  out[7] = x2 * a01 + y2 * a11 + a21;
  out[8] = x2 * a02 + y2 * a12 + a22;
  return out;
}
function rotate2(out, a2, rad) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2 * a00 + s2 * a10;
  out[1] = c2 * a01 + s2 * a11;
  out[2] = c2 * a02 + s2 * a12;
  out[3] = c2 * a10 - s2 * a00;
  out[4] = c2 * a11 - s2 * a01;
  out[5] = c2 * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale3(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  out[0] = x2 * a2[0];
  out[1] = x2 * a2[1];
  out[2] = x2 * a2[2];
  out[3] = y2 * a2[3];
  out[4] = y2 * a2[4];
  out[5] = y2 * a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromQuat(out, q2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w3 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const yx = y2 * x22;
  const yy = y2 * y22;
  const zx = z2 * x22;
  const zy = z2 * y22;
  const zz = z2 * z22;
  const wx = w3 * x22;
  const wy = w3 * y22;
  const wz = w3 * z22;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}

// node_modules/@math.gl/core/dist/classes/matrix3.js
var INDICES;
(function(INDICES3) {
  INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
  INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
  INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
  INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
  INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
  INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
})(INDICES || (INDICES = {}));
var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
var Matrix3 = class extends Matrix {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array, ...args) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else if (args.length > 0) {
      this.copy([array, ...args]);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    return this.check();
  }
  // Constructors
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(object) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(q2) {
    fromQuat(this, q2);
    return this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  // Accessors
  determinant() {
    return determinant(this);
  }
  // Modifiers
  transpose() {
    transpose(this, this);
    return this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    invert(this, this);
    return this.check();
  }
  // Operations
  multiplyLeft(a2) {
    multiply3(this, a2, this);
    return this.check();
  }
  multiplyRight(a2) {
    multiply3(this, this, a2);
    return this.check();
  }
  rotate(radians2) {
    rotate2(this, this, radians2);
    return this.check();
  }
  scale(factor) {
    if (Array.isArray(factor)) {
      scale3(this, this, factor);
    } else {
      scale3(this, this, [factor, factor]);
    }
    return this.check();
  }
  translate(vec) {
    translate(this, this, vec);
    return this.check();
  }
  // Transforms
  transform(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = transformMat3(result || [-0, -0], vector, this);
        break;
      case 3:
        out = transformMat32(result || [-0, -0, -0], vector, this);
        break;
      case 4:
        out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /** @deprecated */
  transformVector(vector, result) {
    return this.transform(vector, result);
  }
  /** @deprecated */
  transformVector2(vector, result) {
    return this.transform(vector, result);
  }
  /** @deprecated */
  transformVector3(vector, result) {
    return this.transform(vector, result);
  }
};
var ZERO_MATRIX3;
var IDENTITY_MATRIX3 = null;
function getZeroMatrix() {
  if (!ZERO_MATRIX3) {
    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO_MATRIX3);
  }
  return ZERO_MATRIX3;
}
function getIdentityMatrix() {
  if (!IDENTITY_MATRIX3) {
    IDENTITY_MATRIX3 = new Matrix3();
    Object.freeze(IDENTITY_MATRIX3);
  }
  return IDENTITY_MATRIX3;
}

// node_modules/@math.gl/core/dist/gl-matrix/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add3,
  adjoint: () => adjoint,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create4,
  decompose: () => decompose,
  determinant: () => determinant2,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  frob: () => frob,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues3,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul3,
  multiply: () => multiply4,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate3,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  scale: () => scale4,
  set: () => set4,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create4() {
  const out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone3(a2) {
  const out = new ARRAY_TYPE(16);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function copy3(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function fromValues3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  const out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set4(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a03 = a2[3];
    const a12 = a2[6];
    const a13 = a2[7];
    const a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert2(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant2(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  const b0 = a00 * a11 - a01 * a10;
  const b1 = a00 * a12 - a02 * a10;
  const b2 = a01 * a12 - a02 * a11;
  const b3 = a20 * a31 - a21 * a30;
  const b4 = a20 * a32 - a22 * a30;
  const b5 = a21 * a32 - a22 * a31;
  const b6 = a00 * b5 - a01 * b4 + a02 * b3;
  const b7 = a10 * b5 - a11 * b4 + a12 * b3;
  const b8 = a20 * b2 - a21 * b1 + a22 * b0;
  const b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply4(out, a2, b2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  const a30 = a2[12];
  const a31 = a2[13];
  const a32 = a2[14];
  const a33 = a2[15];
  let b0 = b2[0];
  let b1 = b2[1];
  let b22 = b2[2];
  let b3 = b2[3];
  out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[4];
  b1 = b2[5];
  b22 = b2[6];
  b3 = b2[7];
  out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[8];
  b1 = b2[9];
  b22 = b2[10];
  b3 = b2[11];
  out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[12];
  b1 = b2[13];
  b22 = b2[14];
  b3 = b2[15];
  out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  return out;
}
function translate2(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  const z2 = v2[2];
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  if (a2 === out) {
    out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z2 + a2[12];
    out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z2 + a2[13];
    out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z2 + a2[14];
    out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z2 + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y2 + a20 * z2 + a2[12];
    out[13] = a01 * x2 + a11 * y2 + a21 * z2 + a2[13];
    out[14] = a02 * x2 + a12 * y2 + a22 * z2 + a2[14];
    out[15] = a03 * x2 + a13 * y2 + a23 * z2 + a2[15];
  }
  return out;
}
function scale4(out, a2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  const z2 = v2[2];
  out[0] = a2[0] * x2;
  out[1] = a2[1] * x2;
  out[2] = a2[2] * x2;
  out[3] = a2[3] * x2;
  out[4] = a2[4] * y2;
  out[5] = a2[5] * y2;
  out[6] = a2[6] * y2;
  out[7] = a2[7] * y2;
  out[8] = a2[8] * z2;
  out[9] = a2[9] * z2;
  out[10] = a2[10] * z2;
  out[11] = a2[11] * z2;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate3(out, a2, rad, axis) {
  let x2 = axis[0];
  let y2 = axis[1];
  let z2 = axis[2];
  let len4 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  let c2;
  let s2;
  let t2;
  let a00;
  let a01;
  let a02;
  let a03;
  let a10;
  let a11;
  let a12;
  let a13;
  let a20;
  let a21;
  let a22;
  let a23;
  let b00;
  let b01;
  let b02;
  let b10;
  let b11;
  let b12;
  let b20;
  let b21;
  let b22;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y2 *= len4;
  z2 *= len4;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t2 = 1 - c2;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x2 * x2 * t2 + c2;
  b01 = y2 * x2 * t2 + z2 * s2;
  b02 = z2 * x2 * t2 - y2 * s2;
  b10 = x2 * y2 * t2 - z2 * s2;
  b11 = y2 * y2 * t2 + c2;
  b12 = z2 * y2 * t2 + x2 * s2;
  b20 = x2 * z2 * t2 + y2 * s2;
  b21 = y2 * z2 * t2 - x2 * s2;
  b22 = z2 * z2 * t2 + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c2 + a20 * s2;
  out[5] = a11 * c2 + a21 * s2;
  out[6] = a12 * c2 + a22 * s2;
  out[7] = a13 * c2 + a23 * s2;
  out[8] = a20 * c2 - a10 * s2;
  out[9] = a21 * c2 - a11 * s2;
  out[10] = a22 * c2 - a12 * s2;
  out[11] = a23 * c2 - a13 * s2;
  return out;
}
function rotateY2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a20 = a2[8];
  const a21 = a2[9];
  const a22 = a2[10];
  const a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 - a20 * s2;
  out[1] = a01 * c2 - a21 * s2;
  out[2] = a02 * c2 - a22 * s2;
  out[3] = a03 * c2 - a23 * s2;
  out[8] = a00 * s2 + a20 * c2;
  out[9] = a01 * s2 + a21 * c2;
  out[10] = a02 * s2 + a22 * c2;
  out[11] = a03 * s2 + a23 * c2;
  return out;
}
function rotateZ2(out, a2, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a03 = a2[3];
  const a10 = a2[4];
  const a11 = a2[5];
  const a12 = a2[6];
  const a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 + a10 * s2;
  out[1] = a01 * c2 + a11 * s2;
  out[2] = a02 * c2 + a12 * s2;
  out[3] = a03 * c2 + a13 * s2;
  out[4] = a10 * c2 - a00 * s2;
  out[5] = a11 * c2 - a01 * s2;
  out[6] = a12 * c2 - a02 * s2;
  out[7] = a13 * c2 - a03 * s2;
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  let x2 = axis[0];
  let y2 = axis[1];
  let z2 = axis[2];
  let len4 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  let c2;
  let s2;
  let t2;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y2 *= len4;
  z2 *= len4;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t2 = 1 - c2;
  out[0] = x2 * x2 * t2 + c2;
  out[1] = y2 * x2 * t2 + z2 * s2;
  out[2] = z2 * x2 * t2 - y2 * s2;
  out[3] = 0;
  out[4] = x2 * y2 * t2 - z2 * s2;
  out[5] = y2 * y2 * t2 + c2;
  out[6] = z2 * y2 * t2 + x2 * s2;
  out[7] = 0;
  out[8] = x2 * z2 * t2 + y2 * s2;
  out[9] = y2 * z2 * t2 - x2 * s2;
  out[10] = z2 * z2 * t2 + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c2;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  const s2 = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q2, v2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w3 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w3 * x22;
  const wy = w3 * y22;
  const wz = w3 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a2) {
  const translation = new ARRAY_TYPE(3);
  const bx = -a2[0];
  const by = -a2[1];
  const bz = -a2[2];
  const bw = a2[3];
  const ax = a2[4];
  const ay = a2[5];
  const az = a2[6];
  const aw = a2[7];
  const magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a2, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  const m11 = mat[0];
  const m12 = mat[1];
  const m13 = mat[2];
  const m21 = mat[4];
  const m22 = mat[5];
  const m23 = mat[6];
  const m31 = mat[8];
  const m32 = mat[9];
  const m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  const scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  const is1 = 1 / scaling[0];
  const is2 = 1 / scaling[1];
  const is3 = 1 / scaling[2];
  const sm11 = mat[0] * is1;
  const sm12 = mat[1] * is2;
  const sm13 = mat[2] * is3;
  const sm21 = mat[4] * is1;
  const sm22 = mat[5] * is2;
  const sm23 = mat[6] * is3;
  const sm31 = mat[8] * is1;
  const sm32 = mat[9] * is2;
  const sm33 = mat[10] * is3;
  const trace = sm11 + sm22 + sm33;
  let S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  const m11 = mat[0];
  const m12 = mat[1];
  const m13 = mat[2];
  const m21 = mat[4];
  const m22 = mat[5];
  const m23 = mat[6];
  const m31 = mat[8];
  const m32 = mat[9];
  const m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  const is1 = 1 / out_s[0];
  const is2 = 1 / out_s[1];
  const is3 = 1 / out_s[2];
  const sm11 = m11 * is1;
  const sm12 = m12 * is2;
  const sm13 = m13 * is3;
  const sm21 = m21 * is1;
  const sm22 = m22 * is2;
  const sm23 = m23 * is3;
  const sm31 = m31 * is1;
  const sm32 = m32 * is2;
  const sm33 = m33 * is3;
  const trace = sm11 + sm22 + sm33;
  let S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S2;
    out_r[0] = (sm23 - sm32) / S2;
    out_r[1] = (sm31 - sm13) / S2;
    out_r[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S2;
    out_r[0] = 0.25 * S2;
    out_r[1] = (sm12 + sm21) / S2;
    out_r[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S2;
    out_r[0] = (sm12 + sm21) / S2;
    out_r[1] = 0.25 * S2;
    out_r[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S2;
    out_r[0] = (sm31 + sm13) / S2;
    out_r[1] = (sm23 + sm32) / S2;
    out_r[2] = 0.25 * S2;
  }
  return out_r;
}
function fromRotationTranslationScale(out, q2, v2, s2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w3 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w3 * x22;
  const wy = w3 * y22;
  const wz = w3 * z22;
  const sx = s2[0];
  const sy = s2[1];
  const sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q2, v2, s2, o3) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w3 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const xy = x2 * y22;
  const xz = x2 * z22;
  const yy = y2 * y22;
  const yz = y2 * z22;
  const zz = z2 * z22;
  const wx = w3 * x22;
  const wy = w3 * y22;
  const wz = w3 * z22;
  const sx = s2[0];
  const sy = s2[1];
  const sz = s2[2];
  const ox = o3[0];
  const oy = o3[1];
  const oz = o3[2];
  const out0 = (1 - (yy + zz)) * sx;
  const out1 = (xy + wz) * sx;
  const out2 = (xz - wy) * sx;
  const out4 = (xy - wz) * sy;
  const out5 = (1 - (xx + zz)) * sy;
  const out6 = (yz + wx) * sy;
  const out8 = (xz + wy) * sz;
  const out9 = (yz - wx) * sz;
  const out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q2) {
  const x2 = q2[0];
  const y2 = q2[1];
  const z2 = q2[2];
  const w3 = q2[3];
  const x22 = x2 + x2;
  const y22 = y2 + y2;
  const z22 = z2 + z2;
  const xx = x2 * x22;
  const yx = y2 * x22;
  const yy = y2 * y22;
  const zx = z2 * x22;
  const zy = z2 * y22;
  const zz = z2 * z22;
  const wx = w3 * x22;
  const wy = w3 * y22;
  const wz = w3 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  const rl = 1 / (right - left);
  const tb = 1 / (top - bottom);
  const nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  const f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    const nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  const f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    const nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  const xScale = 2 / (leftTan + rightTan);
  const yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  let len4;
  let x0;
  let x1;
  let x2;
  let y0;
  let y1;
  let y2;
  let z0;
  let z1;
  let z2;
  const eyex = eye[0];
  const eyey = eye[1];
  const eyez = eye[2];
  const upx = up[0];
  const upy = up[1];
  const upz = up[2];
  const centerx = center[0];
  const centery = center[1];
  const centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len4 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len4;
  z1 *= len4;
  z2 *= len4;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len4 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len4) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len4 = 1 / len4;
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len4 = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len4) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len4 = 1 / len4;
    y0 *= len4;
    y1 *= len4;
    y2 *= len4;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target2, up) {
  const eyex = eye[0];
  const eyey = eye[1];
  const eyez = eye[2];
  const upx = up[0];
  const upy = up[1];
  const upz = up[2];
  let z0 = eyex - target2[0];
  let z1 = eyey - target2[1];
  let z2 = eyez - target2[2];
  let len4 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
  }
  let x0 = upy * z2 - upz * z1;
  let x1 = upz * z0 - upx * z2;
  let x2 = upx * z1 - upy * z0;
  len4 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str3(a2) {
  return `mat4(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]}, ${a2[4]}, ${a2[5]}, ${a2[6]}, ${a2[7]}, ${a2[8]}, ${a2[9]}, ${a2[10]}, ${a2[11]}, ${a2[12]}, ${a2[13]}, ${a2[14]}, ${a2[15]})`;
}
function frob(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8] + a2[9] * a2[9] + a2[10] * a2[10] + a2[11] * a2[11] + a2[12] * a2[12] + a2[13] * a2[13] + a2[14] * a2[14] + a2[15] * a2[15]);
}
function add3(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  out[4] = a2[4] + b2[4];
  out[5] = a2[5] + b2[5];
  out[6] = a2[6] + b2[6];
  out[7] = a2[7] + b2[7];
  out[8] = a2[8] + b2[8];
  out[9] = a2[9] + b2[9];
  out[10] = a2[10] + b2[10];
  out[11] = a2[11] + b2[11];
  out[12] = a2[12] + b2[12];
  out[13] = a2[13] + b2[13];
  out[14] = a2[14] + b2[14];
  out[15] = a2[15] + b2[15];
  return out;
}
function subtract3(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  out[4] = a2[4] - b2[4];
  out[5] = a2[5] - b2[5];
  out[6] = a2[6] - b2[6];
  out[7] = a2[7] - b2[7];
  out[8] = a2[8] - b2[8];
  out[9] = a2[9] - b2[9];
  out[10] = a2[10] - b2[10];
  out[11] = a2[11] - b2[11];
  out[12] = a2[12] - b2[12];
  out[13] = a2[13] - b2[13];
  out[14] = a2[14] - b2[14];
  out[15] = a2[15] - b2[15];
  return out;
}
function multiplyScalar(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  out[4] = a2[4] * b2;
  out[5] = a2[5] * b2;
  out[6] = a2[6] * b2;
  out[7] = a2[7] * b2;
  out[8] = a2[8] * b2;
  out[9] = a2[9] * b2;
  out[10] = a2[10] * b2;
  out[11] = a2[11] * b2;
  out[12] = a2[12] * b2;
  out[13] = a2[13] * b2;
  out[14] = a2[14] * b2;
  out[15] = a2[15] * b2;
  return out;
}
function multiplyScalarAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  out[4] = a2[4] + b2[4] * scale7;
  out[5] = a2[5] + b2[5] * scale7;
  out[6] = a2[6] + b2[6] * scale7;
  out[7] = a2[7] + b2[7] * scale7;
  out[8] = a2[8] + b2[8] * scale7;
  out[9] = a2[9] + b2[9] * scale7;
  out[10] = a2[10] + b2[10] * scale7;
  out[11] = a2[11] + b2[11] * scale7;
  out[12] = a2[12] + b2[12] * scale7;
  out[13] = a2[13] + b2[13] * scale7;
  out[14] = a2[14] + b2[14] * scale7;
  out[15] = a2[15] + b2[15] * scale7;
  return out;
}
function exactEquals3(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3] && a2[4] === b2[4] && a2[5] === b2[5] && a2[6] === b2[6] && a2[7] === b2[7] && a2[8] === b2[8] && a2[9] === b2[9] && a2[10] === b2[10] && a2[11] === b2[11] && a2[12] === b2[12] && a2[13] === b2[13] && a2[14] === b2[14] && a2[15] === b2[15];
}
function equals4(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const a4 = a2[4];
  const a5 = a2[5];
  const a6 = a2[6];
  const a7 = a2[7];
  const a8 = a2[8];
  const a9 = a2[9];
  const a10 = a2[10];
  const a11 = a2[11];
  const a12 = a2[12];
  const a13 = a2[13];
  const a14 = a2[14];
  const a15 = a2[15];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  const b4 = b2[4];
  const b5 = b2[5];
  const b6 = b2[6];
  const b7 = b2[7];
  const b8 = b2[8];
  const b9 = b2[9];
  const b10 = b2[10];
  const b11 = b2[11];
  const b12 = b2[12];
  const b13 = b2[13];
  const b14 = b2[14];
  const b15 = b2[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul3 = multiply4;
var sub3 = subtract3;

// node_modules/@math.gl/core/dist/gl-matrix/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil3,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create5,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  floor: () => floor3,
  forEach: () => forEach4,
  fromValues: () => fromValues4,
  inverse: () => inverse3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul4,
  multiply: () => multiply5,
  negate: () => negate3,
  normalize: () => normalize3,
  random: () => random3,
  round: () => round5,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set5,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength3,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat43,
  transformQuat: () => transformQuat2,
  zero: () => zero4
});
function create5() {
  const out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a2) {
  const out = new ARRAY_TYPE(4);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function fromValues4(x2, y2, z2, w3) {
  const out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w3;
  return out;
}
function copy4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function set5(out, x2, y2, z2, w3) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w3;
  return out;
}
function add4(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  return out;
}
function subtract4(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  return out;
}
function multiply5(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  out[3] = a2[3] * b2[3];
  return out;
}
function divide3(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  out[2] = a2[2] / b2[2];
  out[3] = a2[3] / b2[3];
  return out;
}
function ceil3(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  out[3] = Math.ceil(a2[3]);
  return out;
}
function floor3(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  out[3] = Math.floor(a2[3]);
  return out;
}
function min3(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  out[3] = Math.min(a2[3], b2[3]);
  return out;
}
function max3(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  out[3] = Math.max(a2[3], b2[3]);
  return out;
}
function round5(out, a2) {
  out[0] = round2(a2[0]);
  out[1] = round2(a2[1]);
  out[2] = round2(a2[2]);
  out[3] = round2(a2[3]);
  return out;
}
function scale5(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  return out;
}
function scaleAndAdd3(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  return out;
}
function distance3(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  const w3 = b2[3] - a2[3];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w3 * w3);
}
function squaredDistance3(a2, b2) {
  const x2 = b2[0] - a2[0];
  const y2 = b2[1] - a2[1];
  const z2 = b2[2] - a2[2];
  const w3 = b2[3] - a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w3 * w3;
}
function length3(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w3 = a2[3];
  return Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w3 * w3);
}
function squaredLength3(a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w3 = a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w3 * w3;
}
function negate3(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = -a2[3];
  return out;
}
function inverse3(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  out[3] = 1 / a2[3];
  return out;
}
function normalize3(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w3 = a2[3];
  let len4 = x2 * x2 + y2 * y2 + z2 * z2 + w3 * w3;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x2 * len4;
  out[1] = y2 * len4;
  out[2] = z2 * len4;
  out[3] = w3 * len4;
  return out;
}
function dot3(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2] + a2[3] * b2[3];
}
function cross3(out, u2, v2, w3) {
  const A3 = v2[0] * w3[1] - v2[1] * w3[0];
  const B3 = v2[0] * w3[2] - v2[2] * w3[0];
  const C3 = v2[0] * w3[3] - v2[3] * w3[0];
  const D3 = v2[1] * w3[2] - v2[2] * w3[1];
  const E3 = v2[1] * w3[3] - v2[3] * w3[1];
  const F2 = v2[2] * w3[3] - v2[3] * w3[2];
  const G3 = u2[0];
  const H2 = u2[1];
  const I3 = u2[2];
  const J2 = u2[3];
  out[0] = H2 * F2 - I3 * E3 + J2 * D3;
  out[1] = -(G3 * F2) + I3 * C3 - J2 * B3;
  out[2] = G3 * E3 - H2 * C3 + J2 * A3;
  out[3] = -(G3 * D3) + H2 * B3 - I3 * A3;
  return out;
}
function lerp4(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  out[0] = ax + t2 * (b2[0] - ax);
  out[1] = ay + t2 * (b2[1] - ay);
  out[2] = az + t2 * (b2[2] - az);
  out[3] = aw + t2 * (b2[3] - aw);
  return out;
}
function random3(out, scale7) {
  scale7 = scale7 === void 0 ? 1 : scale7;
  let v1;
  let v2;
  let v3;
  let v4;
  let s1;
  let s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  const d2 = Math.sqrt((1 - s1) / s2);
  out[0] = scale7 * v1;
  out[1] = scale7 * v2;
  out[2] = scale7 * v3 * d2;
  out[3] = scale7 * v4 * d2;
  return out;
}
function transformMat43(out, a2, m2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const w3 = a2[3];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12] * w3;
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13] * w3;
  out[2] = m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14] * w3;
  out[3] = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15] * w3;
  return out;
}
function transformQuat2(out, a2, q2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  const qx = q2[0];
  const qy = q2[1];
  const qz = q2[2];
  const qw = q2[3];
  const ix = qw * x2 + qy * z2 - qz * y2;
  const iy = qw * y2 + qz * x2 - qx * z2;
  const iz = qw * z2 + qx * y2 - qy * x2;
  const iw = -qx * x2 - qy * y2 - qz * z2;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a2[3];
  return out;
}
function zero4(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a2) {
  return `vec4(${a2[0]}, ${a2[1]}, ${a2[2]}, ${a2[3]})`;
}
function exactEquals4(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3];
}
function equals5(a2, b2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const b0 = b2[0];
  const b1 = b2[1];
  const b22 = b2[2];
  const b3 = b2[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply5;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var len3 = length3;
var sqrLen3 = squaredLength3;
var forEach4 = function() {
  const vec = create5();
  return function(a2, stride, offset, count2, fn, arg) {
    let i3;
    let l2;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i3 = offset; i3 < l2; i3 += stride) {
      vec[0] = a2[i3];
      vec[1] = a2[i3 + 1];
      vec[2] = a2[i3 + 2];
      vec[3] = a2[i3 + 3];
      fn(vec, vec, arg);
      a2[i3] = vec[0];
      a2[i3 + 1] = vec[1];
      a2[i3 + 2] = vec[2];
      a2[i3 + 3] = vec[3];
    }
    return a2;
  };
}();

// node_modules/@math.gl/core/dist/classes/matrix4.js
var INDICES2;
(function(INDICES3) {
  INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES2 || (INDICES2 = {}));
var DEFAULT_FOVY = 45 * Math.PI / 180;
var DEFAULT_ASPECT = 1;
var DEFAULT_NEAR = 0.1;
var DEFAULT_FAR = 500;
var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
var Matrix4 = class extends Matrix {
  static get IDENTITY() {
    return getIdentityMatrix2();
  }
  static get ZERO() {
    return getZeroMatrix2();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return INDICES2;
  }
  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }
  // eslint-disable-next-line max-params
  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(IDENTITY_MATRIX2);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(object) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(quaternion) {
    fromQuat3(this, quaternion);
    return this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(view) {
    const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    if (far === Infinity) {
      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      frustum(this, left, right, bottom, top, near, far);
    }
    return this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(view) {
    const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
    lookAt(this, eye, center, up);
    return this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(view) {
    const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(view) {
    const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
    checkRadians(fovy);
    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return this.ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(view) {
    const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
    checkRadians(fovy);
    perspective(this, fovy, aspect, near, far);
    return this.check();
  }
  // Accessors
  determinant() {
    return determinant2(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale7 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale7[0];
    const inverseScale1 = 1 / scale7[1];
    const inverseScale2 = 1 / scale7[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale7 = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale7[0];
    const inverseScale1 = 1 / scale7[1];
    const inverseScale2 = 1 / scale7[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }
  // Modifiers
  transpose() {
    transpose2(this, this);
    return this.check();
  }
  invert() {
    invert2(this, this);
    return this.check();
  }
  // Operations
  multiplyLeft(a2) {
    multiply4(this, a2, this);
    return this.check();
  }
  multiplyRight(a2) {
    multiply4(this, this, a2);
    return this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(radians2) {
    rotateX2(this, this, radians2);
    return this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(radians2) {
    rotateY2(this, this, radians2);
    return this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(radians2) {
    rotateZ2(this, this, radians2);
    return this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(angleXYZ) {
    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(radians2, axis) {
    rotate3(this, this, radians2, axis);
    return this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(factor) {
    scale4(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
    return this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(vector) {
    translate2(this, this, vector);
    return this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(vector, result) {
    if (vector.length === 4) {
      result = transformMat43(result || [-0, -0, -0, -0], vector, this);
      checkVector(result, 4);
      return result;
    }
    return this.transformAsPoint(vector, result);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(vector, result) {
    const { length: length5 } = vector;
    let out;
    switch (length5) {
      case 2:
        out = transformMat4(result || [-0, -0], vector, this);
        break;
      case 3:
        out = transformMat42(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /** @deprecated */
  transformPoint(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  /** @deprecated */
  transformVector(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  /** @deprecated */
  transformDirection(vector, result) {
    return this.transformAsVector(vector, result);
  }
  // three.js math API compatibility
  makeRotationX(radians2) {
    return this.identity().rotateX(radians2);
  }
  makeTranslation(x2, y2, z2) {
    return this.identity().translate([x2, y2, z2]);
  }
};
var ZERO3;
var IDENTITY;
function getZeroMatrix2() {
  if (!ZERO3) {
    ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO3);
  }
  return ZERO3;
}
function getIdentityMatrix2() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }
  return IDENTITY;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error("expected radians");
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}

// node_modules/@math.gl/core/dist/gl-matrix/quat.js
function create6() {
  const out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  const s2 = Math.sin(rad);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function multiply6(out, a2, b2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bx = b2[0];
  const by = b2[1];
  const bz = b2[2];
  const bw = b2[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bx = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const by = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a2, rad) {
  rad *= 0.5;
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  const bz = Math.sin(rad);
  const bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a2) {
  const x2 = a2[0];
  const y2 = a2[1];
  const z2 = a2[2];
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y2 * y2 - z2 * z2));
  return out;
}
function slerp2(out, a2, b2, t2) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const aw = a2[3];
  let bx = b2[0];
  let by = b2[1];
  let bz = b2[2];
  let bw = b2[3];
  let cosom;
  let omega;
  let scale0;
  let scale1;
  let sinom;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t2) * omega) / sinom;
    scale1 = Math.sin(t2 * omega) / sinom;
  } else {
    scale0 = 1 - t2;
    scale1 = t2;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert3(out, a2) {
  const a0 = a2[0];
  const a1 = a2[1];
  const a22 = a2[2];
  const a3 = a2[3];
  const dot5 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  const invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a2[3];
  return out;
}
function fromMat3(out, m2) {
  const fTrace = m2[0] + m2[4] + m2[8];
  let fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m2[5] - m2[7]) * fRoot;
    out[1] = (m2[6] - m2[2]) * fRoot;
    out[2] = (m2[1] - m2[3]) * fRoot;
  } else {
    let i3 = 0;
    if (m2[4] > m2[0])
      i3 = 1;
    if (m2[8] > m2[i3 * 3 + i3])
      i3 = 2;
    const j2 = (i3 + 1) % 3;
    const k2 = (i3 + 2) % 3;
    fRoot = Math.sqrt(m2[i3 * 3 + i3] - m2[j2 * 3 + j2] - m2[k2 * 3 + k2] + 1);
    out[i3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m2[j2 * 3 + k2] - m2[k2 * 3 + j2]) * fRoot;
    out[j2] = (m2[j2 * 3 + i3] + m2[i3 * 3 + j2]) * fRoot;
    out[k2] = (m2[k2 * 3 + i3] + m2[i3 * 3 + k2]) * fRoot;
  }
  return out;
}
var add5 = add4;
var scale6 = scale5;
var dot4 = dot3;
var lerp5 = lerp4;
var length4 = length3;
var squaredLength4 = squaredLength3;
var normalize4 = normalize3;
var rotationTo = function() {
  const tmpvec3 = create2();
  const xUnitVec3 = fromValues2(1, 0, 0);
  const yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a2, b2) {
    const dot5 = dot2(a2, b2);
    if (dot5 < -0.999999) {
      cross2(tmpvec3, xUnitVec3, a2);
      if (len2(tmpvec3) < 1e-6)
        cross2(tmpvec3, yUnitVec3, a2);
      normalize2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    }
    cross2(tmpvec3, a2, b2);
    out[0] = tmpvec3[0];
    out[1] = tmpvec3[1];
    out[2] = tmpvec3[2];
    out[3] = 1 + dot5;
    return normalize4(out, out);
  };
}();
var sqlerp = function() {
  const temp1 = create6();
  const temp2 = create6();
  return function(out, a2, b2, c2, d2, t2) {
    slerp2(temp1, a2, d2, t2);
    slerp2(temp2, b2, c2, t2);
    slerp2(out, temp1, temp2, 2 * t2 * (1 - t2));
    return out;
  };
}();
var setAxes = function() {
  const matr = create3();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize4(out, fromMat3(out, matr));
  };
}();

// node_modules/@math.gl/core/dist/classes/quaternion.js
var IDENTITY_QUATERNION = [0, 0, 0, 1];
var Quaternion = class extends MathArray {
  constructor(x2 = 0, y2 = 0, z2 = 0, w3 = 1) {
    super(-0, -0, -0, -0);
    if (Array.isArray(x2) && arguments.length === 1) {
      this.copy(x2);
    } else {
      this.set(x2, y2, z2, w3);
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }
  set(x2, y2, z2, w3) {
    this[0] = x2;
    this[1] = y2;
    this[2] = z2;
    this[3] = w3;
    return this.check();
  }
  fromObject(object) {
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(m2) {
    fromMat3(this, m2);
    return this.check();
  }
  fromAxisRotation(axis, rad) {
    setAxisAngle(this, axis, rad);
    return this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    identity2(this);
    return this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(axis, rad) {
    return this.fromAxisRotation(axis, rad);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = checkNumber(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = checkNumber(value);
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  get w() {
    return this[3];
  }
  set w(value) {
    this[3] = checkNumber(value);
  }
  // Calculates the length of a quat
  len() {
    return length4(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return squaredLength4(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(a2) {
    return dot4(this, a2);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(vectorA, vectorB) {
    rotationTo(this, vectorA, vectorB);
    return this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(a2) {
    add5(this, this, a2);
    return this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    calculateW(this, this);
    return this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    conjugate(this, this);
    return this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    invert3(this, this);
    return this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(a2, b2, t2) {
    if (t2 === void 0) {
      return this.lerp(this, a2, b2);
    }
    lerp5(this, a2, b2, t2);
    return this.check();
  }
  // Multiplies two quat's
  multiplyRight(a2) {
    multiply6(this, this, a2);
    return this.check();
  }
  multiplyLeft(a2) {
    multiply6(this, a2, this);
    return this.check();
  }
  // Normalize a quat
  normalize() {
    const length5 = this.len();
    const l2 = length5 > 0 ? 1 / length5 : 0;
    this[0] = this[0] * l2;
    this[1] = this[1] * l2;
    this[2] = this[2] * l2;
    this[3] = this[3] * l2;
    if (length5 === 0) {
      this[3] = 1;
    }
    return this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(rad) {
    rotateX3(this, this, rad);
    return this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(rad) {
    rotateY3(this, this, rad);
    return this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(rad) {
    rotateZ3(this, this, rad);
    return this.check();
  }
  // Scales a quat by a scalar number
  scale(b2) {
    scale6(this, this, b2);
    return this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(arg0, arg1, arg2) {
    let start;
    let target2;
    let ratio;
    switch (arguments.length) {
      case 1:
        ({
          start = IDENTITY_QUATERNION,
          target: target2,
          ratio
        } = arg0);
        break;
      case 2:
        start = this;
        target2 = arg0;
        ratio = arg1;
        break;
      default:
        start = arg0;
        target2 = arg1;
        ratio = arg2;
    }
    slerp2(this, start, target2, ratio);
    return this.check();
  }
  transformVector4(vector, result = new Vector4()) {
    transformQuat2(result, vector, this);
    return checkVector(result, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(axis, rad) {
    return this.setAxisAngle(axis, rad);
  }
  premultiply(a2) {
    return this.multiplyLeft(a2);
  }
  multiply(a2) {
    return this.multiplyRight(a2);
  }
};

// node_modules/@math.gl/core/dist/lib/math-utils.js
var math_utils_exports = {};
__export(math_utils_exports, {
  EPSILON1: () => EPSILON1,
  EPSILON10: () => EPSILON10,
  EPSILON11: () => EPSILON11,
  EPSILON12: () => EPSILON12,
  EPSILON13: () => EPSILON13,
  EPSILON14: () => EPSILON14,
  EPSILON15: () => EPSILON15,
  EPSILON16: () => EPSILON16,
  EPSILON17: () => EPSILON17,
  EPSILON18: () => EPSILON18,
  EPSILON19: () => EPSILON19,
  EPSILON2: () => EPSILON2,
  EPSILON20: () => EPSILON20,
  EPSILON3: () => EPSILON3,
  EPSILON4: () => EPSILON4,
  EPSILON5: () => EPSILON5,
  EPSILON6: () => EPSILON6,
  EPSILON7: () => EPSILON7,
  EPSILON8: () => EPSILON8,
  EPSILON9: () => EPSILON9,
  PI_OVER_FOUR: () => PI_OVER_FOUR,
  PI_OVER_SIX: () => PI_OVER_SIX,
  PI_OVER_TWO: () => PI_OVER_TWO,
  TWO_PI: () => TWO_PI
});
var EPSILON1 = 0.1;
var EPSILON2 = 0.01;
var EPSILON3 = 1e-3;
var EPSILON4 = 1e-4;
var EPSILON5 = 1e-5;
var EPSILON6 = 1e-6;
var EPSILON7 = 1e-7;
var EPSILON8 = 1e-8;
var EPSILON9 = 1e-9;
var EPSILON10 = 1e-10;
var EPSILON11 = 1e-11;
var EPSILON12 = 1e-12;
var EPSILON13 = 1e-13;
var EPSILON14 = 1e-14;
var EPSILON15 = 1e-15;
var EPSILON16 = 1e-16;
var EPSILON17 = 1e-17;
var EPSILON18 = 1e-18;
var EPSILON19 = 1e-19;
var EPSILON20 = 1e-20;
var PI_OVER_TWO = Math.PI / 2;
var PI_OVER_FOUR = Math.PI / 4;
var PI_OVER_SIX = Math.PI / 6;
var TWO_PI = Math.PI * 2;

// node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js
function fp64ify(a2, out = [], startIndex = 0) {
  const hiPart = Math.fround(a2);
  const loPart = a2 - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart(a2) {
  return a2 - Math.fround(a2);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);
  for (let i3 = 0; i3 < 4; ++i3) {
    for (let j2 = 0; j2 < 4; ++j2) {
      const index = i3 * 4 + j2;
      fp64ify(matrix[j2 * 4 + i3], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}

// node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js
var fp32shader = (
  /* glsl */
  `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
);
var fp32 = {
  name: "fp32",
  vs: fp32shader
};

// node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js
var fp64arithmeticShader = (
  /* glsl */
  `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js
var defaultUniforms = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
};
var fp64arithmetic = {
  name: "fp64arithmetic",
  vs: fp64arithmeticShader,
  defaultUniforms,
  uniformTypes: { ONE: "f32" },
  // Additional Functions
  fp64ify,
  fp64LowPart,
  fp64ifyMatrix4
};

// node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js
var DEFAULT_HIGHLIGHT_COLOR = [0, 1, 1, 1];
var vs = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
);
var fs = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
);
var picking = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: false,
    isAttribute: false,
    isHighlightActive: false,
    useFloatColors: true,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: DEFAULT_HIGHLIGHT_COLOR
  },
  vs,
  fs,
  getUniforms
};
function getUniforms(opts = {}, prevUniforms) {
  const uniforms = {};
  if (opts.highlightedObjectColor === void 0) {
  } else if (opts.highlightedObjectColor === null) {
    uniforms.isHighlightActive = false;
  } else {
    uniforms.isHighlightActive = true;
    const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
    uniforms.highlightedObjectColor = highlightedObjectColor;
  }
  if (opts.highlightColor) {
    const color = Array.from(opts.highlightColor, (x2) => x2 / 255);
    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }
    uniforms.highlightColor = color;
  }
  if (opts.isActive !== void 0) {
    uniforms.isActive = Boolean(opts.isActive);
    uniforms.isAttribute = Boolean(opts.isAttribute);
  }
  if (opts.useFloatColors !== void 0) {
    uniforms.useFloatColors = Boolean(opts.useFloatColors);
  }
  return uniforms;
}

// node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js
var lightingUniformsGLSL = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js
var lightingUniformsWGSL = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js
var MAX_LIGHTS = 3;
var COLOR_FACTOR = 255;
var LIGHT_TYPE;
(function(LIGHT_TYPE2) {
  LIGHT_TYPE2[LIGHT_TYPE2["POINT"] = 0] = "POINT";
  LIGHT_TYPE2[LIGHT_TYPE2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
})(LIGHT_TYPE || (LIGHT_TYPE = {}));
var lighting = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    MAX_LIGHTS
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientLightColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: LIGHT_TYPE.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientLightColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: lightingUniformsWGSL,
  vs: lightingUniformsGLSL,
  fs: lightingUniformsGLSL,
  getUniforms: getUniforms2
};
function getUniforms2(props, prevUniforms = {}) {
  props = props ? { ...props } : props;
  if (!props) {
    return { ...lighting.defaultUniforms };
  }
  if (props.lights) {
    props = { ...props, ...extractLightTypes(props.lights), lights: void 0 };
  }
  const { ambientLight, pointLights, directionalLights } = props || {};
  const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
  if (!hasLights) {
    return { ...lighting.defaultUniforms, enabled: 0 };
  }
  const uniforms = {
    ...lighting.defaultUniforms,
    ...prevUniforms,
    ...getLightSourceUniforms({ ambientLight, pointLights, directionalLights })
  };
  if (props.enabled !== void 0) {
    uniforms.enabled = props.enabled ? 1 : 0;
  }
  return uniforms;
}
function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
  const lightSourceUniforms = {};
  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);
  let currentLight = 0;
  for (const pointLight of pointLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
    const i3 = currentLight;
    lightSourceUniforms[`lightColor${i3}`] = convertColor(pointLight);
    lightSourceUniforms[`lightPosition${i3}`] = pointLight.position;
    lightSourceUniforms[`lightAttenuation${i3}`] = pointLight.attenuation || [1, 0, 0];
    currentLight++;
  }
  for (const directionalLight of directionalLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
    const i3 = currentLight;
    lightSourceUniforms[`lightColor${i3}`] = convertColor(directionalLight);
    lightSourceUniforms[`lightDirection${i3}`] = directionalLight.direction;
    currentLight++;
  }
  if (currentLight > MAX_LIGHTS) {
    log2.warn("MAX_LIGHTS exceeded")();
  }
  lightSourceUniforms.directionalLightCount = directionalLights.length;
  lightSourceUniforms.pointLightCount = pointLights.length;
  return lightSourceUniforms;
}
function extractLightTypes(lights) {
  const lightSources = { pointLights: [], directionalLights: [] };
  for (const light of lights || []) {
    switch (light.type) {
      case "ambient":
        lightSources.ambientLight = light;
        break;
      case "directional":
        lightSources.directionalLights?.push(light);
        break;
      case "point":
        lightSources.pointLights?.push(light);
        break;
      default:
    }
  }
  return lightSources;
}
function convertColor(colorDef = {}) {
  const { color = [0, 0, 0], intensity = 1 } = colorDef;
  return color.map((component) => component * intensity / COLOR_FACTOR);
}

// node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js
var PHONG_VS = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
);
var PHONG_FS = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js
var PHONG_WGSL = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
);

// node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js
var gouraudMaterial = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: PHONG_FS.replace("phongMaterial", "gouraudMaterial"),
  fs: PHONG_VS.replace("phongMaterial", "gouraudMaterial"),
  source: PHONG_WGSL.replaceAll("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: 1
  },
  dependencies: [lighting],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(props) {
    const uniforms = { ...props };
    if (uniforms.specularColor) {
      uniforms.specularColor = uniforms.specularColor.map((x2) => x2 / 255);
    }
    return { ...gouraudMaterial.defaultUniforms, ...uniforms };
  }
};

// node_modules/@deck.gl/core/dist/shaderlib/misc/layer-uniforms.js
var uniformBlock = `uniform layerUniforms {
  uniform float opacity;
} layer;
`;
var layerUniforms = {
  name: "layer",
  vs: uniformBlock,
  fs: uniformBlock,
  getUniforms: (props) => {
    return {
      // apply gamma to opacity to make it visually "linear"
      // TODO - v10: use raw opacity?
      opacity: Math.pow(props.opacity, 1 / 2.2)
    };
  },
  uniformTypes: {
    opacity: "f32"
  }
};

// node_modules/@deck.gl/core/dist/shaderlib/misc/geometry.js
var source = (
  /* wgsl */
  `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
);
var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
var vs2 = (
  /* glsl */
  `${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`
);
var fs2 = (
  /* glsl */
  `${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
);
var geometry_default = {
  name: "geometry",
  source,
  vs: vs2,
  fs: fs2
};

// node_modules/mjolnir.js/dist/hammerjs/input/input-consts.js
var COMPUTE_INTERVAL = 25;
var InputEvent;
(function(InputEvent2) {
  InputEvent2[InputEvent2["Start"] = 1] = "Start";
  InputEvent2[InputEvent2["Move"] = 2] = "Move";
  InputEvent2[InputEvent2["End"] = 4] = "End";
  InputEvent2[InputEvent2["Cancel"] = 8] = "Cancel";
})(InputEvent || (InputEvent = {}));
var InputDirection;
(function(InputDirection2) {
  InputDirection2[InputDirection2["None"] = 0] = "None";
  InputDirection2[InputDirection2["Left"] = 1] = "Left";
  InputDirection2[InputDirection2["Right"] = 2] = "Right";
  InputDirection2[InputDirection2["Up"] = 4] = "Up";
  InputDirection2[InputDirection2["Down"] = 8] = "Down";
  InputDirection2[InputDirection2["Horizontal"] = 3] = "Horizontal";
  InputDirection2[InputDirection2["Vertical"] = 12] = "Vertical";
  InputDirection2[InputDirection2["All"] = 15] = "All";
})(InputDirection || (InputDirection = {}));

// node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer-state.js
var RecognizerState;
(function(RecognizerState2) {
  RecognizerState2[RecognizerState2["Possible"] = 1] = "Possible";
  RecognizerState2[RecognizerState2["Began"] = 2] = "Began";
  RecognizerState2[RecognizerState2["Changed"] = 4] = "Changed";
  RecognizerState2[RecognizerState2["Ended"] = 8] = "Ended";
  RecognizerState2[RecognizerState2["Recognized"] = 8] = "Recognized";
  RecognizerState2[RecognizerState2["Cancelled"] = 16] = "Cancelled";
  RecognizerState2[RecognizerState2["Failed"] = 32] = "Failed";
})(RecognizerState || (RecognizerState = {}));

// node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction-Consts.js
var TOUCH_ACTION_COMPUTE = "compute";
var TOUCH_ACTION_AUTO = "auto";
var TOUCH_ACTION_MANIPULATION = "manipulation";
var TOUCH_ACTION_NONE = "none";
var TOUCH_ACTION_PAN_X = "pan-x";
var TOUCH_ACTION_PAN_Y = "pan-y";

// node_modules/mjolnir.js/dist/hammerjs/touchaction/clean-touch-actions.js
function cleanTouchActions(actions) {
  if (actions.includes(TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }
  const hasPanX = actions.includes(TOUCH_ACTION_PAN_X);
  const hasPanY = actions.includes(TOUCH_ACTION_PAN_Y);
  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  }
  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  }
  if (actions.includes(TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }
  return TOUCH_ACTION_AUTO;
}

// node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction.js
var TouchAction = class {
  constructor(manager, value) {
    this.actions = "";
    this.manager = manager;
    this.set(value);
  }
  /**
   * set the touchAction value on the element or enable the polyfill
   */
  set(value) {
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }
    if (this.manager.element) {
      this.manager.element.style.touchAction = value;
      this.actions = value;
    }
  }
  /**
   * just re-set the touchAction value
   */
  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * compute the value for the touchAction property based on the recognizer's settings
   */
  compute() {
    let actions = [];
    for (const recognizer of this.manager.recognizers) {
      if (recognizer.options.enable) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    }
    return cleanTouchActions(actions.join(" "));
  }
};

// node_modules/mjolnir.js/dist/hammerjs/utils/split-str.js
function splitStr(str5) {
  return str5.trim().split(/\s+/g);
}

// node_modules/mjolnir.js/dist/hammerjs/utils/event-listeners.js
function addEventListeners(target2, types, handler) {
  if (!target2) {
    return;
  }
  for (const type of splitStr(types)) {
    target2.addEventListener(type, handler, false);
  }
}
function removeEventListeners(target2, types, handler) {
  if (!target2) {
    return;
  }
  for (const type of splitStr(types)) {
    target2.removeEventListener(type, handler, false);
  }
}

// node_modules/mjolnir.js/dist/hammerjs/utils/get-window-for-element.js
function getWindowForElement(element) {
  const doc = element.ownerDocument || element;
  return doc.defaultView;
}

// node_modules/mjolnir.js/dist/hammerjs/utils/has-parent.js
function hasParent(node, parent) {
  let ancestor = node;
  while (ancestor) {
    if (ancestor === parent) {
      return true;
    }
    ancestor = ancestor.parentNode;
  }
  return false;
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-center.js
function getCenter(pointers) {
  const pointersLength = pointers.length;
  if (pointersLength === 1) {
    return {
      x: Math.round(pointers[0].clientX),
      y: Math.round(pointers[0].clientY)
    };
  }
  let x2 = 0;
  let y2 = 0;
  let i3 = 0;
  while (i3 < pointersLength) {
    x2 += pointers[i3].clientX;
    y2 += pointers[i3].clientY;
    i3++;
  }
  return {
    x: Math.round(x2 / pointersLength),
    y: Math.round(y2 / pointersLength)
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/simple-clone-input-data.js
function simpleCloneInputData(input) {
  const pointers = [];
  let i3 = 0;
  while (i3 < input.pointers.length) {
    pointers[i3] = {
      clientX: Math.round(input.pointers[i3].clientX),
      clientY: Math.round(input.pointers[i3].clientY)
    };
    i3++;
  }
  return {
    timeStamp: Date.now(),
    pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-distance.js
function getPointDistance(p1, p2) {
  const x2 = p2.x - p1.x;
  const y2 = p2.y - p1.y;
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function getEventDistance(p1, p2) {
  const x2 = p2.clientX - p1.clientX;
  const y2 = p2.clientY - p1.clientY;
  return Math.sqrt(x2 * x2 + y2 * y2);
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-angle.js
function getPointAngle(p1, p2) {
  const x2 = p2.x - p1.x;
  const y2 = p2.y - p1.y;
  return Math.atan2(y2, x2) * 180 / Math.PI;
}
function getEventAngle(p1, p2) {
  const x2 = p2.clientX - p1.clientX;
  const y2 = p2.clientY - p1.clientY;
  return Math.atan2(y2, x2) * 180 / Math.PI;
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-direction.js
function getDirection(dx, dy) {
  if (dx === dy) {
    return InputDirection.None;
  }
  if (Math.abs(dx) >= Math.abs(dy)) {
    return dx < 0 ? InputDirection.Left : InputDirection.Right;
  }
  return dy < 0 ? InputDirection.Up : InputDirection.Down;
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-delta-xy.js
function computeDeltaXY(session, input) {
  const center = input.center;
  let offset = session.offsetDelta;
  let prevDelta = session.prevDelta;
  const prevInput = session.prevInput;
  if (input.eventType === InputEvent.Start || prevInput?.eventType === InputEvent.End) {
    prevDelta = session.prevDelta = {
      x: prevInput?.deltaX || 0,
      y: prevInput?.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }
  return {
    deltaX: prevDelta.x + (center.x - offset.x),
    deltaY: prevDelta.y + (center.y - offset.y)
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-velocity.js
function getVelocity(deltaTime, x2, y2) {
  return {
    x: x2 / deltaTime || 0,
    y: y2 / deltaTime || 0
  };
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-scale.js
function getScale(start, end) {
  return getEventDistance(end[0], end[1]) / getEventDistance(start[0], start[1]);
}

// node_modules/mjolnir.js/dist/hammerjs/input/get-rotation.js
function getRotation2(start, end) {
  return getEventAngle(end[1], end[0]) - getEventAngle(start[1], start[0]);
}

// node_modules/mjolnir.js/dist/hammerjs/input/compute-interval-input-data.js
function computeIntervalInputData(session, input) {
  const last = session.lastInterval || input;
  const deltaTime = input.timeStamp - last.timeStamp;
  let velocity;
  let velocityX;
  let velocityY;
  let direction;
  if (input.eventType !== InputEvent.Cancel && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {
    const deltaX = input.deltaX - last.deltaX;
    const deltaY = input.deltaY - last.deltaY;
    const v2 = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v2.x;
    velocityY = v2.y;
    velocity = Math.abs(v2.x) > Math.abs(v2.y) ? v2.x : v2.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }
  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}

// node_modules/mjolnir.js/dist/hammerjs/input/compute-input-data.js
function computeInputData(manager, input) {
  const { session } = manager;
  const { pointers } = input;
  const { length: pointersLength } = pointers;
  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  }
  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }
  const { firstInput, firstMultiple } = session;
  const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  const center = input.center = getCenter(pointers);
  input.timeStamp = Date.now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getPointAngle(offsetCenter, center);
  input.distance = getPointDistance(offsetCenter, center);
  const { deltaX, deltaY } = computeDeltaXY(session, input);
  input.deltaX = deltaX;
  input.deltaY = deltaY;
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation2(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  let target2 = manager.element;
  if (hasParent(input.srcEvent.target, target2)) {
    target2 = input.srcEvent.target;
  }
  input.target = target2;
  computeIntervalInputData(session, input);
  return input;
}

// node_modules/mjolnir.js/dist/hammerjs/input/input-handler.js
function inputHandler(manager, eventType, input) {
  const pointersLen = input.pointers.length;
  const changedPointersLen = input.changedPointers.length;
  const isFirst = eventType & InputEvent.Start && pointersLen - changedPointersLen === 0;
  const isFinal = eventType & (InputEvent.End | InputEvent.Cancel) && pointersLen - changedPointersLen === 0;
  input.isFirst = Boolean(isFirst);
  input.isFinal = Boolean(isFinal);
  if (isFirst) {
    manager.session = {};
  }
  input.eventType = eventType;
  const processedInput = computeInputData(manager, input);
  manager.emit("hammer.input", processedInput);
  manager.recognize(processedInput);
  manager.session.prevInput = processedInput;
}

// node_modules/mjolnir.js/dist/hammerjs/input/input.js
var Input = class {
  constructor(manager) {
    this.evEl = "";
    this.evWin = "";
    this.evTarget = "";
    this.domHandler = (ev) => {
      if (this.manager.options.enable) {
        this.handler(ev);
      }
    };
    this.manager = manager;
    this.element = manager.element;
    this.target = manager.options.inputTarget || manager.element;
  }
  callback(eventType, input) {
    inputHandler(this.manager, eventType, input);
  }
  // eslint-disable @typescript-eslint/unbound-method
  /**
   * bind the events
   */
  init() {
    addEventListeners(this.element, this.evEl, this.domHandler);
    addEventListeners(this.target, this.evTarget, this.domHandler);
    addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  }
  /**
   * unbind the events
   */
  destroy() {
    removeEventListeners(this.element, this.evEl, this.domHandler);
    removeEventListeners(this.target, this.evTarget, this.domHandler);
    removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  }
};

// node_modules/mjolnir.js/dist/hammerjs/inputs/pointerevent.js
var POINTER_INPUT_MAP = {
  pointerdown: InputEvent.Start,
  pointermove: InputEvent.Move,
  pointerup: InputEvent.End,
  pointercancel: InputEvent.Cancel,
  pointerout: InputEvent.Cancel
};
var POINTER_ELEMENT_EVENTS = "pointerdown";
var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
var PointerEventInput = class extends Input {
  constructor(manager) {
    super(manager);
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    this.store = this.manager.session.pointerEvents = [];
    this.init();
  }
  /**
   * handle mouse events
   */
  handler(ev) {
    const { store } = this;
    let removePointer = false;
    const eventType = POINTER_INPUT_MAP[ev.type];
    const pointerType = ev.pointerType;
    const isTouch = pointerType === "touch";
    let storeIndex = store.findIndex((e2) => e2.pointerId === ev.pointerId);
    if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {
      if (storeIndex < 0) {
        store.push(ev);
        storeIndex = store.length - 1;
      }
    } else if (eventType & (InputEvent.End | InputEvent.Cancel)) {
      removePointer = true;
    }
    if (storeIndex < 0) {
      return;
    }
    store[storeIndex] = ev;
    this.callback(eventType, {
      pointers: store,
      changedPointers: [ev],
      eventType,
      pointerType,
      srcEvent: ev
    });
    if (removePointer) {
      store.splice(storeIndex, 1);
    }
  }
};

// node_modules/mjolnir.js/dist/hammerjs/utils/prefixed.js
var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
function prefixed(obj, property) {
  const camelProp = property[0].toUpperCase() + property.slice(1);
  for (const prefix of VENDOR_PREFIXES) {
    const prop = prefix ? prefix + camelProp : property;
    if (prop in obj) {
      return prop;
    }
  }
  return void 0;
}

// node_modules/mjolnir.js/dist/hammerjs/manager.js
var STOP = 1;
var FORCED_STOP = 2;
var defaultOptions = {
  touchAction: "compute",
  enable: true,
  inputTarget: null,
  cssProps: {
    /**
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     */
    userSelect: "none",
    /**
     * (Webkit) Disable default dragging behavior
     */
    // @ts-ignore
    userDrag: "none",
    /**
     * (iOS only) Disables the default callout shown when you touch and hold a touch target.
     * When you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     */
    // @ts-ignore
    touchCallout: "none",
    /**
     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
     */
    // @ts-ignore
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
var Manager = class {
  constructor(element, options) {
    this.options = {
      ...defaultOptions,
      ...options,
      cssProps: { ...defaultOptions.cssProps, ...options.cssProps },
      inputTarget: options.inputTarget || element
    };
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = new PointerEventInput(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    this.toggleCssProps(true);
  }
  /**
   * set options
   */
  set(options) {
    Object.assign(this.options, options);
    if (options.touchAction) {
      this.touchAction.update();
    }
    if (options.inputTarget) {
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }
    return this;
  }
  /**
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   */
  stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  }
  /**
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   */
  recognize(inputData) {
    const { session } = this;
    if (session.stopped) {
      return;
    }
    if (this.session.prevented) {
      inputData.srcEvent.preventDefault();
    }
    let recognizer;
    const { recognizers } = this;
    let { curRecognizer } = session;
    if (!curRecognizer || curRecognizer && curRecognizer.state & RecognizerState.Recognized) {
      curRecognizer = session.curRecognizer = null;
    }
    let i3 = 0;
    while (i3 < recognizers.length) {
      recognizer = recognizers[i3];
      if (session.stopped !== FORCED_STOP && // 1
      (!curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      }
      if (!curRecognizer && recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)) {
        curRecognizer = session.curRecognizer = recognizer;
      }
      i3++;
    }
  }
  /**
   * get a recognizer by its event name.
   */
  get(recognizerName) {
    const { recognizers } = this;
    for (let i3 = 0; i3 < recognizers.length; i3++) {
      if (recognizers[i3].options.event === recognizerName) {
        return recognizers[i3];
      }
    }
    return null;
  }
  /**
   * add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   */
  add(recognizer) {
    if (Array.isArray(recognizer)) {
      for (const item of recognizer) {
        this.add(item);
      }
      return this;
    }
    const existing = this.get(recognizer.options.event);
    if (existing) {
      this.remove(existing);
    }
    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  }
  /**
   * remove a recognizer by name or instance
   */
  remove(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.remove(item);
      }
      return this;
    }
    const recognizer = typeof recognizerOrName === "string" ? this.get(recognizerOrName) : recognizerOrName;
    if (recognizer) {
      const { recognizers } = this;
      const index = recognizers.indexOf(recognizer);
      if (index !== -1) {
        recognizers.splice(index, 1);
        this.touchAction.update();
      }
    }
    return this;
  }
  /**
   * bind event
   */
  on(events, handler) {
    if (!events || !handler) {
      return;
    }
    const { handlers } = this;
    for (const event of splitStr(events)) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    }
  }
  /**
   * unbind event, leave hander blank to remove all handlers
   */
  off(events, handler) {
    if (!events) {
      return;
    }
    const { handlers } = this;
    for (const event of splitStr(events)) {
      if (!handler) {
        delete handlers[event];
      } else if (handlers[event]) {
        handlers[event].splice(handlers[event].indexOf(handler), 1);
      }
    }
  }
  /**
   * emit event to the listeners
   */
  emit(event, data) {
    const handlers = this.handlers[event] && this.handlers[event].slice();
    if (!handlers || !handlers.length) {
      return;
    }
    const evt = data;
    evt.type = event;
    evt.preventDefault = function() {
      data.srcEvent.preventDefault();
    };
    let i3 = 0;
    while (i3 < handlers.length) {
      handlers[i3](evt);
      i3++;
    }
  }
  /**
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */
  destroy() {
    this.toggleCssProps(false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  }
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   */
  toggleCssProps(add7) {
    const { element } = this;
    if (!element) {
      return;
    }
    for (const [name2, value] of Object.entries(this.options.cssProps)) {
      const prop = prefixed(element.style, name2);
      if (add7) {
        this.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = this.oldCssProps[prop] || "";
      }
    }
    if (!add7) {
      this.oldCssProps = {};
    }
  }
};

// node_modules/mjolnir.js/dist/hammerjs/utils/unique-id.js
var _uniqueId = 1;
function uniqueId() {
  return _uniqueId++;
}

// node_modules/mjolnir.js/dist/hammerjs/recognizer/state-str.js
function stateStr(state) {
  if (state & RecognizerState.Cancelled) {
    return "cancel";
  } else if (state & RecognizerState.Ended) {
    return "end";
  } else if (state & RecognizerState.Changed) {
    return "move";
  } else if (state & RecognizerState.Began) {
    return "start";
  }
  return "";
}

// node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer.js
var Recognizer = class {
  constructor(options) {
    this.options = options;
    this.id = uniqueId();
    this.state = RecognizerState.Possible;
    this.simultaneous = {};
    this.requireFail = [];
  }
  /**
   * set options
   */
  set(options) {
    Object.assign(this.options, options);
    this.manager.touchAction.update();
    return this;
  }
  /**
   * recognize simultaneous with an other recognizer.
   */
  recognizeWith(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.recognizeWith(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
      if (!otherRecognizer) {
        throw new Error(`Cannot find recognizer ${recognizerOrName}`);
      }
    } else {
      otherRecognizer = recognizerOrName;
    }
    const { simultaneous } = this;
    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }
    return this;
  }
  /**
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   */
  dropRecognizeWith(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.dropRecognizeWith(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
    } else {
      otherRecognizer = recognizerOrName;
    }
    if (otherRecognizer) {
      delete this.simultaneous[otherRecognizer.id];
    }
    return this;
  }
  /**
   * recognizer can only run when an other is failing
   */
  requireFailure(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.requireFailure(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
      if (!otherRecognizer) {
        throw new Error(`Cannot find recognizer ${recognizerOrName}`);
      }
    } else {
      otherRecognizer = recognizerOrName;
    }
    const { requireFail } = this;
    if (requireFail.indexOf(otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }
    return this;
  }
  /**
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   */
  dropRequireFailure(recognizerOrName) {
    if (Array.isArray(recognizerOrName)) {
      for (const item of recognizerOrName) {
        this.dropRequireFailure(item);
      }
      return this;
    }
    let otherRecognizer;
    if (typeof recognizerOrName === "string") {
      otherRecognizer = this.manager.get(recognizerOrName);
    } else {
      otherRecognizer = recognizerOrName;
    }
    if (otherRecognizer) {
      const index = this.requireFail.indexOf(otherRecognizer);
      if (index > -1) {
        this.requireFail.splice(index, 1);
      }
    }
    return this;
  }
  /**
   * has require failures boolean
   */
  hasRequireFailures() {
    return Boolean(this.requireFail.find((recognier) => recognier.options.enable));
  }
  /**
   * if the recognizer can recognize simultaneous with an other recognizer
   */
  canRecognizeWith(otherRecognizer) {
    return Boolean(this.simultaneous[otherRecognizer.id]);
  }
  /**
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   */
  emit(input) {
    if (!input)
      return;
    const { state } = this;
    if (state < RecognizerState.Ended) {
      this.manager.emit(this.options.event + stateStr(state), input);
    }
    this.manager.emit(this.options.event, input);
    if (input.additionalEvent) {
      this.manager.emit(input.additionalEvent, input);
    }
    if (state >= RecognizerState.Ended) {
      this.manager.emit(this.options.event + stateStr(state), input);
    }
  }
  /**
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   */
  tryEmit(input) {
    if (this.canEmit()) {
      this.emit(input);
    } else {
      this.state = RecognizerState.Failed;
    }
  }
  /**
   * can we emit?
   */
  canEmit() {
    let i3 = 0;
    while (i3 < this.requireFail.length) {
      if (!(this.requireFail[i3].state & (RecognizerState.Failed | RecognizerState.Possible))) {
        return false;
      }
      i3++;
    }
    return true;
  }
  /**
   * update the recognizer
   */
  recognize(inputData) {
    const inputDataClone = { ...inputData };
    if (!this.options.enable) {
      this.reset();
      this.state = RecognizerState.Failed;
      return;
    }
    if (this.state & (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)) {
      this.state = RecognizerState.Possible;
    }
    this.state = this.process(inputDataClone);
    if (this.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended | RecognizerState.Cancelled)) {
      this.tryEmit(inputDataClone);
    }
  }
  /**
   * return the event names that are emitted by this recognizer
   */
  getEventNames() {
    return [this.options.event];
  }
  /**
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   */
  reset() {
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/attribute.js
var AttrRecognizer = class extends Recognizer {
  /**
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   */
  attrTest(input) {
    const optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  }
  /**
   * Process the input and return the state for the recognizer
   */
  process(input) {
    const { state } = this;
    const { eventType } = input;
    const isRecognized = state & (RecognizerState.Began | RecognizerState.Changed);
    const isValid2 = this.attrTest(input);
    if (isRecognized && (eventType & InputEvent.Cancel || !isValid2)) {
      return state | RecognizerState.Cancelled;
    } else if (isRecognized || isValid2) {
      if (eventType & InputEvent.End) {
        return state | RecognizerState.Ended;
      } else if (!(state & RecognizerState.Began)) {
        return RecognizerState.Began;
      }
      return state | RecognizerState.Changed;
    }
    return RecognizerState.Failed;
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/tap.js
var TapRecognizer = class extends Recognizer {
  constructor(options = {}) {
    super({
      enable: true,
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10,
      ...options
    });
    this.pTime = null;
    this.pCenter = null;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }
  getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  }
  process(input) {
    const { options } = this;
    const validPointers = input.pointers.length === options.pointers;
    const validMovement = input.distance < options.threshold;
    const validTouchTime = input.deltaTime < options.time;
    this.reset();
    if (input.eventType & InputEvent.Start && this.count === 0) {
      return this.failTimeout();
    }
    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== InputEvent.End) {
        return this.failTimeout();
      }
      const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      const validMultiTap = !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;
      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }
      this._input = input;
      const tapCount = this.count % options.taps;
      if (tapCount === 0) {
        if (!this.hasRequireFailures()) {
          return RecognizerState.Recognized;
        }
        this._timer = setTimeout(() => {
          this.state = RecognizerState.Recognized;
          this.tryEmit(this._input);
        }, options.interval);
        return RecognizerState.Began;
      }
    }
    return RecognizerState.Failed;
  }
  failTimeout() {
    this._timer = setTimeout(() => {
      this.state = RecognizerState.Failed;
    }, this.options.interval);
    return RecognizerState.Failed;
  }
  reset() {
    clearTimeout(this._timer);
  }
  emit(input) {
    if (this.state === RecognizerState.Recognized) {
      input.tapCount = this.count;
      this.manager.emit(this.options.event, input);
    }
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/pan.js
var EVENT_NAMES = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
var PanRecognizer = class extends AttrRecognizer {
  constructor(options = {}) {
    super({
      enable: true,
      pointers: 1,
      event: "pan",
      threshold: 10,
      direction: InputDirection.All,
      ...options
    });
    this.pX = null;
    this.pY = null;
  }
  getTouchAction() {
    const { options: { direction } } = this;
    const actions = [];
    if (direction & InputDirection.Horizontal) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }
    if (direction & InputDirection.Vertical) {
      actions.push(TOUCH_ACTION_PAN_X);
    }
    return actions;
  }
  getEventNames() {
    return EVENT_NAMES.map((suffix) => this.options.event + suffix);
  }
  directionTest(input) {
    const { options } = this;
    let hasMoved = true;
    let { distance: distance5 } = input;
    let { direction } = input;
    const x2 = input.deltaX;
    const y2 = input.deltaY;
    if (!(direction & options.direction)) {
      if (options.direction & InputDirection.Horizontal) {
        direction = x2 === 0 ? InputDirection.None : x2 < 0 ? InputDirection.Left : InputDirection.Right;
        hasMoved = x2 !== this.pX;
        distance5 = Math.abs(input.deltaX);
      } else {
        direction = y2 === 0 ? InputDirection.None : y2 < 0 ? InputDirection.Up : InputDirection.Down;
        hasMoved = y2 !== this.pY;
        distance5 = Math.abs(input.deltaY);
      }
    }
    input.direction = direction;
    return hasMoved && distance5 > options.threshold && Boolean(direction & options.direction);
  }
  attrTest(input) {
    return super.attrTest(input) && (Boolean(this.state & RecognizerState.Began) || !(this.state & RecognizerState.Began) && this.directionTest(input));
  }
  emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    const direction = InputDirection[input.direction].toLowerCase();
    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }
    super.emit(input);
  }
};

// node_modules/mjolnir.js/dist/hammerjs/recognizers/pinch.js
var EVENT_NAMES2 = ["", "start", "move", "end", "cancel", "in", "out"];
var PinchRecognizer = class extends AttrRecognizer {
  constructor(options = {}) {
    super({
      enable: true,
      event: "pinch",
      threshold: 0,
      pointers: 2,
      ...options
    });
  }
  getTouchAction() {
    return [TOUCH_ACTION_NONE];
  }
  getEventNames() {
    return EVENT_NAMES2.map((suffix) => this.options.event + suffix);
  }
  attrTest(input) {
    return super.attrTest(input) && (Math.abs(input.scale - 1) > this.options.threshold || Boolean(this.state & RecognizerState.Began));
  }
  emit(input) {
    if (input.scale !== 1) {
      const inOut = input.scale < 1 ? "in" : "out";
      input.additionalEvent = this.options.event + inOut;
    }
    super.emit(input);
  }
};

// node_modules/mjolnir.js/dist/inputs/input.js
var Input2 = class {
  constructor(element, callback, options) {
    this.element = element;
    this.callback = callback;
    this.options = options;
  }
};

// node_modules/mjolnir.js/dist/utils/globals.js
var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
var window_4 = typeof window !== "undefined" ? window : global;

// node_modules/mjolnir.js/dist/inputs/wheel-input.js
var firefox = userAgent.indexOf("firefox") !== -1;
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var SHIFT_MULTIPLIER = 0.25;
var WheelInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, { enable: true, ...options });
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      let value = event.deltaY;
      if (globalThis.WheelEvent) {
        if (firefox && event.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL) {
          value /= globalThis.devicePixelRatio;
        }
        if (event.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }
      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }
      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }
      this.callback({
        type: "wheel",
        center: {
          x: event.clientX,
          y: event.clientY
        },
        delta: -value,
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    element.addEventListener("wheel", this.handleEvent, { passive: false });
  }
  destroy() {
    this.element.removeEventListener("wheel", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === "wheel") {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/inputs/move-input.js
var MOUSE_EVENTS = [
  "mousedown",
  "mousemove",
  "mouseup",
  "mouseover",
  "mouseout",
  "mouseleave"
];
var MoveInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, { enable: true, ...options });
    this.handleEvent = (event) => {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleEnterEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    };
    this.pressed = false;
    const { enable: enable2 } = this.options;
    this.enableMoveEvent = enable2;
    this.enableLeaveEvent = enable2;
    this.enableEnterEvent = enable2;
    this.enableOutEvent = enable2;
    this.enableOverEvent = enable2;
    MOUSE_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    MOUSE_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    switch (eventType) {
      case "pointermove":
        this.enableMoveEvent = enabled;
        break;
      case "pointerover":
        this.enableOverEvent = enabled;
        break;
      case "pointerout":
        this.enableOutEvent = enabled;
        break;
      case "pointerenter":
        this.enableEnterEvent = enabled;
        break;
      case "pointerleave":
        this.enableLeaveEvent = enabled;
        break;
      default:
    }
  }
  handleOverEvent(event) {
    if (this.enableOverEvent && event.type === "mouseover") {
      this._emit("pointerover", event);
    }
  }
  handleOutEvent(event) {
    if (this.enableOutEvent && event.type === "mouseout") {
      this._emit("pointerout", event);
    }
  }
  handleEnterEvent(event) {
    if (this.enableEnterEvent && event.type === "mouseenter") {
      this._emit("pointerenter", event);
    }
  }
  handleLeaveEvent(event) {
    if (this.enableLeaveEvent && event.type === "mouseleave") {
      this._emit("pointerleave", event);
    }
  }
  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case "mousedown":
          if (event.button >= 0) {
            this.pressed = true;
          }
          break;
        case "mousemove":
          if (event.buttons === 0) {
            this.pressed = false;
          }
          if (!this.pressed) {
            this._emit("pointermove", event);
          }
          break;
        case "mouseup":
          this.pressed = false;
          break;
        default:
      }
    }
  }
  _emit(type, event) {
    this.callback({
      type,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: "mouse",
      target: event.target
    });
  }
};

// node_modules/mjolnir.js/dist/inputs/key-input.js
var KEY_EVENTS = ["keydown", "keyup"];
var KeyInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, { enable: true, tabIndex: 0, ...options });
    this.handleEvent = (event) => {
      const targetElement = event.target || event.srcElement;
      if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
        return;
      }
      if (this.enableDownEvent && event.type === "keydown") {
        this.callback({
          type: "keydown",
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
      if (this.enableUpEvent && event.type === "keyup") {
        this.callback({
          type: "keyup",
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    };
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    element.tabIndex = this.options.tabIndex;
    element.style.outline = "none";
    KEY_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    KEY_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === "keydown") {
      this.enableDownEvent = enabled;
    }
    if (eventType === "keyup") {
      this.enableUpEvent = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/inputs/contextmenu-input.js
var ContextmenuInput = class extends Input2 {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = (event) => {
      if (!this.options.enable) {
        return;
      }
      this.callback({
        type: "contextmenu",
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    };
    element.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === "contextmenu") {
      this.options.enable = enabled;
    }
  }
};

// node_modules/mjolnir.js/dist/utils/event-utils.js
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS2 = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2;
var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
function whichButtons(event) {
  const eventType = MOUSE_EVENTS2[event.srcEvent.type];
  if (!eventType) {
    return null;
  }
  const { buttons, button } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return { leftButton, middleButton, rightButton };
}
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  if (!center) {
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  const scaleX2 = rect.width / rootElement.offsetWidth || 1;
  const scaleY2 = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY2
  };
  return { center, offsetCenter };
}

// node_modules/mjolnir.js/dist/utils/event-registrar.js
var DEFAULT_OPTIONS = {
  srcElement: "root",
  priority: 0
};
var EventRegistrar = class {
  constructor(eventManager, recognizerName) {
    this.handleEvent = (event) => {
      if (this.isEmpty()) {
        return;
      }
      const mjolnirEvent = this._normalizeEvent(event);
      let target2 = event.srcEvent.target;
      while (target2 && target2 !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target2);
        if (mjolnirEvent.handled) {
          return;
        }
        target2 = target2.parentNode;
      }
      this._emit(mjolnirEvent, "root");
    };
    this.eventManager = eventManager;
    this.recognizerName = recognizerName;
    this.handlers = [];
    this.handlersByElement = /* @__PURE__ */ new Map();
    this._active = false;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(type, handler, options, once = false, passive = false) {
    const { handlers, handlersByElement } = this;
    const opts = { ...DEFAULT_OPTIONS, ...options };
    let entries = handlersByElement.get(opts.srcElement);
    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }
    const entry = {
      type,
      handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };
    if (once) {
      entry.once = true;
    }
    if (passive) {
      entry.passive = true;
    }
    handlers.push(entry);
    this._active = this._active || !entry.passive;
    let insertPosition = entries.length - 1;
    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }
      insertPosition--;
    }
    entries.splice(insertPosition + 1, 0, entry);
  }
  remove(type, handler) {
    const { handlers, handlersByElement } = this;
    for (let i3 = handlers.length - 1; i3 >= 0; i3--) {
      const entry = handlers[i3];
      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i3, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);
        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }
    this._active = handlers.some((entry) => !entry.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);
    if (entries) {
      let immediatePropagationStopped = false;
      const stopPropagation = () => {
        event.handled = true;
      };
      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };
      const entriesToRemove = [];
      for (let i3 = 0; i3 < entries.length; i3++) {
        const { type, handler, once } = entries[i3];
        handler({
          ...event,
          type,
          stopPropagation,
          stopImmediatePropagation
        });
        if (once) {
          entriesToRemove.push(entries[i3]);
        }
        if (immediatePropagationStopped) {
          break;
        }
      }
      for (let i3 = 0; i3 < entriesToRemove.length; i3++) {
        const { type, handler } = entriesToRemove[i3];
        this.remove(type, handler);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(event) {
    const rootElement = this.eventManager.getElement();
    return {
      ...event,
      ...whichButtons(event),
      ...getOffsetPosition(event, rootElement),
      preventDefault: () => {
        event.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: false,
      rootElement
    };
  }
};

// node_modules/mjolnir.js/dist/event-manager.js
function normalizeRecognizer(item) {
  if ("recognizer" in item) {
    return item;
  }
  let recognizer;
  const itemArray = Array.isArray(item) ? [...item] : [item];
  if (typeof itemArray[0] === "function") {
    const RecognizerType = itemArray.shift();
    const options = itemArray.shift() || {};
    recognizer = new RecognizerType(options);
  } else {
    recognizer = itemArray.shift();
  }
  return {
    recognizer,
    recognizeWith: typeof itemArray[0] === "string" ? [itemArray[0]] : itemArray[0],
    requireFailure: typeof itemArray[1] === "string" ? [itemArray[1]] : itemArray[1]
  };
}
var EventManager = class {
  constructor(element = null, options = {}) {
    this._onBasicInput = (event) => {
      this.manager.emit(event.srcEvent.type, event);
    };
    this._onOtherEvent = (event) => {
      this.manager.emit(event.type, event);
    };
    this.options = {
      recognizers: [],
      events: {},
      touchAction: "compute",
      tabIndex: 0,
      cssProps: {},
      ...options
    };
    this.events = /* @__PURE__ */ new Map();
    this.element = element;
    if (!element)
      return;
    this.manager = new Manager(element, this.options);
    for (const item of this.options.recognizers) {
      const { recognizer, recognizeWith, requireFailure } = normalizeRecognizer(item);
      this.manager.add(recognizer);
      if (recognizeWith) {
        recognizer.recognizeWith(recognizeWith);
      }
      if (requireFailure) {
        recognizer.requireFailure(requireFailure);
      }
    }
    this.manager.on("hammer.input", this._onBasicInput);
    this.wheelInput = new WheelInput(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new MoveInput(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new KeyInput(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
      enable: false
    });
    this.on(this.options.events);
  }
  getElement() {
    return this.element;
  }
  // Tear down internal event management implementations.
  destroy() {
    if (!this.element)
      return;
    this.wheelInput.destroy();
    this.moveInput.destroy();
    this.keyInput.destroy();
    this.contextmenuInput.destroy();
    this.manager.destroy();
  }
  /** Register an event handler function to be called on `event` */
  on(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false);
  }
  once(event, handler, opts) {
    this._addEventHandler(event, handler, opts, true);
  }
  watch(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false, true);
  }
  off(event, handler) {
    this._removeEventHandler(event, handler);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(name2, enabled) {
    const { manager } = this;
    if (!manager) {
      return;
    }
    const recognizer = manager.get(name2);
    if (recognizer) {
      recognizer.set({ enable: enabled });
      manager.touchAction.update();
    }
    this.wheelInput?.enableEventType(name2, enabled);
    this.moveInput?.enableEventType(name2, enabled);
    this.keyInput?.enableEventType(name2, enabled);
    this.contextmenuInput?.enableEventType(name2, enabled);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(event, handler, opts, once, passive) {
    if (typeof event !== "string") {
      opts = handler;
      for (const [eventName, eventHandler] of Object.entries(event)) {
        this._addEventHandler(eventName, eventHandler, opts, once, passive);
      }
      return;
    }
    const { manager, events } = this;
    if (!manager)
      return;
    let eventRegistrar = events.get(event);
    if (!eventRegistrar) {
      const recognizerName = this._getRecognizerName(event) || event;
      eventRegistrar = new EventRegistrar(this, recognizerName);
      events.set(event, eventRegistrar);
      if (manager) {
        manager.on(event, eventRegistrar.handleEvent);
      }
    }
    eventRegistrar.add(event, handler, opts, once, passive);
    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(event, handler) {
    if (typeof event !== "string") {
      for (const [eventName, eventHandler] of Object.entries(event)) {
        this._removeEventHandler(eventName, eventHandler);
      }
      return;
    }
    const { events } = this;
    const eventRegistrar = events.get(event);
    if (!eventRegistrar) {
      return;
    }
    eventRegistrar.remove(event, handler);
    if (eventRegistrar.isEmpty()) {
      const { recognizerName } = eventRegistrar;
      let isRecognizerUsed = false;
      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }
      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }
  _getRecognizerName(event) {
    return this.manager.recognizers.find((recognizer) => {
      return recognizer.getEventNames().includes(event);
    })?.options.event;
  }
};

// node_modules/@deck.gl/core/dist/lib/constants.js
var COORDINATE_SYSTEM = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
  get: () => {
    log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
    return 0;
  }
});
var PROJECTION_MODE = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
};
var UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
var EVENT_HANDLERS = {
  click: "onClick",
  dblclick: "onClick",
  panstart: "onDragStart",
  panmove: "onDrag",
  panend: "onDragEnd"
};
var RECOGNIZERS = {
  multipan: [PanRecognizer, { threshold: 10, direction: InputDirection.Vertical, pointers: 2 }],
  pinch: [PinchRecognizer, {}, null, ["multipan"]],
  pan: [PanRecognizer, { threshold: 1 }, ["pinch"], ["multipan"]],
  dblclick: [TapRecognizer, { event: "dblclick", taps: 2 }],
  click: [TapRecognizer, { event: "click" }, null, ["dblclick"]]
};

// node_modules/@deck.gl/core/dist/utils/memoize.js
function isEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (Array.isArray(a2)) {
    const len4 = a2.length;
    if (!b2 || b2.length !== len4) {
      return false;
    }
    for (let i3 = 0; i3 < len4; i3++) {
      if (a2[i3] !== b2[i3]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}

// node_modules/@deck.gl/core/dist/shaderlib/project/viewport-uniforms.js
var ZERO_VECTOR = [0, 0, 0, 0];
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }
  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? (
      // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
      [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]
    ) : null;
  }
  switch (viewport.projectionMode) {
    case PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }
      break;
    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [
          Math.fround(viewport.center[0]),
          Math.fround(viewport.center[1]),
          0
        ];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;
    case PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;
    default:
      offsetMode = false;
  }
  return { geospatialOrigin, shaderCoordinateOrigin, offsetMode };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const { viewMatrixUncentered, projectionMatrix } = viewport;
  let { viewMatrix: viewMatrix2, viewProjectionMatrix } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const { geospatialOrigin, shaderCoordinateOrigin, offsetMode } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [
      cameraPosCommon[0] - originCommon[0],
      cameraPosCommon[1] - originCommon[1],
      cameraPosCommon[2] - originCommon[2]
    ];
    originCommon[3] = 1;
    projectionCenter = vec4_exports.transformMat4([], originCommon, viewProjectionMatrix);
    viewMatrix2 = viewMatrixUncentered || viewMatrix2;
    viewProjectionMatrix = mat4_exports.multiply([], projectionMatrix, viewMatrix2);
    viewProjectionMatrix = mat4_exports.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }
  return {
    viewMatrix: viewMatrix2,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  // Match Layer.defaultProps
  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.wrapLongitude = autoWrapLongitude;
  uniforms.modelMatrix = modelMatrix || IDENTITY_MATRIX4;
  return uniforms;
}
function calculateViewportUniforms({ viewport, devicePixelRatio, coordinateSystem, coordinateOrigin }) {
  const { projectionCenter, viewProjectionMatrix, originCommon, cameraPosCommon, shaderCoordinateOrigin, geospatialOrigin } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [
    viewport.width * devicePixelRatio,
    viewport.height * devicePixelRatio
  ];
  const focalDistance = vec4_exports.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    // Projection mode values
    coordinateSystem,
    projectionMode: viewport.projectionMode,
    coordinateOrigin: shaderCoordinateOrigin,
    commonOrigin: originCommon.slice(0, 3),
    center: projectionCenter,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    pseudoMeters: Boolean(viewport._pseudoMeters),
    // Screen size
    viewportSize,
    devicePixelRatio,
    focalDistance,
    commonUnitsPerMeter: distanceScales.unitsPerMeter,
    commonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    scale: viewport.scale,
    // This is the mercator scale (2 ** zoom)
    wrapLongitude: false,
    viewProjectionMatrix,
    modelMatrix: IDENTITY_MATRIX4,
    // This is for lighting calculations
    cameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case COORDINATE_SYSTEM.LNGLAT:
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }
        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      case COORDINATE_SYSTEM.CARTESIAN:
        uniforms.commonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.commonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;
      default:
        break;
    }
  }
  return uniforms;
}

// node_modules/@deck.gl/core/dist/shaderlib/project/project.wgsl.js
var COORDINATE_SYSTEM_WGSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const COORDINATE_SYSTEM_${key}: i32 = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_WGSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const PROJECTION_MODE_${key}: i32 = ${PROJECTION_MODE[key]};`).join("");
var UNIT_WGSL_CONSTANTS = Object.keys(UNIT).map((key) => `const UNIT_${key.toUpperCase()}: i32 = ${UNIT[key]};`).join("");
var projectWGSLHeader = (
  /* wgsl */
  `${COORDINATE_SYSTEM_WGSL_CONSTANTS}
${PROJECTION_MODE_WGSL_CONSTANTS}
${UNIT_WGSL_CONSTANTS}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`
);
var projectWGSL = (
  /* wgsl */
  `${projectWGSLHeader}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the z\u2011axis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`
);

// node_modules/@deck.gl/core/dist/shaderlib/project/project.glsl.js
var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
var projectGLSL = (
  /* glsl */
  `${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`
);

// node_modules/@deck.gl/core/dist/shaderlib/project/project.js
var INITIAL_MODULE_OPTIONS = {};
function getUniforms3(opts = INITIAL_MODULE_OPTIONS) {
  if ("viewport" in opts) {
    return getUniformsFromViewport(opts);
  }
  return {};
}
var project_default = {
  name: "project",
  dependencies: [fp32, geometry_default],
  source: projectWGSL,
  vs: projectGLSL,
  getUniforms: getUniforms3,
  uniformTypes: {
    wrapLongitude: "f32",
    coordinateSystem: "i32",
    commonUnitsPerMeter: "vec3<f32>",
    projectionMode: "i32",
    scale: "f32",
    commonUnitsPerWorldUnit: "vec3<f32>",
    commonUnitsPerWorldUnit2: "vec3<f32>",
    center: "vec4<f32>",
    modelMatrix: "mat4x4<f32>",
    viewProjectionMatrix: "mat4x4<f32>",
    viewportSize: "vec2<f32>",
    devicePixelRatio: "f32",
    focalDistance: "f32",
    cameraPosition: "vec3<f32>",
    coordinateOrigin: "vec3<f32>",
    commonOrigin: "vec3<f32>",
    pseudoMeters: "f32"
  }
  // @ts-ignore TODO v9.1
};

// node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js
var source2 = (
  /* wgsl */
  `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`
);
var vs3 = (
  /* glsl */
  `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`
);
var project32_default = {
  name: "project32",
  dependencies: [project_default],
  source: source2,
  vs: vs3
};

// node_modules/@math.gl/web-mercator/dist/math-utils.js
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = vec4_exports.transformMat4([], vector, matrix);
  vec4_exports.scale(result, result, 1 / result[3]);
  return result;
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function clamp2(x2, min4, max4) {
  return x2 < min4 ? min4 : x2 > max4 ? max4 : x2;
}
function ieLog2(x2) {
  return Math.log(x2) * Math.LOG2E;
}
var log22 = Math.log2 || ieLog2;

// node_modules/@math.gl/web-mercator/dist/assert.js
function assert7(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "@math.gl/web-mercator: assertion failed.");
  }
}

// node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS2 = PI / 180;
var RADIANS_TO_DEGREES2 = 180 / PI;
var TILE_SIZE = 512;
var EARTH_CIRCUMFERENCE = 4003e4;
var MAX_LATITUDE = 85.051129;
var DEFAULT_ALTITUDE = 1.5;
function scaleToZoom(scale7) {
  return log22(scale7);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert7(Number.isFinite(lng));
  assert7(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  const lambda2 = lng * DEGREES_TO_RADIANS2;
  const phi2 = lat * DEGREES_TO_RADIANS2;
  const x2 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y2 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x2, y2];
}
function worldToLngLat(xy) {
  const [x2, y2] = xy;
  const lambda2 = x2 / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y2 / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
}
function getMeterZoom(options) {
  const { latitude } = options;
  assert7(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
  const { latitude, longitude, highPrecision = false } = options;
  assert7(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x2, y2, z2] = xyz;
  const { unitsPerMeter: unitsPerMeter2, unitsPerMeter2: unitsPerMeter22 } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x2 * (unitsPerMeter2[0] + unitsPerMeter22[0] * y2);
  worldspace[1] += y2 * (unitsPerMeter2[1] + unitsPerMeter22[1] * y2);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z2 || 0);
  return Number.isFinite(z0) || Number.isFinite(z2) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}
function getViewMatrix(options) {
  const {
    // Viewport props
    height,
    pitch,
    bearing,
    altitude,
    // Pre-calculated parameters
    scale: scale7,
    center
  } = options;
  const vm = createMat4();
  mat4_exports.translate(vm, vm, [0, 0, -altitude]);
  mat4_exports.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS2);
  mat4_exports.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS2);
  const relativeScale = scale7 / height;
  mat4_exports.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    mat4_exports.translate(vm, vm, vec3_exports.negate([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const { width, height, altitude, pitch = 0, offset, center, scale: scale7, nearZMultiplier = 1, farZMultiplier = 1 } = options;
  let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
  if (altitude !== void 0) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS2;
  const pitchRadians = pitch * DEGREES_TO_RADIANS2;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale7 / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x2, y2, z2 = 0] = xyz;
  assert7(Number.isFinite(x2) && Number.isFinite(y2) && Number.isFinite(z2));
  return transformVector(pixelProjectionMatrix, [x2, y2, z2, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x2, y2, z2] = xyz;
  assert7(Number.isFinite(x2) && Number.isFinite(y2), "invalid pixel coordinate");
  if (Number.isFinite(z2)) {
    const coord = transformVector(pixelUnprojectionMatrix, [x2, y2, z2, 1]);
    return coord;
  }
  const coord0 = transformVector(pixelUnprojectionMatrix, [x2, y2, 0, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x2, y2, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t2 = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2_exports.lerp([], coord0, coord1, t2);
}

// node_modules/@math.gl/web-mercator/dist/fit-bounds.js
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom = 24,
    // ~x4,000,000 => About 10 meter extents
    offset = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
  const se2 = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
  const size = [
    Math.max(Math.abs(se2[0] - nw[0]), minExtent),
    Math.max(Math.abs(se2[1] - nw[1]), minExtent)
  ];
  const targetSize = [
    width - padding.left - padding.right - Math.abs(offset[0]) * 2,
    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
  ];
  assert7(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX2 = targetSize[0] / size[0];
  const scaleY2 = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX2;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
  const center = [(se2[0] + nw[0]) / 2 + offsetX, (se2[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = worldToLngLat(center);
  const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
  assert7(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === "number") {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  assert7(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}

// node_modules/@math.gl/web-mercator/dist/get-bounds.js
var DEGREES_TO_RADIANS3 = Math.PI / 180;
function getBounds(viewport, z2 = 0) {
  const { width, height, unproject } = viewport;
  const unprojectOps = { targetZ: z2 };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z2);
    topRight = unprojectOnFarPlane(viewport, width, z2);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x2, targetZ) {
  const { pixelUnprojectionMatrix } = viewport;
  const coord0 = transformVector(pixelUnprojectionMatrix, [x2, 0, 1, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x2, viewport.height, 1, 1]);
  const z2 = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t2 = (z2 - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = vec2_exports.lerp([], coord0, coord1, t2);
  const result = worldToLngLat(coord);
  result.push(targetZ);
  return result;
}

// node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js
var TILE_SIZE2 = 512;
function normalizeViewportProps(props) {
  const { width, height, pitch = 0 } = props;
  let { longitude, latitude, zoom, bearing = 0 } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = mod(longitude + 180, 360) - 180;
  }
  if (bearing < -180 || bearing > 180) {
    bearing = mod(bearing + 180, 360) - 180;
  }
  const minZoom = log22(height / TILE_SIZE2);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return { width, height, longitude, latitude, zoom, pitch, bearing };
}

// node_modules/@deck.gl/core/dist/shaderlib/shadow/shadow.js
var uniformBlock2 = (
  /* glsl */
  `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
);
var vertex = (
  /* glsl */
  `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
);
var vs4 = `
${uniformBlock2}
${vertex}
`;
var fragment = (
  /* glsl */
  `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
);
var fs3 = `
${uniformBlock2}
${fragment}
`;
var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x2, y2, z2] = xyz;
  const coord = pixelsToWorld([x2, y2, z2], pixelUnprojectionMatrix);
  if (Number.isFinite(z2)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition({ viewport, center }) {
  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({ viewport, shadowMatrices }) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? void 0 : 1;
  const corners = [
    [0, 0, farZ],
    // top left ground
    [viewport.width, 0, farZ],
    // top right ground
    [0, viewport.height, farZ],
    // bottom left ground
    [viewport.width, viewport.height, farZ],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [viewport.width, 0, -1],
    // top right near
    [0, viewport.height, -1],
    // bottom left near
    [viewport.width, viewport.height, -1]
    // bottom right near
  ].map((pixel) => (
    // @ts-expect-error z may be undefined
    screenToCommonSpace(pixel, pixelUnprojectionMatrix)
  ));
  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix2 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
    const positions = corners.map((corner) => viewMatrix2.transform(corner));
    const projectionMatrix = new Matrix4().ortho({
      left: Math.min(...positions.map((position) => position[0])),
      right: Math.max(...positions.map((position) => position[0])),
      bottom: Math.min(...positions.map((position) => position[1])),
      top: Math.max(...positions.map((position) => position[1])),
      near: Math.min(...positions.map((position) => -position[2])),
      far: Math.max(...positions.map((position) => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }
  return projectionMatrices;
}
function createShadowUniforms(opts) {
  const { shadowEnabled = true, project: projectProps } = opts;
  if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      drawShadowMap: false,
      useShadowMap: false,
      shadow_uShadowMap0: opts.dummyShadowMap,
      shadow_uShadowMap1: opts.dummyShadowMap
    };
  }
  const projectUniforms = project_default.getUniforms(projectProps);
  const center = getMemoizedViewportCenterPosition({
    viewport: projectProps.viewport,
    center: projectUniforms.center
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: projectProps.viewport
  }).slice();
  for (let i3 = 0; i3 < opts.shadowMatrices.length; i3++) {
    const viewProjectionMatrix = viewProjectionMatrices[i3];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(projectProps.viewport.center).negate());
    if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT && projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i3] = viewProjectionMatrixCentered;
      projectCenters[i3] = center;
    } else {
      viewProjectionMatrices[i3] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
      projectCenters[i3] = viewProjectionMatrixCentered.transform(center);
    }
  }
  const uniforms = {
    drawShadowMap: Boolean(opts.drawToShadowMap),
    useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    color: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    lightId: opts.shadowLightId || 0,
    lightCount: opts.shadowMatrices.length,
    shadow_uShadowMap0: opts.dummyShadowMap,
    shadow_uShadowMap1: opts.dummyShadowMap
  };
  for (let i3 = 0; i3 < viewProjectionMatrices.length; i3++) {
    uniforms[`viewProjectionMatrix${i3}`] = viewProjectionMatrices[i3];
    uniforms[`projectCenter${i3}`] = projectCenters[i3];
  }
  for (let i3 = 0; i3 < 2; i3++) {
    uniforms[`shadow_uShadowMap${i3}`] = opts.shadowMaps && opts.shadowMaps[i3] || opts.dummyShadowMap;
  }
  return uniforms;
}
var shadow_default = {
  name: "shadow",
  dependencies: [project_default],
  vs: vs4,
  fs: fs3,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: createShadowUniforms,
  uniformTypes: {
    drawShadowMap: "f32",
    useShadowMap: "f32",
    color: "vec4<f32>",
    lightId: "i32",
    lightCount: "f32",
    viewProjectionMatrix0: "mat4x4<f32>",
    viewProjectionMatrix1: "mat4x4<f32>",
    projectCenter0: "vec4<f32>",
    projectCenter1: "vec4<f32>"
  }
};

// node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js
var picking_default = {
  ...picking,
  defaultUniforms: { ...picking.defaultUniforms, useFloatColors: false },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
};

// node_modules/@deck.gl/core/dist/shaderlib/index.js
var DEFAULT_MODULES = [geometry_default];
var SHADER_HOOKS_GLSL = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
var SHADER_HOOKS_WGSL = [
  // Not yet supported
];
function getShaderAssembler(language) {
  const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();
  for (const shaderModule of DEFAULT_MODULES) {
    shaderAssembler.addDefaultModule(shaderModule);
  }
  const shaderHooks = language === "glsl" ? SHADER_HOOKS_GLSL : SHADER_HOOKS_WGSL;
  for (const shaderHook of shaderHooks) {
    shaderAssembler.addShaderHook(shaderHook);
  }
  return shaderAssembler;
}

// node_modules/@deck.gl/core/dist/effects/lighting/ambient-light.js
var DEFAULT_LIGHT_COLOR = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY = 1;
var idCount = 0;
var AmbientLight = class {
  constructor(props = {}) {
    this.type = "ambient";
    const { color = DEFAULT_LIGHT_COLOR } = props;
    const { intensity = DEFAULT_LIGHT_INTENSITY } = props;
    this.id = props.id || `ambient-${idCount++}`;
    this.color = color;
    this.intensity = intensity;
  }
};

// node_modules/@deck.gl/core/dist/effects/lighting/directional-light.js
var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY2 = 1;
var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
var idCount2 = 0;
var DirectionalLight = class {
  constructor(props = {}) {
    this.type = "directional";
    const { color = DEFAULT_LIGHT_COLOR2 } = props;
    const { intensity = DEFAULT_LIGHT_INTENSITY2 } = props;
    const { direction = DEFAULT_LIGHT_DIRECTION } = props;
    const { _shadow = false } = props;
    this.id = props.id || `directional-${idCount2++}`;
    this.color = color;
    this.intensity = intensity;
    this.type = "directional";
    this.direction = new Vector3(direction).normalize().toArray();
    this.shadow = _shadow;
  }
  getProjectedLight(opts) {
    return this;
  }
};

// node_modules/@deck.gl/core/dist/passes/pass.js
var Pass = class {
  /** Create a new Pass instance */
  constructor(device, props = { id: "pass" }) {
    const { id } = props;
    this.id = id;
    this.device = device;
    this.props = { ...props };
  }
  setProps(props) {
    Object.assign(this.props, props);
  }
  render(params) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
};

// node_modules/@deck.gl/core/dist/passes/layers-pass.js
var LayersPass = class extends Pass {
  constructor() {
    super(...arguments);
    this._lastRenderIndex = -1;
  }
  render(options) {
    const [width, height] = this.device.canvasContext.getDrawingBufferSize();
    const clearCanvas = options.clearCanvas ?? true;
    const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);
    const clearDepth = clearCanvas ? 1 : false;
    const clearStencil = clearCanvas ? 0 : false;
    const colorMask = options.colorMask ?? 15;
    const parameters = { viewport: [0, 0, width, height] };
    if (options.colorMask) {
      parameters.colorMask = colorMask;
    }
    if (options.scissorRect) {
      parameters.scissorRect = options.scissorRect;
    }
    const renderPass = this.device.beginRenderPass({
      framebuffer: options.target,
      parameters,
      clearColor,
      clearDepth,
      clearStencil
    });
    try {
      return this._drawLayers(renderPass, options);
    } finally {
      renderPass.end();
      this.device.submit();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(renderPass, options) {
    const { target: target2, shaderModuleProps, viewports, views, onViewportActive, clearStack = true } = options;
    options.pass = options.pass || "unknown";
    if (clearStack) {
      this._lastRenderIndex = -1;
    }
    const renderStats = [];
    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive?.(viewport);
      const drawLayerParams = this._getDrawLayerParams(viewport, options);
      const subViewports = viewport.subViewports || [viewport];
      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(renderPass, {
          target: target2,
          shaderModuleProps,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);
        renderStats.push(stats);
      }
    }
    return renderStats;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(viewport, { layers, pass, isPicking = false, layerFilter, cullRect, effects, shaderModuleProps }, evaluateShouldDrawOnly = false) {
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking,
      renderPass: pass,
      cullRect
    };
    const layerFilterCache = {};
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
      const layerParam = { shouldDrawLayer };
      if (shouldDrawLayer && !evaluateShouldDrawOnly) {
        layerParam.shouldDrawLayer = true;
        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
        layerParam.shaderModuleProps = this._getShaderModuleProps(layer, effects, pass, shaderModuleProps);
        layerParam.layerParameters = {
          ...layer.context.deck?.props.parameters,
          ...this.getLayerParameters(layer, layerIndex, viewport)
        };
      }
      drawLayerParams[layerIndex] = layerParam;
    }
    return drawLayerParams;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(renderPass, { layers, shaderModuleProps: globalModuleParameters, pass, target: target2, viewport, view }, drawLayerParams) {
    const glViewport = getGLViewport(this.device, {
      shaderModuleProps: globalModuleParameters,
      target: target2,
      viewport
    });
    if (view && view.props.clear) {
      const clearOpts = view.props.clear === true ? { color: true, depth: true } : view.props.clear;
      const clearRenderPass = this.device.beginRenderPass({
        framebuffer: target2,
        parameters: {
          viewport: glViewport,
          scissorRect: glViewport
        },
        clearColor: clearOpts.color ? [0, 0, 0, 0] : false,
        clearDepth: clearOpts.depth ? 1 : false
      });
      clearRenderPass.end();
    }
    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    renderPass.setParameters({ viewport: glViewport });
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const drawLayerParameters = drawLayerParams[layerIndex];
      const { shouldDrawLayer } = drawLayerParameters;
      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }
      if (layer.isComposite) {
        renderStatus.compositeCount++;
      }
      if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {
        const { layerRenderIndex, shaderModuleProps, layerParameters } = drawLayerParameters;
        renderStatus.visibleCount++;
        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
        if (shaderModuleProps.project) {
          shaderModuleProps.project.viewport = viewport;
        }
        layer.context.renderPass = renderPass;
        try {
          layer._drawLayer({
            renderPass,
            shaderModuleProps,
            uniforms: { layerIndex: layerRenderIndex },
            parameters: layerParameters
          });
        } catch (err2) {
          layer.raiseError(err2, `drawing ${layer} to ${pass}`);
        }
      }
    }
    return renderStatus;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(layer) {
    return true;
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return null;
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
    if (!shouldDrawLayer) {
      return false;
    }
    drawContext.layer = layer;
    let parent = layer.parent;
    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }
      drawContext.layer = parent;
      parent = parent.parent;
    }
    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;
      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }
      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }
    layer.activateViewport(drawContext.viewport);
    return true;
  }
  _getShaderModuleProps(layer, effects, pass, overrides) {
    const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const layerProps = layer.internalState?.propsInTransition || layer.props;
    const shaderModuleProps = {
      layer: layerProps,
      picking: {
        isActive: false
      },
      project: {
        viewport: layer.context.viewport,
        devicePixelRatio,
        modelMatrix: layerProps.modelMatrix,
        coordinateSystem: layerProps.coordinateSystem,
        coordinateOrigin: layerProps.coordinateOrigin,
        autoWrapLongitude: layer.wrapLongitude
      }
    };
    if (effects) {
      for (const effect of effects) {
        mergeModuleParameters(shaderModuleProps, effect.getShaderModuleProps?.(layer, shaderModuleProps));
      }
    }
    return mergeModuleParameters(shaderModuleProps, this.getShaderModuleProps(layer, effects, shaderModuleProps), overrides);
  }
};
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};
  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;
    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }
    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }
    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }
    layerIndices[layerId] = index;
    return index;
  };
  return resolveLayerIndex;
}
function getGLViewport(device, { shaderModuleProps, target: target2, viewport }) {
  const pixelRatio = shaderModuleProps?.project?.devicePixelRatio ?? // @ts-expect-error TODO - assuming WebGL context
  device.canvasContext.cssToDeviceRatio();
  const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();
  const height = target2 ? target2.height : drawingBufferHeight;
  const dimensions = viewport;
  return [
    dimensions.x * pixelRatio,
    height - (dimensions.y + dimensions.height) * pixelRatio,
    dimensions.width * pixelRatio,
    dimensions.height * pixelRatio
  ];
}
function mergeModuleParameters(target2, ...sources) {
  for (const source3 of sources) {
    if (source3) {
      for (const key in source3) {
        if (target2[key]) {
          Object.assign(target2[key], source3[key]);
        } else {
          target2[key] = source3[key];
        }
      }
    }
  }
  return target2;
}

// node_modules/@deck.gl/core/dist/passes/shadow-pass.js
var ShadowPass = class extends LayersPass {
  constructor(device, props) {
    super(device, props);
    const shadowMap = device.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      mipmaps: true
    });
    const depthBuffer = device.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: false
    });
    this.fbo = device.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [shadowMap],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: depthBuffer
    });
  }
  delete() {
    if (this.fbo) {
      this.fbo.destroy();
      this.fbo = null;
    }
  }
  getShadowMap() {
    return this.fbo.colorAttachments[0].texture;
  }
  render(params) {
    const target2 = this.fbo;
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const viewport = params.viewports[0];
    const width = viewport.width * pixelRatio;
    const height = viewport.height * pixelRatio;
    const clearColor = [1, 1, 1, 1];
    if (width !== target2.width || height !== target2.height) {
      target2.resize({ width, height });
    }
    super.render({ ...params, clearColor, target: target2, pass: "shadow" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: false,
      depthWriteEnabled: true,
      depthCompare: "less-equal"
    };
  }
  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return {
      shadow: {
        project: otherShaderModuleProps.project,
        drawToShadowMap: true
      }
    };
  }
};

// node_modules/@deck.gl/core/dist/effects/lighting/lighting-effect.js
var DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1
};
var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
];
var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
var LightingEffect = class {
  constructor(props = {}) {
    this.id = "lighting-effect";
    this.shadowColor = DEFAULT_SHADOW_COLOR2;
    this.shadow = false;
    this.directionalLights = [];
    this.pointLights = [];
    this.shadowPasses = [];
    this.dummyShadowMap = null;
    this.setProps(props);
  }
  setup(context) {
    this.context = context;
    const { device, deck } = context;
    if (this.shadow && !this.dummyShadowMap) {
      this._createShadowPasses(device);
      deck._addDefaultShaderModule(shadow_default);
      this.dummyShadowMap = device.createTexture({
        width: 1,
        height: 1
      });
    }
  }
  setProps(props) {
    this.ambientLight = void 0;
    this.directionalLights = [];
    this.pointLights = [];
    for (const key in props) {
      const lightSource = props[key];
      switch (lightSource.type) {
        case "ambient":
          this.ambientLight = lightSource;
          break;
        case "directional":
          this.directionalLights.push(lightSource);
          break;
        case "point":
          this.pointLights.push(lightSource);
          break;
        default:
      }
    }
    this._applyDefaultLights();
    this.shadow = this.directionalLights.some((light) => light.shadow);
    if (this.context) {
      this.setup(this.context);
    }
    this.props = props;
  }
  preRender({ layers, layerFilter, viewports, onViewportActive, views }) {
    if (!this.shadow)
      return;
    this.shadowMatrices = this._calculateMatrices();
    for (let i3 = 0; i3 < this.shadowPasses.length; i3++) {
      const shadowPass = this.shadowPasses[i3];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        shaderModuleProps: {
          shadow: {
            shadowLightId: i3,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        }
      });
    }
  }
  getShaderModuleProps(layer, otherShaderModuleProps) {
    const shadowProps = this.shadow ? {
      project: otherShaderModuleProps.project,
      shadowMaps: this.shadowPasses.map((shadowPass) => shadowPass.getShadowMap()),
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    const lightingProps = {
      enabled: true,
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({ layer })),
      pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({ layer }))
    };
    const materialProps = layer.props.material;
    return {
      shadow: shadowProps,
      lighting: lightingProps,
      phongMaterial: materialProps,
      gouraudMaterial: materialProps
    };
  }
  cleanup(context) {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }
    this.shadowPasses.length = 0;
    if (this.dummyShadowMap) {
      this.dummyShadowMap.destroy();
      this.dummyShadowMap = null;
      context.deck._removeDefaultShaderModule(shadow_default);
    }
  }
  _calculateMatrices() {
    const lightMatrices = [];
    for (const light of this.directionalLights) {
      const viewMatrix2 = new Matrix4().lookAt({
        eye: new Vector3(light.direction).negate()
      });
      lightMatrices.push(viewMatrix2);
    }
    return lightMatrices;
  }
  _createShadowPasses(device) {
    for (let i3 = 0; i3 < this.directionalLights.length; i3++) {
      const shadowPass = new ShadowPass(device);
      this.shadowPasses[i3] = shadowPass;
    }
  }
  _applyDefaultLights() {
    const { ambientLight, pointLights, directionalLights } = this;
    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }
};

// node_modules/@deck.gl/core/dist/utils/typed-array-manager.js
var TypedArrayManager = class {
  constructor(options = {}) {
    this._pool = [];
    this.opts = { overAlloc: 2, poolSize: 100 };
    this.setOptions(options);
  }
  setOptions(options) {
    Object.assign(this.opts, options);
  }
  allocate(typedArray, count2, { size = 1, type, padding = 0, copy: copy6 = false, initialize = false, maxCount }) {
    const Type = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count2 * size + padding;
    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }
      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type(typedArray.buffer, 0, newSize);
      }
    }
    let maxSize = Infinity;
    if (maxCount) {
      maxSize = maxCount * size + padding;
    }
    const newArray = this._allocate(Type, newSize, initialize, maxSize);
    if (typedArray && copy6) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }
    this._release(typedArray);
    return newArray;
  }
  release(typedArray) {
    this._release(typedArray);
  }
  _allocate(Type, size, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }
    const pool = this._pool;
    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
    const i3 = pool.findIndex((b2) => b2.byteLength >= byteLength);
    if (i3 >= 0) {
      const array = new Type(pool.splice(i3, 1)[0], 0, sizeToAllocate);
      if (initialize) {
        array.fill(0);
      }
      return array;
    }
    return new Type(sizeToAllocate);
  }
  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }
    const pool = this._pool;
    const { buffer } = typedArray;
    const { byteLength } = buffer;
    const i3 = pool.findIndex((b2) => b2.byteLength >= byteLength);
    if (i3 < 0) {
      pool.push(buffer);
    } else if (i3 > 0 || pool.length < this.opts.poolSize) {
      pool.splice(i3, 0, buffer);
    }
    if (pool.length > this.opts.poolSize) {
      pool.shift();
    }
  }
};
var typed_array_manager_default = new TypedArrayManager();

// node_modules/@deck.gl/core/dist/utils/math-utils.js
function createMat42() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mod2(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
var scratchVector = new Vector3();
function getFrustumPlane(a2, b2, c2, d2) {
  scratchVector.set(a2, b2, c2);
  const L2 = scratchVector.len();
  return { distance: d2 / L2, normal: new Vector3(-a2 / L2, -b2 / L2, -c2 / L2) };
}
function fp64LowPart2(x2) {
  return x2 - Math.fround(x2);
}
var scratchArray;
function toDoublePrecisionArray(typedArray, options) {
  const { size = 1, startIndex = 0 } = options;
  const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
  const count2 = (endIndex - startIndex) / size;
  scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (let j2 = 0; j2 < size; j2++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j2] = value;
      scratchArray[targetIndex + j2 + size] = fp64LowPart2(value);
    }
    targetIndex += size * 2;
  }
  return scratchArray.subarray(0, count2 * size * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;
  for (const bounds of boundsList) {
    if (!bounds)
      continue;
    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [
          [mergedBounds[0][0], mergedBounds[0][1]],
          [mergedBounds[1][0], mergedBounds[1][1]]
        ];
        isMerged = true;
      }
      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }
  return mergedBounds;
}

// node_modules/@deck.gl/core/dist/viewports/viewport.js
var DEGREES_TO_RADIANS4 = Math.PI / 180;
var IDENTITY2 = createMat42();
var ZERO_VECTOR2 = [0, 0, 0];
var DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function createProjectionMatrix({ width, height, orthographic, fovyRadians, focalDistance, padding, near, far }) {
  const aspect = width / height;
  const matrix = orthographic ? new Matrix4().orthographic({ fovy: fovyRadians, aspect, focalDistance, near, far }) : new Matrix4().perspective({ fovy: fovyRadians, aspect, near, far });
  if (padding) {
    const { left = 0, right = 0, top = 0, bottom = 0 } = padding;
    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }
  return matrix;
}
var Viewport = class _Viewport {
  // eslint-disable-next-line complexity
  constructor(opts = {}) {
    this._frustumPlanes = {};
    this.id = opts.id || this.constructor.displayName || "viewport";
    this.x = opts.x || 0;
    this.y = opts.y || 0;
    this.width = opts.width || 1;
    this.height = opts.height || 1;
    this.zoom = opts.zoom || 0;
    this.padding = opts.padding;
    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = opts.focalDistance || 1;
    this.position = opts.position || ZERO_VECTOR2;
    this.modelMatrix = opts.modelMatrix || null;
    const { longitude, latitude } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
    this._initProps(opts);
    this._initMatrices(opts);
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }
    return PROJECTION_MODE.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(viewport) {
    if (!(viewport instanceof _Viewport)) {
      return false;
    }
    if (this === viewport) {
      return true;
    }
    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(xyz, { topLeft = true } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
    const [x2, y2] = coord;
    const y22 = topLeft ? y2 : this.height - y2;
    return xyz.length === 2 ? [x2, y22] : [x2, y22, coord[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(xyz, { topLeft = true, targetZ } = {}) {
    const [x2, y2, z2] = xyz;
    const y22 = topLeft ? y2 : this.height - y2;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = pixelsToWorld([x2, y22, z2], this.pixelUnprojectionMatrix, targetZWorld);
    const [X2, Y2, Z2] = this.unprojectPosition(coord);
    if (Number.isFinite(z2)) {
      return [X2, Y2, Z2];
    }
    return Number.isFinite(targetZ) ? [X2, Y2, targetZ] : [X2, Y2];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(xyz) {
    const [X2, Y2] = this.projectFlat(xyz);
    const Z2 = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X2, Y2, Z2];
  }
  unprojectPosition(xyz) {
    const [X2, Y2] = this.unprojectFlat(xyz);
    const Z2 = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X2, Y2, Z2];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = lngLatToWorld(xyz);
      result[1] = clamp(result[1], -318, 830);
      return result;
    }
    return xyz;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return worldToLngLat(xyz);
    }
    return xyz;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(options = {}) {
    const unprojectOption = { targetZ: options.z || 0 };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [
      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
    ];
  }
  getDistanceScales(coordinateOrigin) {
    if (coordinateOrigin && this.isGeospatial) {
      return getDistanceScales({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }
    return this.distanceScales;
  }
  containsPixel({ x: x2, y: y2, width = 1, height = 1 }) {
    return x2 < this.x + this.width && this.x < x2 + width && y2 < this.y + this.height && this.y < y2 + height;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }
    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(coords, pixel) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(opts) {
    const longitude = opts.longitude;
    const latitude = opts.latitude;
    if (this.isGeospatial) {
      if (!Number.isFinite(opts.zoom)) {
        this.zoom = getMeterZoom({ latitude }) + Math.log2(this.focalDistance);
      }
      this.distanceScales = opts.distanceScales || getDistanceScales({ latitude, longitude });
    }
    const scale7 = Math.pow(2, this.zoom);
    this.scale = scale7;
    const { position, modelMatrix } = opts;
    let meterOffset = ZERO_VECTOR2;
    if (position) {
      meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
    }
    if (this.isGeospatial) {
      const center = this.projectPosition([longitude, latitude, 0]);
      this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
    } else {
      this.center = this.projectPosition(meterOffset);
    }
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(opts) {
    const {
      // View matrix
      viewMatrix: viewMatrix2 = IDENTITY2,
      // Projection matrix
      projectionMatrix = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      // Distance of near clipping plane
      far = 1e3,
      // Distance of far clipping plane
      padding = null,
      // Center offset in pixels
      focalDistance = 1
    } = opts;
    this.viewMatrixUncentered = viewMatrix2;
    this.viewMatrix = new Matrix4().multiplyRight(viewMatrix2).translate(new Vector3(this.center).negate());
    this.projectionMatrix = projectionMatrix || createProjectionMatrix({
      width: this.width,
      height: this.height,
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
      focalDistance,
      padding,
      near,
      far
    });
    const vpm = createMat42();
    mat4_exports.multiply(vpm, vpm, this.projectionMatrix);
    mat4_exports.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = mat4_exports.invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
    const viewportMatrix = createMat42();
    const pixelProjectionMatrix = createMat42();
    mat4_exports.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    mat4_exports.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    mat4_exports.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.pixelUnprojectionMatrix = mat4_exports.invert(createMat42(), this.pixelProjectionMatrix);
    if (!this.pixelUnprojectionMatrix) {
      log_default.warn("Pixel project matrix not invertible")();
    }
  }
};
Viewport.displayName = "Viewport";
var viewport_default = Viewport;

// node_modules/@deck.gl/core/dist/viewports/web-mercator-viewport.js
var WebMercatorViewport2 = class _WebMercatorViewport extends viewport_default {
  /* eslint-disable complexity, max-statements */
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      nearZ,
      farZ,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      position,
      padding,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes = false
    } = opts;
    let { width, height, altitude = 1.5 } = opts;
    const scale7 = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;
    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = altitudeToFovy(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = fovyToAltitude(fovy);
      } else {
        fovy = altitudeToFovy(altitude);
      }
      let offset;
      if (padding) {
        const { top = 0, bottom = 0 } = padding;
        offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
      }
      projectionParameters = getProjectionParameters({
        width,
        height,
        scale: scale7,
        center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
        offset,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
      if (Number.isFinite(nearZ)) {
        projectionParameters.near = nearZ;
      }
      if (Number.isFinite(farZ)) {
        projectionParameters.far = farZ;
      }
    }
    let viewMatrixUncentered = getViewMatrix({
      height,
      pitch,
      bearing,
      scale: scale7,
      altitude
    });
    if (worldOffset) {
      const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }
    super({
      ...opts,
      // x, y,
      width,
      height,
      // view matrix
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      // projection matrix parameters
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);
      for (let x2 = minOffset; x2 <= maxOffset; x2++) {
        const offsetViewport = x2 ? new _WebMercatorViewport({
          ...this,
          worldOffset: x2
        }) : this;
        this._subViewports.push(offsetViewport);
      }
    }
    return this._subViewports;
  }
  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }
    const [X2, Y2] = this.projectFlat(xyz);
    const Z2 = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
    return [X2, Y2, Z2];
  }
  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }
    const [X2, Y2] = this.unprojectFlat(xyz);
    const Z2 = (xyz[2] || 0) / unitsPerMeter(Y2);
    return [X2, Y2, Z2];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(lngLatZ, xyz) {
    return addMetersToLngLat(lngLatZ, xyz);
  }
  panByPosition(coords, pixel) {
    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate3 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
    const newCenter = vec2_exports.add([], this.center, translate3);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return { longitude, latitude };
  }
  getBounds(options = {}) {
    const corners = getBounds(this, options.z || 0);
    return [
      Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
      Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
      Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
      Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(bounds, options = {}) {
    const { width, height } = this;
    const { longitude, latitude, zoom } = fitBounds({ width, height, bounds, ...options });
    return new _WebMercatorViewport({ width, height, longitude, latitude, zoom });
  }
};
WebMercatorViewport2.displayName = "WebMercatorViewport";
var web_mercator_viewport_default = WebMercatorViewport2;

// node_modules/@deck.gl/core/dist/shaderlib/project/project-functions.js
var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p2 = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof web_mercator_viewport_default) {
    const [longitude, latitude, z2 = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p2[2] = z2 * distanceScales.unitsPerMeter[2];
  }
  return p2;
}
function normalizeParameters(opts) {
  const { viewport, modelMatrix, coordinateOrigin } = opts;
  let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === void 0) {
    fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === void 0) {
    fromCoordinateOrigin = coordinateOrigin;
  }
  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}
function getWorldPosition(position, { viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode }) {
  let [x2, y2, z2 = 0] = position;
  if (modelMatrix) {
    [x2, y2, z2] = vec4_exports.transformMat4([], [x2, y2, z2, 1], modelMatrix);
  }
  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x2, y2, z2], viewport, offsetMode);
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z2 + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x2, y2, z2]), viewport, offsetMode);
    case COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z2 + coordinateOrigin[2]] : viewport.projectPosition([x2, y2, z2]);
  }
}
function projectPosition(position, params) {
  const { viewport, coordinateSystem, coordinateOrigin, modelMatrix, fromCoordinateSystem, fromCoordinateOrigin } = normalizeParameters(params);
  const { autoOffset = true } = params;
  const { geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2, shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2, offsetMode = false } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    vec3_exports.sub(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}

// node_modules/@luma.gl/engine/dist/animation/timeline.js
var channelHandles = 1;
var animationHandles = 1;
var Timeline = class {
  constructor() {
    __publicField(this, "time", 0);
    __publicField(this, "channels", /* @__PURE__ */ new Map());
    __publicField(this, "animations", /* @__PURE__ */ new Map());
    __publicField(this, "playing", false);
    __publicField(this, "lastEngineTime", -1);
  }
  addChannel(props) {
    const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
    const channelId = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };
    this._setChannelTime(channel, this.time);
    this.channels.set(channelId, channel);
    return channelId;
  }
  removeChannel(channelId) {
    this.channels.delete(channelId);
    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === channelId) {
        this.detachAnimation(animationHandle);
      }
    }
  }
  isFinished(channelId) {
    const channel = this.channels.get(channelId);
    if (channel === void 0) {
      return false;
    }
    return this.time >= channel.delay + channel.duration * channel.repeat;
  }
  getTime(channelId) {
    if (channelId === void 0) {
      return this.time;
    }
    const channel = this.channels.get(channelId);
    if (channel === void 0) {
      return -1;
    }
    return channel.time;
  }
  setTime(time) {
    this.time = Math.max(0, time);
    const channels2 = this.channels.values();
    for (const channel of channels2) {
      this._setChannelTime(channel, this.time);
    }
    const animations = this.animations.values();
    for (const animationData of animations) {
      const { animation, channel } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }
  play() {
    this.playing = true;
  }
  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }
  detachAnimation(channelId) {
    this.animations.delete(channelId);
  }
  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }
      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }
  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;
    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }
};

// node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js
function requestAnimationFramePolyfill(callback) {
  return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
}
function cancelAnimationFramePolyfill(timerId) {
  return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}

// node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js
var statIdCounter = 0;
var DEFAULT_ANIMATION_LOOP_PROPS = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => {
    return null;
  },
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (error) => console.error(error),
  // eslint-disable-line no-console
  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
  // view parameters
  useDevicePixels: true,
  autoResizeViewport: false,
  autoResizeDrawingBuffer: false
};
var AnimationLoop = class {
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(props) {
    __publicField(this, "device", null);
    __publicField(this, "canvas", null);
    __publicField(this, "props");
    __publicField(this, "animationProps", null);
    __publicField(this, "timeline", null);
    __publicField(this, "stats");
    __publicField(this, "cpuTime");
    __publicField(this, "gpuTime");
    __publicField(this, "frameRate");
    __publicField(this, "display");
    __publicField(this, "needsRedraw", "initialized");
    __publicField(this, "_initialized", false);
    __publicField(this, "_running", false);
    __publicField(this, "_animationFrameId", null);
    __publicField(this, "_nextFramePromise", null);
    __publicField(this, "_resolveNextFrame", null);
    __publicField(this, "_cpuStartTime", 0);
    __publicField(this, "_error", null);
    this.props = { ...DEFAULT_ANIMATION_LOOP_PROPS, ...props };
    props = this.props;
    if (!props.device) {
      throw new Error("No device provided");
    }
    const { useDevicePixels = true } = this.props;
    this.stats = props.stats || new Stats({ id: "animation-loop-stats" });
    this.cpuTime = this.stats.get("CPU Time");
    this.gpuTime = this.stats.get("GPU Time");
    this.frameRate = this.stats.get("Frame Rate");
    this.setProps({
      autoResizeViewport: props.autoResizeViewport,
      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop();
    this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  setError(error) {
    this.props.onError(error);
    this._error = Error();
    const canvas2 = this.device?.canvasContext?.canvas;
    if (canvas2 instanceof HTMLCanvasElement) {
      const errorDiv = document.createElement("h1");
      errorDiv.innerHTML = error.message;
      errorDiv.style.position = "absolute";
      errorDiv.style.top = "20%";
      errorDiv.style.left = "10px";
      errorDiv.style.color = "black";
      errorDiv.style.backgroundColor = "red";
      document.body.appendChild(errorDiv);
    }
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(props) {
    if ("autoResizeViewport" in props) {
      this.props.autoResizeViewport = props.autoResizeViewport || false;
    }
    if ("autoResizeDrawingBuffer" in props) {
      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
    }
    if ("useDevicePixels" in props) {
      this.props.useDevicePixels = props.useDevicePixels || false;
    }
    return this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running) {
      return this;
    }
    this._running = true;
    try {
      let appContext;
      if (!this._initialized) {
        this._initialized = true;
        await this._initDevice();
        this._initialize();
        await this.props.onInitialize(this._getAnimationProps());
      }
      if (!this._running) {
        return null;
      }
      if (appContext !== false) {
        this._cancelAnimationFrame();
        this._requestAnimationFrame();
      }
      return this;
    } catch (err2) {
      const error = err2 instanceof Error ? err2 : new Error("Unknown error");
      this.props.onError(error);
      throw error;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    if (this._running) {
      if (this.animationProps && !this._error) {
        this.props.onFinalize(this.animationProps);
      }
      this._cancelAnimationFrame();
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._running = false;
    }
    return this;
  }
  /** Explicitly draw a frame */
  redraw() {
    if (this.device?.isLost || this._error) {
      return this;
    }
    this._beginFrameTimers();
    this._setupFrame();
    this._updateAnimationProps();
    this._renderFrame(this._getAnimationProps());
    this._clearNeedsRedraw();
    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }
    this._endFrameTimers();
    return this;
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    this.setNeedsRedraw("waitForRender");
    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise((resolve3) => {
        this._resolveNextFrame = resolve3;
      });
    }
    return this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    this.setNeedsRedraw("toDataURL");
    await this.waitForRender();
    if (this.canvas instanceof HTMLCanvasElement) {
      return this.canvas.toDataURL();
    }
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling();
    this._initializeAnimationProps();
    this._updateAnimationProps();
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
  }
  _setDisplay(display) {
    if (this.display) {
      this.display.destroy();
      this.display.animationLoop = null;
    }
    if (display) {
      display.animationLoop = this;
    }
    this.display = display;
  }
  _requestAnimationFrame() {
    if (!this._running) {
      return;
    }
    this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));
  }
  _cancelAnimationFrame() {
    if (this._animationFrameId === null) {
      return;
    }
    cancelAnimationFramePolyfill(this._animationFrameId);
    this._animationFrameId = null;
  }
  _animationFrame() {
    if (!this._running) {
      return;
    }
    this.redraw();
    this._requestAnimationFrame();
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(animationProps) {
    if (this.display) {
      this.display._renderFrame(animationProps);
      return;
    }
    this.props.onRender(this._getAnimationProps());
    this.device?.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = false;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    const canvas2 = this.device?.canvasContext?.canvas;
    if (!this.device || !canvas2) {
      throw new Error("loop");
    }
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: canvas2,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: false,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps) {
      throw new Error("animationProps");
    }
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps) {
      return;
    }
    const { width, height, aspect } = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw("drawing buffer resized");
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw("drawing buffer aspect changed");
    }
    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }
    this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    this.device = await this.props.device;
    if (!this.device) {
      throw new Error("No device provided");
    }
    this.canvas = this.device.canvasContext?.canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement("div");
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = "relative";
      const div4 = document.createElement("div");
      div4.style.position = "absolute";
      div4.style.left = "10px";
      div4.style.bottom = "10px";
      div4.style.width = "300px";
      div4.style.background = "white";
      if (this.canvas instanceof HTMLCanvasElement) {
        wrapperDiv.appendChild(this.canvas);
      }
      wrapperDiv.appendChild(div4);
      const html = this.props.onAddHTML(div4);
      if (html) {
        div4.innerHTML = html;
      }
    }
  }
  _getSizeAndAspect() {
    if (!this.device) {
      return { width: 1, height: 1, aspect: 1 };
    }
    const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];
    let aspect = 1;
    const canvas2 = this.device?.canvasContext?.canvas;
    if (canvas2 && canvas2.clientHeight) {
      aspect = canvas2.clientWidth / canvas2.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }
    return { width, height, aspect };
  }
  /** Default viewport setup */
  _resizeViewport() {
    if (this.props.autoResizeViewport && this.device.gl) {
      this.device.gl.viewport(
        0,
        0,
        // @ts-expect-error Expose canvasContext
        this.device.gl.drawingBufferWidth,
        // @ts-expect-error Expose canvasContext
        this.device.gl.drawingBufferHeight
      );
    }
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    if (this.props.autoResizeDrawingBuffer) {
      this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });
    }
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();
    this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    if (this.canvas) {
      this.canvas.addEventListener("mousemove", this._onMousemove.bind(this));
      this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this));
    }
  }
  _onMousemove(event) {
    if (event instanceof MouseEvent) {
      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
    }
  }
  _onMouseleave(event) {
    this._getAnimationProps()._mousePosition = null;
  }
};

// node_modules/@luma.gl/engine/dist/utils/uid.js
var uidCounters2 = {};
function uid2(id = "id") {
  uidCounters2[id] = uidCounters2[id] || 1;
  const count2 = uidCounters2[id]++;
  return `${id}-${count2}`;
}

// node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js
var GPUGeometry = class {
  constructor(props) {
    __publicField(this, "id");
    __publicField(this, "userData", {});
    /** Determines how vertices are read from the 'vertex' attributes */
    __publicField(this, "topology");
    __publicField(this, "bufferLayout", []);
    __publicField(this, "vertexCount");
    __publicField(this, "indices");
    __publicField(this, "attributes");
    this.id = props.id || uid2("geometry");
    this.topology = props.topology;
    this.indices = props.indices || null;
    this.attributes = props.attributes;
    this.vertexCount = props.vertexCount;
    this.bufferLayout = props.bufferLayout || [];
    if (this.indices) {
      if (!(this.indices.usage & Buffer2.INDEX)) {
        throw new Error("Index buffer must have INDEX usage");
      }
    }
  }
  destroy() {
    this.indices?.destroy();
    for (const attribute of Object.values(this.attributes)) {
      attribute.destroy();
    }
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices || null;
  }
  _calculateVertexCount(positions) {
    const vertexCount = positions.byteLength / 12;
    return vertexCount;
  }
};
function makeGPUGeometry(device, geometry) {
  if (geometry instanceof GPUGeometry) {
    return geometry;
  }
  const indices = getIndexBufferFromGeometry(device, geometry);
  const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
  return new GPUGeometry({
    topology: geometry.topology || "triangle-list",
    bufferLayout,
    vertexCount: geometry.vertexCount,
    indices,
    attributes
  });
}
function getIndexBufferFromGeometry(device, geometry) {
  if (!geometry.indices) {
    return void 0;
  }
  const data = geometry.indices.value;
  return device.createBuffer({ usage: Buffer2.INDEX, data });
}
function getAttributeBuffersFromGeometry(device, geometry) {
  const bufferLayout = [];
  const attributes = {};
  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {
    let name2 = attributeName;
    switch (attributeName) {
      case "POSITION":
        name2 = "positions";
        break;
      case "NORMAL":
        name2 = "normals";
        break;
      case "TEXCOORD_0":
        name2 = "texCoords";
        break;
      case "COLOR_0":
        name2 = "colors";
        break;
    }
    if (attribute) {
      attributes[name2] = device.createBuffer({
        data: attribute.value,
        id: `${attributeName}-buffer`
      });
      const { value, size, normalized } = attribute;
      bufferLayout.push({ name: name2, format: getVertexFormatFromAttribute(value, size, normalized) });
    }
  }
  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
  return { attributes, bufferLayout, vertexCount };
}

// node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js
var _PipelineFactory = class _PipelineFactory {
  constructor(device) {
    __publicField(this, "device");
    __publicField(this, "destroyPolicy");
    __publicField(this, "_hashCounter", 0);
    __publicField(this, "_hashes", {});
    __publicField(this, "_renderPipelineCache", {});
    __publicField(this, "_computePipelineCache", {});
    this.device = device;
    this.destroyPolicy = device.props._factoryDestroyPolicy;
  }
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(device) {
    device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new _PipelineFactory(device);
    return device._lumaData.defaultPipelineFactory;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(props) {
    const allProps = { ...RenderPipeline.defaultProps, ...props };
    const hash = this._hashRenderPipeline(allProps);
    if (!this._renderPipelineCache[hash]) {
      const pipeline = this.device.createRenderPipeline({
        ...allProps,
        id: allProps.id ? `${allProps.id}-cached` : void 0
      });
      pipeline.hash = hash;
      this._renderPipelineCache[hash] = { pipeline, useCount: 0 };
    }
    this._renderPipelineCache[hash].useCount++;
    return this._renderPipelineCache[hash].pipeline;
  }
  createComputePipeline(props) {
    const allProps = { ...ComputePipeline.defaultProps, ...props };
    const hash = this._hashComputePipeline(allProps);
    if (!this._computePipelineCache[hash]) {
      const pipeline = this.device.createComputePipeline({
        ...allProps,
        id: allProps.id ? `${allProps.id}-cached` : void 0
      });
      pipeline.hash = hash;
      this._computePipelineCache[hash] = { pipeline, useCount: 0 };
    }
    this._computePipelineCache[hash].useCount++;
    return this._computePipelineCache[hash].pipeline;
  }
  release(pipeline) {
    const hash = pipeline.hash;
    const cache3 = pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;
    cache3[hash].useCount--;
    if (cache3[hash].useCount === 0) {
      if (this.destroyPolicy === "unused") {
        cache3[hash].pipeline.destroy();
        delete cache3[hash];
      }
    }
  }
  // PRIVATE
  _hashComputePipeline(props) {
    const shaderHash = this._getHash(props.shader.source);
    return `${shaderHash}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(props) {
    const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
    const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
    const varyingHash = "-";
    const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
      default:
        const parameterHash = this._getHash(JSON.stringify(props.parameters));
        return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
    }
  }
  _getHash(key) {
    if (this._hashes[key] === void 0) {
      this._hashes[key] = this._hashCounter++;
    }
    return this._hashes[key];
  }
};
__publicField(_PipelineFactory, "defaultProps", { ...RenderPipeline.defaultProps });
var PipelineFactory = _PipelineFactory;

// node_modules/@luma.gl/engine/dist/factories/shader-factory.js
var _ShaderFactory = class _ShaderFactory {
  /** @internal */
  constructor(device) {
    __publicField(this, "device");
    __publicField(this, "destroyPolicy");
    __publicField(this, "_cache", {});
    this.device = device;
    this.destroyPolicy = device.props._factoryDestroyPolicy;
  }
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(device) {
    var _a5;
    (_a5 = device._lumaData).defaultShaderFactory || (_a5.defaultShaderFactory = new _ShaderFactory(device));
    return device._lumaData.defaultShaderFactory;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(props) {
    const key = this._hashShader(props);
    let cacheEntry = this._cache[key];
    if (!cacheEntry) {
      const shader = this.device.createShader({
        ...props,
        id: props.id ? `${props.id}-cached` : void 0
      });
      this._cache[key] = cacheEntry = { shader, useCount: 0 };
    }
    cacheEntry.useCount++;
    return cacheEntry.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(shader) {
    const key = this._hashShader(shader);
    const cacheEntry = this._cache[key];
    if (cacheEntry) {
      cacheEntry.useCount--;
      if (cacheEntry.useCount === 0) {
        if (this.destroyPolicy === "unused") {
          delete this._cache[key];
          cacheEntry.shader.destroy();
        }
      }
    }
  }
  // PRIVATE
  _hashShader(value) {
    return `${value.stage}:${value.source}`;
  }
};
__publicField(_ShaderFactory, "defaultProps", { ...Shader.defaultProps });
var ShaderFactory = _ShaderFactory;

// node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js
function getDebugTableForShaderLayout(layout, name2) {
  const table = {};
  const header = "Values";
  if (layout.attributes.length === 0 && !layout.varyings?.length) {
    return { "No attributes or varyings": { [header]: "N/A" } };
  }
  for (const attributeDeclaration of layout.attributes) {
    if (attributeDeclaration) {
      const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
      table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || "vertex" };
    }
  }
  for (const varyingDeclaration of layout.varyings || []) {
    const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
    table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration) };
  }
  return table;
}

// node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js
var canvas = null;
var ctx = null;
function debugFramebuffer(fbo, { id, minimap, opaque, top = "0", left = "0", rgbaScale = 1 }) {
  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.id = id;
    canvas.title = id;
    canvas.style.zIndex = "100";
    canvas.style.position = "absolute";
    canvas.style.top = top;
    canvas.style.left = left;
    canvas.style.border = "blue 5px solid";
    canvas.style.transform = "scaleY(-1)";
    document.body.appendChild(canvas);
    ctx = canvas.getContext("2d");
  }
  if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
    canvas.width = fbo.width / 2;
    canvas.height = fbo.height / 2;
    canvas.style.width = "400px";
    canvas.style.height = "400px";
  }
  const color = fbo.device.readPixelsToArrayWebGL(fbo);
  const imageData = ctx?.createImageData(fbo.width, fbo.height);
  if (imageData) {
    const offset = 0;
    for (let i3 = 0; i3 < color.length; i3 += 4) {
      imageData.data[offset + i3 + 0] = color[i3 + 0] * rgbaScale;
      imageData.data[offset + i3 + 1] = color[i3 + 1] * rgbaScale;
      imageData.data[offset + i3 + 2] = color[i3 + 2] * rgbaScale;
      imageData.data[offset + i3 + 3] = opaque ? 255 : color[i3 + 3] * rgbaScale;
    }
    ctx?.putImageData(imageData, 0, 0);
  }
}

// node_modules/@luma.gl/engine/dist/utils/deep-equal.js
function deepEqual(a2, b2, depth) {
  if (a2 === b2) {
    return true;
  }
  if (!depth || !a2 || !b2) {
    return false;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b2) || a2.length !== b2.length) {
      return false;
    }
    for (let i3 = 0; i3 < a2.length; i3++) {
      if (!deepEqual(a2[i3], b2[i3], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b2)) {
    return false;
  }
  if (typeof a2 === "object" && typeof b2 === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b2.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a2[key], b2[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@math.gl/types/dist/is-array.js
function isTypedArray2(value) {
  return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function isNumberArray2(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || typeof value[0] === "number";
  }
  return false;
}
function isNumericArray(value) {
  return isTypedArray2(value) || isNumberArray2(value);
}

// node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js
function isUniformValue(value) {
  return isNumericArray(value) || typeof value === "number" || typeof value === "boolean";
}
function splitUniformsAndBindings(uniforms) {
  const result = { bindings: {}, uniforms: {} };
  Object.keys(uniforms).forEach((name2) => {
    const uniform = uniforms[name2];
    if (isUniformValue(uniform)) {
      result.uniforms[name2] = uniform;
    } else {
      result.bindings[name2] = uniform;
    }
  });
  return result;
}

// node_modules/@luma.gl/engine/dist/shader-inputs.js
var ShaderInputs = class {
  /** Tracks if uniforms have changed */
  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(modules, options) {
    __publicField(this, "options", {
      disableWarnings: false
    });
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */
    // @ts-ignore Fix typings
    __publicField(this, "modules");
    /** Stores the uniform values for each module */
    __publicField(this, "moduleUniforms");
    /** Stores the uniform bindings for each module  */
    __publicField(this, "moduleBindings");
    Object.assign(this.options, options);
    const resolvedModules = getShaderModuleDependencies(Object.values(modules).filter((module) => module.dependencies));
    for (const resolvedModule of resolvedModules) {
      modules[resolvedModule.name] = resolvedModule;
    }
    log2.log(1, "Creating ShaderInputs with modules", Object.keys(modules))();
    this.modules = modules;
    this.moduleUniforms = {};
    this.moduleBindings = {};
    for (const [name2, module] of Object.entries(modules)) {
      this._addModule(module);
      if (module.name && name2 !== module.name && !this.options.disableWarnings) {
        log2.warn(`Module name: ${name2} vs ${module.name}`)();
      }
    }
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(props) {
    for (const name2 of Object.keys(props)) {
      const moduleName = name2;
      const moduleProps = props[moduleName] || {};
      const module = this.modules[moduleName];
      if (!module) {
        if (!this.options.disableWarnings) {
          log2.warn(`Module ${name2} not found`)();
        }
        continue;
      }
      const oldUniforms = this.moduleUniforms[moduleName];
      const oldBindings = this.moduleBindings[moduleName];
      const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;
      const { uniforms, bindings } = splitUniformsAndBindings(uniformsAndBindings);
      this.moduleUniforms[moduleName] = { ...oldUniforms, ...uniforms };
      this.moduleBindings[moduleName] = { ...oldBindings, ...bindings };
    }
  }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindingValues() {
    const bindings = {};
    for (const moduleBindings of Object.values(this.moduleBindings)) {
      Object.assign(bindings, moduleBindings);
    }
    return bindings;
  }
  // INTERNAL
  /** Return a debug table that can be used for console.table() or log.table() */
  getDebugTable() {
    const table = {};
    for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {
      for (const [key, value] of Object.entries(module)) {
        table[`${moduleName}.${key}`] = {
          type: this.modules[moduleName].uniformTypes?.[key],
          value: String(value)
        };
      }
    }
    return table;
  }
  _addModule(module) {
    const moduleName = module.name;
    this.moduleUniforms[moduleName] = module.defaultUniforms || {};
    this.moduleBindings[moduleName] = {};
  }
};

// node_modules/@luma.gl/engine/dist/application-utils/load-file.js
var pathPrefix2 = "";
async function loadImageBitmap(url, opts) {
  const image = new Image();
  image.crossOrigin = opts?.crossOrigin || "anonymous";
  image.src = url.startsWith("http") ? url : pathPrefix2 + url;
  await image.decode();
  return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
}

// node_modules/@luma.gl/engine/dist/async-texture/async-texture.js
var AsyncTexture = class {
  constructor(device, props) {
    __publicField(this, "device");
    __publicField(this, "id");
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    __publicField(this, "texture");
    // @ts-expect-error
    __publicField(this, "sampler");
    // @ts-expect-error
    __publicField(this, "view");
    __publicField(this, "ready");
    __publicField(this, "isReady", false);
    __publicField(this, "destroyed", false);
    __publicField(this, "resolveReady", () => {
    });
    __publicField(this, "rejectReady", () => {
    });
    this.device = device;
    this.id = props.id || uid2("async-texture");
    if (typeof props?.data === "string" && props.dimension === "2d") {
      props = { ...props, data: loadImageBitmap(props.data) };
    }
    this.ready = new Promise((resolve3, reject) => {
      this.resolveReady = () => {
        this.isReady = true;
        resolve3();
      };
      this.rejectReady = reject;
    });
    this.initAsync(props);
  }
  get [Symbol.toStringTag]() {
    return "AsyncTexture";
  }
  toString() {
    return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
  }
  async initAsync(props) {
    const asyncData = props.data;
    let data;
    try {
      data = await awaitAllPromises(asyncData);
    } catch (error) {
      this.rejectReady(error);
    }
    if (this.destroyed) {
      return;
    }
    const syncProps = { ...props, data };
    this.texture = this.device.createTexture(syncProps);
    this.sampler = this.texture.sampler;
    this.view = this.texture.view;
    this.isReady = true;
    this.resolveReady();
  }
  destroy() {
    if (this.texture) {
      this.texture.destroy();
      this.texture = null;
    }
    this.destroyed = true;
  }
  /**
   * Textures are immutable and cannot be resized after creation,
   * but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   * @todo Abort pending promise and create a texture with the new size?
   */
  resize(size) {
    if (!this.isReady) {
      throw new Error("Cannot resize texture before it is ready");
    }
    if (size.width === this.texture.width && size.height === this.texture.height) {
      return false;
    }
    if (this.texture) {
      const texture = this.texture;
      this.texture = texture.clone(size);
      texture.destroy();
    }
    return true;
  }
};
async function awaitAllPromises(x2) {
  x2 = await x2;
  if (Array.isArray(x2)) {
    return await Promise.all(x2.map(awaitAllPromises));
  }
  if (x2 && typeof x2 === "object" && x2.constructor === Object) {
    const object = x2;
    const values = await Promise.all(Object.values(object));
    const keys = Object.keys(object);
    const resolvedObject = {};
    for (let i3 = 0; i3 < keys.length; i3++) {
      resolvedObject[keys[i3]] = values[i3];
    }
    return resolvedObject;
  }
  return x2;
}

// node_modules/@luma.gl/engine/dist/model/model.js
var LOG_DRAW_PRIORITY = 2;
var LOG_DRAW_TIMEOUT = 1e4;
var _Model = class _Model {
  constructor(device, props) {
    __publicField(this, "device");
    __publicField(this, "id");
    // @ts-expect-error assigned in function called from constructor
    __publicField(this, "source");
    // @ts-expect-error assigned in function called from constructor
    __publicField(this, "vs");
    // @ts-expect-error assigned in function called from constructor
    __publicField(this, "fs");
    __publicField(this, "pipelineFactory");
    __publicField(this, "shaderFactory");
    __publicField(this, "userData", {});
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */
    __publicField(this, "parameters");
    /** The primitive topology */
    __publicField(this, "topology");
    /** Buffer layout */
    __publicField(this, "bufferLayout");
    // Dynamic properties
    /** Use instanced rendering */
    __publicField(this, "isInstanced");
    /** instance count. `undefined` means not instanced */
    __publicField(this, "instanceCount", 0);
    /** Vertex count */
    __publicField(this, "vertexCount");
    /** Index buffer */
    __publicField(this, "indexBuffer", null);
    /** Buffer-valued attributes */
    __publicField(this, "bufferAttributes", {});
    /** Constant-valued attributes */
    __publicField(this, "constantAttributes", {});
    /** Bindings (textures, samplers, uniform buffers) */
    __publicField(this, "bindings", {});
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
    __publicField(this, "uniforms", {});
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */
    __publicField(this, "vertexArray");
    /** TransformFeedback, WebGL 2 only. */
    __publicField(this, "transformFeedback", null);
    /** The underlying GPU "program". @note May be recreated if parameters change */
    __publicField(this, "pipeline");
    /** ShaderInputs instance */
    // @ts-expect-error Assigned in function called by constructor
    __publicField(this, "shaderInputs");
    // @ts-expect-error Assigned in function called by constructor
    __publicField(this, "_uniformStore");
    __publicField(this, "_attributeInfos", {});
    __publicField(this, "_gpuGeometry", null);
    __publicField(this, "_getModuleUniforms");
    __publicField(this, "props");
    __publicField(this, "_pipelineNeedsUpdate", "newly created");
    __publicField(this, "_needsRedraw", "initializing");
    __publicField(this, "_destroyed", false);
    /** "Time" of last draw. Monotonically increasing timestamp */
    __publicField(this, "_lastDrawTimestamp", -1);
    /** Throttle draw call logging */
    __publicField(this, "_lastLogTime", 0);
    __publicField(this, "_logOpen", false);
    __publicField(this, "_drawCount", 0);
    var _a5;
    this.props = { ..._Model.defaultProps, ...props };
    props = this.props;
    this.id = props.id || uid2("model");
    this.device = device;
    Object.assign(this.userData, props.userData);
    const moduleMap = Object.fromEntries(this.props.modules?.map((module) => [module.name, module]) || []);
    const shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap, { disableWarnings: this.props.disableWarnings });
    this.setShaderInputs(shaderInputs);
    const platformInfo = getPlatformInfo(device);
    const modules = (
      // @ts-ignore shaderInputs is assigned in setShaderInputs above.
      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || []
    );
    const isWebGPU = this.device.type === "webgpu";
    if (isWebGPU && this.props.source) {
      const { source: source3, getUniforms: getUniforms4 } = this.props.shaderAssembler.assembleWGSLShader({
        platformInfo,
        ...this.props,
        modules
      });
      this.source = source3;
      this._getModuleUniforms = getUniforms4;
      (_a5 = this.props).shaderLayout || (_a5.shaderLayout = getShaderLayoutFromWGSL(this.source));
    } else {
      const { vs: vs8, fs: fs7, getUniforms: getUniforms4 } = this.props.shaderAssembler.assembleGLSLShaderPair({
        platformInfo,
        ...this.props,
        modules
      });
      this.vs = vs8;
      this.fs = fs7;
      this._getModuleUniforms = getUniforms4;
    }
    this.vertexCount = this.props.vertexCount;
    this.instanceCount = this.props.instanceCount;
    this.topology = this.props.topology;
    this.bufferLayout = this.props.bufferLayout;
    this.parameters = this.props.parameters;
    if (props.geometry) {
      this.setGeometry(props.geometry);
    }
    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
    this.pipeline = this._updatePipeline();
    this.vertexArray = device.createVertexArray({
      renderPipeline: this.pipeline
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
    if ("isInstanced" in props) {
      this.isInstanced = props.isInstanced;
    }
    if (props.instanceCount) {
      this.setInstanceCount(props.instanceCount);
    }
    if (props.vertexCount) {
      this.setVertexCount(props.vertexCount);
    }
    if (props.indexBuffer) {
      this.setIndexBuffer(props.indexBuffer);
    }
    if (props.attributes) {
      this.setAttributes(props.attributes);
    }
    if (props.constantAttributes) {
      this.setConstantAttributes(props.constantAttributes);
    }
    if (props.bindings) {
      this.setBindings(props.bindings);
    }
    if (props.uniforms) {
      this.setUniformsWebGL(props.uniforms);
    }
    if (props.moduleSettings) {
      this.updateModuleSettingsWebGL(props.moduleSettings);
    }
    if (props.transformFeedback) {
      this.transformFeedback = props.transformFeedback;
    }
    Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Model";
  }
  toString() {
    return `Model(${this.id})`;
  }
  destroy() {
    if (this._destroyed)
      return;
    this.pipelineFactory.release(this.pipeline);
    this.shaderFactory.release(this.pipeline.vs);
    if (this.pipeline.fs) {
      this.shaderFactory.release(this.pipeline.fs);
    }
    this._uniformStore.destroy();
    this._gpuGeometry?.destroy();
    this._destroyed = true;
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
      this.setNeedsRedraw("contents of bound textures or buffers updated");
    }
    const needsRedraw = this._needsRedraw;
    this._needsRedraw = false;
    return needsRedraw;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(reason) {
    this._needsRedraw || (this._needsRedraw = reason);
  }
  predraw() {
    this.updateShaderInputs();
    this.pipeline = this._updatePipeline();
  }
  draw(renderPass) {
    const loadingBinding = this._areBindingsLoading();
    if (loadingBinding) {
      log2.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
      return false;
    }
    try {
      renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
      this.predraw();
    } finally {
      renderPass.popDebugGroup();
    }
    let drawSuccess;
    try {
      renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
      this._logDrawCallStart();
      this.pipeline = this._updatePipeline();
      const syncBindings = this._getBindings();
      this.pipeline.setBindings(syncBindings, {
        disableWarnings: this.props.disableWarnings
      });
      if (!isObjectEmpty(this.uniforms)) {
        this.pipeline.setUniformsWebGL(this.uniforms);
      }
      const { indexBuffer } = this.vertexArray;
      const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
      drawSuccess = this.pipeline.draw({
        renderPass,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      renderPass.popDebugGroup();
      this._logDrawCallEnd();
    }
    this._logFramebuffer(renderPass);
    if (drawSuccess) {
      this._lastDrawTimestamp = this.device.timestamp;
      this._needsRedraw = false;
    } else {
      this._needsRedraw = "waiting for resource initialization";
    }
    return drawSuccess;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(geometry) {
    this._gpuGeometry?.destroy();
    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
    if (gpuGeometry) {
      this.setTopology(gpuGeometry.topology || "triangle-list");
      const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
      this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
      if (this.vertexArray) {
        this._setGeometryAttributes(gpuGeometry);
      }
    }
    this._gpuGeometry = gpuGeometry;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(topology) {
    if (topology !== this.topology) {
      this.topology = topology;
      this._setPipelineNeedsUpdate("topology");
    }
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(bufferLayout) {
    const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
    this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
    this._setPipelineNeedsUpdate("bufferLayout");
    this.pipeline = this._updatePipeline();
    this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(parameters) {
    if (!deepEqual(parameters, this.parameters, 2)) {
      this.parameters = parameters;
      this._setPipelineNeedsUpdate("parameters");
    }
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(instanceCount) {
    this.instanceCount = instanceCount;
    if (this.isInstanced === void 0 && instanceCount > 0) {
      this.isInstanced = true;
    }
    this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(vertexCount) {
    this.vertexCount = vertexCount;
    this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(shaderInputs) {
    this.shaderInputs = shaderInputs;
    this._uniformStore = new UniformStore(this.shaderInputs.modules);
    for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {
      if (shaderModuleHasUniforms(module)) {
        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
      }
    }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
    this.setBindings(this.shaderInputs.getBindingValues());
    this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(bindings) {
    Object.assign(this.bindings, bindings);
    this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(transformFeedback) {
    this.transformFeedback = transformFeedback;
    this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(indexBuffer) {
    this.vertexArray.setIndexBuffer(indexBuffer);
    this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(buffers, options) {
    const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;
    if (buffers.indices) {
      log2.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    }
    this.bufferLayout = sortedBufferLayoutByShaderSourceLocations(this.pipeline.shaderLayout, this.bufferLayout);
    const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
    for (const [bufferName, buffer] of Object.entries(buffers)) {
      const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
      if (!bufferLayout) {
        if (!disableWarnings) {
          log2.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
        }
        continue;
      }
      const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
      let set6 = false;
      for (const attributeName of attributeNames) {
        const attributeInfo = this._attributeInfos[attributeName];
        if (attributeInfo) {
          const location = this.device.type === "webgpu" ? bufferLayoutHelper.getBufferIndex(attributeInfo.bufferName) : attributeInfo.location;
          this.vertexArray.setBuffer(location, buffer);
          set6 = true;
        }
      }
      if (!set6 && !disableWarnings) {
        log2.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
      }
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(attributes, options) {
    for (const [attributeName, value] of Object.entries(attributes)) {
      const attributeInfo = this._attributeInfos[attributeName];
      if (attributeInfo) {
        this.vertexArray.setConstantWebGL(attributeInfo.location, value);
      } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {
        log2.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
      }
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(uniforms) {
    this.setUniformsWebGL(uniforms);
  }
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniformsWebGL(uniforms) {
    if (!isObjectEmpty(uniforms)) {
      this.pipeline.setUniformsWebGL(uniforms);
      Object.assign(this.uniforms, uniforms);
    }
    this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettingsWebGL(props) {
    const { bindings, uniforms } = splitUniformsAndBindings(this._getModuleUniforms(props));
    Object.assign(this.bindings, bindings);
    Object.assign(this.uniforms, uniforms);
    this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Check that bindings are loaded. Returns id of first binding that is still loading. */
  _areBindingsLoading() {
    for (const binding of Object.values(this.bindings)) {
      if (binding instanceof AsyncTexture && !binding.isReady) {
        return binding.id;
      }
    }
    return false;
  }
  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
  _getBindings() {
    const validBindings = {};
    for (const [name2, binding] of Object.entries(this.bindings)) {
      if (binding instanceof AsyncTexture) {
        if (binding.isReady) {
          validBindings[name2] = binding.texture;
        }
      } else {
        validBindings[name2] = binding;
      }
    }
    return validBindings;
  }
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let timestamp = 0;
    for (const binding of Object.values(this.bindings)) {
      if (binding instanceof TextureView) {
        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
      } else if (binding instanceof Buffer2 || binding instanceof Texture) {
        timestamp = Math.max(timestamp, binding.updateTimestamp);
      } else if (binding instanceof AsyncTexture) {
        timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : (
          // The texture will become available in the future
          Infinity
        );
      } else if (!(binding instanceof Sampler)) {
        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
      }
    }
    return timestamp;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(gpuGeometry) {
    const attributes = { ...gpuGeometry.attributes };
    for (const [attributeName] of Object.entries(attributes)) {
      if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") {
        delete attributes[attributeName];
      }
    }
    this.vertexCount = gpuGeometry.vertexCount;
    this.setIndexBuffer(gpuGeometry.indices || null);
    this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });
    this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });
    this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(reason) {
    this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = reason);
    this.setNeedsRedraw(reason);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let prevShaderVs = null;
      let prevShaderFs = null;
      if (this.pipeline) {
        log2.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
        prevShaderVs = this.pipeline.vs;
        prevShaderFs = this.pipeline.fs;
      }
      this._pipelineNeedsUpdate = false;
      const vs8 = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debugShaders: this.props.debugShaders
      });
      let fs7 = null;
      if (this.source) {
        fs7 = vs8;
      } else if (this.fs) {
        fs7 = this.shaderFactory.createShader({
          id: `${this.id}-fragment`,
          stage: "fragment",
          source: this.source || this.fs,
          debugShaders: this.props.debugShaders
        });
      }
      this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        // TODO - why set bindings here when we reset them every frame?
        // Should we expose a BindGroup abstraction?
        bindings: this._getBindings(),
        vs: vs8,
        fs: fs7
      });
      this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
      if (prevShaderVs)
        this.shaderFactory.release(prevShaderVs);
      if (prevShaderFs)
        this.shaderFactory.release(prevShaderFs);
    }
    return this.pipeline;
  }
  _logDrawCallStart() {
    const logDrawTimeout = log2.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (log2.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
      return;
    }
    this._lastLogTime = Date.now();
    this._logOpen = true;
    log2.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log2.level <= 2 })();
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
      log2.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
      const uniformTable = this.shaderInputs.getDebugTable();
      for (const [name2, value] of Object.entries(this.uniforms)) {
        uniformTable[name2] = { value };
      }
      log2.table(LOG_DRAW_PRIORITY, uniformTable)();
      const attributeTable = this._getAttributeDebugTable();
      log2.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
      log2.table(LOG_DRAW_PRIORITY, attributeTable)();
      log2.groupEnd(LOG_DRAW_PRIORITY)();
      this._logOpen = false;
    }
  }
  _logFramebuffer(renderPass) {
    const debugFramebuffers = this.device.props.debugFramebuffers;
    this._drawCount++;
    if (!debugFramebuffers) {
      return;
    }
    const framebuffer = renderPass.props.framebuffer;
    if (framebuffer) {
      debugFramebuffer(framebuffer, { id: framebuffer.id, minimap: true });
    }
  }
  _getAttributeDebugTable() {
    const table = {};
    for (const [name2, attributeInfo] of Object.entries(this._attributeInfos)) {
      const values = this.vertexArray.attributes[attributeInfo.location];
      table[attributeInfo.location] = {
        name: name2,
        type: attributeInfo.shaderType,
        values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : "null"
      };
    }
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer } = this.vertexArray;
      const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
      table.indices = {
        name: "indices",
        type: indexBuffer.indexType,
        values: values.toString()
      };
    }
    return table;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(attribute, dataType) {
    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);
    const typedArray = attribute instanceof Buffer2 ? new TypedArrayConstructor(attribute.debugData) : attribute;
    return typedArray.toString();
  }
};
__publicField(_Model, "defaultProps", {
  ...RenderPipeline.defaultProps,
  source: void 0,
  vs: null,
  fs: null,
  id: "unnamed",
  handle: void 0,
  userData: {},
  defines: {},
  modules: [],
  moduleSettings: void 0,
  geometry: null,
  indexBuffer: null,
  attributes: {},
  constantAttributes: {},
  varyings: [],
  isInstanced: void 0,
  instanceCount: 0,
  vertexCount: 0,
  shaderInputs: void 0,
  pipelineFactory: void 0,
  shaderFactory: void 0,
  transformFeedback: void 0,
  shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
  debugShaders: void 0,
  disableWarnings: void 0
});
var Model = _Model;
function shaderModuleHasUniforms(module) {
  return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));
}
function getPlatformInfo(device) {
  return {
    type: device.type,
    shaderLanguage: device.info.shadingLanguage,
    shaderLanguageVersion: device.info.shadingLanguageVersion,
    gpu: device.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: device.features
  };
}
function isObjectEmpty(obj) {
  for (const key in obj) {
    return false;
  }
  return true;
}

// node_modules/@luma.gl/engine/dist/compute/buffer-transform.js
var _BufferTransform = class _BufferTransform {
  constructor(device, props = _BufferTransform.defaultProps) {
    __publicField(this, "device");
    __publicField(this, "model");
    __publicField(this, "transformFeedback");
    if (!_BufferTransform.isSupported(device)) {
      throw new Error("BufferTransform not yet implemented on WebGPU");
    }
    this.device = device;
    this.model = new Model(this.device, {
      id: props.id || "buffer-transform-model",
      fs: props.fs || getPassthroughFS(),
      topology: props.topology || "point-list",
      varyings: props.outputs || props.varyings,
      ...props
    });
    this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      // @ts-expect-error TODO
      buffers: props.feedbackBuffers
    });
    this.model.setTransformFeedback(this.transformFeedback);
    Object.seal(this);
  }
  static isSupported(device) {
    return device?.info?.type === "webgl";
  }
  /** Destroy owned resources. */
  destroy() {
    if (this.model) {
      this.model.destroy();
    }
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(options) {
    if (options?.inputBuffers) {
      this.model.setAttributes(options.inputBuffers);
    }
    if (options?.outputBuffers) {
      this.transformFeedback.setBuffers(options.outputBuffers);
    }
    const renderPass = this.device.beginRenderPass(options);
    this.model.draw(renderPass);
    renderPass.end();
  }
  // DEPRECATED METHODS
  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(varyingName) {
    return this.transformFeedback.getBuffer(varyingName);
  }
  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
  readAsync(varyingName) {
    const result = this.getBuffer(varyingName);
    if (!result) {
      throw new Error("BufferTransform#getBuffer");
    }
    if (result instanceof Buffer2) {
      return result.readAsync();
    }
    const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
    return buffer.readAsync(byteOffset, byteLength);
  }
};
__publicField(_BufferTransform, "defaultProps", {
  ...Model.defaultProps,
  outputs: void 0,
  feedbackBuffers: void 0
});
var BufferTransform = _BufferTransform;

// node_modules/@luma.gl/engine/dist/geometry/geometry.js
var Geometry = class {
  constructor(props) {
    __publicField(this, "id");
    /** Determines how vertices are read from the 'vertex' attributes */
    __publicField(this, "topology");
    __publicField(this, "vertexCount");
    __publicField(this, "indices");
    __publicField(this, "attributes");
    __publicField(this, "userData", {});
    const { attributes = {}, indices = null, vertexCount = null } = props;
    this.id = props.id || uid2("geometry");
    this.topology = props.topology;
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? { value: indices, size: 1 } : indices;
    }
    this.attributes = {};
    for (const [attributeName, attributeValue] of Object.entries(attributes)) {
      const attribute = ArrayBuffer.isView(attributeValue) ? { value: attributeValue } : attributeValue;
      if (!ArrayBuffer.isView(attribute.value)) {
        throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
      }
      if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
        attribute.size = 3;
      }
      if (attributeName === "indices") {
        if (this.indices) {
          throw new Error("Multiple indices detected");
        }
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }
    if (this.indices && this.indices.isIndexed !== void 0) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }
    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(attributeName) {
    return `Geometry ${this.id} attribute ${attributeName}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(attributes, indices) {
    return this;
  }
  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attribute of Object.values(attributes)) {
      const { value, size, constant } = attribute;
      if (!constant && value && size !== void 0 && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }
    return vertexCount;
  }
};

// node_modules/@deck.gl/core/dist/passes/pick-layers-pass.js
var PICKING_BLENDING = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
var PickLayersPass = class extends LayersPass {
  constructor() {
    super(...arguments);
    this._colorEncoderState = null;
  }
  render(props) {
    if ("pickingFBO" in props) {
      return this._drawPickingBuffer(props);
    }
    return super.render(props);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers, layerFilter, views, viewports, onViewportActive, pickingFBO, deviceRect: { x: x2, y: y2, width, height }, cullRect, effects, pass = "picking", pickZ, shaderModuleProps }) {
    this.pickZ = pickZ;
    const colorEncoderState = this._resetColorEncoder(pickZ);
    const scissorRect = [x2, y2, width, height];
    const renderStatus = super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      cullRect,
      effects: effects?.filter((e2) => e2.useInPicking),
      pass,
      isPicking: true,
      shaderModuleProps,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect
    });
    this._colorEncoderState = null;
    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
    return { decodePickingColor, stats: renderStatus };
  }
  shouldDrawLayer(layer) {
    const { pickable, operation } = layer.props;
    return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      lighting: { enabled: false }
    };
  }
  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = {
      ...layer.props.parameters
    };
    const { pickable, operation } = layer.props;
    if (!this._colorEncoderState || operation.includes("terrain")) {
      pickParameters.blend = false;
    } else if (pickable && operation.includes("draw")) {
      Object.assign(pickParameters, PICKING_BLENDING);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
    }
    return pickParameters;
  }
  _resetColorEncoder(pickZ) {
    this._colorEncoderState = pickZ ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    };
    return this._colorEncoderState;
  }
};
function encodeColor(encoded, layer, viewport) {
  const { byLayer, byAlpha } = encoded;
  let a2;
  let entry = byLayer.get(layer);
  if (entry) {
    entry.viewports.push(viewport);
    a2 = entry.a;
  } else {
    a2 = byLayer.size + 1;
    if (a2 <= 255) {
      entry = { a: a2, layer, viewports: [viewport] };
      byLayer.set(layer, entry);
      byAlpha[a2] = entry;
    } else {
      log_default.warn("Too many pickable layers, only picking the first 255")();
      a2 = 0;
    }
  }
  return [0, 0, 0, a2 / 255];
}
function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}

// node_modules/@deck.gl/core/dist/lifecycle/constants.js
var LIFECYCLE = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
};
var COMPONENT_SYMBOL = Symbol.for("component");
var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

// node_modules/@deck.gl/core/dist/utils/flatten.js
function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }
  return flattenArray(array, filter, []);
}
function flattenArray(array, filter, result) {
  let index = -1;
  while (++index < array.length) {
    const value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }
  return result;
}
function fillArray({ target: target2, source: source3, start = 0, count: count2 = 1 }) {
  const length5 = source3.length;
  const total = count2 * length5;
  let copied = 0;
  for (let i3 = start; copied < length5; copied++) {
    target2[i3++] = source3[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target2.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target2.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target2;
}

// node_modules/@deck.gl/core/dist/lib/resource/resource.js
var Resource2 = class {
  constructor(id, data, context) {
    this._loadCount = 0;
    this._subscribers = /* @__PURE__ */ new Set();
    this.id = id;
    this.context = context;
    this.setData(data);
  }
  // consumer: {onChange: Function}
  subscribe(consumer) {
    this._subscribers.add(consumer);
  }
  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(data, forceUpdate) {
    if (data === this._data && !forceUpdate) {
      return;
    }
    this._data = data;
    const loadCount = ++this._loadCount;
    let loader = data;
    if (typeof data === "string") {
      loader = load2(data);
    }
    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then((result) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = void 0;
          this._content = result;
        }
      }).catch((error) => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = void 0;
      this._content = data;
    }
    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/resource/resource-manager.js
var ResourceManager = class {
  constructor(props) {
    this.protocol = props.protocol || "resource://";
    this._context = {
      device: props.device,
      // @ts-expect-error
      gl: props.device?.gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }
  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }
    return resourceId in this._resources;
  }
  add({ resourceId, data, forceUpdate = false, persistent = true }) {
    let res = this._resources[resourceId];
    if (res) {
      res.setData(data, forceUpdate);
    } else {
      res = new Resource2(resourceId, data, this._context);
      this._resources[resourceId] = res;
    }
    res.persistent = persistent;
  }
  remove(resourceId) {
    const res = this._resources[resourceId];
    if (res) {
      res.delete();
      delete this._resources[resourceId];
    }
  }
  unsubscribe({ consumerId }) {
    const consumer = this._consumers[consumerId];
    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];
        const resource = this._resources[request.resourceId];
        if (resource) {
          resource.unsubscribe(request);
        }
      }
      delete this._consumers[consumerId];
      this.prune();
    }
  }
  subscribe({ resourceId, onChange, consumerId, requestId = "default" }) {
    const { _resources: resources, protocol } = this;
    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, "");
      if (!resources[resourceId]) {
        this.add({ resourceId, data: null, persistent: false });
      }
    }
    const res = resources[resourceId];
    this._track(consumerId, requestId, res, onChange);
    if (res) {
      return res.getData();
    }
    return void 0;
  }
  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }
  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }
  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    let request = consumer[requestId];
    const oldResource = request && request.resourceId && this._resources[request.resourceId];
    if (oldResource) {
      oldResource.unsubscribe(request);
      this.prune();
    }
    if (resource) {
      if (request) {
        request.onChange = onChange;
        request.resourceId = resource.id;
      } else {
        request = {
          onChange,
          resourceId: resource.id
        };
      }
      consumer[requestId] = request;
      resource.subscribe(request);
    }
  }
  _prune() {
    this._pruneRequest = null;
    for (const key of Object.keys(this._resources)) {
      const res = this._resources[key];
      if (!res.persistent && !res.inUse()) {
        res.delete();
        delete this._resources[key];
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/layer-manager.js
var TRACE_SET_LAYERS = "layerManager.setLayers";
var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
var LayerManager = class {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(device, props) {
    this._lastRenderedLayers = [];
    this._needsRedraw = false;
    this._needsUpdate = false;
    this._nextLayers = null;
    this._debug = false;
    this._defaultShaderModulesChanged = false;
    this.activateViewport = (viewport2) => {
      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport2);
      if (viewport2) {
        this.context.viewport = viewport2;
      }
    };
    const { deck, stats, viewport, timeline } = props || {};
    this.layers = [];
    this.resourceManager = new ResourceManager({ device, protocol: "deck://" });
    this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device,
      // @ts-expect-error
      gl: device?.gl,
      deck,
      shaderAssembler: getShaderAssembler(device?.info?.shadingLanguage || "glsl"),
      defaultShaderModules: [layerUniforms],
      renderPass: void 0,
      stats: stats || new Stats({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: viewport || new viewport_default({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: timeline || new Timeline(),
      resourceManager: this.resourceManager,
      onError: void 0
    };
    Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }
  /** Check if a redraw is needed */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }
    return redraw;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
      return "layers changed";
    }
    if (this._defaultShaderModulesChanged) {
      return "shader modules changed";
    }
    return this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds } = {}) {
    return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(props) {
    if ("debug" in props) {
      this._debug = props.debug;
    }
    if ("userData" in props) {
      this.context.userData = props.userData;
    }
    if ("layers" in props) {
      this._nextLayers = props.layers;
    }
    if ("onError" in props) {
      this.context.onError = props.onError;
    }
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(newLayers, reason) {
    debug(TRACE_SET_LAYERS, this, reason, newLayers);
    this._lastRenderedLayers = newLayers;
    const flatLayers = flatten(newLayers, Boolean);
    for (const layer of flatLayers) {
      layer.context = this.context;
    }
    this._updateLayers(this.layers, flatLayers);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const reason = this.needsUpdate();
    if (reason) {
      this.setNeedsRedraw(`updating layers: ${reason}`);
      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
    }
    this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(module) {
    const { defaultShaderModules } = this.context;
    if (!defaultShaderModules.find((m2) => m2.name === module.name)) {
      defaultShaderModules.push(module);
      this._defaultShaderModulesChanged = true;
    }
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(module) {
    const { defaultShaderModules } = this.context;
    const i3 = defaultShaderModules.findIndex((m2) => m2.name === module.name);
    if (i3 >= 0) {
      defaultShaderModules.splice(i3, 1);
      this._defaultShaderModulesChanged = true;
    }
  }
  _handleError(stage, error, layer) {
    layer.raiseError(error, `${stage} of ${layer}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};
    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        log_default.warn(`Multiple old layers with same id ${oldLayer.id}`)();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }
    if (this._defaultShaderModulesChanged) {
      for (const layer of oldLayers) {
        layer.setNeedsUpdate();
        layer.setChangeFlags({ extensionsChanged: true });
      }
      this._defaultShaderModulesChanged = false;
    }
    const generatedLayers = [];
    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
    this._finalizeOldLayers(oldLayerMap);
    let needsUpdate = false;
    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = `Uniform transition in ${layer}`;
        break;
      }
    }
    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];
      if (oldLayer === null) {
        log_default.warn(`Multiple new layers with same id ${newLayer.id}`)();
      }
      oldLayerMap[newLayer.id] = null;
      let sublayers = null;
      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }
        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);
          this._updateLayer(newLayer);
        }
        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
      } catch (err2) {
        this._handleError("matching", err2, newLayer);
      }
      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];
      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(layer) {
    try {
      layer._initialize();
      layer.lifecycle = LIFECYCLE.INITIALIZED;
    } catch (err2) {
      this._handleError("initialization", err2, layer);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);
    newLayer.lifecycle = LIFECYCLE.MATCHED;
    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
    }
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err2) {
      this._handleError("update", err2, layer);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;
    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
    try {
      layer._finalize();
      layer.lifecycle = LIFECYCLE.FINALIZED;
    } catch (err2) {
      this._handleError("finalization", err2, layer);
    }
  }
};

// node_modules/@deck.gl/core/dist/utils/deep-equal.js
function deepEqual2(a2, b2, depth) {
  if (a2 === b2) {
    return true;
  }
  if (!depth || !a2 || !b2) {
    return false;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b2) || a2.length !== b2.length) {
      return false;
    }
    for (let i3 = 0; i3 < a2.length; i3++) {
      if (!deepEqual2(a2[i3], b2[i3], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b2)) {
    return false;
  }
  if (typeof a2 === "object" && typeof b2 === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b2.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual2(a2[key], b2[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/core/dist/lib/view-manager.js
var ViewManager = class {
  constructor(props) {
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = "First render";
    this._needsUpdate = "Initialize";
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const key in this.controllers) {
      const controller = this.controllers[key];
      if (controller) {
        controller.finalize();
      }
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];
      if (controller) {
        controller.updateTransition();
      }
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(rect) {
    if (rect) {
      return this._viewports.filter((viewport) => viewport.containsPixel(rect));
    }
    return this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const viewMap = {};
    this.views.forEach((view) => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }
  /** Resolves a viewId string to a View */
  getView(viewId) {
    return this.views.find((view) => view.id === viewId);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(viewOrViewId) {
    const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }
  getViewport(viewId) {
    return this._viewportMap[viewId];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = { x: xyz[0], y: xyz[1] };
    for (let i3 = viewports.length - 1; i3 >= 0; --i3) {
      const viewport = viewports[i3];
      if (viewport.containsPixel(pixel)) {
        const p2 = xyz.slice();
        p2[0] -= viewport.x;
        p2[1] -= viewport.y;
        return viewport.unproject(p2, opts);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(props) {
    if (props.views) {
      this._setViews(props.views);
    }
    if (props.viewState) {
      this._setViewState(props.viewState);
    }
    if ("width" in props || "height" in props) {
      this._setSize(props.width, props.height);
    }
    if (!this._isUpdating) {
      this._update();
    }
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = true;
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    this._isUpdating = false;
  }
  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate("Size changed");
    }
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(views) {
    views = flatten(views, Boolean);
    const viewsChanged = this._diffViews(views, this.views);
    if (viewsChanged) {
      this.setNeedsUpdate("views changed");
    }
    this.views = views;
  }
  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !deepEqual2(viewState, this.viewState, 3);
      if (viewStateChanged) {
        this.setNeedsUpdate("viewState changed");
      }
      this.viewState = viewState;
    } else {
      log_default.warn("missing `viewState` or `initialViewState`")();
    }
  }
  _createController(view, props) {
    const Controller2 = props.type;
    const controller = new Controller2({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (viewState) => this.getView(view.id)?.makeViewport({
        viewState,
        width: this.width,
        height: this.height
      })
    });
    return controller;
  }
  _updateController(view, viewState, viewport, controller) {
    const controllerProps = view.controller;
    if (controllerProps && viewport) {
      const resolvedProps = {
        ...viewState,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };
      if (!controller || controller.constructor !== controllerProps.type) {
        controller = this._createController(view, resolvedProps);
      }
      if (controller) {
        controller.setProps(resolvedProps);
      }
      return controller;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;
    for (let i3 = views.length; i3--; ) {
      const view = views[i3];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({ viewState, width: this.width, height: this.height });
      let oldController = oldControllers[view.id];
      const hasController = Boolean(view.controller);
      if (hasController && !oldController) {
        invalidateControllers = true;
      }
      if ((invalidateControllers || !hasController) && oldController) {
        oldController.finalize();
        oldController = null;
      }
      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
      if (viewport) {
        this._viewports.unshift(viewport);
      }
    }
    for (const id in oldControllers) {
      const oldController = oldControllers[id];
      if (oldController && !this.controllers[id]) {
        oldController.finalize();
      }
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {};
    this._viewports.forEach((viewport) => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }
    return newViews.some((_2, i3) => !newViews[i3].equals(oldViews[i3]));
  }
};

// node_modules/@deck.gl/core/dist/utils/positions.js
var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
  switch (typeof value) {
    case "number":
      return {
        position: value,
        relative: false
      };
    case "string":
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);
      if (match && match.length >= 3) {
        const relative = match[2] === "%";
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    default:
      throw new Error(`Could not parse position string ${value}`);
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}

// node_modules/@deck.gl/core/dist/views/view.js
var View = class {
  constructor(props) {
    const { id, x: x2 = 0, y: y2 = 0, width = "100%", height = "100%", padding = null } = props;
    this.id = id || this.constructor.displayName || "view";
    this.props = { ...props, id: this.id };
    this._x = parsePosition(x2);
    this._y = parsePosition(y2);
    this._width = parsePosition(width);
    this._height = parsePosition(height);
    this._padding = padding && {
      left: parsePosition(padding.left || 0),
      right: parsePosition(padding.right || 0),
      top: parsePosition(padding.top || 0),
      bottom: parsePosition(padding.bottom || 0)
    };
    this.equals = this.equals.bind(this);
    Object.seal(this);
  }
  equals(view) {
    if (this === view) {
      return true;
    }
    return this.constructor === view.constructor && deepEqual2(this.props, view.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width, height, viewState }) {
    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({ width, height });
    if (!viewportDimensions.height || !viewportDimensions.width) {
      return null;
    }
    const ViewportType = this.getViewportType(viewState);
    return new ViewportType({ ...viewState, ...this.props, ...viewportDimensions });
  }
  getViewStateId() {
    const { viewState } = this.props;
    if (typeof viewState === "string") {
      return viewState;
    }
    return viewState?.id || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === "object") {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }
      const newViewState = { ...viewState };
      for (const key in this.props.viewState) {
        if (key !== "id") {
          newViewState[key] = this.props.viewState[key];
        }
      }
      return newViewState;
    }
    return viewState;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width, height }) {
    const dimensions = {
      x: getPosition(this._x, width),
      y: getPosition(this._y, height),
      width: getPosition(this._width, width),
      height: getPosition(this._height, height)
    };
    if (this._padding) {
      dimensions.padding = {
        left: getPosition(this._padding.left, width),
        top: getPosition(this._padding.top, height),
        right: getPosition(this._padding.right, width),
        bottom: getPosition(this._padding.bottom, height)
      };
    }
    return dimensions;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const opts = this.props.controller;
    if (!opts) {
      return null;
    }
    if (opts === true) {
      return { type: this.ControllerType };
    }
    if (typeof opts === "function") {
      return { type: opts };
    }
    return { type: this.ControllerType, ...opts };
  }
};

// node_modules/@deck.gl/core/dist/transitions/transition.js
var Transition = class {
  /**
   * @params timeline {Timeline}
   */
  constructor(timeline) {
    this._inProgress = false;
    this._handle = null;
    this.time = 0;
    this.settings = {
      duration: 0
    };
    this._timeline = timeline;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(settings) {
    this.cancel();
    this.settings = settings;
    this._inProgress = true;
    this.settings.onStart?.(this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    if (this._inProgress) {
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
      this.settings.onEnd?.(this);
    }
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    if (this._inProgress) {
      this.settings.onInterrupt?.(this);
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
    }
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    if (!this._inProgress) {
      return false;
    }
    if (this._handle === null) {
      const { _timeline: timeline, settings } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }
    this.time = this._timeline.getTime(this._handle);
    this._onUpdate();
    this.settings.onUpdate?.(this);
    if (this._timeline.isFinished(this._handle)) {
      this.end();
    }
    return true;
  }
  /* Private API */
  _onUpdate() {
  }
};

// node_modules/@deck.gl/core/dist/controllers/transition-manager.js
var noop2 = () => {
};
var TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
var DEFAULT_EASING = (t2) => t2;
var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
var TransitionManager = class {
  constructor(opts) {
    this._onTransitionUpdate = (transition) => {
      const { time, settings: { interpolator, startProps, endProps, duration, easing } } = transition;
      const t2 = easing(time / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t2);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    };
    this.getControllerState = opts.getControllerState;
    this.propsInTransition = null;
    this.transition = new Transition(opts.timeline);
    this.onViewStateChange = opts.onViewStateChange || noop2;
    this.onStateChange = opts.onStateChange || noop2;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    this.props = nextProps;
    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return false;
    }
    if (this._isTransitionEnabled(nextProps)) {
      let startProps = currentProps;
      if (this.transition.inProgress) {
        const { interruption, endProps } = this.transition.settings;
        startProps = {
          ...currentProps,
          ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
        };
      }
      this._triggerTransition(startProps, nextProps);
      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }
    return transitionTriggered;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(props) {
    const { transitionDuration, transitionInterpolator } = props;
    return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
  }
  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress && this.propsInTransition) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }
    return false;
  }
  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      const transitionSettings = this.transition.settings;
      return transitionSettings.interruption === TRANSITION_EVENTS.IGNORE || // Ignore update if it is due to current active transition.
      this._isUpdateDueToCurrentTransition(nextProps);
    }
    if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }
    return true;
  }
  _triggerTransition(startProps, endProps) {
    const startViewstate = this.getControllerState(startProps);
    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
    const transitionInterpolator = endProps.transitionInterpolator;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
    if (duration === 0) {
      return;
    }
    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    const transitionSettings = {
      duration,
      easing: endProps.transitionEasing || DEFAULT_EASING,
      interpolator: transitionInterpolator,
      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    };
    this.transition.start(transitionSettings);
    this.onStateChange({ inTransition: true });
    this.updateTransition();
  }
  _onTransitionEnd(callback) {
    return (transition) => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback?.(transition);
    };
  }
};

// node_modules/@deck.gl/core/dist/utils/assert.js
function assert8(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "deck.gl: assertion failed.");
  }
}

// node_modules/@deck.gl/core/dist/transitions/transition-interpolator.js
var TransitionInterpolator = class {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(opts) {
    const { compare, extract, required } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract || compare;
    this._requiredProps = required;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare) {
      if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(startProps, endProps) {
    const startViewStateProps = {};
    const endViewStateProps = {};
    for (const key of this._propsToExtract) {
      if (key in startProps || key in endProps) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }
    }
    this._checkRequiredProps(startViewStateProps);
    this._checkRequiredProps(endViewStateProps);
    return { start: startViewStateProps, end: endViewStateProps };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }
  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }
    this._requiredProps.forEach((propName) => {
      const value = props[propName];
      assert8(Number.isFinite(value) || Array.isArray(value), `${propName} is required for transition`);
    });
  }
};

// node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js
var DEFAULT_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
var LinearInterpolator = class extends TransitionInterpolator {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    const normalizedOpts = Array.isArray(opts) ? {} : opts;
    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
      compare: transitionProps,
      required: transitionProps
    } : transitionProps || {
      compare: DEFAULT_PROPS3,
      required: DEFAULT_REQUIRED_PROPS
    };
    super(normalizedOpts.transitionProps);
    this.opts = normalizedOpts;
  }
  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const { makeViewport, around } = this.opts;
    if (makeViewport && around) {
      const startViewport = makeViewport(startProps);
      const endViewport = makeViewport(endProps);
      const aroundPosition = startViewport.unproject(around);
      result.start.around = around;
      Object.assign(result.end, {
        around: endViewport.project(aroundPosition),
        aroundPosition,
        width: endProps.width,
        height: endProps.height
      });
    }
    return result;
  }
  interpolateProps(startProps, endProps, t2) {
    const propsInTransition = {};
    for (const key of this._propsToExtract) {
      propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t2);
    }
    if (endProps.aroundPosition && this.opts.makeViewport) {
      const viewport = this.opts.makeViewport({ ...endProps, ...propsInTransition });
      Object.assign(propsInTransition, viewport.panByPosition(
        endProps.aroundPosition,
        // anchor point in current screen coordinates
        lerp(startProps.around, endProps.around, t2)
      ));
    }
    return propsInTransition;
  }
};

// node_modules/@deck.gl/core/dist/controllers/controller.js
var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var DEFAULT_INERTIA = 300;
var INERTIA_EASING = (t2) => 1 - (1 - t2) * (1 - t2);
var EVENT_TYPES = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
  DOUBLE_CLICK: ["dblclick"],
  KEYBOARD: ["keydown"]
};
var pinchEventWorkaround = {};
var Controller = class {
  constructor(opts) {
    this.state = {};
    this._events = {};
    this._interactionState = {
      isDragging: false
    };
    this._customEvents = [];
    this._eventStartBlocked = null;
    this._panMove = false;
    this.invertPan = false;
    this.dragMode = "rotate";
    this.inertia = 0;
    this.scrollZoom = true;
    this.dragPan = true;
    this.dragRotate = true;
    this.doubleClickZoom = true;
    this.touchZoom = true;
    this.touchRotate = false;
    this.keyboard = true;
    this.transitionManager = new TransitionManager({
      ...opts,
      getControllerState: (props) => new this.ControllerState(props),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    this.handleEvent = this.handleEvent.bind(this);
    this.eventManager = opts.eventManager;
    this.onViewStateChange = opts.onViewStateChange || (() => {
    });
    this.onStateChange = opts.onStateChange || (() => {
    });
    this.makeViewport = opts.makeViewport;
  }
  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;
    if (this.props) {
      this.setProps(this.props);
    }
  }
  finalize() {
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        this.eventManager?.off(eventName, this.handleEvent);
      }
    }
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(event) {
    this._controllerState = void 0;
    const eventStartBlocked = this._eventStartBlocked;
    switch (event.type) {
      case "panstart":
        return eventStartBlocked ? false : this._onPanStart(event);
      case "panmove":
        return this._onPan(event);
      case "panend":
        return this._onPanEnd(event);
      case "pinchstart":
        return eventStartBlocked ? false : this._onPinchStart(event);
      case "pinchmove":
        return this._onPinch(event);
      case "pinchend":
        return this._onPinchEnd(event);
      case "multipanstart":
        return eventStartBlocked ? false : this._onMultiPanStart(event);
      case "multipanmove":
        return this._onMultiPan(event);
      case "multipanend":
        return this._onMultiPanEnd(event);
      case "dblclick":
        return this._onDoubleClick(event);
      case "wheel":
        return this._onWheel(event);
      case "keydown":
        return this._onKeyDown(event);
      default:
        return false;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    });
    return this._controllerState;
  }
  getCenter(event) {
    const { x: x2, y: y2 } = this.props;
    const { offsetCenter } = event;
    return [offsetCenter.x - x2, offsetCenter.y - y2];
  }
  isPointInBounds(pos, event) {
    const { width, height } = this.props;
    if (event && event.handled) {
      return false;
    }
    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
    if (inside && event) {
      event.stopPropagation();
    }
    return inside;
  }
  isFunctionKeyPressed(event) {
    const { srcEvent } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || false;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }
  /**
   * Extract interactivity options
   */
  setProps(props) {
    if (props.dragMode) {
      this.dragMode = props.dragMode;
    }
    this.props = props;
    if (!("transitionInterpolator" in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }
    this.transitionManager.processViewStateChange(props);
    const { inertia } = props;
    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
    const { scrollZoom = true, dragPan = true, dragRotate = true, doubleClickZoom = true, touchZoom = true, touchRotate = false, keyboard = true } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.MULTI_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_CLICK, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach((eventName) => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;
          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(newControllerState, extraProps = null, interactionState = {}) {
    const viewState = { ...newControllerState.getViewportProps(), ...extraProps };
    const changed = this.controllerState !== newControllerState;
    this.state = newControllerState.getState();
    this._setInteractionState(interactionState);
    if (changed) {
      const oldViewState = this.controllerState && this.controllerState.getViewportProps();
      if (this.onViewStateChange) {
        this.onViewStateChange({ viewState, interactionState: this._interactionState, oldViewState, viewId: this.props.id });
      }
    }
  }
  _onTransition(params) {
    this.onViewStateChange({ ...params, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);
    this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
    if (this.invertPan || this.dragMode === "pan") {
      alternateMode = !alternateMode;
    }
    const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }
  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }
  _onPanMoveEnd(event) {
    const { inertia } = this;
    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [
        pos[0] + event.velocityX * inertia / 2,
        pos[1] + event.velocityY * inertia / 2
      ];
      const newControllerState = this.controllerState.pan({ pos: endPos }).panEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }
    return true;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onPanRotateEnd(event) {
    const { inertia } = this;
    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [
        pos[0] + event.velocityX * inertia / 2,
        pos[1] + event.velocityY * inertia / 2
      ];
      const newControllerState = this.controllerState.rotate({ pos: endPos }).rotateEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  // Default handler for the `wheel` event.
  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    event.srcEvent.preventDefault();
    const { speed = 0.01, smooth = false } = this.scrollZoom === true ? {} : this.scrollZoom;
    const { delta } = event;
    let scale7 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
    if (delta < 0 && scale7 !== 0) {
      scale7 = 1 / scale7;
    }
    const transitionProps = smooth ? { ...this._getTransitionProps({ around: pos }), transitionDuration: 250 } : NO_TRANSITION_PROPS;
    const newControllerState = this.controllerState.zoom({ pos, scale: scale7 });
    this.updateViewport(newControllerState, transitionProps, {
      isZooming: true,
      isPanning: true
    });
    return true;
  }
  _onMultiPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.rotateStart({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  _onMultiPan(event) {
    if (!this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({ pos });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onMultiPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const { inertia } = this;
    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({ pos: endPos });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.zoomStart({ pos }).rotateStart({ pos });
    pinchEventWorkaround._startPinchRotation = event.rotation;
    pinchEventWorkaround._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
    return true;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    let newControllerState = this.controllerState;
    if (this.touchZoom) {
      const { scale: scale7 } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({ pos, scale: scale7 });
    }
    if (this.touchRotate) {
      const { rotation } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
      });
    }
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    pinchEventWorkaround._lastPinchEvent = event;
    return true;
  }
  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const { inertia } = this;
    const { _lastPinchEvent } = pinchEventWorkaround;
    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z2 = Math.log2(event.scale);
      const velocityZ = (z2 - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
      const endScale = Math.pow(2, z2 + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({ pos, scale: endScale }).zoomEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({ around: pos }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }
    pinchEventWorkaround._startPinchRotation = null;
    pinchEventWorkaround._lastPinchEvent = null;
    return true;
  }
  // Default handler for the `dblclick` event.
  _onDoubleClick(event) {
    if (!this.doubleClickZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({ pos, scale: isZoomOut ? 0.5 : 2 });
    this.updateViewport(newControllerState, this._getTransitionProps({ around: pos }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }
  // Default handler for the `keydown` event
  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }
    const funcKey = this.isFunctionKeyPressed(event);
    const { zoomSpeed, moveSpeed, rotateSpeedX, rotateSpeedY } = this.keyboard === true ? {} : this.keyboard;
    const { controllerState } = this;
    let newControllerState;
    const interactionState = {};
    switch (event.srcEvent.code) {
      case "Minus":
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "Equal":
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case "ArrowLeft":
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowRight":
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowUp":
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case "ArrowDown":
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      default:
        return false;
    }
    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }
  _getTransitionProps(opts) {
    const { transition } = this;
    if (!transition || !transition.transitionInterpolator) {
      return NO_TRANSITION_PROPS;
    }
    return opts ? {
      ...transition,
      transitionInterpolator: new LinearInterpolator({
        ...opts,
        ...transition.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : transition;
  }
};

// node_modules/@deck.gl/core/dist/controllers/view-state.js
var ViewState = class {
  constructor(props, state) {
    this._viewportProps = this.applyConstraints(props);
    this._state = state;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
};

// node_modules/@deck.gl/core/dist/controllers/map-controller.js
var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var MapState = class extends ViewState {
  constructor(options) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width,
      /** The height of the viewport */
      height,
      /** The latitude at the center of the viewport */
      latitude,
      /** The longitude at the center of the viewport */
      longitude,
      /** The tile zoom level of the map. */
      zoom,
      /** The bearing of the viewport in degrees */
      bearing = 0,
      /** The pitch of the viewport in degrees */
      pitch = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude = 1.5,
      /** Viewport position */
      position = [0, 0, 0],
      /** Viewport constraints */
      maxZoom = 20,
      minZoom = 0,
      maxPitch = 60,
      minPitch = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat,
      /* Center of the zoom when the operation first started */
      startZoomLngLat,
      /* Pointer position when rotation started */
      startRotatePos,
      /** Bearing when current perspective rotate operation started */
      startBearing,
      /** Pitch when current perspective rotate operation started */
      startPitch,
      /** Zoom when current zoom operation started */
      startZoom,
      /** Normalize viewport props to fit map height into viewport */
      normalize: normalize6 = true
    } = options;
    assert8(Number.isFinite(longitude));
    assert8(Number.isFinite(latitude));
    assert8(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize: normalize6,
      position
    }, {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    });
    this.makeViewport = options.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos, startPos }) {
    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
    if (!startPanLngLat) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
    const { startRotatePos, startBearing, startPitch } = this.getState();
    if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
      return this;
    }
    let newRotation;
    if (pos) {
      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos, startPos, scale: scale7 }) {
    let { startZoom, startZoomLngLat } = this.getState();
    if (!startZoomLngLat) {
      startZoom = this.getViewportProps().zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomLngLat) {
      return this;
    }
    const { maxZoom, minZoom } = this.getViewportProps();
    let zoom = startZoom + Math.log2(scale7);
    zoom = clamp(zoom, minZoom, maxZoom);
    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }
  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }
  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }
  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }
  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }
  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps() };
    const { bearing, longitude } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(props) {
    const { maxZoom, minZoom, zoom } = props;
    props.zoom = clamp(zoom, minZoom, maxZoom);
    const { maxPitch, minPitch, pitch } = props;
    props.pitch = clamp(pitch, minPitch, maxPitch);
    const { normalize: normalize6 = true } = props;
    if (normalize6) {
      Object.assign(props, normalizeViewportProps(props));
    }
    return props;
  }
  /* Private methods */
  _zoomFromCenter(scale7) {
    const { width, height } = this.getViewportProps();
    return this.zoom({
      pos: [width / 2, height / 2],
      scale: scale7
    });
  }
  _panFromCenter(offset) {
    const { width, height } = this.getViewportProps();
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _getNewRotation(pos, startPos, startPitch, startBearing) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const { width, height } = this.getViewportProps();
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;
    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }
    deltaScaleY = clamp(deltaScaleY, -1, 1);
    const { minPitch, maxPitch } = this.getViewportProps();
    const bearing = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;
    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }
    return {
      pitch,
      bearing
    };
  }
};
var MapController = class extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = MapState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    };
    this.dragMode = "pan";
  }
  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.props;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;
    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...props,
        ...this.state
      }));
    }
  }
};

// node_modules/@deck.gl/core/dist/views/map-view.js
var MapView = class extends View {
  constructor(props = {}) {
    super(props);
  }
  getViewportType() {
    return web_mercator_viewport_default;
  }
  get ControllerType() {
    return MapController;
  }
};
MapView.displayName = "MapView";
var map_view_default = MapView;

// node_modules/@deck.gl/core/dist/lib/effect-manager.js
var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
function compareEffects(e1, e2) {
  const o1 = e1.order ?? Infinity;
  const o22 = e2.order ?? Infinity;
  return o1 - o22;
}
var EffectManager = class {
  constructor(context) {
    this._resolvedEffects = [];
    this._defaultEffects = [];
    this.effects = [];
    this._context = context;
    this._needsRedraw = "Initial render";
    this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(effect) {
    const defaultEffects = this._defaultEffects;
    if (!defaultEffects.find((e2) => e2.id === effect.id)) {
      const index = defaultEffects.findIndex((e2) => compareEffects(e2, effect) > 0);
      if (index < 0) {
        defaultEffects.push(effect);
      } else {
        defaultEffects.splice(index, 0, effect);
      }
      effect.setup(this._context);
      this._setEffects(this.effects);
    }
  }
  setProps(props) {
    if ("effects" in props) {
      if (!deepEqual2(props.effects, this.effects, 1)) {
        this._setEffects(props.effects);
      }
    }
  }
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(effects) {
    const oldEffectsMap = {};
    for (const effect of this.effects) {
      oldEffectsMap[effect.id] = effect;
    }
    const nextEffects = [];
    for (const effect of effects) {
      const oldEffect = oldEffectsMap[effect.id];
      let effectToAdd = effect;
      if (oldEffect && oldEffect !== effect) {
        if (oldEffect.setProps) {
          oldEffect.setProps(effect.props);
          effectToAdd = oldEffect;
        } else {
          oldEffect.cleanup(this._context);
        }
      } else if (!oldEffect) {
        effect.setup(this._context);
      }
      nextEffects.push(effectToAdd);
      delete oldEffectsMap[effect.id];
    }
    for (const removedEffectId in oldEffectsMap) {
      oldEffectsMap[removedEffectId].cleanup(this._context);
    }
    this.effects = nextEffects;
    this._resolvedEffects = nextEffects.concat(this._defaultEffects);
    if (!effects.some((effect) => effect instanceof LightingEffect)) {
      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
    }
    this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const effect of this._resolvedEffects) {
      effect.cleanup(this._context);
    }
    this.effects.length = 0;
    this._resolvedEffects.length = 0;
    this._defaultEffects.length = 0;
  }
};

// node_modules/@deck.gl/core/dist/passes/draw-layers-pass.js
var DrawLayersPass = class extends LayersPass {
  shouldDrawLayer(layer) {
    const { operation } = layer.props;
    return operation.includes("draw") || operation.includes("terrain");
  }
};

// node_modules/@deck.gl/core/dist/lib/deck-renderer.js
var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
var DeckRenderer = class {
  constructor(device) {
    this.device = device;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new DrawLayersPass(device);
    this.pickLayersPass = new PickLayersPass(device);
    this.renderCount = 0;
    this._needsRedraw = "Initial render";
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }
  setProps(props) {
    if (this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = "layerFilter changed";
    }
    if (this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = "drawPickingColors changed";
    }
  }
  renderLayers(opts) {
    if (!opts.viewports.length) {
      return;
    }
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    const renderOpts = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...opts
    };
    if (renderOpts.effects) {
      this._preRender(renderOpts.effects, renderOpts);
    }
    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
    if (this.lastPostProcessEffect) {
      renderOpts.clearColor = [0, 0, 0, 0];
      renderOpts.clearCanvas = true;
    }
    const renderStats = layerPass.render({ ...renderOpts, target: outputBuffer });
    if (renderOpts.effects) {
      this._postRender(renderOpts.effects, renderOpts);
    }
    this.renderCount++;
    debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
  }
  needsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  finalize() {
    const { renderBuffers } = this;
    for (const buffer of renderBuffers) {
      buffer.delete();
    }
    renderBuffers.length = 0;
  }
  _preRender(effects, opts) {
    this.lastPostProcessEffect = null;
    opts.preRenderStats = opts.preRenderStats || {};
    for (const effect of effects) {
      opts.preRenderStats[effect.id] = effect.preRender(opts);
      if (effect.postRender) {
        this.lastPostProcessEffect = effect.id;
      }
    }
    if (this.lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }
  }
  _resizeRenderBuffers() {
    const { renderBuffers } = this;
    const size = this.device.canvasContext.getDrawingBufferSize();
    if (renderBuffers.length === 0) {
      [0, 1].map((i3) => {
        const texture = this.device.createTexture({
          sampler: { minFilter: "linear", magFilter: "linear" }
        });
        renderBuffers.push(this.device.createFramebuffer({
          id: `deck-renderbuffer-${i3}`,
          colorAttachments: [texture]
        }));
      });
    }
    for (const buffer of renderBuffers) {
      buffer.resize(size);
    }
  }
  _postRender(effects, opts) {
    const { renderBuffers } = this;
    const params = {
      ...opts,
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1]
    };
    for (const effect of effects) {
      if (effect.postRender) {
        params.target = effect.id === this.lastPostProcessEffect ? opts.target : void 0;
        const buffer = effect.postRender(params);
        params.inputBuffer = buffer;
        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/picking/query-object.js
var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function getClosestObject({ pickedColors, decodePickingColor, deviceX, deviceY, deviceRadius, deviceRect }) {
  const { x: x2, y: y2, width, height } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i3 = 0;
  for (let row = 0; row < height; row++) {
    const dy = row + y2 - deviceY;
    const dy2 = dy * dy;
    if (dy2 > minSquareDistanceToCenter) {
      i3 += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i3 + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const dx = col + x2 - deviceX;
          const d2 = dx * dx + dy2;
          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i3;
          }
        }
        i3 += 4;
      }
    }
  }
  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);
    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return {
        ...pickedObject,
        pickedColor,
        pickedX: x2 + dx,
        pickedY: y2 + dy
      };
    }
    log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects({ pickedColors, decodePickingColor }) {
  const uniqueColors = /* @__PURE__ */ new Map();
  if (pickedColors) {
    for (let i3 = 0; i3 < pickedColors.length; i3 += 4) {
      const pickedLayerIndex = pickedColors[i3 + 3] - 1;
      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i3, i3 + 4);
        const colorKey = pickedColor.join(",");
        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);
          if (pickedObject) {
            uniqueColors.set(colorKey, {
              ...pickedObject,
              color: pickedColor
            });
          } else {
            log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}

// node_modules/@deck.gl/core/dist/lib/picking/pick-info.js
function getEmptyPickingInfo({ pickInfo, viewports, pixelRatio, x: x2, y: y2, z: z2 }) {
  let pickedViewport = viewports[0];
  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates(pickInfo?.pickedViewports || viewports, { x: x2, y: y2 });
  }
  let coordinate;
  if (pickedViewport) {
    const point = [x2 - pickedViewport.x, y2 - pickedViewport.y];
    if (z2 !== void 0) {
      point[2] = z2;
    }
    coordinate = pickedViewport.unproject(point);
  }
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x: x2,
    y: y2,
    pixel: [x2, y2],
    coordinate,
    devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const { pickInfo, lastPickedInfo, mode, layers } = opts;
  const { pickedColor, pickedLayer, pickedObjectIndex } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === "hover") {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  const baseInfo = getEmptyPickingInfo(opts);
  const infos = /* @__PURE__ */ new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach((layer) => {
    let info = { ...baseInfo };
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({ layer, info, mode });
    const rootLayer = info.layer;
    if (layer === pickedLayer && mode === "hover") {
      lastPickedInfo.info = info;
    }
    infos.set(rootLayer.id, info);
    if (mode === "hover") {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({ layer, info, mode }) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({ info, mode, sourceLayer });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(viewports, pixel) {
  for (let i3 = viewports.length - 1; i3 >= 0; i3--) {
    const viewport = viewports[i3];
    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }
  return viewports[0];
}

// node_modules/@deck.gl/core/dist/lib/deck-picker.js
var DeckPicker = class {
  constructor(device) {
    this._pickable = true;
    this.device = device;
    this.pickLayersPass = new PickLayersPass(device);
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(props) {
    if ("layerFilter" in props) {
      this.layerFilter = props.layerFilter;
    }
    if ("_pickable" in props) {
      this._pickable = props._pickable;
    }
  }
  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.destroy();
    }
    if (this.depthFBO) {
      this.depthFBO.destroy();
    }
  }
  /** Pick the closest info at given coordinate */
  pickObject(opts) {
    return this._pickClosestObject(opts);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: x2, y: y2, layers, viewports }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find((l2) => l2.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find((v2) => v2.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x2 - viewport.x, y2 - viewport.y]);
    const info = {
      x: x2,
      y: y2,
      viewport,
      coordinate,
      layer
    };
    return { ...lastPickedInfo, ...info };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    if (!this.pickingFBO) {
      this.pickingFBO = this.device.createFramebuffer({
        colorAttachments: ["rgba8unorm"],
        depthStencilAttachment: "depth16unorm"
      });
      if (this.device.isTextureFormatRenderable("rgba32float")) {
        const depthFBO = this.device.createFramebuffer({
          colorAttachments: ["rgba32float"],
          depthStencilAttachment: "depth16unorm"
        });
        this.depthFBO = depthFBO;
      }
    }
    const { canvas: canvas2 } = this.device.getDefaultCanvasContext();
    this.pickingFBO?.resize({ width: canvas2.width, height: canvas2.height });
    this.depthFBO?.resize({ width: canvas2.width, height: canvas2.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }
    const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers, views, viewports, x: x2, y: y2, radius = 0, depth = 1, mode = "query", unproject3D, onViewportActive, effects }) {
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return {
        result: [],
        emptyInfo: getEmptyPickingInfo({ viewports, x: x2, y: y2, pixelRatio })
      };
    }
    this._resizeBuffer();
    const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const devicePixel = [
      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
    ];
    const deviceRadius = Math.round(radius * pixelRatio);
    const { width, height } = this.pickingFBO;
    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    const cullRect = {
      x: x2 - radius,
      y: y2 - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = /* @__PURE__ */ new Set();
    for (let i3 = 0; i3 < depth; i3++) {
      let pickInfo;
      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: `picking:${mode}`
        });
        pickInfo = getClosestObject({
          ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }
      let z2;
      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const { pickedColors: pickedColors2 } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: `picking:${mode}:z`
        }, true);
        if (pickedColors2[3]) {
          z2 = pickedColors2[0];
        }
      }
      if (pickInfo.pickedLayer && i3 + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }
      infos = processPickInfo({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x: x2,
        y: y2,
        z: z2,
        pixelRatio
      });
      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }
      if (!pickInfo.pickedColor) {
        break;
      }
    }
    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }
    return { result, emptyInfo: infos.get(null) };
  }
  /** Pick all objects within the given bounding box */
  // eslint-disable-next-line max-statements
  _pickVisibleObjects({ layers, views, viewports, x: x2, y: y2, width = 1, height = 1, mode = "query", maxObjects = null, onViewportActive, effects }) {
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers || viewports.length === 0) {
      return [];
    }
    this._resizeBuffer();
    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
    const leftTop = this.device.canvasContext.cssToDevicePixels([x2, y2], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = this.device.canvasContext.cssToDevicePixels([x2 + width, y2 + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: { x: x2, y: y2, width, height },
      effects,
      pass: `picking:${mode}`
    });
    const pickInfos = getUniqueObjects(pickedResult);
    const uniquePickedObjects = /* @__PURE__ */ new Map();
    const uniqueInfos = [];
    const limitMaxObjects = Number.isFinite(maxObjects);
    for (let i3 = 0; i3 < pickInfos.length; i3++) {
      if (limitMaxObjects && uniqueInfos.length >= maxObjects) {
        break;
      }
      const pickInfo = pickInfos[i3];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x: x2,
        y: y2,
        pixelRatio
      };
      info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });
      const pickedLayerId = info.layer.id;
      if (!uniquePickedObjects.has(pickedLayerId)) {
        uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
      }
      const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
      const pickedObjectKey = info.object ?? info.index;
      if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
        uniqueObjectsInLayer.add(pickedObjectKey);
        uniqueInfos.push(info);
      }
    }
    return uniqueInfos;
  }
  _drawAndSample({ layers, views, viewports, onViewportActive, deviceRect, cullRect, effects, pass }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {},
      isPicking: true
    };
    for (const effect of effects) {
      if (effect.useInPicking) {
        opts.preRenderStats[effect.id] = effect.preRender(opts);
      }
    }
    const { decodePickingColor } = this.pickLayersPass.render(opts);
    const { x: x2, y: y2, width, height } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    this.device.readPixelsToArrayWebGL(pickingFBO, {
      sourceX: x2,
      sourceY: y2,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return { pickedColors, decodePickingColor };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect({ deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight }) {
    const x2 = Math.max(0, deviceX - deviceRadius);
    const y2 = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x2;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y2;
    if (width <= 0 || height <= 0) {
      return null;
    }
    return { x: x2, y: y2, width, height };
  }
};

// node_modules/@deck.gl/core/dist/lib/widget-manager.js
var PLACEMENTS = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
};
var DEFAULT_PLACEMENT = "top-left";
var ROOT_CONTAINER_ID = "__root";
var WidgetManager = class {
  constructor({ deck, parentElement }) {
    this.defaultWidgets = [];
    this.widgets = [];
    this.resolvedWidgets = [];
    this.containers = {};
    this.lastViewports = {};
    this.deck = deck;
    this.parentElement = parentElement;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(props) {
    if (props.widgets && !deepEqual2(props.widgets, this.widgets, 1)) {
      this._setWidgets(props.widgets);
    }
  }
  finalize() {
    for (const widget of this.getWidgets()) {
      this._remove(widget);
    }
    this.defaultWidgets.length = 0;
    this.resolvedWidgets.length = 0;
    for (const id in this.containers) {
      this.containers[id].remove();
    }
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(widget) {
    if (!this.defaultWidgets.find((w3) => w3.id === widget.id)) {
      this._add(widget);
      this.defaultWidgets.push(widget);
      this._setWidgets(this.widgets);
    }
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(nextWidgets) {
    const oldWidgetMap = {};
    for (const widget of this.resolvedWidgets) {
      oldWidgetMap[widget.id] = widget;
    }
    this.resolvedWidgets.length = 0;
    for (const widget of this.defaultWidgets) {
      oldWidgetMap[widget.id] = null;
      this.resolvedWidgets.push(widget);
    }
    for (let widget of nextWidgets) {
      const oldWidget = oldWidgetMap[widget.id];
      if (!oldWidget) {
        this._add(widget);
      } else if (
        // Widget placement changed
        oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement
      ) {
        this._remove(oldWidget);
        this._add(widget);
      } else if (widget !== oldWidget) {
        oldWidget.setProps(widget.props);
        widget = oldWidget;
      }
      oldWidgetMap[widget.id] = null;
      this.resolvedWidgets.push(widget);
    }
    for (const id in oldWidgetMap) {
      const oldWidget = oldWidgetMap[id];
      if (oldWidget) {
        this._remove(oldWidget);
      }
    }
    this.widgets = nextWidgets;
  }
  _add(widget) {
    const { viewId = null, placement = DEFAULT_PLACEMENT } = widget;
    const element = widget.onAdd({ deck: this.deck, viewId });
    if (element) {
      this._getContainer(viewId, placement).append(element);
    }
    widget._element = element;
  }
  _remove(widget) {
    widget.onRemove?.();
    if (widget._element) {
      widget._element.remove();
    }
    widget._element = void 0;
  }
  /* global document */
  _getContainer(viewId, placement) {
    const containerId = viewId || ROOT_CONTAINER_ID;
    let viewContainer = this.containers[containerId];
    if (!viewContainer) {
      viewContainer = document.createElement("div");
      viewContainer.style.pointerEvents = "none";
      viewContainer.style.position = "absolute";
      viewContainer.style.overflow = "hidden";
      this.parentElement?.append(viewContainer);
      this.containers[containerId] = viewContainer;
    }
    let container = viewContainer.querySelector(`.${placement}`);
    if (!container) {
      container = document.createElement("div");
      container.className = placement;
      container.style.position = "absolute";
      container.style.zIndex = "2";
      Object.assign(container.style, PLACEMENTS[placement]);
      viewContainer.append(container);
    }
    return container;
  }
  _updateContainers() {
    const canvasWidth = this.deck.width;
    const canvasHeight = this.deck.height;
    for (const id in this.containers) {
      const viewport = this.lastViewports[id] || null;
      const visible = id === ROOT_CONTAINER_ID || viewport;
      const container = this.containers[id];
      if (visible) {
        container.style.display = "block";
        container.style.left = `${viewport ? viewport.x : 0}px`;
        container.style.top = `${viewport ? viewport.y : 0}px`;
        container.style.width = `${viewport ? viewport.width : canvasWidth}px`;
        container.style.height = `${viewport ? viewport.height : canvasHeight}px`;
      } else {
        container.style.display = "none";
      }
    }
  }
  onRedraw({ viewports, layers }) {
    const viewportsById = viewports.reduce((acc, v2) => {
      acc[v2.id] = v2;
      return acc;
    }, {});
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (viewId) {
        const viewport = viewportsById[viewId];
        if (viewport) {
          if (widget.onViewportChange) {
            widget.onViewportChange(viewport);
          }
          widget.onRedraw?.({ viewports: [viewport], layers });
        }
      } else {
        if (widget.onViewportChange) {
          for (const viewport of viewports) {
            widget.onViewportChange(viewport);
          }
        }
        widget.onRedraw?.({ viewports, layers });
      }
    }
    this.lastViewports = viewportsById;
    this._updateContainers();
  }
  onHover(info, event) {
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (!viewId || viewId === info.viewport?.id) {
        widget.onHover?.(info, event);
      }
    }
  }
  onEvent(info, event) {
    const eventHandlerProp = EVENT_HANDLERS[event.type];
    if (!eventHandlerProp) {
      return;
    }
    for (const widget of this.getWidgets()) {
      const { viewId } = widget;
      if (!viewId || viewId === info.viewport?.id) {
        widget[eventHandlerProp]?.(info, event);
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/tooltip.js
var defaultStyle = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
var Tooltip = class {
  constructor() {
    this.id = "default-tooltip";
    this.placement = "fill";
    this.props = {};
    this.isVisible = false;
  }
  onAdd({ deck }) {
    const el = document.createElement("div");
    el.className = "deck-tooltip";
    Object.assign(el.style, defaultStyle);
    this.deck = deck;
    this.element = el;
    return el;
  }
  onRemove() {
    this.deck = void 0;
    this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(viewport) {
    if (this.isVisible && viewport.id === this.lastViewport?.id && viewport !== this.lastViewport) {
      this.setTooltip(null);
    }
  }
  onHover(info) {
    const { deck } = this;
    const getTooltip = deck && deck.props.getTooltip;
    if (!getTooltip) {
      return;
    }
    const displayInfo = getTooltip(info);
    this.lastViewport = info.viewport;
    this.setTooltip(displayInfo, info.x, info.y);
  }
  setTooltip(displayInfo, x2, y2) {
    const el = this.element;
    if (!el) {
      return;
    }
    if (typeof displayInfo === "string") {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = "none";
      return;
    } else {
      if (displayInfo.text) {
        el.innerText = displayInfo.text;
      }
      if (displayInfo.html) {
        el.innerHTML = displayInfo.html;
      }
      if (displayInfo.className) {
        el.className = displayInfo.className;
      }
    }
    this.isVisible = true;
    el.style.display = "block";
    el.style.transform = `translate(${x2}px, ${y2}px)`;
    if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
      Object.assign(el.style, displayInfo.style);
    }
  }
};

// node_modules/@luma.gl/constants/dist/webgl-constants.js
var GLEnum;
(function(GLEnum2) {
  GLEnum2[GLEnum2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
  GLEnum2[GLEnum2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
  GLEnum2[GLEnum2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
  GLEnum2[GLEnum2["POINTS"] = 0] = "POINTS";
  GLEnum2[GLEnum2["LINES"] = 1] = "LINES";
  GLEnum2[GLEnum2["LINE_LOOP"] = 2] = "LINE_LOOP";
  GLEnum2[GLEnum2["LINE_STRIP"] = 3] = "LINE_STRIP";
  GLEnum2[GLEnum2["TRIANGLES"] = 4] = "TRIANGLES";
  GLEnum2[GLEnum2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  GLEnum2[GLEnum2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  GLEnum2[GLEnum2["ZERO"] = 0] = "ZERO";
  GLEnum2[GLEnum2["ONE"] = 1] = "ONE";
  GLEnum2[GLEnum2["SRC_COLOR"] = 768] = "SRC_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  GLEnum2[GLEnum2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  GLEnum2[GLEnum2["DST_ALPHA"] = 772] = "DST_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  GLEnum2[GLEnum2["DST_COLOR"] = 774] = "DST_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  GLEnum2[GLEnum2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  GLEnum2[GLEnum2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  GLEnum2[GLEnum2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  GLEnum2[GLEnum2["FUNC_ADD"] = 32774] = "FUNC_ADD";
  GLEnum2[GLEnum2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
  GLEnum2[GLEnum2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
  GLEnum2[GLEnum2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
  GLEnum2[GLEnum2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
  GLEnum2[GLEnum2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
  GLEnum2[GLEnum2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
  GLEnum2[GLEnum2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
  GLEnum2[GLEnum2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
  GLEnum2[GLEnum2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
  GLEnum2[GLEnum2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
  GLEnum2[GLEnum2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
  GLEnum2[GLEnum2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
  GLEnum2[GLEnum2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
  GLEnum2[GLEnum2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
  GLEnum2[GLEnum2["FRONT_FACE"] = 2886] = "FRONT_FACE";
  GLEnum2[GLEnum2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
  GLEnum2[GLEnum2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
  GLEnum2[GLEnum2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
  GLEnum2[GLEnum2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
  GLEnum2[GLEnum2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
  GLEnum2[GLEnum2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
  GLEnum2[GLEnum2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
  GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
  GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
  GLEnum2[GLEnum2["STENCIL_REF"] = 2967] = "STENCIL_REF";
  GLEnum2[GLEnum2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
  GLEnum2[GLEnum2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
  GLEnum2[GLEnum2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
  GLEnum2[GLEnum2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
  GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
  GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
  GLEnum2[GLEnum2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
  GLEnum2[GLEnum2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
  GLEnum2[GLEnum2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
  GLEnum2[GLEnum2["VIEWPORT"] = 2978] = "VIEWPORT";
  GLEnum2[GLEnum2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
  GLEnum2[GLEnum2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
  GLEnum2[GLEnum2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
  GLEnum2[GLEnum2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
  GLEnum2[GLEnum2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
  GLEnum2[GLEnum2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
  GLEnum2[GLEnum2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
  GLEnum2[GLEnum2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
  GLEnum2[GLEnum2["RED_BITS"] = 3410] = "RED_BITS";
  GLEnum2[GLEnum2["GREEN_BITS"] = 3411] = "GREEN_BITS";
  GLEnum2[GLEnum2["BLUE_BITS"] = 3412] = "BLUE_BITS";
  GLEnum2[GLEnum2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
  GLEnum2[GLEnum2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
  GLEnum2[GLEnum2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
  GLEnum2[GLEnum2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
  GLEnum2[GLEnum2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
  GLEnum2[GLEnum2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
  GLEnum2[GLEnum2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
  GLEnum2[GLEnum2["SAMPLES"] = 32937] = "SAMPLES";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
  GLEnum2[GLEnum2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
  GLEnum2[GLEnum2["VENDOR"] = 7936] = "VENDOR";
  GLEnum2[GLEnum2["RENDERER"] = 7937] = "RENDERER";
  GLEnum2[GLEnum2["VERSION"] = 7938] = "VERSION";
  GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
  GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
  GLEnum2[GLEnum2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
  GLEnum2[GLEnum2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
  GLEnum2[GLEnum2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
  GLEnum2[GLEnum2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
  GLEnum2[GLEnum2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  GLEnum2[GLEnum2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
  GLEnum2[GLEnum2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
  GLEnum2[GLEnum2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
  GLEnum2[GLEnum2["CULL_FACE"] = 2884] = "CULL_FACE";
  GLEnum2[GLEnum2["FRONT"] = 1028] = "FRONT";
  GLEnum2[GLEnum2["BACK"] = 1029] = "BACK";
  GLEnum2[GLEnum2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
  GLEnum2[GLEnum2["BLEND"] = 3042] = "BLEND";
  GLEnum2[GLEnum2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  GLEnum2[GLEnum2["DITHER"] = 3024] = "DITHER";
  GLEnum2[GLEnum2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  GLEnum2[GLEnum2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  GLEnum2[GLEnum2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
  GLEnum2[GLEnum2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
  GLEnum2[GLEnum2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
  GLEnum2[GLEnum2["NO_ERROR"] = 0] = "NO_ERROR";
  GLEnum2[GLEnum2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
  GLEnum2[GLEnum2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
  GLEnum2[GLEnum2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
  GLEnum2[GLEnum2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
  GLEnum2[GLEnum2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
  GLEnum2[GLEnum2["CW"] = 2304] = "CW";
  GLEnum2[GLEnum2["CCW"] = 2305] = "CCW";
  GLEnum2[GLEnum2["DONT_CARE"] = 4352] = "DONT_CARE";
  GLEnum2[GLEnum2["FASTEST"] = 4353] = "FASTEST";
  GLEnum2[GLEnum2["NICEST"] = 4354] = "NICEST";
  GLEnum2[GLEnum2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
  GLEnum2[GLEnum2["BYTE"] = 5120] = "BYTE";
  GLEnum2[GLEnum2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  GLEnum2[GLEnum2["SHORT"] = 5122] = "SHORT";
  GLEnum2[GLEnum2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  GLEnum2[GLEnum2["INT"] = 5124] = "INT";
  GLEnum2[GLEnum2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  GLEnum2[GLEnum2["FLOAT"] = 5126] = "FLOAT";
  GLEnum2[GLEnum2["DOUBLE"] = 5130] = "DOUBLE";
  GLEnum2[GLEnum2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  GLEnum2[GLEnum2["ALPHA"] = 6406] = "ALPHA";
  GLEnum2[GLEnum2["RGB"] = 6407] = "RGB";
  GLEnum2[GLEnum2["RGBA"] = 6408] = "RGBA";
  GLEnum2[GLEnum2["LUMINANCE"] = 6409] = "LUMINANCE";
  GLEnum2[GLEnum2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  GLEnum2[GLEnum2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  GLEnum2[GLEnum2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
  GLEnum2[GLEnum2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
  GLEnum2[GLEnum2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
  GLEnum2[GLEnum2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
  GLEnum2[GLEnum2["LINK_STATUS"] = 35714] = "LINK_STATUS";
  GLEnum2[GLEnum2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
  GLEnum2[GLEnum2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
  GLEnum2[GLEnum2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
  GLEnum2[GLEnum2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
  GLEnum2[GLEnum2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
  GLEnum2[GLEnum2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
  GLEnum2[GLEnum2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
  GLEnum2[GLEnum2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
  GLEnum2[GLEnum2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
  GLEnum2[GLEnum2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
  GLEnum2[GLEnum2["NEVER"] = 512] = "NEVER";
  GLEnum2[GLEnum2["LESS"] = 513] = "LESS";
  GLEnum2[GLEnum2["EQUAL"] = 514] = "EQUAL";
  GLEnum2[GLEnum2["LEQUAL"] = 515] = "LEQUAL";
  GLEnum2[GLEnum2["GREATER"] = 516] = "GREATER";
  GLEnum2[GLEnum2["NOTEQUAL"] = 517] = "NOTEQUAL";
  GLEnum2[GLEnum2["GEQUAL"] = 518] = "GEQUAL";
  GLEnum2[GLEnum2["ALWAYS"] = 519] = "ALWAYS";
  GLEnum2[GLEnum2["KEEP"] = 7680] = "KEEP";
  GLEnum2[GLEnum2["REPLACE"] = 7681] = "REPLACE";
  GLEnum2[GLEnum2["INCR"] = 7682] = "INCR";
  GLEnum2[GLEnum2["DECR"] = 7683] = "DECR";
  GLEnum2[GLEnum2["INVERT"] = 5386] = "INVERT";
  GLEnum2[GLEnum2["INCR_WRAP"] = 34055] = "INCR_WRAP";
  GLEnum2[GLEnum2["DECR_WRAP"] = 34056] = "DECR_WRAP";
  GLEnum2[GLEnum2["NEAREST"] = 9728] = "NEAREST";
  GLEnum2[GLEnum2["LINEAR"] = 9729] = "LINEAR";
  GLEnum2[GLEnum2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  GLEnum2[GLEnum2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  GLEnum2[GLEnum2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  GLEnum2[GLEnum2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  GLEnum2[GLEnum2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
  GLEnum2[GLEnum2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
  GLEnum2[GLEnum2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
  GLEnum2[GLEnum2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
  GLEnum2[GLEnum2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  GLEnum2[GLEnum2["TEXTURE"] = 5890] = "TEXTURE";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  GLEnum2[GLEnum2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  GLEnum2[GLEnum2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
  GLEnum2[GLEnum2["TEXTURE0"] = 33984] = "TEXTURE0";
  GLEnum2[GLEnum2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
  GLEnum2[GLEnum2["REPEAT"] = 10497] = "REPEAT";
  GLEnum2[GLEnum2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  GLEnum2[GLEnum2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  GLEnum2[GLEnum2["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
  GLEnum2[GLEnum2["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
  GLEnum2[GLEnum2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  GLEnum2[GLEnum2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  GLEnum2[GLEnum2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  GLEnum2[GLEnum2["INT_VEC2"] = 35667] = "INT_VEC2";
  GLEnum2[GLEnum2["INT_VEC3"] = 35668] = "INT_VEC3";
  GLEnum2[GLEnum2["INT_VEC4"] = 35669] = "INT_VEC4";
  GLEnum2[GLEnum2["BOOL"] = 35670] = "BOOL";
  GLEnum2[GLEnum2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  GLEnum2[GLEnum2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  GLEnum2[GLEnum2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  GLEnum2[GLEnum2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  GLEnum2[GLEnum2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  GLEnum2[GLEnum2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  GLEnum2[GLEnum2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  GLEnum2[GLEnum2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  GLEnum2[GLEnum2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
  GLEnum2[GLEnum2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
  GLEnum2[GLEnum2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
  GLEnum2[GLEnum2["LOW_INT"] = 36339] = "LOW_INT";
  GLEnum2[GLEnum2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
  GLEnum2[GLEnum2["HIGH_INT"] = 36341] = "HIGH_INT";
  GLEnum2[GLEnum2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
  GLEnum2[GLEnum2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
  GLEnum2[GLEnum2["RGBA4"] = 32854] = "RGBA4";
  GLEnum2[GLEnum2["RGB5_A1"] = 32855] = "RGB5_A1";
  GLEnum2[GLEnum2["RGB565"] = 36194] = "RGB565";
  GLEnum2[GLEnum2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
  GLEnum2[GLEnum2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
  GLEnum2[GLEnum2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
  GLEnum2[GLEnum2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  GLEnum2[GLEnum2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
  GLEnum2[GLEnum2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
  GLEnum2[GLEnum2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
  GLEnum2[GLEnum2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
  GLEnum2[GLEnum2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
  GLEnum2[GLEnum2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
  GLEnum2[GLEnum2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
  GLEnum2[GLEnum2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
  GLEnum2[GLEnum2["NONE"] = 0] = "NONE";
  GLEnum2[GLEnum2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
  GLEnum2[GLEnum2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
  GLEnum2[GLEnum2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
  GLEnum2[GLEnum2["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
  GLEnum2[GLEnum2["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
  GLEnum2[GLEnum2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
  GLEnum2[GLEnum2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
  GLEnum2[GLEnum2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  GLEnum2[GLEnum2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
  GLEnum2[GLEnum2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
  GLEnum2[GLEnum2["READ_BUFFER"] = 3074] = "READ_BUFFER";
  GLEnum2[GLEnum2["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
  GLEnum2[GLEnum2["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
  GLEnum2[GLEnum2["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
  GLEnum2[GLEnum2["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
  GLEnum2[GLEnum2["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
  GLEnum2[GLEnum2["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
  GLEnum2[GLEnum2["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
  GLEnum2[GLEnum2["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
  GLEnum2[GLEnum2["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
  GLEnum2[GLEnum2["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
  GLEnum2[GLEnum2["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
  GLEnum2[GLEnum2["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
  GLEnum2[GLEnum2["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
  GLEnum2[GLEnum2["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
  GLEnum2[GLEnum2["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
  GLEnum2[GLEnum2["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
  GLEnum2[GLEnum2["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
  GLEnum2[GLEnum2["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
  GLEnum2[GLEnum2["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
  GLEnum2[GLEnum2["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
  GLEnum2[GLEnum2["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
  GLEnum2[GLEnum2["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
  GLEnum2[GLEnum2["RED"] = 6403] = "RED";
  GLEnum2[GLEnum2["RGB8"] = 32849] = "RGB8";
  GLEnum2[GLEnum2["RGBA8"] = 32856] = "RGBA8";
  GLEnum2[GLEnum2["RGB10_A2"] = 32857] = "RGB10_A2";
  GLEnum2[GLEnum2["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
  GLEnum2[GLEnum2["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
  GLEnum2[GLEnum2["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
  GLEnum2[GLEnum2["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
  GLEnum2[GLEnum2["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
  GLEnum2[GLEnum2["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
  GLEnum2[GLEnum2["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
  GLEnum2[GLEnum2["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
  GLEnum2[GLEnum2["SRGB"] = 35904] = "SRGB";
  GLEnum2[GLEnum2["SRGB8"] = 35905] = "SRGB8";
  GLEnum2[GLEnum2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
  GLEnum2[GLEnum2["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
  GLEnum2[GLEnum2["RGBA32F"] = 34836] = "RGBA32F";
  GLEnum2[GLEnum2["RGB32F"] = 34837] = "RGB32F";
  GLEnum2[GLEnum2["RGBA16F"] = 34842] = "RGBA16F";
  GLEnum2[GLEnum2["RGB16F"] = 34843] = "RGB16F";
  GLEnum2[GLEnum2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  GLEnum2[GLEnum2["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
  GLEnum2[GLEnum2["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
  GLEnum2[GLEnum2["RGB9_E5"] = 35901] = "RGB9_E5";
  GLEnum2[GLEnum2["RGBA32UI"] = 36208] = "RGBA32UI";
  GLEnum2[GLEnum2["RGB32UI"] = 36209] = "RGB32UI";
  GLEnum2[GLEnum2["RGBA16UI"] = 36214] = "RGBA16UI";
  GLEnum2[GLEnum2["RGB16UI"] = 36215] = "RGB16UI";
  GLEnum2[GLEnum2["RGBA8UI"] = 36220] = "RGBA8UI";
  GLEnum2[GLEnum2["RGB8UI"] = 36221] = "RGB8UI";
  GLEnum2[GLEnum2["RGBA32I"] = 36226] = "RGBA32I";
  GLEnum2[GLEnum2["RGB32I"] = 36227] = "RGB32I";
  GLEnum2[GLEnum2["RGBA16I"] = 36232] = "RGBA16I";
  GLEnum2[GLEnum2["RGB16I"] = 36233] = "RGB16I";
  GLEnum2[GLEnum2["RGBA8I"] = 36238] = "RGBA8I";
  GLEnum2[GLEnum2["RGB8I"] = 36239] = "RGB8I";
  GLEnum2[GLEnum2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  GLEnum2[GLEnum2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  GLEnum2[GLEnum2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  GLEnum2[GLEnum2["R8"] = 33321] = "R8";
  GLEnum2[GLEnum2["RG8"] = 33323] = "RG8";
  GLEnum2[GLEnum2["R16F"] = 33325] = "R16F";
  GLEnum2[GLEnum2["R32F"] = 33326] = "R32F";
  GLEnum2[GLEnum2["RG16F"] = 33327] = "RG16F";
  GLEnum2[GLEnum2["RG32F"] = 33328] = "RG32F";
  GLEnum2[GLEnum2["R8I"] = 33329] = "R8I";
  GLEnum2[GLEnum2["R8UI"] = 33330] = "R8UI";
  GLEnum2[GLEnum2["R16I"] = 33331] = "R16I";
  GLEnum2[GLEnum2["R16UI"] = 33332] = "R16UI";
  GLEnum2[GLEnum2["R32I"] = 33333] = "R32I";
  GLEnum2[GLEnum2["R32UI"] = 33334] = "R32UI";
  GLEnum2[GLEnum2["RG8I"] = 33335] = "RG8I";
  GLEnum2[GLEnum2["RG8UI"] = 33336] = "RG8UI";
  GLEnum2[GLEnum2["RG16I"] = 33337] = "RG16I";
  GLEnum2[GLEnum2["RG16UI"] = 33338] = "RG16UI";
  GLEnum2[GLEnum2["RG32I"] = 33339] = "RG32I";
  GLEnum2[GLEnum2["RG32UI"] = 33340] = "RG32UI";
  GLEnum2[GLEnum2["R8_SNORM"] = 36756] = "R8_SNORM";
  GLEnum2[GLEnum2["RG8_SNORM"] = 36757] = "RG8_SNORM";
  GLEnum2[GLEnum2["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
  GLEnum2[GLEnum2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
  GLEnum2[GLEnum2["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
  GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
  GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
  GLEnum2[GLEnum2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  GLEnum2[GLEnum2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  GLEnum2[GLEnum2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  GLEnum2[GLEnum2["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
  GLEnum2[GLEnum2["RG"] = 33319] = "RG";
  GLEnum2[GLEnum2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  GLEnum2[GLEnum2["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
  GLEnum2[GLEnum2["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
  GLEnum2[GLEnum2["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
  GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
  GLEnum2[GLEnum2["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
  GLEnum2[GLEnum2["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
  GLEnum2[GLEnum2["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
  GLEnum2[GLEnum2["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
  GLEnum2[GLEnum2["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
  GLEnum2[GLEnum2["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
  GLEnum2[GLEnum2["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
  GLEnum2[GLEnum2["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
  GLEnum2[GLEnum2["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
  GLEnum2[GLEnum2["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
  GLEnum2[GLEnum2["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
  GLEnum2[GLEnum2["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
  GLEnum2[GLEnum2["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
  GLEnum2[GLEnum2["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
  GLEnum2[GLEnum2["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
  GLEnum2[GLEnum2["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
  GLEnum2[GLEnum2["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
  GLEnum2[GLEnum2["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
  GLEnum2[GLEnum2["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
  GLEnum2[GLEnum2["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
  GLEnum2[GLEnum2["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
  GLEnum2[GLEnum2["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
  GLEnum2[GLEnum2["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
  GLEnum2[GLEnum2["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
  GLEnum2[GLEnum2["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
  GLEnum2[GLEnum2["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
  GLEnum2[GLEnum2["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
  GLEnum2[GLEnum2["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
  GLEnum2[GLEnum2["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
  GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
  GLEnum2[GLEnum2["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
  GLEnum2[GLEnum2["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
  GLEnum2[GLEnum2["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
  GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
  GLEnum2[GLEnum2["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
  GLEnum2[GLEnum2["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
  GLEnum2[GLEnum2["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
  GLEnum2[GLEnum2["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
  GLEnum2[GLEnum2["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
  GLEnum2[GLEnum2["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
  GLEnum2[GLEnum2["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
  GLEnum2[GLEnum2["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
  GLEnum2[GLEnum2["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
  GLEnum2[GLEnum2["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
  GLEnum2[GLEnum2["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
  GLEnum2[GLEnum2["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
  GLEnum2[GLEnum2["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
  GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
  GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
  GLEnum2[GLEnum2["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
  GLEnum2[GLEnum2["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
  GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
  GLEnum2[GLEnum2["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
  GLEnum2[GLEnum2["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
  GLEnum2[GLEnum2["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
  GLEnum2[GLEnum2["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
  GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
  GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
  GLEnum2[GLEnum2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
  GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
  GLEnum2[GLEnum2["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
  GLEnum2[GLEnum2["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
  GLEnum2[GLEnum2["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
  GLEnum2[GLEnum2["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
  GLEnum2[GLEnum2["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
  GLEnum2[GLEnum2["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
  GLEnum2[GLEnum2["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
  GLEnum2[GLEnum2["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
  GLEnum2[GLEnum2["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
  GLEnum2[GLEnum2["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
  GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
  GLEnum2[GLEnum2["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
  GLEnum2[GLEnum2["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
  GLEnum2[GLEnum2["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
  GLEnum2[GLEnum2["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
  GLEnum2[GLEnum2["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
  GLEnum2[GLEnum2["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
  GLEnum2[GLEnum2["UNSIGNALED"] = 37144] = "UNSIGNALED";
  GLEnum2[GLEnum2["SIGNALED"] = 37145] = "SIGNALED";
  GLEnum2[GLEnum2["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
  GLEnum2[GLEnum2["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
  GLEnum2[GLEnum2["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
  GLEnum2[GLEnum2["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
  GLEnum2[GLEnum2["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
  GLEnum2[GLEnum2["COLOR"] = 6144] = "COLOR";
  GLEnum2[GLEnum2["DEPTH"] = 6145] = "DEPTH";
  GLEnum2[GLEnum2["STENCIL"] = 6146] = "STENCIL";
  GLEnum2[GLEnum2["MIN"] = 32775] = "MIN";
  GLEnum2[GLEnum2["MAX"] = 32776] = "MAX";
  GLEnum2[GLEnum2["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
  GLEnum2[GLEnum2["STREAM_READ"] = 35041] = "STREAM_READ";
  GLEnum2[GLEnum2["STREAM_COPY"] = 35042] = "STREAM_COPY";
  GLEnum2[GLEnum2["STATIC_READ"] = 35045] = "STATIC_READ";
  GLEnum2[GLEnum2["STATIC_COPY"] = 35046] = "STATIC_COPY";
  GLEnum2[GLEnum2["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
  GLEnum2[GLEnum2["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
  GLEnum2[GLEnum2["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
  GLEnum2[GLEnum2["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
  GLEnum2[GLEnum2["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
  GLEnum2[GLEnum2["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
  GLEnum2[GLEnum2["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
  GLEnum2[GLEnum2["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
  GLEnum2[GLEnum2["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
  GLEnum2[GLEnum2["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
  GLEnum2[GLEnum2["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
  GLEnum2[GLEnum2["R16_EXT"] = 33322] = "R16_EXT";
  GLEnum2[GLEnum2["RG16_EXT"] = 33324] = "RG16_EXT";
  GLEnum2[GLEnum2["RGB16_EXT"] = 32852] = "RGB16_EXT";
  GLEnum2[GLEnum2["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
  GLEnum2[GLEnum2["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
  GLEnum2[GLEnum2["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
  GLEnum2[GLEnum2["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
  GLEnum2[GLEnum2["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
  GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
  GLEnum2[GLEnum2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  GLEnum2[GLEnum2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  GLEnum2[GLEnum2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
  GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
  GLEnum2[GLEnum2["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
  GLEnum2[GLEnum2["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
  GLEnum2[GLEnum2["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
  GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
  GLEnum2[GLEnum2["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
  GLEnum2[GLEnum2["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
  GLEnum2[GLEnum2["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
  GLEnum2[GLEnum2["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
  GLEnum2[GLEnum2["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
  GLEnum2[GLEnum2["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
  GLEnum2[GLEnum2["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
  GLEnum2[GLEnum2["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
  GLEnum2[GLEnum2["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
  GLEnum2[GLEnum2["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
  GLEnum2[GLEnum2["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
  GLEnum2[GLEnum2["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
  GLEnum2[GLEnum2["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
  GLEnum2[GLEnum2["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
  GLEnum2[GLEnum2["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
  GLEnum2[GLEnum2["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
  GLEnum2[GLEnum2["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
  GLEnum2[GLEnum2["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
  GLEnum2[GLEnum2["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
  GLEnum2[GLEnum2["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
  GLEnum2[GLEnum2["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
  GLEnum2[GLEnum2["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
  GLEnum2[GLEnum2["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
  GLEnum2[GLEnum2["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
  GLEnum2[GLEnum2["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
  GLEnum2[GLEnum2["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
  GLEnum2[GLEnum2["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(GLEnum || (GLEnum = {}));

// node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js
var GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  // TBD
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  // TBD
  [2930]: true,
  [3024]: true,
  [35725]: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [36006]: null,
  [36007]: null,
  [34229]: null,
  [34964]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32926]: false,
  [32928]: false,
  [32938]: 1,
  [32939]: false,
  [3089]: false,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 4294967295,
  [36005]: 4294967295,
  [2962]: 519,
  [2967]: 0,
  [2963]: 4294967295,
  [34816]: 519,
  [36003]: 0,
  [36004]: 4294967295,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  [2978]: [0, 0, 1024, 1024],
  [36389]: null,
  [36662]: null,
  [36663]: null,
  [35053]: null,
  [35055]: null,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};
var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
var hint = (gl, value, key) => gl.hint(key, value);
var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
var bindFramebuffer = (gl, value, key) => {
  const target2 = key === 36006 ? 36009 : 36008;
  return gl.bindFramebuffer(target2, value);
};
var bindBuffer = (gl, value, key) => {
  const bindingMap = {
    [34964]: 34962,
    [36662]: 36662,
    [36663]: 36663,
    [35053]: 35051,
    [35055]: 35052
  };
  const glTarget = bindingMap[key];
  gl.bindBuffer(glTarget, value);
};
function isArray2(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
}
var GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: "blendEquation",
  [34877]: "blendEquation",
  [32969]: "blendFunc",
  [32968]: "blendFunc",
  [32971]: "blendFunc",
  [32970]: "blendFunc",
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [35725]: (gl, value) => gl.useProgram(value),
  [36007]: (gl, value) => gl.bindRenderbuffer(36161, value),
  [36389]: (gl, value) => gl.bindTransformFeedback?.(36386, value),
  [34229]: (gl, value) => gl.bindVertexArray(value),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [36006]: bindFramebuffer,
  [36010]: bindFramebuffer,
  // Buffers
  [34964]: bindBuffer,
  [36662]: bindBuffer,
  [36663]: bindBuffer,
  [35053]: bindBuffer,
  [35055]: bindBuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: "polygonOffset",
  [10752]: "polygonOffset",
  [35977]: enable,
  [32926]: enable,
  [32928]: enable,
  [32938]: "sampleCoverage",
  [32939]: "sampleCoverage",
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: "stencilFuncFront",
  [2967]: "stencilFuncFront",
  [2963]: "stencilFuncFront",
  [34816]: "stencilFuncBack",
  [36003]: "stencilFuncBack",
  [36004]: "stencilFuncBack",
  [2964]: "stencilOpFront",
  [2965]: "stencilOpFront",
  [2966]: "stencilOpFront",
  [34817]: "stencilOpBack",
  [34818]: "stencilOpBack",
  [34819]: "stencilOpBack",
  [2978]: (gl, value) => gl.viewport(...value),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  [34383]: enable,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  [10754]: enable,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  [12288]: enable,
  [12289]: enable,
  [12290]: enable,
  [12291]: enable,
  [12292]: enable,
  [12293]: enable,
  [12294]: enable,
  [12295]: enable,
  // PIXEL PACK/UNPACK MODES
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  // Function-style setters
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    const separateModes = typeof args === "number" ? [args, args] : args;
    gl.blendEquationSeparate(...separateModes);
  },
  blendFunc: (gl, args) => {
    const separateFuncs = args?.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...separateFuncs);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(value[0], value[1] || false),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray2(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
function getValue(glEnum, values, cache3) {
  return values[glEnum] !== void 0 ? values[glEnum] : cache3[glEnum];
}
var GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache3) => gl.blendEquationSeparate(getValue(32777, values, cache3), getValue(34877, values, cache3)),
  blendFunc: (gl, values, cache3) => gl.blendFuncSeparate(getValue(32969, values, cache3), getValue(32968, values, cache3), getValue(32971, values, cache3), getValue(32970, values, cache3)),
  polygonOffset: (gl, values, cache3) => gl.polygonOffset(getValue(32824, values, cache3), getValue(10752, values, cache3)),
  sampleCoverage: (gl, values, cache3) => gl.sampleCoverage(getValue(32938, values, cache3), getValue(32939, values, cache3)),
  stencilFuncFront: (gl, values, cache3) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache3), getValue(2967, values, cache3), getValue(2963, values, cache3)),
  stencilFuncBack: (gl, values, cache3) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache3), getValue(36003, values, cache3), getValue(36004, values, cache3)),
  stencilOpFront: (gl, values, cache3) => gl.stencilOpSeparate(1028, getValue(2964, values, cache3), getValue(2965, values, cache3), getValue(2966, values, cache3)),
  stencilOpBack: (gl, values, cache3) => gl.stencilOpSeparate(1029, getValue(34817, values, cache3), getValue(34818, values, cache3), getValue(34819, values, cache3))
};
var GL_HOOKED_SETTERS = {
  // GENERIC SETTERS
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, value) => update({
    [pname]: value
  }),
  // SPECIFIC SETTERS
  useProgram: (update, value) => update({
    [35725]: value
  }),
  bindRenderbuffer: (update, target2, value) => update({
    [36007]: value
  }),
  bindTransformFeedback: (update, target2, value) => update({
    [36389]: value
  }),
  bindVertexArray: (update, value) => update({
    [34229]: value
  }),
  bindFramebuffer: (update, target2, framebuffer) => {
    switch (target2) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });
      case 36009:
        return update({ [36006]: framebuffer });
      case 36008:
        return update({ [36010]: framebuffer });
      default:
        return null;
    }
  },
  bindBuffer: (update, target2, buffer) => {
    const pname = {
      [34962]: [34964],
      [36662]: [36662],
      [36663]: [36663],
      [35051]: [35053],
      [35052]: [35055]
    }[target2];
    if (pname) {
      return update({ [pname]: buffer });
    }
    return { valueChanged: true };
  },
  blendColor: (update, r2, g3, b2, a2) => update({
    [32773]: new Float32Array([r2, g3, b2, a2])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r2, g3, b2, a2) => update({
    [3106]: new Float32Array([r2, g3, b2, a2])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s2) => update({
    [2961]: s2
  }),
  colorMask: (update, r2, g3, b2, a2) => update({
    [3107]: [r2, g3, b2, a2]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert4) => update({
    [32938]: value,
    [32939]: invert4
  }),
  scissor: (update, x2, y2, width, height) => update({
    [3088]: new Int32Array([x2, y2, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x2, y2, width, height) => update({
    [2978]: [x2, y2, width, height]
  })
};
var isEnabled = (gl, key) => gl.isEnabled(key);
var GL_PARAMETER_GETTERS = {
  [3042]: isEnabled,
  [2884]: isEnabled,
  [2929]: isEnabled,
  [3024]: isEnabled,
  [32823]: isEnabled,
  [32926]: isEnabled,
  [32928]: isEnabled,
  [3089]: isEnabled,
  [2960]: isEnabled,
  [35977]: isEnabled
};
var NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);

// node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js
function setGLParameters(gl, parameters) {
  if (isObjectEmpty2(parameters)) {
    return;
  }
  const compositeSetters = {};
  for (const key in parameters) {
    const glConstant = Number(key);
    const setter2 = GL_PARAMETER_SETTERS[key];
    if (setter2) {
      if (typeof setter2 === "string") {
        compositeSetters[setter2] = true;
      } else {
        setter2(gl, parameters[key], glConstant);
      }
    }
  }
  const cache3 = gl.state && gl.state.cache;
  if (cache3) {
    for (const key in compositeSetters) {
      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, parameters, cache3);
    }
  }
}
function getGLParameters(gl, parameters = GL_PARAMETER_DEFAULTS) {
  if (typeof parameters === "number") {
    const key = parameters;
    const getter = GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetGLParameters(gl) {
  setGLParameters(gl, GL_PARAMETER_DEFAULTS);
}
function isObjectEmpty2(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

// node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js
function deepArrayEqual(x2, y2) {
  if (x2 === y2) {
    return true;
  }
  const isArrayX = Array.isArray(x2) || ArrayBuffer.isView(x2);
  const isArrayY = Array.isArray(y2) || ArrayBuffer.isView(y2);
  if (isArrayX && isArrayY && x2.length === y2.length) {
    for (let i3 = 0; i3 < x2.length; ++i3) {
      if (x2[i3] !== y2[i3]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js
var WebGLStateTracker = class {
  constructor(gl, props) {
    __publicField(this, "gl");
    __publicField(this, "program", null);
    __publicField(this, "stateStack", []);
    __publicField(this, "enable", true);
    __publicField(this, "cache", null);
    __publicField(this, "log");
    __publicField(this, "initialized", false);
    this.gl = gl;
    this.log = props?.log || (() => {
    });
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  static get(gl) {
    return gl.state;
  }
  push(values = {}) {
    this.stateStack.push({});
  }
  pop() {
    const oldValues = this.stateStack[this.stateStack.length - 1];
    setGLParameters(this.gl, oldValues);
    this.stateStack.pop();
  }
  /**
   * Initialize WebGL state caching on a context
   * can be called multiple times to enable/disable
   *
   * @note After calling this function, context state will be cached
   * .push() and .pop() will be available for saving,
   * temporarily modifying, and then restoring state.
   */
  trackState(gl, options) {
    this.cache = options.copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
    if (this.initialized) {
      throw new Error("WebGLStateTracker");
    }
    this.initialized = true;
    this.gl.state = this;
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter2 = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter2);
    }
    installGetterOverride(gl, "getParameter");
    installGetterOverride(gl, "isEnabled");
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const key in values) {
      const value = values[key];
      const cached = this.cache[key];
      if (!deepArrayEqual(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return { valueChanged, oldValue };
  }
};
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get3(pname) {
    if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
      return originalGetterFunc(pname);
    }
    const glState = WebGLStateTracker.get(gl);
    if (!(pname in glState.cache)) {
      glState.cache[pname] = originalGetterFunc(pname);
    }
    return glState.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      glState.cache[pname]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      originalGetterFunc(pname)
    );
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter2) {
  if (!gl[functionName]) {
    return;
  }
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set6(...params) {
    const glState = WebGLStateTracker.get(gl);
    const { valueChanged, oldValue } = setter2(glState._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    const glState = WebGLStateTracker.get(gl);
    if (glState.program !== handle) {
      originalUseProgram(handle);
      glState.program = handle;
    }
  };
}

// node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js
function createBrowserContext(canvas2, props, webglContextAttributes) {
  let errorMessage = "";
  const webglProps = {
    preserveDrawingBuffer: true,
    // failIfMajorPerformanceCaveat: true,
    ...webglContextAttributes
  };
  let gl = null;
  gl || (gl = canvas2.getContext("webgl2", webglProps));
  if (webglProps.failIfMajorPerformanceCaveat) {
    errorMessage || (errorMessage = "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.");
  }
  if (!gl && !webglContextAttributes.failIfMajorPerformanceCaveat) {
    webglProps.failIfMajorPerformanceCaveat = false;
    gl = canvas2.getContext("webgl2", webglProps);
    gl.luma || (gl.luma = {});
    gl.luma.softwareRenderer = true;
  }
  if (!gl) {
    gl = canvas2.getContext("webgl", {});
    if (gl) {
      gl = null;
      errorMessage || (errorMessage = "Your browser only supports WebGL1");
    }
  }
  if (!gl) {
    errorMessage || (errorMessage = "Your browser does not support WebGL");
    throw new Error(`Failed to create WebGL context: ${errorMessage}`);
  }
  const { onContextLost, onContextRestored } = props;
  canvas2.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
  canvas2.addEventListener("webglcontextrestored", (event) => onContextRestored(event), false);
  gl.luma || (gl.luma = {});
  return gl;
}

// node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js
function getWebGLExtension(gl, name2, extensions) {
  if (extensions[name2] === void 0) {
    extensions[name2] = gl.getExtension(name2) || null;
  }
  return extensions[name2];
}

// node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js
function getDeviceInfo(gl, extensions) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  getWebGLExtension(gl, "WEBGL_debug_renderer_info", extensions);
  const ext = extensions.WEBGL_debug_renderer_info;
  const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
  const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
  const vendor = vendorUnmasked || vendorMasked;
  const renderer = rendererUnmasked || rendererMasked;
  const version2 = gl.getParameter(7938);
  const gpu = identifyGPUVendor(vendor, renderer);
  const gpuBackend = identifyGPUBackend(vendor, renderer);
  const gpuType = identifyGPUType(vendor, renderer);
  const shadingLanguage = "glsl";
  const shadingLanguageVersion = 300;
  return {
    type: "webgl",
    gpu,
    gpuType,
    gpuBackend,
    vendor,
    renderer,
    version: version2,
    shadingLanguage,
    shadingLanguageVersion
  };
}
function identifyGPUVendor(vendor, renderer) {
  if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
    return "nvidia";
  }
  if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
    return "intel";
  }
  if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
    return "apple";
  }
  if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
    return "amd";
  }
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "software";
  }
  return "unknown";
}
function identifyGPUBackend(vendor, renderer) {
  if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
    return "metal";
  }
  if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
    return "opengl";
  }
  return "unknown";
}
function identifyGPUType(vendor, renderer) {
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "cpu";
  }
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  switch (gpuVendor) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/vertex-formats.js
function getGLFromVertexType(dataType) {
  switch (dataType) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(dataType));
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js
var X_S3TC = "WEBGL_compressed_texture_s3tc";
var X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
var X_RGTC = "EXT_texture_compression_rgtc";
var X_BPTC = "EXT_texture_compression_bptc";
var X_ETC2 = "WEBGL_compressed_texture_etc";
var X_ASTC = "WEBGL_compressed_texture_astc";
var X_ETC1 = "WEBGL_compressed_texture_etc1";
var X_PVRTC = "WEBGL_compressed_texture_pvrtc";
var X_ATC = "WEBGL_compressed_texture_atc";
var EXT_texture_norm16 = "EXT_texture_norm16";
var EXT_render_snorm = "EXT_render_snorm";
var EXT_color_buffer_float = "EXT_color_buffer_float";
var TEXTURE_FEATURES = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [EXT_render_snorm],
  "norm16-renderable-webgl": [EXT_texture_norm16],
  "snorm16-renderable-webgl": [EXT_texture_norm16, EXT_render_snorm],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [X_RGTC],
  "texture-compression-bc7-webgl": [X_BPTC],
  "texture-compression-etc2": [X_ETC2],
  "texture-compression-astc": [X_ASTC],
  "texture-compression-etc1-webgl": [X_ETC1],
  "texture-compression-pvrtc-webgl": [X_PVRTC],
  "texture-compression-atc-webgl": [X_ATC]
};
function isTextureFeature(feature) {
  return feature in TEXTURE_FEATURES;
}
function checkTextureFeature(gl, feature, extensions) {
  const textureExtensions = TEXTURE_FEATURES[feature] || [];
  return textureExtensions.every((extension) => getWebGLExtension(gl, extension, extensions));
}
var WEBGL_TEXTURE_FORMATS = {
  // 8-bit formats
  "r8unorm": { gl: 33321, rb: true },
  "r8snorm": { gl: 36756 },
  "r8uint": { gl: 33330, rb: true },
  "r8sint": { gl: 33329, rb: true },
  // 16-bit formats
  "rg8unorm": { gl: 33323, rb: true },
  "rg8snorm": { gl: 36757 },
  "rg8uint": { gl: 33336, rb: true },
  "rg8sint": { gl: 33335, rb: true },
  "r16uint": { gl: 33332, rb: true },
  "r16sint": { gl: 33331, rb: true },
  "r16float": { gl: 33325, rb: true },
  "r16unorm-webgl": { gl: 33322, rb: true },
  "r16snorm-webgl": { gl: 36760 },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, rb: true },
  "rgb565unorm-webgl": { gl: 36194, rb: true },
  "rgb5a1unorm-webgl": { gl: 32855, rb: true },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849 },
  "rgb8snorm-webgl": { gl: 36758 },
  // 32-bit formats  
  "rgba8unorm": { gl: 32856 },
  "rgba8unorm-srgb": { gl: 35907 },
  "rgba8snorm": { gl: 36759 },
  "rgba8uint": { gl: 36220 },
  "rgba8sint": { gl: 36238 },
  // reverse colors, webgpu only
  "bgra8unorm": {},
  "bgra8unorm-srgb": {},
  "rg16uint": { gl: 33338 },
  "rg16sint": { gl: 33337 },
  "rg16float": { gl: 33327, rb: true },
  "rg16unorm-webgl": { gl: 33324 },
  "rg16snorm-webgl": { gl: 36761 },
  "r32uint": { gl: 33334, rb: true },
  "r32sint": { gl: 33333, rb: true },
  "r32float": { gl: 33326 },
  // Packed 32-bit formats
  "rgb9e5ufloat": { gl: 35901 },
  // , filter: true},
  "rg11b10ufloat": { gl: 35898, rb: true },
  "rgb10a2unorm": { gl: 32857, rb: true },
  "rgb10a2uint-webgl": { gl: 36975, rb: true },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852 },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762 },
  // rgb not renderable
  // 64-bit formats
  "rg32uint": { gl: 33340, rb: true },
  "rg32sint": { gl: 33339, rb: true },
  "rg32float": { gl: 33328, rb: true },
  "rgba16uint": { gl: 36214, rb: true },
  "rgba16sint": { gl: 36232, rb: true },
  "rgba16float": { gl: 34842 },
  "rgba16unorm-webgl": { gl: 32859, rb: true },
  "rgba16snorm-webgl": { gl: 36763 },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": { gl: 34837, x: EXT_color_buffer_float, dataFormat: 6407, types: [5126] },
  // 128-bit formats
  "rgba32uint": { gl: 36208, rb: true },
  "rgba32sint": { gl: 36226, rb: true },
  "rgba32float": { gl: 34836, rb: true },
  // Depth and stencil formats
  "stencil8": { gl: 36168, rb: true },
  // 8 stencil bits
  "depth16unorm": { gl: 33189, dataFormat: 6402, types: [5123], rb: true },
  // 16 depth bits
  "depth24plus": { gl: 33190, dataFormat: 6402, types: [5125] },
  "depth32float": { gl: 36012, dataFormat: 6402, types: [5126], rb: true },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { gl: 35056, rb: true, depthTexture: true, dataFormat: 34041, types: [34042] },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": { gl: 36013, dataFormat: 34041, types: [36269], rb: true },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: X_S3TC },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: X_S3TC_SRGB },
  "bc1-rgba-unorm": { gl: 33777, x: X_S3TC },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: X_S3TC_SRGB },
  "bc2-rgba-unorm": { gl: 33778, x: X_S3TC },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: X_S3TC_SRGB },
  "bc3-rgba-unorm": { gl: 33779, x: X_S3TC },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: X_S3TC_SRGB },
  "bc4-r-unorm": { gl: 36283, x: X_RGTC },
  "bc4-r-snorm": { gl: 36284, x: X_RGTC },
  "bc5-rg-unorm": { gl: 36285, x: X_RGTC },
  "bc5-rg-snorm": { gl: 36286, x: X_RGTC },
  "bc6h-rgb-ufloat": { gl: 36495, x: X_BPTC },
  "bc6h-rgb-float": { gl: 36494, x: X_BPTC },
  "bc7-rgba-unorm": { gl: 36492, x: X_BPTC },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: X_BPTC },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492 },
  "etc2-rgb8unorm-srgb": { gl: 37494 },
  "etc2-rgb8a1unorm": { gl: 37496 },
  "etc2-rgb8a1unorm-srgb": { gl: 37497 },
  "etc2-rgba8unorm": { gl: 37493 },
  "etc2-rgba8unorm-srgb": { gl: 37495 },
  "eac-r11unorm": { gl: 37488 },
  "eac-r11snorm": { gl: 37489 },
  "eac-rg11unorm": { gl: 37490 },
  "eac-rg11snorm": { gl: 37491 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808 },
  "astc-4x4-unorm-srgb": { gl: 37840 },
  "astc-5x4-unorm": { gl: 37809 },
  "astc-5x4-unorm-srgb": { gl: 37841 },
  "astc-5x5-unorm": { gl: 37810 },
  "astc-5x5-unorm-srgb": { gl: 37842 },
  "astc-6x5-unorm": { gl: 37811 },
  "astc-6x5-unorm-srgb": { gl: 37843 },
  "astc-6x6-unorm": { gl: 37812 },
  "astc-6x6-unorm-srgb": { gl: 37844 },
  "astc-8x5-unorm": { gl: 37813 },
  "astc-8x5-unorm-srgb": { gl: 37845 },
  "astc-8x6-unorm": { gl: 37814 },
  "astc-8x6-unorm-srgb": { gl: 37846 },
  "astc-8x8-unorm": { gl: 37815 },
  "astc-8x8-unorm-srgb": { gl: 37847 },
  "astc-10x5-unorm": { gl: 37819 },
  "astc-10x5-unorm-srgb": { gl: 37851 },
  "astc-10x6-unorm": { gl: 37817 },
  "astc-10x6-unorm-srgb": { gl: 37849 },
  "astc-10x8-unorm": { gl: 37818 },
  "astc-10x8-unorm-srgb": { gl: 37850 },
  "astc-10x10-unorm": { gl: 37819 },
  "astc-10x10-unorm-srgb": { gl: 37851 },
  "astc-12x10-unorm": { gl: 37820 },
  "astc-12x10-unorm-srgb": { gl: 37852 },
  "astc-12x12-unorm": { gl: 37821 },
  "astc-12x12-unorm-srgb": { gl: 37853 },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840 },
  "pvrtc-rgba4unorm-webgl": { gl: 35842 },
  "pvrtc-rbg2unorm-webgl": { gl: 35841 },
  "pvrtc-rgba2unorm-webgl": { gl: 35843 },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196 },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986 },
  "atc-rgba-unorm-webgl": { gl: 35986 },
  "atc-rgbai-unorm-webgl": { gl: 34798 }
};
function getTextureFormatCapabilitiesWebGL(gl, formatSupport, extensions) {
  let supported = formatSupport.create;
  const webglFormatInfo = WEBGL_TEXTURE_FORMATS[formatSupport.format];
  if (webglFormatInfo?.gl === void 0) {
    supported = false;
  }
  if (webglFormatInfo?.x) {
    supported = supported && Boolean(getWebGLExtension(gl, webglFormatInfo.x, extensions));
  }
  return {
    format: formatSupport.format,
    // @ts-ignore
    create: supported && formatSupport.create,
    // @ts-ignore
    render: supported && formatSupport.render,
    // @ts-ignore
    filter: supported && formatSupport.filter,
    // @ts-ignore
    blend: supported && formatSupport.blend,
    // @ts-ignore
    store: supported && formatSupport.store
  };
}
function getTextureFormatWebGL(format) {
  const formatData = WEBGL_TEXTURE_FORMATS[format];
  const webglFormat = convertTextureFormatToGL(format);
  const decoded = decodeTextureFormat(format);
  return {
    internalFormat: webglFormat,
    format: formatData?.dataFormat || getWebGLPixelDataFormat(decoded.channels, decoded.integer, decoded.normalized, webglFormat),
    // depth formats don't have a type
    type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : formatData?.types?.[0] || 5121,
    compressed: decoded.compressed || false
  };
}
function getDepthStencilAttachmentWebGL(format) {
  const formatInfo = decodeTextureFormat(format);
  switch (formatInfo.attachment) {
    case "depth":
      return 36096;
    case "stencil":
      return 36128;
    case "depth-stencil":
      return 33306;
    default:
      throw new Error(`Not a depth stencil format: ${format}`);
  }
}
function getWebGLPixelDataFormat(channels2, integer, normalized, format) {
  if (format === 6408 || format === 6407) {
    return format;
  }
  switch (channels2) {
    case "r":
      return integer && !normalized ? 36244 : 6403;
    case "rg":
      return integer && !normalized ? 33320 : 33319;
    case "rgb":
      return integer && !normalized ? 36248 : 6407;
    case "rgba":
      return integer && !normalized ? 36249 : 6408;
    case "bgra":
      throw new Error("bgra pixels not supported by WebGL");
    default:
      return 6408;
  }
}
function convertTextureFormatToGL(format) {
  const formatInfo = WEBGL_TEXTURE_FORMATS[format];
  const webglFormat = formatInfo?.gl;
  if (webglFormat === void 0) {
    throw new Error(`Unsupported texture format ${format}`);
  }
  return webglFormat;
}

// node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js
var WEBGL_FEATURES = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
var WebGLDeviceFeatures = class extends DeviceFeatures {
  constructor(gl, extensions, disabledFeatures) {
    super([], disabledFeatures);
    __publicField(this, "gl");
    __publicField(this, "extensions");
    __publicField(this, "testedFeatures", /* @__PURE__ */ new Set());
    this.gl = gl;
    this.extensions = extensions;
    getWebGLExtension(gl, "EXT_color_buffer_float", extensions);
  }
  *[Symbol.iterator]() {
    const features = this.getFeatures();
    for (const feature of features) {
      if (this.has(feature)) {
        yield feature;
      }
    }
    return [];
  }
  has(feature) {
    if (this.disabledFeatures?.[feature]) {
      return false;
    }
    if (!this.testedFeatures.has(feature)) {
      this.testedFeatures.add(feature);
      if (isTextureFeature(feature) && checkTextureFeature(this.gl, feature, this.extensions)) {
        this.features.add(feature);
      }
      if (this.getWebGLFeature(feature)) {
        this.features.add(feature);
      }
    }
    return this.features.has(feature);
  }
  // FOR DEVICE
  initializeFeatures() {
    const features = this.getFeatures().filter((feature) => feature !== "polygon-mode-webgl");
    for (const feature of features) {
      this.has(feature);
    }
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(WEBGL_FEATURES), ...Object.keys(TEXTURE_FEATURES)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(feature) {
    const featureInfo = WEBGL_FEATURES[feature];
    const isSupported = typeof featureInfo === "string" ? Boolean(getWebGLExtension(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
    return isSupported;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js
var WebGLDeviceLimits = class extends DeviceLimits {
  constructor(gl) {
    super();
    // WebGL does not support compute shaders
    // PRIVATE
    __publicField(this, "gl");
    __publicField(this, "limits", {});
    this.gl = gl;
  }
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  getParameter(parameter) {
    if (this.limits[parameter] === void 0) {
      this.limits[parameter] = this.gl.getParameter(parameter);
    }
    return this.limits[parameter] || 0;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js
var WEBGLFramebuffer = class extends Framebuffer {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    __publicField(this, "colorAttachments", []);
    __publicField(this, "depthStencilAttachment", null);
    const isDefaultFramebuffer = props.handle === null;
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
    if (!isDefaultFramebuffer) {
      device.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props });
      this.autoCreateAttachmentTextures();
      this.updateAttachments();
    }
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy();
    if (!this.destroyed && this.handle !== null) {
      this.gl.deleteFramebuffer(this.handle);
    }
  }
  updateAttachments() {
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    for (let i3 = 0; i3 < this.colorAttachments.length; ++i3) {
      const attachment = this.colorAttachments[i3];
      if (attachment) {
        const attachmentPoint = 36064 + i3;
        this._attachTextureView(attachmentPoint, attachment);
      }
    }
    if (this.depthStencilAttachment) {
      const attachmentPoint = getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format);
      this._attachTextureView(attachmentPoint, this.depthStencilAttachment);
    }
    if (this.device.props.debug) {
      const status = this.gl.checkFramebufferStatus(36160);
      if (status !== 36053) {
        throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
      }
    }
    this.gl.bindFramebuffer(36160, prevHandle);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  // protected override createDepthStencilTexture(format: TextureFormat): Texture {
  //   // return new WEBGLRenderbuffer(this.device, {
  //   return new WEBGLTexture(this.device, {
  //     id: `${this.id}-depth-stencil`,
  //     format,
  //     width: this.width,
  //     height: this.height,
  //     mipmaps: false
  //   });
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTextureView(attachment, textureView) {
    const { gl } = this.device;
    const { texture } = textureView;
    const level = textureView.props.baseMipLevel;
    const layer = textureView.props.baseArrayLayer;
    gl.bindTexture(texture.glTarget, texture.handle);
    switch (texture.glTarget) {
      case 35866:
      case 32879:
        gl.framebufferTextureLayer(36160, attachment, texture.handle, level, layer);
        break;
      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;
      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;
      default:
        throw new Error("Illegal texture type");
    }
    gl.bindTexture(texture.glTarget, null);
  }
};
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  switch (status) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    case 36182:
      return "Samples mismatch";
    default:
      return `${status}`;
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js
var WebGLCanvasContext = class extends CanvasContext {
  constructor(device, props) {
    super(props);
    __publicField(this, "device");
    __publicField(this, "format", "rgba8unorm");
    __publicField(this, "depthStencilFormat", "depth24plus");
    __publicField(this, "presentationSize");
    __publicField(this, "_framebuffer", null);
    this.device = device;
    this.presentationSize = [-1, -1];
    this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
    this.update();
  }
  get [Symbol.toStringTag]() {
    return "WebGLCanvasContext";
  }
  getCurrentFramebuffer() {
    this.update();
    this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
    return this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const size = this.getPixelSize();
    const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
    if (sizeChanged) {
      this.presentationSize = size;
      this.resize();
    }
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(options) {
    if (!this.device.gl)
      return;
    if (this.canvas) {
      const devicePixelRatio = this.getDevicePixelRatio(options?.useDevicePixels);
      this.setDevicePixelRatio(devicePixelRatio, options);
      return;
    }
  }
  commit() {
  }
};

// node_modules/@luma.gl/webgl/dist/utils/load-script.js
async function loadScript(scriptUrl, scriptId) {
  const head = document.getElementsByTagName("head")[0];
  if (!head) {
    throw new Error("loadScript");
  }
  const script = document.createElement("script");
  script.setAttribute("type", "text/javascript");
  script.setAttribute("src", scriptUrl);
  if (scriptId) {
    script.id = scriptId;
  }
  return new Promise((resolve3, reject) => {
    script.onload = resolve3;
    script.onerror = (error) => reject(new Error(`Unable to load script '${scriptUrl}': ${error}`));
    head.appendChild(script);
  });
}

// node_modules/@luma.gl/webgl/dist/context/debug/spector.js
var LOG_LEVEL = 1;
var spector = null;
var initialized = false;
var DEFAULT_SPECTOR_PROPS = {
  debugSpectorJS: log2.get("debug-spectorjs"),
  // https://github.com/BabylonJS/Spector.js#basic-usage
  // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
  // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
  debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
  gl: void 0
};
async function loadSpectorJS(props) {
  if (!globalThis.SPECTOR) {
    try {
      await loadScript(props.debugSpectorJSUrl || DEFAULT_SPECTOR_PROPS.debugSpectorJSUrl);
    } catch (error) {
      log2.warn(String(error));
    }
  }
}
function initializeSpectorJS(props) {
  props = { ...DEFAULT_SPECTOR_PROPS, ...props };
  if (!props.debugSpectorJS) {
    return null;
  }
  if (!spector && globalThis.SPECTOR && !globalThis.luma?.spector) {
    log2.probe(LOG_LEVEL, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
    const { Spector: SpectorJS } = globalThis.SPECTOR;
    spector = new SpectorJS();
    if (globalThis.luma) {
      globalThis.luma.spector = spector;
    }
  }
  if (!spector) {
    return null;
  }
  if (!initialized) {
    initialized = true;
    spector.spyCanvases();
    spector?.onCaptureStarted.add((capture) => log2.info("Spector capture started:", capture)());
    spector?.onCapture.add((capture) => {
      log2.info("Spector capture complete:", capture)();
      spector?.getResultUI();
      spector?.resultView.display();
      spector?.resultView.addCapture(capture);
    });
  }
  if (props.gl) {
    const gl = props.gl;
    const device = gl.device;
    spector?.startCapture(props.gl, 500);
    gl.device = device;
    new Promise((resolve3) => setTimeout(resolve3, 2e3)).then((_2) => {
      log2.info("Spector capture stopped after 2 seconds")();
      spector?.stopCapture();
    });
  }
  return spector;
}

// node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js
var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function getWebGLContextData(gl) {
  gl.luma = gl.luma || {};
  return gl.luma;
}
async function loadWebGLDeveloperTools() {
  if (isBrowser2() && !globalThis.WebGLDebugUtils) {
    globalThis.global = globalThis.global || globalThis;
    globalThis.global.module = {};
    await loadScript(WEBGL_DEBUG_CDN_URL);
  }
}
function makeDebugContext(gl, props = {}) {
  return props.debugWebGL || props.traceWebGL ? getDebugContext(gl, props) : getRealContext(gl);
}
function getRealContext(gl) {
  const data = getWebGLContextData(gl);
  return data.realContext ? data.realContext : gl;
}
function getDebugContext(gl, props) {
  if (!globalThis.WebGLDebugUtils) {
    log2.warn("webgl-debug not loaded")();
    return gl;
  }
  const data = getWebGLContextData(gl);
  if (data.debugContext) {
    return data.debugContext;
  }
  globalThis.WebGLDebugUtils.init({ ...GLEnum, ...gl });
  const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
  for (const key in GLEnum) {
    if (!(key in glDebug) && typeof GLEnum[key] === "number") {
      glDebug[key] = GLEnum[key];
    }
  }
  class WebGLDebugContext {
  }
  Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
  Object.setPrototypeOf(WebGLDebugContext, glDebug);
  const debugContext = Object.create(WebGLDebugContext);
  data.realContext = gl;
  data.debugContext = debugContext;
  debugContext.debug = true;
  return debugContext;
}
function getFunctionString(functionName, functionArgs) {
  functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
  let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
  args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
  return `gl.${functionName}(${args})`;
}
function onGLError(props, err2, functionName, args) {
  args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
  const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err2);
  const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
  const message2 = `${errorMessage} in gl.${functionName}(${functionArgs})`;
  log2.error(message2)();
  debugger;
}
function onValidateGLFunc(props, functionName, functionArgs) {
  let functionString = "";
  if (log2.level >= 1) {
    functionString = getFunctionString(functionName, functionArgs);
    if (props.traceWebGL) {
      log2.log(1, functionString)();
    }
  }
  for (const arg of functionArgs) {
    if (arg === void 0) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      debugger;
    }
  }
}

// node_modules/@luma.gl/webgl/dist/utils/uid.js
var uidCounters3 = {};
function uid3(id = "id") {
  uidCounters3[id] = uidCounters3[id] || 1;
  const count2 = uidCounters3[id]++;
  return `${id}-${count2}`;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js
var WEBGLBuffer = class extends Buffer2 {
  constructor(device, props = {}) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    /** Target in OpenGL defines the type of buffer */
    __publicField(this, "glTarget");
    /** Usage is a hint on how frequently the buffer will be updates */
    __publicField(this, "glUsage");
    /** Index type is needed when issuing draw calls, so we pre-compute it */
    __publicField(this, "glIndexType", 5123);
    /** Number of bytes allocated on the GPU for this buffer */
    __publicField(this, "byteLength");
    /** Number of bytes used */
    __publicField(this, "bytesUsed");
    this.device = device;
    this.gl = this.device.gl;
    const handle = typeof props === "object" ? props.handle : void 0;
    this.handle = handle || this.gl.createBuffer();
    device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
    this.glTarget = getWebGLTarget(this.props.usage);
    this.glUsage = getWebGLUsage(this.props.usage);
    this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123;
    if (props.data) {
      this._initWithData(props.data, props.byteOffset, props.byteLength);
    } else {
      this._initWithByteLength(props.byteLength || 0);
    }
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, byteLength, this.glUsage);
    this.gl.bufferSubData(glTarget, byteOffset, data);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(data, byteOffset, byteLength);
    this.trackAllocatedMemory(byteLength);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(byteLength) {
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, data, this.glUsage);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(null, 0, byteLength);
    this.trackAllocatedMemory(byteLength);
    return this;
  }
  destroy() {
    if (!this.destroyed && this.handle) {
      this.removeStats();
      this.trackDeallocatedMemory();
      this.gl.deleteBuffer(this.handle);
      this.destroyed = true;
      this.handle = null;
    }
  }
  write(data, byteOffset = 0) {
    const srcOffset = 0;
    const byteLength = void 0;
    const glTarget = 36663;
    this.gl.bindBuffer(glTarget, this.handle);
    if (srcOffset !== 0 || byteLength !== void 0) {
      this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(glTarget, byteOffset, data);
    }
    this.gl.bindBuffer(glTarget, null);
    this._setDebugData(data, byteOffset, data.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync(byteOffset = 0, byteLength) {
    return this.readSyncWebGL(byteOffset, byteLength);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL(byteOffset = 0, byteLength) {
    byteLength = byteLength ?? this.byteLength - byteOffset;
    const data = new Uint8Array(byteLength);
    const dstOffset = 0;
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
    this.gl.bindBuffer(36662, null);
    this._setDebugData(data, byteOffset, byteLength);
    return data;
  }
};
function getWebGLTarget(usage) {
  if (usage & Buffer2.INDEX) {
    return 34963;
  }
  if (usage & Buffer2.VERTEX) {
    return 34962;
  }
  if (usage & Buffer2.UNIFORM) {
    return 35345;
  }
  return 34962;
}
function getWebGLUsage(usage) {
  if (usage & Buffer2.INDEX) {
    return 35044;
  }
  if (usage & Buffer2.VERTEX) {
    return 35044;
  }
  if (usage & Buffer2.UNIFORM) {
    return 35048;
  }
  return 35044;
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js
function parseShaderCompilerLog(errLog) {
  const lines = errLog.split(/\r?\n/);
  const messages2 = [];
  for (const line of lines) {
    if (line.length <= 1) {
      continue;
    }
    const segments = line.split(":");
    if (segments.length === 2) {
      const [messageType2, message2] = segments;
      messages2.push({
        message: message2.trim(),
        type: getMessageType(messageType2),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [messageType, linePosition, lineNumber, ...rest] = segments;
    let lineNum = parseInt(lineNumber, 10);
    if (isNaN(lineNum)) {
      lineNum = 0;
    }
    let linePos = parseInt(linePosition, 10);
    if (isNaN(linePos)) {
      linePos = 0;
    }
    messages2.push({
      message: rest.join(":").trim(),
      type: getMessageType(messageType),
      lineNum,
      linePos
      // TODO
    });
  }
  return messages2;
}
function getMessageType(messageType) {
  const MESSAGE_TYPES = ["warning", "error", "info"];
  const lowerCaseType = messageType.toLowerCase();
  return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js
var WEBGLShader = class extends Shader {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    this.device = device;
    switch (this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    if (this.handle) {
      this.removeStats();
      this.device.gl.deleteShader(this.handle);
      this.destroyed = true;
    }
  }
  get asyncCompilationStatus() {
    return this._waitForCompilationComplete().then(() => this.compilationStatus);
  }
  async getCompilationInfo() {
    await this._waitForCompilationComplete();
    return this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const shaderLog = this.device.gl.getShaderInfoLog(this.handle);
    return shaderLog ? parseShaderCompilerLog(shaderLog) : [];
  }
  getTranslatedSource() {
    const extensions = this.device.getExtension("WEBGL_debug_shaders");
    const ext = extensions.WEBGL_debug_shaders;
    return ext?.getTranslatedShaderSource(this.handle) || null;
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(source3) {
    source3 = source3.startsWith("#version ") ? source3 : `#version 300 es
${source3}`;
    const { gl } = this.device;
    gl.shaderSource(this.handle, source3);
    gl.compileShader(this.handle);
    if (!this.device.props.debug) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      this._getCompilationStatus();
      this.debugShader();
      if (this.compilationStatus === "error") {
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      }
      return;
    }
    log2.once(1, "Shader compilation is asynchronous")();
    await this._waitForCompilationComplete();
    log2.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
    this._getCompilationStatus();
    this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const waitMs = async (ms) => await new Promise((resolve3) => setTimeout(resolve3, ms));
    const DELAY_MS = 10;
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await waitMs(DELAY_MS);
      return;
    }
    const { gl } = this.device;
    for (; ; ) {
      const complete = gl.getShaderParameter(this.handle, 37297);
      if (complete) {
        return;
      }
      await waitMs(DELAY_MS);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js
function withDeviceAndGLParameters(device, parameters, glParameters, func) {
  if (isObjectEmpty3(parameters)) {
    return func(device);
  }
  const webglDevice = device;
  webglDevice.pushState();
  try {
    setDeviceParameters(device, parameters);
    setGLParameters(webglDevice.gl, glParameters);
    return func(device);
  } finally {
    webglDevice.popState();
  }
}
function setDeviceParameters(device, parameters) {
  const webglDevice = device;
  const { gl } = webglDevice;
  if (parameters.cullMode) {
    switch (parameters.cullMode) {
      case "none":
        gl.disable(2884);
        break;
      case "front":
        gl.enable(2884);
        gl.cullFace(1028);
        break;
      case "back":
        gl.enable(2884);
        gl.cullFace(1029);
        break;
    }
  }
  if (parameters.frontFace) {
    gl.frontFace(map2("frontFace", parameters.frontFace, {
      ccw: 2305,
      cw: 2304
    }));
  }
  if (parameters.unclippedDepth) {
    if (device.features.has("depth-clip-control")) {
      gl.enable(34383);
    }
  }
  if (parameters.depthBias !== void 0) {
    gl.enable(32823);
    gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
  }
  if (parameters.provokingVertex) {
    if (device.features.has("provoking-vertex-webgl")) {
      const extensions = webglDevice.getExtension("WEBGL_provoking_vertex");
      const ext = extensions.WEBGL_provoking_vertex;
      const vertex2 = map2("provokingVertex", parameters.provokingVertex, {
        first: 36429,
        last: 36430
      });
      ext?.provokingVertexWEBGL(vertex2);
    }
  }
  if (parameters.polygonMode || parameters.polygonOffsetLine) {
    if (device.features.has("polygon-mode-webgl")) {
      if (parameters.polygonMode) {
        const extensions = webglDevice.getExtension("WEBGL_polygon_mode");
        const ext = extensions.WEBGL_polygon_mode;
        const mode = map2("polygonMode", parameters.polygonMode, {
          fill: 6914,
          line: 6913
        });
        ext?.polygonModeWEBGL(1028, mode);
        ext?.polygonModeWEBGL(1029, mode);
      }
      if (parameters.polygonOffsetLine) {
        gl.enable(10754);
      }
    }
  }
  if (device.features.has("shader-clip-cull-distance-webgl")) {
    if (parameters.clipDistance0) {
      gl.enable(12288);
    }
    if (parameters.clipDistance1) {
      gl.enable(12289);
    }
    if (parameters.clipDistance2) {
      gl.enable(12290);
    }
    if (parameters.clipDistance3) {
      gl.enable(12291);
    }
    if (parameters.clipDistance4) {
      gl.enable(12292);
    }
    if (parameters.clipDistance5) {
      gl.enable(12293);
    }
    if (parameters.clipDistance6) {
      gl.enable(12294);
    }
    if (parameters.clipDistance7) {
      gl.enable(12295);
    }
  }
  if (parameters.depthWriteEnabled !== void 0) {
    gl.depthMask(mapBoolean("depthWriteEnabled", parameters.depthWriteEnabled));
  }
  if (parameters.depthCompare) {
    parameters.depthCompare !== "always" ? gl.enable(2929) : gl.disable(2929);
    gl.depthFunc(convertCompareFunction("depthCompare", parameters.depthCompare));
  }
  if (parameters.stencilWriteMask) {
    const mask = parameters.stencilWriteMask;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, mask);
  }
  if (parameters.stencilReadMask) {
    log2.warn("stencilReadMask not supported under WebGL");
  }
  if (parameters.stencilCompare) {
    const mask = parameters.stencilReadMask || 4294967295;
    const glValue = convertCompareFunction("depthCompare", parameters.stencilCompare);
    parameters.stencilCompare !== "always" ? gl.enable(2960) : gl.disable(2960);
    gl.stencilFuncSeparate(1028, glValue, 0, mask);
    gl.stencilFuncSeparate(1029, glValue, 0, mask);
  }
  if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
    const dppass = convertStencilOperation("stencilPassOperation", parameters.stencilPassOperation);
    const sfail = convertStencilOperation("stencilFailOperation", parameters.stencilFailOperation);
    const dpfail = convertStencilOperation("stencilDepthFailOperation", parameters.stencilDepthFailOperation);
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
  }
  switch (parameters.blend) {
    case true:
      gl.enable(3042);
      break;
    case false:
      gl.disable(3042);
      break;
    default:
  }
  if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
    const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters.blendColorOperation || "add");
    const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters.blendAlphaOperation || "add");
    gl.blendEquationSeparate(colorEquation, alphaEquation);
    const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters.blendColorSrcFactor || "one");
    const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters.blendColorDstFactor || "zero");
    const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters.blendAlphaSrcFactor || "one");
    const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters.blendAlphaDstFactor || "zero");
    gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
  }
}
function convertCompareFunction(parameter, value) {
  return map2(parameter, value, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function convertStencilOperation(parameter, value) {
  return map2(parameter, value, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function convertBlendOperationToEquation(parameter, value) {
  return map2(parameter, value, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function convertBlendFactorToFunction(parameter, value) {
  return map2(parameter, value, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function message(parameter, value) {
  return `Illegal parameter ${value} for ${parameter}`;
}
function map2(parameter, value, valueMap) {
  if (!(value in valueMap)) {
    throw new Error(message(parameter, value));
  }
  return valueMap[value];
}
function mapBoolean(parameter, value) {
  return value;
}
function isObjectEmpty3(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}

// node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js
function convertSamplerParametersToWebGL(props) {
  const params = {};
  if (props.addressModeU) {
    params[10242] = convertAddressMode(props.addressModeU);
  }
  if (props.addressModeV) {
    params[10243] = convertAddressMode(props.addressModeV);
  }
  if (props.addressModeW) {
    params[32882] = convertAddressMode(props.addressModeW);
  }
  if (props.magFilter) {
    params[10240] = convertMaxFilterMode(props.magFilter);
  }
  if (props.minFilter || props.mipmapFilter) {
    params[10241] = convertMinFilterMode(props.minFilter || "linear", props.mipmapFilter);
  }
  if (props.lodMinClamp !== void 0) {
    params[33082] = props.lodMinClamp;
  }
  if (props.lodMaxClamp !== void 0) {
    params[33083] = props.lodMaxClamp;
  }
  if (props.type === "comparison-sampler") {
    params[34892] = 34894;
  }
  if (props.compare) {
    params[34893] = convertCompareFunction("compare", props.compare);
  }
  if (props.maxAnisotropy) {
    params[34046] = props.maxAnisotropy;
  }
  return params;
}
function convertAddressMode(addressMode) {
  switch (addressMode) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function convertMaxFilterMode(maxFilter) {
  switch (maxFilter) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function convertMinFilterMode(minFilter, mipmapFilter = "none") {
  if (!mipmapFilter) {
    return convertMaxFilterMode(minFilter);
  }
  switch (mipmapFilter) {
    case "none":
      return convertMaxFilterMode(minFilter);
    case "nearest":
      return minFilter === "nearest" ? 9984 : 9986;
    case "linear":
      return minFilter === "nearest" ? 9985 : 9987;
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js
var WEBGLSampler = class extends Sampler {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    __publicField(this, "parameters");
    this.device = device;
    this.parameters = convertSamplerParametersToWebGL(props);
    this.handle = this.handle || this.device.gl.createSampler();
    this._setSamplerParameters(this.parameters);
  }
  destroy() {
    if (this.handle) {
      this.device.gl.deleteSampler(this.handle);
      this.handle = void 0;
    }
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(parameters) {
    for (const [pname, value] of Object.entries(parameters)) {
      const param = Number(pname);
      switch (param) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, param, value);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, param, value);
          break;
      }
    }
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js
var WEBGLTextureView = class extends TextureView {
  constructor(device, props) {
    super(device, { ...Texture.defaultProps, ...props });
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    // Does not have a WebGL representation
    __publicField(this, "texture");
    this.device = device;
    this.gl = this.device.gl;
    this.handle = null;
    this.texture = props.texture;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/helpers/typed-array-utils.js
var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType, options) {
  const { clamped = true } = options || {};
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/format-utils.js
function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
    case 36244:
      return 1;
    case 33339:
    case 33340:
    case 33328:
    case 33320:
    case 33319:
      return 2;
    case 6407:
    case 36248:
    case 34837:
      return 3;
    case 6408:
    case 36249:
    case 34836:
      return 4;
    default:
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      return 0;
  }
}

// node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js
function withGLParameters(gl, parameters, func) {
  if (isObjectEmpty4(parameters)) {
    return func(gl);
  }
  const { nocatch = true } = parameters;
  const webglState = WebGLStateTracker.get(gl);
  webglState.push();
  setGLParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    webglState.pop();
  } else {
    try {
      value = func(gl);
    } finally {
      webglState.pop();
    }
  }
  return value;
}
function isObjectEmpty4(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js
function initializeTextureStorage(gl, levels, options) {
  const { dimension, width, height, depth = 0 } = options;
  const { glInternalFormat } = options;
  const glTarget = options.glTarget;
  switch (dimension) {
    case "2d-array":
    case "3d":
      gl.texStorage3D(glTarget, levels, glInternalFormat, width, height, depth);
      break;
    default:
      gl.texStorage2D(glTarget, levels, glInternalFormat, width, height);
  }
}
function copyExternalImageToMipLevel(gl, handle, image, options) {
  const { width, height } = options;
  const { dimension, depth = 0, mipLevel = 0 } = options;
  const { x: x2 = 0, y: y2 = 0, z: z2 = 0 } = options;
  const { glFormat, glType } = options;
  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
  const glParameters = options.flipY ? { [37440]: true } : {};
  withGLParameters(gl, glParameters, () => {
    switch (dimension) {
      case "2d-array":
      case "3d":
        gl.bindTexture(glTarget, handle);
        gl.texSubImage3D(glTarget, mipLevel, x2, y2, z2, width, height, depth, glFormat, glType, image);
        gl.bindTexture(glTarget, null);
        break;
      case "2d":
      case "cube":
        gl.bindTexture(glTarget, handle);
        gl.texSubImage2D(glTarget, mipLevel, x2, y2, width, height, glFormat, glType, image);
        gl.bindTexture(glTarget, null);
        break;
      default:
        throw new Error(dimension);
    }
  });
}
function copyCPUDataToMipLevel(gl, typedArray, options) {
  const { dimension, width, height, depth = 0, mipLevel = 0, byteOffset = 0 } = options;
  const { x: x2 = 0, y: y2 = 0, z: z2 = 0 } = options;
  const { glFormat, glType, compressed } = options;
  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
  switch (dimension) {
    case "2d-array":
    case "3d":
      if (compressed) {
        gl.compressedTexSubImage3D(glTarget, mipLevel, x2, y2, z2, width, height, depth, glFormat, typedArray, byteOffset);
      } else {
        gl.texSubImage3D(glTarget, mipLevel, x2, y2, z2, width, height, depth, glFormat, glType, typedArray, byteOffset);
      }
      break;
    case "2d":
    case "cube":
      if (compressed) {
        gl.compressedTexSubImage2D(glTarget, mipLevel, x2, y2, width, height, glFormat, typedArray, byteOffset);
      } else {
        gl.texSubImage2D(glTarget, mipLevel, x2, y2, width, height, glFormat, glType, typedArray, byteOffset);
      }
      break;
    default:
      throw new Error(dimension);
  }
}
function getWebGLTextureTarget(dimension) {
  switch (dimension) {
    case "1d":
      break;
    case "2d":
      return 3553;
    case "3d":
      return 32879;
    case "cube":
      return 34067;
    case "2d-array":
      return 35866;
    case "cube-array":
      break;
  }
  throw new Error(dimension);
}
function getWebGLCubeFaceTarget(glTarget, dimension, level) {
  return dimension === "cube" ? 34069 + level : glTarget;
}
function readPixelsToArray(source3, options) {
  const {
    sourceX = 0,
    sourceY = 0,
    sourceAttachment = 0
    // TODO - support gl.readBuffer
  } = options || {};
  let {
    target: target2 = null,
    // following parameters are auto deduced if not provided
    sourceWidth,
    sourceHeight,
    sourceDepth,
    sourceFormat,
    sourceType
  } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer(source3);
  const { gl, handle } = framebuffer;
  sourceWidth || (sourceWidth = framebuffer.width);
  sourceHeight || (sourceHeight = framebuffer.height);
  const texture = framebuffer.colorAttachments[sourceAttachment]?.texture;
  if (!texture) {
    throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);
  }
  sourceDepth = texture?.depth || 1;
  sourceFormat || (sourceFormat = texture?.glFormat || 6408);
  sourceType || (sourceType = texture?.glType || 5121);
  target2 = getPixelArray(target2, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);
  sourceType = sourceType || getGLTypeFromTypedArray(target2);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readBuffer(36064 + sourceAttachment);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target2);
  gl.readBuffer(36064);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return target2;
}
function readPixelsToBuffer(source3, options) {
  const { target: target2, sourceX = 0, sourceY = 0, sourceFormat = 6408, targetByteOffset = 0 } = options || {};
  let { sourceWidth, sourceHeight, sourceType } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer(source3);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const webglFramebuffer = framebuffer;
  sourceType = sourceType || 5121;
  let webglBufferTarget = target2;
  if (!webglBufferTarget) {
    const components = glFormatToComponents(sourceFormat);
    const byteCount = glTypeToBytes(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
  }
  const commandEncoder = source3.device.createCommandEncoder();
  commandEncoder.copyTextureToBuffer({
    sourceTexture: source3,
    width: sourceWidth,
    height: sourceHeight,
    origin: [sourceX, sourceY],
    destinationBuffer: webglBufferTarget,
    byteOffset: targetByteOffset
  });
  commandEncoder.destroy();
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return webglBufferTarget;
}
function getFramebuffer(source3) {
  if (!(source3 instanceof Framebuffer)) {
    return { framebuffer: toFramebuffer(source3), deleteFramebuffer: true };
  }
  return { framebuffer: source3, deleteFramebuffer: false };
}
function toFramebuffer(texture, props) {
  const { device, width, height, id } = texture;
  const framebuffer = device.createFramebuffer({
    ...props,
    id: `framebuffer-for-${id}`,
    width,
    height,
    colorAttachments: [texture]
  });
  return framebuffer;
}
function getPixelArray(pixelArray, glType, glFormat, width, height, depth) {
  if (pixelArray) {
    return pixelArray;
  }
  glType || (glType = 5121);
  const ArrayType = getTypedArrayFromGLType(glType, { clamped: false });
  const components = glFormatToComponents(glFormat);
  return new ArrayType(width * height * components);
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js
var WEBGLTexture = class extends Texture {
  constructor(device, props) {
    super(device, props);
    // readonly MAX_ATTRIBUTES: number;
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    __publicField(this, "sampler");
    // TODO - currently unused in WebGL. Create dummy sampler?
    __publicField(this, "view");
    // TODO - currently unused in WebGL. Create dummy view?
    __publicField(this, "mipmaps");
    // Texture type
    /** Whether the internal format is compressed */
    __publicField(this, "compressed");
    /**
     * The WebGL target corresponding to the texture type
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     */
    __publicField(this, "glTarget");
    /** The WebGL format - essentially channel structure */
    __publicField(this, "glFormat");
    /** The WebGL data format - the type of each channel */
    __publicField(this, "glType");
    /** The WebGL constant corresponding to the WebGPU style constant in format */
    __publicField(this, "glInternalFormat");
    // state
    /** Texture binding slot - TODO - move to texture view? */
    __publicField(this, "textureUnit", 0);
    const propsWithData = { ...this.props };
    propsWithData.data = props.data;
    this.device = device;
    this.gl = this.device.gl;
    this.glTarget = getWebGLTextureTarget(this.props.dimension);
    const formatInfo = getTextureFormatWebGL(this.props.format);
    this.glInternalFormat = formatInfo.internalFormat;
    this.glFormat = formatInfo.format;
    this.glType = formatInfo.type;
    this.compressed = formatInfo.compressed;
    this.mipmaps = Boolean(this.props.mipmaps);
    this._initialize(propsWithData);
    Object.seal(this);
  }
  /** Initialize texture with supplied props */
  // eslint-disable-next-line max-statements
  _initialize(propsWithData) {
    this.handle = this.props.handle || this.gl.createTexture();
    this.device.setSpectorMetadata(this.handle, { ...this.props, data: propsWithData.data });
    let { width, height } = propsWithData;
    if (!width || !height) {
      const textureSize = Texture.getTextureDataSize(propsWithData.data);
      width = textureSize?.width || 1;
      height = textureSize?.height || 1;
    }
    this.width = width;
    this.height = height;
    this.depth = propsWithData.depth;
    this.setSampler(propsWithData.sampler);
    this.view = new WEBGLTextureView(this.device, { ...this.props, texture: this });
    this.bind();
    initializeTextureStorage(this.gl, this.mipLevels, this);
    if (propsWithData.data) {
      switch (propsWithData.dimension) {
        case "1d":
          this.setTexture1DData(propsWithData.data);
          break;
        case "2d":
          this.setTexture2DData(propsWithData.data);
          break;
        case "3d":
          this.setTexture3DData(propsWithData.data);
          break;
        case "cube":
          this.setTextureCubeData(propsWithData.data);
          break;
        case "2d-array":
          this.setTextureArrayData(propsWithData.data);
          break;
        case "cube-array":
          this.setTextureCubeArrayData(propsWithData.data);
          break;
        default:
          throw new Error(propsWithData.dimension);
      }
    }
    if (this.mipmaps) {
      this.generateMipmap();
    }
  }
  destroy() {
    if (this.handle) {
      this.gl.deleteTexture(this.handle);
      this.removeStats();
      this.trackDeallocatedMemory("Texture");
      this.destroyed = true;
    }
  }
  createView(props) {
    return new WEBGLTextureView(this.device, { ...props, texture: this });
  }
  setSampler(sampler = {}) {
    let samplerProps;
    if (sampler instanceof WEBGLSampler) {
      this.sampler = sampler;
      samplerProps = sampler.props;
    } else {
      this.sampler = new WEBGLSampler(this.device, sampler);
      samplerProps = sampler;
    }
    const parameters = convertSamplerParametersToWebGL(samplerProps);
    this._setSamplerParameters(parameters);
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(options) {
    const isFilterableAndRenderable = this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format);
    if (!isFilterableAndRenderable) {
      log2.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();
      if (!options?.force) {
        return;
      }
    }
    try {
      this.gl.bindTexture(this.glTarget, this.handle);
      this.gl.generateMipmap(this.glTarget);
    } catch (error) {
      log2.warn(`Error generating mipmap for ${this}: ${error.message}`)();
    } finally {
      this.gl.bindTexture(this.glTarget, null);
    }
  }
  // Image Data Setters
  copyExternalImage(options) {
    const size = Texture.getExternalImageSize(options.image);
    const opts = { ...Texture.defaultCopyExternalImageOptions, ...size, ...options };
    const { image, depth, mipLevel, x: x2, y: y2, z: z2, flipY } = opts;
    let { width, height } = opts;
    const { dimension, glTarget, glFormat, glInternalFormat, glType } = this;
    width = Math.min(width, this.width - x2);
    height = Math.min(height, this.height - y2);
    if (options.sourceX || options.sourceY) {
      throw new Error("WebGL does not support sourceX/sourceY)");
    }
    copyExternalImageToMipLevel(this.device.gl, this.handle, image, {
      dimension,
      mipLevel,
      x: x2,
      y: y2,
      z: z2,
      width,
      height,
      depth,
      glFormat,
      glInternalFormat,
      glType,
      glTarget,
      flipY
    });
    return { width: opts.width, height: opts.height };
  }
  setTexture1DData(data) {
    throw new Error("setTexture1DData not supported in WebGL.");
  }
  /** Set a simple texture */
  setTexture2DData(lodData, depth = 0) {
    this.bind();
    const lodArray = Texture.normalizeTextureData(lodData, this);
    if (lodArray.length > 1 && this.props.mipmaps !== false) {
      log2.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
    }
    for (let lodLevel = 0; lodLevel < lodArray.length; lodLevel++) {
      const imageData = lodArray[lodLevel];
      this._setMipLevel(depth, lodLevel, imageData);
    }
    this.unbind();
  }
  /**
   * Sets a 3D texture
   * @param data
   */
  setTexture3DData(data) {
    if (this.props.dimension !== "3d") {
      throw new Error(this.id);
    }
    if (ArrayBuffer.isView(data)) {
      this.bind();
      copyCPUDataToMipLevel(this.device.gl, data, this);
      this.unbind();
    }
  }
  /**
   * Set a Texture Cube Data
   * @todo - could support TextureCubeArray with depth
   * @param data
   * @param index
   */
  setTextureCubeData(data, depth = 0) {
    if (this.props.dimension !== "cube") {
      throw new Error(this.id);
    }
    for (const face of Texture.CubeFaces) {
      this.setTextureCubeFaceData(data[face], face);
    }
  }
  /**
   * Sets an entire texture array
   * @param data
   */
  setTextureArrayData(data) {
    if (this.props.dimension !== "2d-array") {
      throw new Error(this.id);
    }
    throw new Error("setTextureArrayData not implemented.");
  }
  /**
   * Sets an entire texture cube array
   * @param data
   */
  setTextureCubeArrayData(data) {
    throw new Error("setTextureCubeArrayData not supported in WebGL2.");
  }
  setTextureCubeFaceData(lodData, face, depth = 0) {
    if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) {
      log2.warn(`${this.id} has mipmap and multiple LODs.`)();
    }
    const faceDepth = Texture.CubeFaces.indexOf(face);
    this.setTexture2DData(lodData, faceDepth);
  }
  // DEPRECATED METHODS
  /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */
  update() {
    throw new Error("Texture.update() not implemented. Use ExternalTexture");
  }
  // INTERNAL METHODS
  /** @todo update this method to accept LODs */
  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      format = 6408,
      type = 5121
      // generateMipmap = false // TODO
    } = options;
    const { gl } = this;
    const imageData = pixels || data;
    this.bind();
    if (imageData instanceof Promise) {
      imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, 0, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }
  }
  _getImageDataMap(faceData) {
    for (let i3 = 0; i3 < Texture.CubeFaces.length; ++i3) {
      const faceName = Texture.CubeFaces[i3];
      if (faceData[faceName]) {
        faceData[34069 + i3] = faceData[faceName];
        delete faceData[faceName];
      }
    }
    return faceData;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(parameters) {
    log2.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(parameters))();
    this.gl.bindTexture(this.glTarget, this.handle);
    for (const [pname, pvalue] of Object.entries(parameters)) {
      const param = Number(pname);
      const value = pvalue;
      switch (param) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.glTarget, param, value);
          break;
        case 10241:
          this.gl.texParameteri(this.glTarget, param, value);
          break;
        case 10242:
        case 10243:
          this.gl.texParameteri(this.glTarget, param, value);
          break;
        case 34046:
          if (this.device.features.has("texture-filterable-anisotropic-webgl")) {
            this.gl.texParameteri(this.glTarget, param, value);
          }
          break;
        default:
          this.gl.texParameteri(this.glTarget, param, value);
          break;
      }
    }
    this.gl.bindTexture(this.glTarget, null);
  }
  // INTERNAL SETTERS
  /**
   * Copy a region of data from a CPU memory buffer into this texture.
   * @todo -   GLUnpackParameters parameters
   */
  _setMipLevel(depth, mipLevel, textureData, glTarget = this.glTarget) {
    if (Texture.isExternalImage(textureData)) {
      copyExternalImageToMipLevel(this.device.gl, this.handle, textureData, {
        ...this,
        depth,
        mipLevel,
        glTarget,
        flipY: this.props.flipY
      });
      return;
    }
    if (Texture.isTextureLevelData(textureData)) {
      copyCPUDataToMipLevel(this.device.gl, textureData.data, {
        ...this,
        depth,
        mipLevel,
        glTarget
      });
      return;
    }
    throw new Error("Texture: invalid image data");
  }
  // HELPERS
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(textureUnit) {
    const { gl } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.glTarget, this.handle);
    return textureUnit;
  }
  unbind(textureUnit) {
    const { gl } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.glTarget, null);
    return textureUnit;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js
var COLOR_CHANNELS = [1, 2, 4, 8];
var WEBGLRenderPass = class extends RenderPass {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    /** Parameters that should be applied before each draw call */
    __publicField(this, "glParameters");
    this.device = device;
    let viewport;
    if (!props?.parameters?.viewport) {
      if (props?.framebuffer) {
        const { width, height } = props.framebuffer;
        viewport = [0, 0, width, height];
      } else {
        const [width, height] = device.getCanvasContext().getDrawingBufferSize();
        viewport = [0, 0, width, height];
      }
    }
    this.device.pushState();
    this.setParameters({ viewport, ...this.props.parameters });
    const webglFramebuffer = this.props.framebuffer;
    if (webglFramebuffer?.handle) {
      if (this.props.framebuffer) {
        const drawBuffers = this.props.framebuffer.colorAttachments.map((_2, i3) => 36064 + i3);
        this.device.gl.drawBuffers(drawBuffers);
      } else {
        this.device.gl.drawBuffers([1029]);
      }
    }
    this.clear();
  }
  end() {
    this.device.popState();
  }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(parameters = {}) {
    const glParameters = { ...this.glParameters };
    glParameters.framebuffer = this.props.framebuffer || null;
    if (this.props.depthReadOnly) {
      glParameters.depthMask = !this.props.depthReadOnly;
    }
    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
    glParameters[35977] = this.props.discard;
    if (parameters.viewport) {
      if (parameters.viewport.length >= 6) {
        glParameters.viewport = parameters.viewport.slice(0, 4);
        glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];
      } else {
        glParameters.viewport = parameters.viewport;
      }
    }
    if (parameters.scissorRect) {
      glParameters.scissorTest = true;
      glParameters.scissor = parameters.scissorRect;
    }
    if (parameters.blendConstant) {
      glParameters.blendColor = parameters.blendConstant;
    }
    if (parameters.stencilReference) {
      console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
      parameters[2967] = parameters.stencilReference;
    }
    if (parameters.colorMask) {
      glParameters.colorMask = COLOR_CHANNELS.map((channel) => Boolean(channel & parameters.colorMask));
    }
    this.glParameters = glParameters;
    setGLParameters(this.device.gl, glParameters);
  }
  beginOcclusionQuery(queryIndex) {
    const webglQuerySet = this.props.occlusionQuerySet;
    webglQuerySet?.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    const webglQuerySet = this.props.occlusionQuerySet;
    webglQuerySet?.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const glParameters = { ...this.glParameters };
    let clearMask = 0;
    if (this.props.clearColors) {
      this.props.clearColors.forEach((color, drawBufferIndex) => {
        if (color) {
          this.clearColorBuffer(drawBufferIndex, color);
        }
      });
    }
    if (this.props.clearColor !== false && this.props.clearColors === void 0) {
      clearMask |= 16384;
      glParameters.clearColor = this.props.clearColor;
    }
    if (this.props.clearDepth !== false) {
      clearMask |= 256;
      glParameters.clearDepth = this.props.clearDepth;
    }
    if (this.props.clearStencil !== false) {
      clearMask |= 1024;
      glParameters.clearStencil = this.props.clearStencil;
    }
    if (clearMask !== 0) {
      withGLParameters(this.device.gl, glParameters, () => {
        this.device.gl.clear(clearMask);
      });
    }
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
    withGLParameters(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (value.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
          this.device.gl.clearBufferiv(6144, drawBuffer, value);
          break;
        case Uint8Array:
        case Uint8ClampedArray:
        case Uint16Array:
        case Uint32Array:
          this.device.gl.clearBufferuiv(6144, drawBuffer, value);
          break;
        case Float32Array:
          this.device.gl.clearBufferfv(6144, drawBuffer, value);
          break;
        default:
          throw new Error("clearColorBuffer: color must be typed array");
      }
    });
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/helpers/decode-webgl-types.js
function isSamplerUniform(type) {
  return SAMPLER_TYPES.includes(type);
}
var SAMPLER_TYPES = [
  35678,
  35680,
  35679,
  35682,
  36289,
  36292,
  36293,
  36298,
  36299,
  36300,
  36303,
  36306,
  36307,
  36308,
  36311
];
var COMPOSITE_GL_TYPES = {
  [5126]: [5126, 1, "float", "f32", "float32"],
  [35664]: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  [35665]: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  [35666]: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  [5124]: [5124, 1, "int", "i32", "sint32"],
  [35667]: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  [35668]: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  [35669]: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  [5125]: [5125, 1, "uint", "u32", "uint32"],
  [36294]: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  [36295]: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  [36296]: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  [35670]: [5126, 1, "bool", "f32", "float32"],
  [35671]: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  [35672]: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  [35673]: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  [35674]: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  [35685]: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  [35686]: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  [35687]: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  [35675]: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  [35688]: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  [35689]: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  [35690]: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  [35676]: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function decodeGLUniformType(glUniformType) {
  const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
  if (!typeAndSize) {
    throw new Error("uniform");
  }
  const [glType, components, , format] = typeAndSize;
  return { format, components, glType };
}
function decodeGLAttributeType(glAttributeType) {
  const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
  if (!typeAndSize) {
    throw new Error("attribute");
  }
  const [, components, , shaderType, vertexFormat] = typeAndSize;
  const attributeType = shaderType;
  return { attributeType, vertexFormat, components };
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout.js
function getShaderLayoutFromGLSL(gl, program) {
  const shaderLayout = {
    attributes: [],
    bindings: []
  };
  shaderLayout.attributes = readAttributeDeclarations(gl, program);
  const uniformBlocks = readUniformBlocks(gl, program);
  for (const uniformBlock11 of uniformBlocks) {
    const uniforms2 = uniformBlock11.uniforms.map((uniform) => ({
      name: uniform.name,
      format: uniform.format,
      byteOffset: uniform.byteOffset,
      byteStride: uniform.byteStride,
      arrayLength: uniform.arrayLength
    }));
    shaderLayout.bindings.push({
      type: "uniform",
      name: uniformBlock11.name,
      group: 0,
      location: uniformBlock11.location,
      visibility: (uniformBlock11.vertex ? 1 : 0) & (uniformBlock11.fragment ? 2 : 0),
      minBindingSize: uniformBlock11.byteLength,
      uniforms: uniforms2
    });
  }
  const uniforms = readUniformBindings(gl, program);
  let textureUnit = 0;
  for (const uniform of uniforms) {
    if (isSamplerUniform(uniform.type)) {
      const { viewDimension, sampleType } = getSamplerInfo(uniform.type);
      shaderLayout.bindings.push({
        type: "texture",
        name: uniform.name,
        group: 0,
        location: textureUnit,
        viewDimension,
        sampleType
      });
      uniform.textureUnit = textureUnit;
      textureUnit += 1;
    }
  }
  if (uniforms.length) {
    shaderLayout.uniforms = uniforms;
  }
  const varyings = readVaryings(gl, program);
  if (varyings?.length) {
    shaderLayout.varyings = varyings;
  }
  return shaderLayout;
}
function readAttributeDeclarations(gl, program) {
  const attributes = [];
  const count2 = gl.getProgramParameter(program, 35721);
  for (let index = 0; index < count2; index++) {
    const activeInfo = gl.getActiveAttrib(program, index);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const {
      name: name2,
      type: compositeType
      /* , size*/
    } = activeInfo;
    const location = gl.getAttribLocation(program, name2);
    if (location >= 0) {
      const { attributeType } = decodeGLAttributeType(compositeType);
      const stepMode = /instance/i.test(name2) ? "instance" : "vertex";
      attributes.push({
        name: name2,
        location,
        stepMode,
        type: attributeType
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  attributes.sort((a2, b2) => a2.location - b2.location);
  return attributes;
}
function readVaryings(gl, program) {
  const varyings = [];
  const count2 = gl.getProgramParameter(program, 35971);
  for (let location = 0; location < count2; location++) {
    const activeInfo = gl.getTransformFeedbackVarying(program, location);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name: name2, type: compositeType, size } = activeInfo;
    const { glType, components } = decodeGLUniformType(compositeType);
    const varying = { location, name: name2, type: glType, size: size * components };
    varyings.push(varying);
  }
  varyings.sort((a2, b2) => a2.location - b2.location);
  return varyings;
}
function readUniformBindings(gl, program) {
  const uniforms = [];
  const uniformCount = gl.getProgramParameter(program, 35718);
  for (let i3 = 0; i3 < uniformCount; i3++) {
    const activeInfo = gl.getActiveUniform(program, i3);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name: rawName, size, type } = activeInfo;
    const { name: name2, isArray: isArray4 } = parseUniformName(rawName);
    let webglLocation = gl.getUniformLocation(program, name2);
    const uniformInfo = {
      // WebGL locations are uniquely typed but just numbers
      location: webglLocation,
      name: name2,
      size,
      type,
      isArray: isArray4
    };
    uniforms.push(uniformInfo);
    if (uniformInfo.size > 1) {
      for (let j2 = 0; j2 < uniformInfo.size; j2++) {
        const elementName = `${name2}[${j2}]`;
        webglLocation = gl.getUniformLocation(program, elementName);
        const arrayElementUniformInfo = {
          ...uniformInfo,
          name: elementName,
          location: webglLocation
        };
        uniforms.push(arrayElementUniformInfo);
      }
    }
  }
  return uniforms;
}
function readUniformBlocks(gl, program) {
  const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);
  const uniformBlocks = [];
  const blockCount = gl.getProgramParameter(program, 35382);
  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
    const blockInfo = {
      name: gl.getActiveUniformBlockName(program, blockIndex) || "",
      location: getBlockParameter(blockIndex, 35391),
      byteLength: getBlockParameter(blockIndex, 35392),
      vertex: getBlockParameter(blockIndex, 35396),
      fragment: getBlockParameter(blockIndex, 35398),
      uniformCount: getBlockParameter(blockIndex, 35394),
      uniforms: []
    };
    const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
    const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383);
    const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384);
    const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387);
    const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388);
    for (let i3 = 0; i3 < blockInfo.uniformCount; ++i3) {
      const activeInfo = gl.getActiveUniform(program, uniformIndices[i3]);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      blockInfo.uniforms.push({
        name: activeInfo.name,
        format: decodeGLUniformType(uniformType[i3]).format,
        type: uniformType[i3],
        arrayLength: uniformArrayLength[i3],
        byteOffset: uniformOffset[i3],
        byteStride: uniformStride[i3]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    uniformBlocks.push(blockInfo);
  }
  uniformBlocks.sort((a2, b2) => a2.location - b2.location);
  return uniformBlocks;
}
var SAMPLER_UNIFORMS_GL_TO_GPU = {
  [35678]: ["2d", "float"],
  [35680]: ["cube", "float"],
  [35679]: ["3d", "float"],
  [35682]: ["3d", "depth"],
  [36289]: ["2d-array", "float"],
  [36292]: ["2d-array", "depth"],
  [36293]: ["cube", "float"],
  [36298]: ["2d", "sint"],
  [36299]: ["3d", "sint"],
  [36300]: ["cube", "sint"],
  [36303]: ["2d-array", "uint"],
  [36306]: ["2d", "uint"],
  [36307]: ["3d", "uint"],
  [36308]: ["cube", "uint"],
  [36311]: ["2d-array", "uint"]
};
function getSamplerInfo(type) {
  const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
  if (!sampler) {
    throw new Error("sampler");
  }
  const [viewDimension, sampleType] = sampler;
  return { viewDimension, sampleType };
}
function parseUniformName(name2) {
  if (name2[name2.length - 1] !== "]") {
    return {
      name: name2,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches3 = UNIFORM_NAME_REGEXP.exec(name2);
  if (!matches3 || matches3.length < 2) {
    throw new Error(`Failed to parse GLSL uniform name ${name2}`);
  }
  return {
    name: matches3[1],
    length: matches3[2] ? 1 : 0,
    isArray: Boolean(matches3[2])
  };
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js
function setUniform(gl, location, type, value) {
  const gl2 = gl;
  let uniformValue = value;
  if (uniformValue === true) {
    uniformValue = 1;
  }
  if (uniformValue === false) {
    uniformValue = 0;
  }
  const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
  switch (type) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof value !== "number") {
        throw new Error("samplers must be set to integers");
      }
      return gl.uniform1i(location, value);
    case 5126:
      return gl.uniform1fv(location, arrayValue);
    case 35664:
      return gl.uniform2fv(location, arrayValue);
    case 35665:
      return gl.uniform3fv(location, arrayValue);
    case 35666:
      return gl.uniform4fv(location, arrayValue);
    case 5124:
      return gl.uniform1iv(location, arrayValue);
    case 35667:
      return gl.uniform2iv(location, arrayValue);
    case 35668:
      return gl.uniform3iv(location, arrayValue);
    case 35669:
      return gl.uniform4iv(location, arrayValue);
    case 35670:
      return gl.uniform1iv(location, arrayValue);
    case 35671:
      return gl.uniform2iv(location, arrayValue);
    case 35672:
      return gl.uniform3iv(location, arrayValue);
    case 35673:
      return gl.uniform4iv(location, arrayValue);
    case 5125:
      return gl2.uniform1uiv(location, arrayValue, 1);
    case 36294:
      return gl2.uniform2uiv(location, arrayValue, 2);
    case 36295:
      return gl2.uniform3uiv(location, arrayValue, 3);
    case 36296:
      return gl2.uniform4uiv(location, arrayValue, 4);
    case 35674:
      return gl.uniformMatrix2fv(location, false, arrayValue);
    case 35675:
      return gl.uniformMatrix3fv(location, false, arrayValue);
    case 35676:
      return gl.uniformMatrix4fv(location, false, arrayValue);
    case 35685:
      return gl2.uniformMatrix2x3fv(location, false, arrayValue);
    case 35686:
      return gl2.uniformMatrix2x4fv(location, false, arrayValue);
    case 35687:
      return gl2.uniformMatrix3x2fv(location, false, arrayValue);
    case 35688:
      return gl2.uniformMatrix3x4fv(location, false, arrayValue);
    case 35689:
      return gl2.uniformMatrix4x2fv(location, false, arrayValue);
    case 35690:
      return gl2.uniformMatrix4x3fv(location, false, arrayValue);
  }
  throw new Error("Illegal uniform");
}

// node_modules/@luma.gl/webgl/dist/utils/split-uniforms-and-bindings.js
function isUniformValue2(value) {
  return isNumericArray(value) !== null || typeof value === "number" || typeof value === "boolean";
}
function splitUniformsAndBindings2(uniforms) {
  const result = { bindings: {}, uniforms: {} };
  Object.keys(uniforms).forEach((name2) => {
    const uniform = uniforms[name2];
    if (isUniformValue2(uniform)) {
      result.uniforms[name2] = uniform;
    } else {
      result.bindings[name2] = uniform;
    }
  });
  return result;
}

// node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js
function getGLDrawMode(topology) {
  switch (topology) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    default:
      throw new Error(topology);
  }
}
function getGLPrimitive(topology) {
  switch (topology) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    default:
      throw new Error(topology);
  }
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js
var LOG_PROGRAM_PERF_PRIORITY = 4;
var WEBGLRenderPipeline = class extends RenderPipeline {
  // TODO are these used?
  constructor(device, props) {
    super(device, props);
    /** The WebGL device that created this render pipeline */
    __publicField(this, "device");
    /** Handle to underlying WebGL program */
    __publicField(this, "handle");
    /** vertex shader */
    __publicField(this, "vs");
    /** fragment shader */
    __publicField(this, "fs");
    /** The layout extracted from shader by WebGL introspection APIs */
    __publicField(this, "introspectedLayout");
    /** Uniforms set on this model */
    __publicField(this, "uniforms", {});
    /** Bindings set on this model */
    __publicField(this, "bindings", {});
    /** WebGL varyings */
    __publicField(this, "varyings", null);
    __publicField(this, "_uniformCount", 0);
    __publicField(this, "_uniformSetters", {});
    this.device = device;
    this.handle = this.props.handle || this.device.gl.createProgram();
    this.device.setSpectorMetadata(this.handle, { id: this.props.id });
    this.vs = props.vs;
    this.fs = props.fs;
    const { varyings, bufferMode = 35981 } = props;
    if (varyings && varyings.length > 0) {
      this.varyings = varyings;
      this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._linkShaders();
    log2.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
    this.introspectedLayout = getShaderLayoutFromGLSL(this.device.gl, this.handle);
    log2.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
    this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);
  }
  destroy() {
    if (this.handle) {
      this.device.gl.deleteProgram(this.handle);
      this.destroyed = true;
    }
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(bindings, options) {
    for (const [name2, value] of Object.entries(bindings)) {
      const binding = this.shaderLayout.bindings.find((binding_) => binding_.name === name2) || this.shaderLayout.bindings.find((binding_) => binding_.name === `${name2}Uniforms`);
      if (!binding) {
        const validBindings = this.shaderLayout.bindings.map((binding_) => `"${binding_.name}"`).join(", ");
        if (!options?.disableWarnings) {
          log2.warn(`No binding "${name2}" in render pipeline "${this.id}", expected one of ${validBindings}`, value)();
        }
        continue;
      }
      if (!value) {
        log2.warn(`Unsetting binding "${name2}" in render pipeline "${this.id}"`)();
      }
      switch (binding.type) {
        case "uniform":
          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
            throw new Error("buffer value");
          }
          break;
        case "texture":
          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error("texture value");
          }
          break;
        case "sampler":
          log2.warn(`Ignoring sampler ${name2}`)();
          break;
        default:
          throw new Error(binding.type);
      }
      this.bindings[name2] = value;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(options) {
    const {
      renderPass,
      parameters = this.props.parameters,
      topology = this.props.topology,
      vertexArray,
      vertexCount,
      // indexCount,
      instanceCount,
      isInstanced = false,
      firstVertex = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback
    } = options;
    const glDrawMode = getGLDrawMode(topology);
    const isIndexed = Boolean(vertexArray.indexBuffer);
    const glIndexType = vertexArray.indexBuffer?.glIndexType;
    if (this.linkStatus !== "success") {
      log2.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
      return false;
    }
    if (!this._areTexturesRenderable()) {
      log2.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
      return false;
    }
    this.device.gl.useProgram(this.handle);
    vertexArray.bindBeforeRender(renderPass);
    if (transformFeedback) {
      transformFeedback.begin(this.props.topology);
    }
    this._applyBindings();
    this._applyUniforms();
    const webglRenderPass = renderPass;
    withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {
      if (isIndexed && isInstanced) {
        this.device.gl.drawElementsInstanced(
          glDrawMode,
          vertexCount || 0,
          // indexCount?
          glIndexType,
          firstVertex,
          instanceCount || 0
        );
      } else if (isIndexed) {
        this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
      } else if (isInstanced) {
        this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
      } else {
        this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
      }
      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    vertexArray.unbindAfterRender(renderPass);
    return true;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(uniforms) {
    const { bindings } = splitUniformsAndBindings2(uniforms);
    Object.keys(bindings).forEach((name2) => {
      log2.warn(`Unsupported value "${JSON.stringify(bindings[name2])}" used in setUniforms() for key ${name2}. Use setBindings() instead?`)();
    });
    Object.assign(this.uniforms, uniforms);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl } = this.device;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    log2.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    gl.linkProgram(this.handle);
    log2.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    if (log2.level === 0) {
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      const status2 = this._getLinkStatus();
      this._reportLinkStatus(status2);
      return;
    }
    log2.once(1, "RenderPipeline linking is asynchronous")();
    await this._waitForLinkComplete();
    log2.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const status = this._getLinkStatus();
    this._reportLinkStatus(status);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  async _reportLinkStatus(status) {
    switch (status) {
      case "success":
        return;
      default:
        switch (this.vs.compilationStatus) {
          case "error":
            this.vs.debugShader();
            throw new Error(`Error during compilation of shader ${this.vs.id}`);
          case "pending":
            this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());
            break;
          case "success":
            break;
        }
        switch (this.fs?.compilationStatus) {
          case "error":
            this.fs.debugShader();
            throw new Error(`Error during compilation of shader ${this.fs.id}`);
          case "pending":
            this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());
            break;
          case "success":
            break;
        }
        const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);
        throw new Error(`Error during ${status}: ${linkErrorLog}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl } = this.device;
    const linked = gl.getProgramParameter(this.handle, 35714);
    if (!linked) {
      this.linkStatus = "error";
      return "linking";
    }
    gl.validateProgram(this.handle);
    const validated = gl.getProgramParameter(this.handle, 35715);
    if (!validated) {
      this.linkStatus = "error";
      return "validation";
    }
    this.linkStatus = "success";
    return "success";
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const waitMs = async (ms) => await new Promise((resolve3) => setTimeout(resolve3, ms));
    const DELAY_MS = 10;
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await waitMs(DELAY_MS);
      return;
    }
    const { gl } = this.device;
    for (; ; ) {
      const complete = gl.getProgramParameter(this.handle, 37297);
      if (complete) {
        return;
      }
      await waitMs(DELAY_MS);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const bindingInfo of this.shaderLayout.bindings) {
      if (!this.bindings[bindingInfo.name] && !this.bindings[bindingInfo.name.replace(/Uniforms$/, "")]) {
        log2.warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();
        texturesRenderable = false;
      }
    }
    return texturesRenderable;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success") {
      return;
    }
    const { gl } = this.device;
    gl.useProgram(this.handle);
    let textureUnit = 0;
    let uniformBufferIndex = 0;
    for (const binding of this.shaderLayout.bindings) {
      const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
      if (!value) {
        throw new Error(`No value for binding ${binding.name} in ${this.id}`);
      }
      switch (binding.type) {
        case "uniform":
          const { name: name2 } = binding;
          const location = gl.getUniformBlockIndex(this.handle, name2);
          if (location === 4294967295) {
            throw new Error(`Invalid uniform block name ${name2}`);
          }
          gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
          if (value instanceof WEBGLBuffer) {
            gl.bindBufferBase(35345, uniformBufferIndex, value.handle);
          } else {
            gl.bindBufferRange(
              35345,
              uniformBufferIndex,
              // @ts-expect-error
              value.buffer.handle,
              // @ts-expect-error
              value.offset || 0,
              // @ts-expect-error
              value.size || value.buffer.byteLength - value.offset
            );
          }
          uniformBufferIndex += 1;
          break;
        case "texture":
          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error("texture");
          }
          let texture;
          if (value instanceof WEBGLTextureView) {
            texture = value.texture;
          } else if (value instanceof WEBGLTexture) {
            texture = value;
          } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {
            log2.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")();
            texture = value.colorAttachments[0].texture;
          } else {
            throw new Error("No texture");
          }
          gl.activeTexture(33984 + textureUnit);
          gl.bindTexture(texture.glTarget, texture.handle);
          textureUnit += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${binding.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const uniformLayout of this.shaderLayout.uniforms || []) {
      const { name: name2, location, type, textureUnit } = uniformLayout;
      const value = this.uniforms[name2] ?? textureUnit;
      if (value !== void 0) {
        setUniform(this.device.gl, location, type, value);
      }
    }
  }
};
function mergeShaderLayout(baseLayout, overrideLayout) {
  const mergedLayout = {
    ...baseLayout,
    attributes: baseLayout.attributes.map((attribute) => ({ ...attribute }))
  };
  for (const attribute of overrideLayout?.attributes || []) {
    const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
    if (!baseAttribute) {
      log2.warn(`shader layout attribute ${attribute.name} not present in shader`);
    } else {
      baseAttribute.type = attribute.type || baseAttribute.type;
      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
    }
  }
  return mergedLayout;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js
var WEBGLCommandBuffer = class extends CommandBuffer {
  constructor(device) {
    super(device, {});
    __publicField(this, "device");
    __publicField(this, "commands", []);
    this.device = device;
  }
  submitCommands(commands = this.commands) {
    for (const command of commands) {
      switch (command.name) {
        case "copy-buffer-to-buffer":
          _copyBufferToBuffer(this.device, command.options);
          break;
        case "copy-buffer-to-texture":
          _copyBufferToTexture(this.device, command.options);
          break;
        case "copy-texture-to-buffer":
          _copyTextureToBuffer(this.device, command.options);
          break;
        case "copy-texture-to-texture":
          _copyTextureToTexture(this.device, command.options);
          break;
        default:
          throw new Error(command.name);
      }
    }
  }
};
function _copyBufferToBuffer(device, options) {
  const source3 = options.sourceBuffer;
  const destination = options.destinationBuffer;
  device.gl.bindBuffer(36662, source3.handle);
  device.gl.bindBuffer(36663, destination.handle);
  device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
  device.gl.bindBuffer(36662, null);
  device.gl.bindBuffer(36663, null);
}
function _copyBufferToTexture(device, options) {
  throw new Error("Not implemented");
}
function _copyTextureToBuffer(device, options) {
  const {
    /** Texture to copy to/from. */
    sourceTexture,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect = "all",
    /** Width to copy */
    width = options.sourceTexture.width,
    /** Height to copy */
    height = options.sourceTexture.height,
    depthOrArrayLayers = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin = [0, 0],
    /** Destination buffer */
    destinationBuffer,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage
  } = options;
  if (aspect !== "all") {
    throw new Error("aspect not supported in WebGL");
  }
  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
    throw new Error("not implemented");
  }
  const { framebuffer, destroyFramebuffer } = getFramebuffer2(sourceTexture);
  let prevHandle;
  try {
    const webglBuffer = destinationBuffer;
    const sourceWidth = width || framebuffer.width;
    const sourceHeight = height || framebuffer.height;
    const sourceParams = getTextureFormatWebGL(framebuffer.colorAttachments[0].texture.props.format);
    const sourceFormat = sourceParams.format;
    const sourceType = sourceParams.type;
    device.gl.bindBuffer(35051, webglBuffer.handle);
    prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
    device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
  } finally {
    device.gl.bindBuffer(35051, null);
    if (prevHandle !== void 0) {
      device.gl.bindFramebuffer(36160, prevHandle);
    }
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
}
function _copyTextureToTexture(device, options) {
  const {
    /** Texture to copy to/from. */
    sourceTexture,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin = [0, 0],
    /** Texture to copy to/from. */
    destinationTexture
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = options;
  let {
    width = options.destinationTexture.width,
    height = options.destinationTexture.height
    // depthOrArrayLayers = 0
  } = options;
  const { framebuffer, destroyFramebuffer } = getFramebuffer2(sourceTexture);
  const [sourceX, sourceY] = origin;
  const [destinationX, destinationY, destinationZ] = destinationOrigin;
  const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
  let texture = null;
  let textureTarget;
  if (destinationTexture instanceof WEBGLTexture) {
    texture = destinationTexture;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    textureTarget = texture.glTarget;
  } else {
    throw new Error("invalid destination");
  }
  switch (textureTarget) {
    case 3553:
    case 34067:
      device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);
      break;
    case 35866:
    case 32879:
      device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);
      break;
    default:
  }
  if (texture) {
    texture.unbind();
  }
  device.gl.bindFramebuffer(36160, prevHandle);
  if (destroyFramebuffer) {
    framebuffer.destroy();
  }
}
function getFramebuffer2(source3) {
  if (source3 instanceof Texture) {
    const { width, height, id } = source3;
    const framebuffer = source3.device.createFramebuffer({
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [source3]
    });
    return { framebuffer, destroyFramebuffer: true };
  }
  return { framebuffer: source3, destroyFramebuffer: false };
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js
var WEBGLCommandEncoder = class extends CommandEncoder {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "commandBuffer");
    this.device = device;
    this.commandBuffer = new WEBGLCommandBuffer(device);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
  }
  copyBufferToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
  }
  copyTextureToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
  }
  copyTextureToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
  }
  // clearTexture(options: ClearTextureOptions): void {
  //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
  // }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  resolveQuerySet(querySet, destination, options) {
  }
};

// node_modules/@luma.gl/webgl/dist/utils/fill-array.js
function fillArray2(options) {
  const { target: target2, source: source3, start = 0, count: count2 = 1 } = options;
  const length5 = source3.length;
  const total = count2 * length5;
  let copied = 0;
  for (let i3 = start; copied < length5; copied++) {
    target2[i3++] = source3[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target2.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target2.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return options.target;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js
var WEBGLVertexArray = class _WEBGLVertexArray extends VertexArray {
  // Create a VertexArray
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    /** Attribute 0 buffer constant */
    __publicField(this, "buffer", null);
    __publicField(this, "bufferValue", null);
    this.device = device;
    this.handle = this.device.gl.createVertexArray();
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(device) {
    return getBrowser() === "Chrome";
  }
  destroy() {
    super.destroy();
    if (this.buffer) {
      this.buffer?.destroy();
    }
    if (this.handle) {
      this.device.gl.deleteVertexArray(this.handle);
      this.handle = void 0;
    }
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(indexBuffer) {
    const buffer = indexBuffer;
    if (buffer && buffer.glTarget !== 34963) {
      throw new Error("Use .setBuffer()");
    }
    this.device.gl.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);
    this.indexBuffer = buffer;
    this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(location, attributeBuffer) {
    const buffer = attributeBuffer;
    if (buffer.glTarget === 34963) {
      throw new Error("Use .setIndexBuffer()");
    }
    const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
    this.device.gl.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(34962, buffer.handle);
    if (integer) {
      this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
    } else {
      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    }
    this.device.gl.bindBuffer(34962, null);
    this.device.gl.enableVertexAttribArray(location);
    this.device.gl.vertexAttribDivisor(location, divisor || 0);
    this.attributes[location] = buffer;
    this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(location, value) {
    this._enable(location, false);
    this.attributes[location] = value;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle);
    this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let location = 0; location < this.maxVertexAttributes; ++location) {
      const constant = this.attributes[location];
      if (ArrayBuffer.isView(constant)) {
        this.device.setConstantAttributeWebGL(location, constant);
      }
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(location) {
    const attributeInfo = this.attributeInfos[location];
    if (!attributeInfo) {
      throw new Error(`Unknown attribute location ${location}`);
    }
    const glType = getGLFromVertexType(attributeInfo.bufferDataType);
    return {
      size: attributeInfo.bufferComponents,
      type: glType,
      stride: attributeInfo.byteStride,
      offset: attributeInfo.byteOffset,
      normalized: attributeInfo.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: attributeInfo.integer,
      divisor: attributeInfo.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(location, enable2 = true) {
    const canDisableAttributeZero = _WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
    const canDisableAttribute = canDisableAttributeZero || location !== 0;
    if (enable2 || canDisableAttribute) {
      location = Number(location);
      this.device.gl.bindVertexArray(this.handle);
      if (enable2) {
        this.device.gl.enableVertexAttribArray(location);
      } else {
        this.device.gl.disableVertexAttribArray(location);
      }
      this.device.gl.bindVertexArray(null);
    }
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(elementCount, value) {
    const constantValue = normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length5 = constantValue.length * elementCount;
    if (this.buffer && byteLength !== this.buffer.byteLength) {
      throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
    }
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || this.device.createBuffer({ byteLength });
    updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
    if (updateNeeded) {
      const typedArray = getScratchArray(value.constructor, length5);
      fillArray2({ target: typedArray, source: constantValue, start: 0, count: length5 });
      this.buffer.write(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
};
function normalizeConstantArrayValue(arrayValue) {
  if (Array.isArray(arrayValue)) {
    return new Float32Array(arrayValue);
  }
  return arrayValue;
}
function compareConstantArrayValues(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i3 = 0; i3 < v1.length; ++i3) {
    if (v1[i3] !== v2[i3]) {
      return false;
    }
  }
  return true;
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js
var WEBGLTransformFeedback = class extends TransformFeedback {
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "gl");
    __publicField(this, "handle");
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */
    __publicField(this, "layout");
    __publicField(this, "buffers", {});
    __publicField(this, "unusedBuffers", {});
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */
    __publicField(this, "bindOnUse", true);
    __publicField(this, "_bound", false);
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || this.gl.createTransformFeedback();
    this.layout = this.props.layout;
    if (props.buffers) {
      this.setBuffers(props.buffers);
    }
    Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle);
    super.destroy();
  }
  begin(topology = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle);
    if (this.bindOnUse) {
      this._bindBuffers();
    }
    this.gl.beginTransformFeedback(getGLPrimitive(topology));
  }
  end() {
    this.gl.endTransformFeedback();
    if (this.bindOnUse) {
      this._unbindBuffers();
    }
    this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(buffers) {
    this.buffers = {};
    this.unusedBuffers = {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
  }
  setBuffer(locationOrName, bufferOrRange) {
    const location = this._getVaryingIndex(locationOrName);
    const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
    if (location < 0) {
      this.unusedBuffers[locationOrName] = buffer;
      log2.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
      return;
    }
    this.buffers[location] = { buffer, byteLength, byteOffset };
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteLength);
    }
  }
  getBuffer(locationOrName) {
    if (isIndex(locationOrName)) {
      return this.buffers[locationOrName] || null;
    }
    const location = this._getVaryingIndex(locationOrName);
    return location >= 0 ? this.buffers[location] : null;
  }
  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== "function") {
      this.gl.bindTransformFeedback(36386, funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this.gl.bindTransformFeedback(36386, this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this.gl.bindTransformFeedback(36386, null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(bufferOrRange) {
    if (bufferOrRange instanceof WEBGLBuffer) {
      return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
    }
    const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
    return { buffer, byteOffset, byteLength };
  }
  _getVaryingIndex(locationOrName) {
    if (isIndex(locationOrName)) {
      return Number(locationOrName);
    }
    for (const varying of this.layout.varyings) {
      if (locationOrName === varying.name) {
        return varying.location;
      }
    }
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const bufferIndex in this.buffers) {
      const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
    }
  }
  _unbindBuffers() {
    for (const bufferIndex in this.buffers) {
      this.gl.bindBufferBase(35982, Number(bufferIndex), null);
    }
  }
  _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
    const handle = buffer && buffer.handle;
    if (!handle || byteLength === void 0) {
      this.gl.bindBufferBase(35982, index, handle);
    } else {
      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteLength);
    }
  }
};
function isIndex(value) {
  if (typeof value === "number") {
    return Number.isInteger(value);
  }
  return /^\d+$/.test(value);
}

// node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js
var WEBGLQuerySet = class extends QuerySet {
  // Create a query class
  constructor(device, props) {
    super(device, props);
    __publicField(this, "device");
    __publicField(this, "handle");
    __publicField(this, "target", null);
    __publicField(this, "_queryPending", false);
    __publicField(this, "_pollingPromise", null);
    this.device = device;
    if (props.count > 1) {
      throw new Error("WebGL QuerySet can only have one value");
    }
    this.handle = this.device.gl.createQuery();
    Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Query";
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(options) {
    return this._begin(options?.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    const value = await this.pollQuery();
    return [value];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(target2) {
    if (this._queryPending) {
      return;
    }
    this.target = target2;
    this.device.gl.beginQuery(this.target, this.handle);
    return;
  }
  // ends the current query
  _end() {
    if (this._queryPending) {
      return;
    }
    if (this.target) {
      this.device.gl.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }
    return;
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }
    const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);
    if (resultAvailable) {
      this._queryPending = false;
    }
    return resultAvailable;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(limit = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise) {
      return this._pollingPromise;
    }
    let counter2 = 0;
    this._pollingPromise = new Promise((resolve3, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve3(this.getResult());
          this._pollingPromise = null;
        } else if (counter2++ > limit) {
          reject("Timed out");
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };
      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }
};

// node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js
var WebGLDevice = class extends Device {
  //
  // Public API
  //
  constructor(props) {
    super({ ...props, id: props.id || uid3("webgl-device") });
    //
    // Public `Device` API
    //
    /** type of this device */
    __publicField(this, "type", "webgl");
    // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
    /** The underlying WebGL context */
    __publicField(this, "handle");
    __publicField(this, "features");
    __publicField(this, "limits");
    __publicField(this, "info");
    __publicField(this, "canvasContext");
    __publicField(this, "lost");
    __publicField(this, "_resolveContextLost");
    /** WebGL2 context. */
    __publicField(this, "gl");
    __publicField(this, "debug", false);
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    __publicField(this, "_canvasSizeInfo", { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 });
    /** State used by luma.gl classes - TODO - not used? */
    __publicField(this, "_extensions", {});
    __publicField(this, "_polyfilled", false);
    /** Instance of Spector.js (if initialized) */
    __publicField(this, "spectorJS");
    __publicField(this, "renderPass", null);
    /** Store constants */
    __publicField(this, "_constants");
    const canvasContextProps = Device._getCanvasContextProps(props);
    if (!canvasContextProps) {
      throw new Error("WebGLDevice requires props.createCanvasContext to be set");
    }
    let device = canvasContextProps.canvas?.gl?.device;
    if (device) {
      throw new Error(`WebGL context already attached to device ${device.id}`);
    }
    this.canvasContext = new WebGLCanvasContext(this, canvasContextProps);
    this.lost = new Promise((resolve3) => {
      this._resolveContextLost = resolve3;
    });
    const webglContextAttributes = { ...props.webgl };
    if (canvasContextProps.alphaMode === "premultiplied") {
      webglContextAttributes.premultipliedAlpha = true;
    }
    if (props.powerPreference !== void 0) {
      webglContextAttributes.powerPreference = props.powerPreference;
    }
    const externalGLContext = this.props._handle;
    const gl = externalGLContext || createBrowserContext(this.canvasContext.canvas, {
      onContextLost: (event) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
      }),
      // eslint-disable-next-line no-console
      onContextRestored: (event) => console.log("WebGL context restored")
    }, webglContextAttributes);
    if (!gl) {
      throw new Error("WebGL context creation failed");
    }
    device = gl.device;
    if (device) {
      if (props._reuseDevices) {
        log2.log(1, `Not creating a new Device, instead returning a reference to Device ${device.id} already attached to WebGL context`, device)();
        device._reused = true;
        return device;
      }
      throw new Error(`WebGL context already attached to device ${device.id}`);
    }
    this.handle = gl;
    this.gl = gl;
    this.spectorJS = initializeSpectorJS({ ...this.props, gl: this.handle });
    this.gl.device = this;
    this.gl._version = 2;
    this.info = getDeviceInfo(this.gl, this._extensions);
    this.limits = new WebGLDeviceLimits(this.gl);
    this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props._disabledFeatures);
    if (this.props._initializeFeatures) {
      this.features.initializeFeatures();
    }
    if (canvasContextProps.autoResize !== false) {
      this.canvasContext.resize();
    }
    const glState = new WebGLStateTracker(this.gl, {
      log: (...args) => log2.log(1, ...args)()
    });
    glState.trackState(this.gl, { copyState: false });
    const debugWebGL = props.debugWebGL || props.debug;
    const traceWebGL = props.debugWebGL;
    if (debugWebGL) {
      this.gl = makeDebugContext(this.gl, { debugWebGL, traceWebGL });
      log2.warn("WebGL debug mode activated. Performance reduced.")();
      if (props.debugWebGL) {
        log2.level = Math.max(log2.level, 1);
      }
    }
  }
  /**
   * Destroys the device
   *
   * @note "Detaches" from the WebGL context unless _reuseDevices is true.
   *
   * @note The underlying WebGL context is not immediately destroyed,
   * but may be destroyed later through normal JavaScript garbage collection.
   * This is a fundamental limitation since WebGL does not offer any
   * browser API for destroying WebGL contexts.
   */
  destroy() {
    if (!this.props._reuseDevices && !this._reused) {
      delete this.gl.device;
    }
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(props) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(props) {
    const newProps = this._normalizeBufferProps(props);
    return new WEBGLBuffer(this, newProps);
  }
  createTexture(props) {
    return new WEBGLTexture(this, props);
  }
  createExternalTexture(props) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(props) {
    return new WEBGLSampler(this, props);
  }
  createShader(props) {
    return new WEBGLShader(this, props);
  }
  createFramebuffer(props) {
    return new WEBGLFramebuffer(this, props);
  }
  createVertexArray(props) {
    return new WEBGLVertexArray(this, props);
  }
  createTransformFeedback(props) {
    return new WEBGLTransformFeedback(this, props);
  }
  createQuerySet(props) {
    return new WEBGLQuerySet(this, props);
  }
  createRenderPipeline(props) {
    return new WEBGLRenderPipeline(this, props);
  }
  beginRenderPass(props) {
    return new WEBGLRenderPass(this, props);
  }
  createComputePipeline(props) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(props) {
    throw new Error("ComputePass not supported in WebGL");
  }
  createCommandEncoder(props = {}) {
    return new WEBGLCommandEncoder(this, props);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    this.renderPass?.end();
    this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(source3, options) {
    return readPixelsToArray(source3, options);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(source3, options) {
    return readPixelsToBuffer(source3, options);
  }
  setParametersWebGL(parameters) {
    setGLParameters(this.gl, parameters);
  }
  getParametersWebGL(parameters) {
    return getGLParameters(this.gl, parameters);
  }
  withParametersWebGL(parameters, func) {
    return withGLParameters(this.gl, parameters, func);
  }
  resetWebGL() {
    log2.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")();
    resetGLParameters(this.gl);
  }
  _getDeviceSpecificTextureFormatCapabilities(capabilities) {
    return getTextureFormatCapabilitiesWebGL(this.gl, capabilities, this._extensions);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    let deviceLossTriggered = false;
    const extensions = this.getExtension("WEBGL_lose_context");
    const ext = extensions.WEBGL_lose_context;
    if (ext) {
      deviceLossTriggered = true;
      ext.loseContext();
    }
    this._resolveContextLost?.({
      reason: "destroyed",
      message: "Application triggered context loss"
    });
    return deviceLossTriggered;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    const webglState = WebGLStateTracker.get(this.gl);
    webglState.push();
  }
  /** Restores previously saved context state */
  popState() {
    const webglState = WebGLStateTracker.get(this.gl);
    webglState.pop();
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(handle, props) {
    handle.__SPECTOR_Metadata = props;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(value, options) {
    const number = Number(value);
    for (const key in this.gl) {
      if (this.gl[key] === number) {
        return `GL.${key}`;
      }
    }
    return options?.emptyIfUnknown ? "" : String(value);
  }
  /**
   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
   */
  getGLKeys(glParameters) {
    const opts = { emptyIfUnknown: true };
    return Object.entries(glParameters).reduce((keys, [key, value]) => {
      keys[`${key}:${this.getGLKey(key, opts)}`] = `${value}:${this.getGLKey(value, opts)}`;
      return keys;
    }, {});
  }
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(location, constant) {
    const maxVertexAttributes = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
    const currentConstant = this._constants[location];
    if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
      log2.info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();
    }
    this._constants[location] = constant;
    switch (constant.constructor) {
      case Float32Array:
        setConstantFloatArray(this, location, constant);
        break;
      case Int32Array:
        setConstantIntArray(this, location, constant);
        break;
      case Uint32Array:
        setConstantUintArray(this, location, constant);
        break;
      default:
        throw new Error("constant");
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(name2) {
    getWebGLExtension(this.gl, name2, this._extensions);
    return this._extensions;
  }
};
function setConstantFloatArray(device, location, array) {
  switch (array.length) {
    case 1:
      device.gl.vertexAttrib1fv(location, array);
      break;
    case 2:
      device.gl.vertexAttrib2fv(location, array);
      break;
    case 3:
      device.gl.vertexAttrib3fv(location, array);
      break;
    case 4:
      device.gl.vertexAttrib4fv(location, array);
      break;
    default:
  }
}
function setConstantIntArray(device, location, array) {
  device.gl.vertexAttribI4iv(location, array);
}
function setConstantUintArray(device, location, array) {
  device.gl.vertexAttribI4uiv(location, array);
}
function compareConstantArrayValues2(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i3 = 0; i3 < v1.length; ++i3) {
    if (v1[i3] !== v2[i3]) {
      return false;
    }
  }
  return true;
}

// node_modules/@luma.gl/webgl/dist/context/polyfills/polyfill-webgl1-extensions.js
var WEBGL1_STATIC_EXTENSIONS = {
  WEBGL_depth_texture: {
    UNSIGNED_INT_24_8_WEBGL: 34042
  },
  OES_element_index_uint: {},
  OES_texture_float: {},
  OES_texture_half_float: {
    // @ts-expect-error different numbers?
    HALF_FLOAT_OES: 5131
  },
  EXT_color_buffer_float: {},
  OES_standard_derivatives: {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
  },
  EXT_frag_depth: {},
  EXT_blend_minmax: {
    MIN_EXT: 32775,
    MAX_EXT: 32776
  },
  EXT_shader_texture_lod: {}
};
var getWEBGL_draw_buffers = (gl) => ({
  drawBuffersWEBGL(buffers) {
    return gl.drawBuffers(buffers);
  },
  COLOR_ATTACHMENT0_WEBGL: 36064,
  COLOR_ATTACHMENT1_WEBGL: 36065,
  COLOR_ATTACHMENT2_WEBGL: 36066,
  COLOR_ATTACHMENT3_WEBGL: 36067
});
var getOES_vertex_array_object = (gl) => ({
  VERTEX_ARRAY_BINDING_OES: 34229,
  createVertexArrayOES() {
    return gl.createVertexArray();
  },
  deleteVertexArrayOES(vertexArray) {
    return gl.deleteVertexArray(vertexArray);
  },
  isVertexArrayOES(vertexArray) {
    return gl.isVertexArray(vertexArray);
  },
  bindVertexArrayOES(vertexArray) {
    return gl.bindVertexArray(vertexArray);
  }
});
var getANGLE_instanced_arrays = (gl) => ({
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
  drawArraysInstancedANGLE(...args) {
    return gl.drawArraysInstanced(...args);
  },
  drawElementsInstancedANGLE(...args) {
    return gl.drawElementsInstanced(...args);
  },
  vertexAttribDivisorANGLE(...args) {
    return gl.vertexAttribDivisor(...args);
  }
});
function enforceWebGL2(enforce = true) {
  const prototype = HTMLCanvasElement.prototype;
  if (!enforce && prototype.originalGetContext) {
    prototype.getContext = prototype.originalGetContext;
    prototype.originalGetContext = void 0;
    return;
  }
  prototype.originalGetContext = prototype.getContext;
  prototype.getContext = function(contextId, options) {
    if (contextId === "webgl" || contextId === "experimental-webgl") {
      const context = this.originalGetContext("webgl2", options);
      if (context instanceof HTMLElement) {
        polyfillWebGL1Extensions(context);
      }
      return context;
    }
    return this.originalGetContext(contextId, options);
  };
}
function polyfillWebGL1Extensions(gl) {
  gl.getExtension("EXT_color_buffer_float");
  const boundExtensions = {
    ...WEBGL1_STATIC_EXTENSIONS,
    WEBGL_disjoint_timer_query: gl.getExtension("EXT_disjoint_timer_query_webgl2"),
    WEBGL_draw_buffers: getWEBGL_draw_buffers(gl),
    OES_vertex_array_object: getOES_vertex_array_object(gl),
    ANGLE_instanced_arrays: getANGLE_instanced_arrays(gl)
  };
  const originalGetExtension = gl.getExtension;
  gl.getExtension = function(extensionName) {
    const ext = originalGetExtension.call(gl, extensionName);
    if (ext) {
      return ext;
    }
    if (extensionName in boundExtensions) {
      return boundExtensions[extensionName];
    }
    return null;
  };
  const originalGetSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function() {
    const extensions = originalGetSupportedExtensions.apply(gl) || [];
    return extensions?.concat(Object.keys(boundExtensions));
  };
}

// node_modules/@luma.gl/webgl/dist/adapter/webgl-adapter.js
var LOG_LEVEL2 = 1;
var WebGLAdapter = class extends Adapter {
  constructor() {
    super();
    /** type of device's created by this adapter */
    __publicField(this, "type", "webgl");
    Device.defaultProps = { ...Device.defaultProps, ...DEFAULT_SPECTOR_PROPS };
    WebGLDevice.adapter = this;
  }
  /** Check if WebGL 2 is available */
  isSupported() {
    return typeof WebGL2RenderingContext !== "undefined";
  }
  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
  enforceWebGL2(enable2) {
    enforceWebGL2(enable2);
  }
  /**
   * Get a device instance from a GL context
   * Creates a WebGLCanvasContext against the contexts canvas
   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
   * @param gl
   * @returns
   */
  async attach(gl) {
    if (gl instanceof WebGLDevice) {
      return gl;
    }
    if (gl?.device instanceof Device) {
      return gl.device;
    }
    if (!isWebGL(gl)) {
      throw new Error("Invalid WebGL2RenderingContext");
    }
    return new WebGLDevice({
      _handle: gl,
      createCanvasContext: { canvas: gl.canvas, autoResize: false }
    });
  }
  async create(props = {}) {
    log2.groupCollapsed(LOG_LEVEL2, "WebGLDevice created")();
    const promises = [];
    if (props.debugWebGL || props.debug) {
      promises.push(loadWebGLDeveloperTools());
    }
    if (props.debugSpectorJS) {
      promises.push(loadSpectorJS(props));
    }
    const results = await Promise.allSettled(promises);
    for (const result of results) {
      if (result.status === "rejected") {
        log2.error(`Failed to initialize debug libraries ${result.reason}`)();
      }
    }
    const device = new WebGLDevice(props);
    const message2 = `${device._reused ? "Reusing" : "Created"} device with WebGL2 ${device.debug ? "debug " : ""}context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
    log2.probe(LOG_LEVEL2, message2)();
    log2.table(LOG_LEVEL2, device.info)();
    log2.groupEnd(LOG_LEVEL2)();
    return device;
  }
};
function isWebGL(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
var webgl2Adapter = new WebGLAdapter();

// node_modules/@deck.gl/core/dist/lib/deck.js
function noop3() {
}
var getCursor = ({ isDragging }) => isDragging ? "grabbing" : "grab";
var defaultProps = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: {},
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: true,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: noop3,
  onWebGLInitialized: noop3,
  onResize: noop3,
  onViewStateChange: noop3,
  onInteractionStateChange: noop3,
  onBeforeRender: noop3,
  onAfterRender: noop3,
  onLoad: noop3,
  onError: (error) => log_default.error(error.message, error.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor,
  getTooltip: null,
  debug: false,
  drawPickingColors: false
};
var Deck = class {
  constructor(props) {
    this.width = 0;
    this.height = 0;
    this.userData = {};
    this.device = null;
    this.canvas = null;
    this.viewManager = null;
    this.layerManager = null;
    this.effectManager = null;
    this.deckRenderer = null;
    this.deckPicker = null;
    this.eventManager = null;
    this.widgetManager = null;
    this.tooltip = null;
    this.animationLoop = null;
    this.cursorState = {
      isHovering: false,
      isDragging: false
    };
    this.stats = new Stats({ id: "deck.gl" });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this._needsRedraw = "Initial render";
    this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    };
    this._lastPointerDownInfo = null;
    this._onPointerMove = (event) => {
      const { _pickRequest } = this;
      if (event.type === "pointerleave") {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;
        if (!pos) {
          return;
        }
        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }
      if (this.layerManager) {
        this.layerManager.context.mousePosition = { x: _pickRequest.x, y: _pickRequest.y };
      }
      _pickRequest.event = event;
    };
    this._onEvent = (event) => {
      const eventHandlerProp = EVENT_HANDLERS[event.type];
      const pos = event.offsetCenter;
      if (!eventHandlerProp || !pos || !this.layerManager) {
        return;
      }
      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const { layer } = info;
      const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);
      const rootHandler = this.props[eventHandlerProp];
      let handled = false;
      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }
      if (!handled) {
        rootHandler?.(info, event);
        this.widgetManager.onEvent(info, event);
      }
    };
    this._onPointerDown = (event) => {
      if (this.device?.type === "webgpu") {
        return;
      }
      const pos = event.offsetCenter;
      const pickedInfo = this._pick("pickObject", "pickObject Time", {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    };
    this.props = { ...defaultProps, ...props };
    props = this.props;
    if (props.viewState && props.initialViewState) {
      log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
    }
    this.viewState = this.props.initialViewState;
    if (props.device) {
      this.device = props.device;
    }
    let deviceOrPromise = this.device;
    if (!deviceOrPromise && props.gl) {
      if (props.gl instanceof WebGLRenderingContext) {
        log_default.error("WebGL1 context not supported.")();
      }
      deviceOrPromise = webgl2Adapter.attach(props.gl);
    }
    if (!deviceOrPromise) {
      deviceOrPromise = luma.createDevice({
        type: "best-available",
        // luma by default throws if a device is already attached
        // asynchronous device creation could happen after finalize() is called
        // TODO - createDevice should support AbortController?
        _reuseDevices: true,
        adapters: [webgl2Adapter],
        ...props.deviceProps,
        createCanvasContext: {
          canvas: this._createCanvas(props),
          useDevicePixels: this.props.useDevicePixels,
          // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`
          autoResize: false
        }
      });
    }
    this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);
    this.setProps(props);
    if (props._typedArrayManagerProps) {
      typed_array_manager_default.setOptions(props._typedArrayManagerProps);
    }
    this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    this.animationLoop?.stop();
    this.animationLoop?.destroy();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;
    this.layerManager?.finalize();
    this.layerManager = null;
    this.viewManager?.finalize();
    this.viewManager = null;
    this.effectManager?.finalize();
    this.effectManager = null;
    this.deckRenderer?.finalize();
    this.deckRenderer = null;
    this.deckPicker?.finalize();
    this.deckPicker = null;
    this.eventManager?.destroy();
    this.eventManager = null;
    this.widgetManager?.finalize();
    this.widgetManager = null;
    if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {
      this.canvas.parentElement?.removeChild(this.canvas);
      this.canvas = null;
    }
  }
  /** Partially update props */
  setProps(props) {
    this.stats.get("setProps Time").timeStart();
    if ("onLayerHover" in props) {
      log_default.removed("onLayerHover", "onHover")();
    }
    if ("onLayerClick" in props) {
      log_default.removed("onLayerClick", "onClick")();
    }
    if (props.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !deepEqual2(this.props.initialViewState, props.initialViewState, 3)) {
      this.viewState = props.initialViewState;
    }
    Object.assign(this.props, props);
    this._setCanvasSize(this.props);
    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    this.animationLoop?.setProps(resolvedProps);
    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
      this.widgetManager.setProps(resolvedProps);
    }
    this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(opts = { clearRedrawFlags: false }) {
    if (!this.layerManager) {
      return false;
    }
    if (this.props._animate) {
      return "Deck._animate";
    }
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(reason) {
    if (!this.layerManager) {
      return;
    }
    let redrawReason = this.needsRedraw({ clearRedrawFlags: true });
    redrawReason = reason || redrawReason;
    if (!redrawReason) {
      return;
    }
    this.stats.get("Redraw Count").incrementCount();
    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    assert8(this.viewManager);
    return this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(rect) {
    assert8(this.viewManager);
    return this.viewManager.getViewports(rect);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(opts) {
    const infos = this._pick("pickObject", "pickObject Time", opts).result;
    return infos.length ? infos[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(opts) {
    return this._pick("pickObjects", "pickObjects Time", opts);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({ resourceId: id, data: resources[id], forceUpdate });
    }
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(effect) {
    this.effectManager.addDefaultEffect(effect);
  }
  _addDefaultShaderModule(module) {
    this.layerManager.addDefaultShaderModule(module);
  }
  _removeDefaultShaderModule(module) {
    this.layerManager?.removeDefaultShaderModule(module);
  }
  _pick(method, statKey, opts) {
    assert8(this.deckPicker);
    const { stats } = this;
    stats.get("Pick Count").incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }
  /** Resolve props.canvas to element */
  _createCanvas(props) {
    let canvas2 = props.canvas;
    if (typeof canvas2 === "string") {
      canvas2 = document.getElementById(canvas2);
      assert8(canvas2);
    }
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      canvas2.id = props.id || "deckgl-overlay";
      const parent = props.parent || document.body;
      parent.appendChild(canvas2);
    }
    Object.assign(canvas2.style, props.style);
    return canvas2;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(props) {
    if (!this.canvas) {
      return;
    }
    const { width, height } = props;
    if (width || width === 0) {
      const cssWidth = Number.isFinite(width) ? `${width}px` : width;
      this.canvas.style.width = cssWidth;
    }
    if (height || height === 0) {
      const cssHeight = Number.isFinite(height) ? `${height}px` : height;
      this.canvas.style.position = props.style?.position || "absolute";
      this.canvas.style.height = cssHeight;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    const { canvas: canvas2 } = this;
    if (!canvas2) {
      return;
    }
    const newWidth = canvas2.clientWidth ?? canvas2.width;
    const newHeight = canvas2.clientHeight ?? canvas2.height;
    if (newWidth !== this.width || newHeight !== this.height) {
      this.width = newWidth;
      this.height = newHeight;
      this.viewManager?.setProps({ width: newWidth, height: newHeight });
      this.layerManager?.activateViewport(this.getViewports()[0]);
      this.props.onResize({ width: newWidth, height: newHeight });
    }
  }
  _createAnimationLoop(deviceOrPromise, props) {
    const {
      // width,
      // height,
      gl,
      // debug,
      onError,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels
    } = props;
    return new AnimationLoop({
      device: deviceOrPromise,
      useDevicePixels,
      // TODO v9
      autoResizeDrawingBuffer: !gl,
      // do not auto resize external context
      autoResizeViewport: false,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (context) => this._setDevice(context.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views } = this.props;
    const normalizedViews = Array.isArray(views) ? views : (
      // If null, default to a full screen map view port
      views ? [views] : [new map_view_default({ id: "default-view" })]
    );
    if (normalizedViews.length && this.props.controller) {
      normalizedViews[0].props.controller = this.props.controller;
    }
    return normalizedViews;
  }
  _onContextLost() {
    const { onError } = this.props;
    if (this.animationLoop && onError) {
      onError(new Error("WebGL context is lost"));
    }
  }
  /** Actually run picking */
  _pickAndCallback() {
    if (this.device?.type === "webgpu") {
      return;
    }
    const { _pickRequest } = this;
    if (_pickRequest.event) {
      const { result, emptyInfo } = this._pick("pickObject", "pickObject Time", _pickRequest);
      this.cursorState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;
      for (const info of result) {
        pickedInfo = info;
        handled = info.layer?.onHover(info, _pickRequest.event) || handled;
      }
      if (!handled) {
        this.props.onHover?.(pickedInfo, _pickRequest.event);
        this.widgetManager.onHover(pickedInfo, _pickRequest.event);
      }
      _pickRequest.event = null;
    }
  }
  _updateCursor() {
    const container = this.props.parent || this.canvas;
    if (container) {
      container.style.cursor = this.props.getCursor(this.cursorState);
    }
  }
  _setDevice(device) {
    this.device = device;
    if (!this.animationLoop) {
      return;
    }
    if (!this.canvas) {
      this.canvas = this.device.canvasContext?.canvas;
    }
    if (this.device.type === "webgl") {
      this.device.setParametersWebGL({
        blend: true,
        blendFunc: [770, 771, 1, 771],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: 515
      });
    }
    this.props.onDeviceInitialized(this.device);
    if (this.device.type === "webgl") {
      this.props.onWebGLInitialized(this.device.gl);
    }
    const timeline = new Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new EventManager(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizers: Object.keys(RECOGNIZERS).map((eventName) => {
        const [RecognizerConstructor, defaultOptions2, recognizeWith, requestFailure] = RECOGNIZERS[eventName];
        const optionsOverride = this.props.eventRecognizerOptions?.[eventName];
        const options = { ...defaultOptions2, ...optionsOverride, event: eventName };
        return {
          recognizer: new RecognizerConstructor(options),
          recognizeWith,
          requestFailure
        };
      }),
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const eventType in EVENT_HANDLERS) {
      this.eventManager.on(eventType, this._onEvent);
    }
    this.viewManager = new ViewManager({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new LayerManager(this.device, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new EffectManager({
      deck: this,
      device: this.device
    });
    this.deckRenderer = new DeckRenderer(this.device);
    this.deckPicker = new DeckPicker(this.device);
    this.widgetManager = new WidgetManager({
      deck: this,
      parentElement: this.canvas?.parentElement
    });
    this.widgetManager.addDefault(new Tooltip());
    this.setProps(this.props);
    this._updateCanvasSize();
    this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(redrawReason, renderOptions) {
    const { device, gl } = this.layerManager.context;
    this.props.onBeforeRender({ device, gl });
    const opts = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...renderOptions
    };
    this.deckRenderer?.renderLayers(opts);
    if (opts.pass === "screen") {
      this.widgetManager.onRedraw({
        viewports: opts.viewports,
        layers: opts.layers
      });
    }
    this.props.onAfterRender({ device, gl });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats();
    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();
      this.stats.reset();
      log_default.table(4, this.metrics)();
      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }
    this._updateCanvasSize();
    this._updateCursor();
    this.layerManager.updateLayers();
    if (this.device?.type !== "webgpu") {
      this._pickAndCallback();
    }
    this.redraw();
    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }
  // Callbacks
  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;
    if (this.viewState) {
      this.viewState = { ...this.viewState, [params.viewId]: viewState };
      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({ viewState: this.viewState });
        }
      }
    }
  }
  _onInteractionStateChange(interactionState) {
    this.cursorState.isDragging = interactionState.isDragging || false;
    this.props.onInteractionStateChange(interactionState);
  }
  _getFrameStats() {
    const { stats } = this;
    stats.get("frameRate").timeEnd();
    stats.get("frameRate").timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
    stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics, stats } = this;
    metrics.fps = stats.get("frameRate").getHz();
    metrics.setPropsTime = stats.get("setProps Time").time;
    metrics.updateAttributesTime = stats.get("Update Attributes").time;
    metrics.framesRedrawn = stats.get("Redraw Count").count;
    metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
    metrics.pickCount = stats.get("Pick Count").count;
    metrics.gpuTime = stats.get("GPU Time").time;
    metrics.cpuTime = stats.get("CPU Time").time;
    metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
    metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
    const memoryStats = luma.stats.get("Memory Usage");
    metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
    metrics.textureMemory = memoryStats.get("Texture Memory").count;
    metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
    metrics.gpuMemory = memoryStats.get("GPU Memory").count;
  }
};
Deck.defaultProps = defaultProps;
Deck.VERSION = VERSION5;
var deck_default = Deck;

// node_modules/@deck.gl/core/dist/lib/attribute/gl-utils.js
function typedArrayFromDataType(type) {
  switch (type) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return getTypedArrayFromDataType(type);
  }
}
var dataTypeFromTypedArray = getDataTypeFromTypedArray;
function getBufferAttributeLayout(name2, accessor, deviceType) {
  const type = deviceType === "webgpu" && accessor.type === "uint8" ? "unorm8" : accessor.type;
  return {
    attribute: name2,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: accessor.size > 1 ? `${type}x${accessor.size}` : accessor.type,
    byteOffset: accessor.offset || 0
    // Note stride is set on the top level
  };
}
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function bufferLayoutEqual(accessor1, accessor2) {
  return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);
}

// node_modules/@deck.gl/core/dist/lib/attribute/data-column.js
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  }
  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = (
    // offsets defined by the attribute
    vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + // offsets defined by external buffers if any
    (baseAccessor.offset || 0)
  );
  return {
    ...shaderAttributeOptions,
    offset,
    stride
  };
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: {
      ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}
var DataColumn = class {
  /* eslint-disable max-statements */
  constructor(device, opts, state) {
    this._buffer = null;
    this.device = device;
    this.id = opts.id || "";
    this.size = opts.size || 1;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === "float64";
    let { defaultValue } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    let bufferType;
    if (doublePrecision) {
      bufferType = "float32";
    } else if (!logicalType && opts.isIndexed) {
      bufferType = "uint32";
    } else {
      bufferType = logicalType || "float32";
    }
    let defaultType = typedArrayFromDataType(logicalType || bufferType);
    this.doublePrecision = doublePrecision;
    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }
    this.value = null;
    this.settings = {
      ...opts,
      defaultType,
      defaultValue,
      logicalType,
      type: bufferType,
      normalized: bufferType.includes("norm"),
      size: this.size,
      bytesPerElement: defaultType.BYTES_PER_ELEMENT
    };
    this.state = {
      ...state,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const accessor = this.getAccessor();
    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }
    return 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(n2) {
    this.state.numInstances = n2;
  }
  delete() {
    if (this._buffer) {
      this._buffer.delete();
      this._buffer = null;
    }
    typed_array_manager_default.release(this.state.allocatedValue);
  }
  getBuffer() {
    if (this.state.constant) {
      return null;
    }
    return this.state.externalBuffer || this._buffer;
  }
  getValue(attributeName = this.id, options = null) {
    const result = {};
    if (this.state.constant) {
      const value = this.value;
      if (options) {
        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
        const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;
        const size = shaderAttributeDef.size || this.size;
        result[attributeName] = value.subarray(offset, offset + size);
      } else {
        result[attributeName] = value;
      }
    } else {
      result[attributeName] = this.getBuffer();
    }
    if (this.doublePrecision) {
      if (this.value instanceof Float64Array) {
        result[`${attributeName}64Low`] = result[attributeName];
      } else {
        result[`${attributeName}64Low`] = new Float32Array(this.size);
      }
    }
    return result;
  }
  _getBufferLayout(attributeName = this.id, options = null) {
    const accessor = this.getAccessor();
    const attributes = [];
    const result = {
      name: this.id,
      byteStride: getStride(accessor),
      attributes
    };
    if (this.doublePrecision) {
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});
      attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...doubleShaderAttributeDefs.high }, this.device.type), getBufferAttributeLayout(`${attributeName}64Low`, {
        ...accessor,
        ...doubleShaderAttributeDefs.low
      }, this.device.type));
    } else if (options) {
      const shaderAttributeDef = resolveShaderAttribute(accessor, options);
      attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...shaderAttributeDef }, this.device.type));
    } else {
      attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));
    }
    return result;
  }
  setAccessor(accessor) {
    this.state.bufferAccessor = accessor;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }
    let result = null;
    if (this.state.constant && this.value) {
      const min4 = Array.from(this.value);
      result = [min4, min4];
    } else {
      const { value, numInstances, size } = this;
      const len4 = numInstances * size;
      if (value && len4 && value.length >= len4) {
        const min4 = new Array(size).fill(Infinity);
        const max4 = new Array(size).fill(-Infinity);
        for (let i3 = 0; i3 < len4; ) {
          for (let j2 = 0; j2 < size; j2++) {
            const v2 = value[i3++];
            if (v2 < min4[j2])
              min4[j2] = v2;
            if (v2 > max4[j2])
              max4[j2] = v2;
          }
        }
        result = [min4, max4];
      }
    }
    this.state.bounds = result;
    return result;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(data) {
    const { state } = this;
    let opts;
    if (ArrayBuffer.isView(data)) {
      opts = { value: data };
    } else if (data instanceof Buffer2) {
      opts = { buffer: data };
    } else {
      opts = data;
    }
    const accessor = { ...this.settings, ...opts };
    if (ArrayBuffer.isView(opts.value)) {
      if (!opts.type) {
        const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;
        if (is64Bit) {
          accessor.type = "float32";
        } else {
          const type = dataTypeFromTypedArray(opts.value);
          accessor.type = accessor.normalized ? type.replace("int", "norm") : type;
        }
      }
      accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
    }
    state.bounds = null;
    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);
      if (this.settings.normalized) {
        value = this.normalizeConstant(value);
      }
      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
      if (!hasChanged) {
        return false;
      }
      state.externalBuffer = null;
      state.constant = true;
      this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);
    } else if (opts.buffer) {
      const buffer = opts.buffer;
      state.externalBuffer = buffer;
      state.constant = false;
      this.value = opts.value || null;
    } else if (opts.value) {
      this._checkExternalBuffer(opts);
      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      let { buffer } = this;
      const stride = getStride(accessor);
      const byteOffset = (accessor.vertexOffset || 0) * stride;
      if (this.doublePrecision && value instanceof Float64Array) {
        value = toDoublePrecisionArray(value, accessor);
      }
      if (this.settings.isIndexed) {
        const ArrayType = this.settings.defaultType;
        if (value.constructor !== ArrayType) {
          value = new ArrayType(value);
        }
      }
      const requiredBufferSize = value.byteLength + byteOffset + stride * 2;
      if (!buffer || buffer.byteLength < requiredBufferSize) {
        buffer = this._createBuffer(requiredBufferSize);
      }
      buffer.write(value, byteOffset);
    }
    this.setAccessor(accessor);
    return true;
  }
  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const value = this.value;
    const { startOffset = 0, endOffset } = opts;
    this.buffer.write(this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
      size: this.size,
      startIndex: startOffset,
      endIndex: endOffset
    }) : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(numInstances, copy6 = false) {
    const { state } = this;
    const oldValue = state.allocatedValue;
    const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: copy6
    });
    this.value = value;
    const { byteOffset } = this;
    let { buffer } = this;
    if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {
      buffer = this._createBuffer(value.byteLength + byteOffset);
      if (copy6 && oldValue) {
        buffer.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);
      }
    }
    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    this.setAccessor(this.settings);
    return true;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(opts) {
    const { value } = opts;
    if (!ArrayBuffer.isView(value)) {
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    }
    const ArrayType = this.settings.defaultType;
    let illegalArrayType = false;
    if (this.doublePrecision) {
      illegalArrayType = value.BYTES_PER_ELEMENT < 4;
    }
    if (illegalArrayType) {
      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
    }
    if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
      log_default.warn(`Attribute ${this.id} is normalized`)();
    }
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(value) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(value).map((x2) => (x2 + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(value).map((x2) => (x2 + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(value).map((x2) => x2 / 255);
      case "unorm16":
        return new Float32Array(value).map((x2) => x2 / 65535);
      default:
        return value;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(value, out, start) {
    const { defaultValue, size } = this.settings;
    if (Number.isFinite(value)) {
      out[start] = value;
      return out;
    }
    if (!value) {
      let i3 = size;
      while (--i3 >= 0) {
        out[start + i3] = defaultValue[i3];
      }
      return out;
    }
    switch (size) {
      case 4:
        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
      case 3:
        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
      case 2:
        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
      case 1:
        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;
      default:
        let i3 = size;
        while (--i3 >= 0) {
          out[start + i3] = Number.isFinite(value[i3]) ? value[i3] : defaultValue[i3];
        }
    }
    return out;
  }
  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }
    const { size } = this;
    for (let i3 = 0; i3 < size; i3++) {
      if (value1[i3] !== value2[i3]) {
        return false;
      }
    }
    return true;
  }
  _createBuffer(byteLength) {
    if (this._buffer) {
      this._buffer.destroy();
    }
    const { isIndexed, type } = this.settings;
    this._buffer = this.device.createBuffer({
      ...this._buffer?.props,
      id: this.id,
      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read
      usage: (isIndexed ? Buffer2.INDEX : Buffer2.VERTEX) | Buffer2.COPY_DST,
      indexType: isIndexed ? type : void 0,
      byteLength
    });
    return this._buffer;
  }
};

// node_modules/@deck.gl/core/dist/utils/iterable-utils.js
var EMPTY_ARRAY = [];
var placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === "function") {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return { iterable, objectInfo };
}
function isAsyncIterable2(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const { size, stride, offset, startIndices, nested } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_2, { index, target: target2 }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;
      for (let j2 = 0; j2 < size; j2++) {
        target2[j2] = typedArray[sourceIndex + j2];
      }
      return target2;
    }
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (let i3 = startIndex; i3 < endIndex; i3++) {
        const sourceIndex = i3 * elementStride + elementOffset;
        target2 = new Array(size);
        for (let j2 = 0; j2 < size; j2++) {
          target2[j2] = typedArray[sourceIndex + j2];
        }
        result[i3 - startIndex] = target2;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;
      for (let i3 = startIndex; i3 < endIndex; i3++) {
        const sourceIndex = i3 * elementStride + elementOffset;
        for (let j2 = 0; j2 < size; j2++) {
          result[targetIndex++] = typedArray[sourceIndex + j2];
        }
      }
    }
    return result;
  };
}

// node_modules/@deck.gl/core/dist/utils/range.js
var EMPTY = [];
var FULL = [[0, Infinity]];
function add6(rangeList, range3) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range3[0] < 0) {
    range3[0] = 0;
  }
  if (range3[0] >= range3[1]) {
    return rangeList;
  }
  const newRangeList = [];
  const len4 = rangeList.length;
  let insertPosition = 0;
  for (let i3 = 0; i3 < len4; i3++) {
    const range0 = rangeList[i3];
    if (range0[1] < range3[0]) {
      newRangeList.push(range0);
      insertPosition = i3 + 1;
    } else if (range0[0] > range3[1]) {
      newRangeList.push(range0);
    } else {
      range3 = [Math.min(range0[0], range3[0]), Math.max(range0[1], range3[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range3);
  return newRangeList;
}

// node_modules/@deck.gl/core/dist/lib/attribute/transition-settings.js
var DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: (t2) => t2
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = { type: "interpolation", duration: userSettings };
  }
  const type = userSettings.type || "interpolation";
  return {
    ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}

// node_modules/@deck.gl/core/dist/lib/attribute/attribute.js
var Attribute = class extends DataColumn {
  constructor(device, opts) {
    super(device, opts, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      layoutChanged: false,
      updateRanges: FULL
    });
    this.constant = false;
    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
    Object.seal(this.settings);
    Object.seal(this.state);
    this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(layout) {
    this.state.startIndices = layout;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags = false } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(accessor) {
    var _a5;
    (_a5 = this.state).layoutChanged || (_a5.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));
    super.setAccessor(accessor);
  }
  getUpdateTriggers() {
    const { accessor } = this.settings;
    return [this.id].concat(typeof accessor !== "function" && accessor || []);
  }
  supportsTransition() {
    return Boolean(this.settings.transition);
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }
    const { accessor } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? (
      // @ts-ignore
      opts[accessor.find((a2) => opts[a2])]
    ) : (
      // @ts-ignore
      opts[accessor]
    );
    return normalizeTransitionSettings(userSettings, layerSettings);
  }
  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);
    if (dataRange) {
      const { startRow = 0, endRow = Infinity } = dataRange;
      this.state.updateRanges = add6(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = FULL;
    }
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = EMPTY;
  }
  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }
  allocate(numInstances) {
    const { state, settings } = this;
    if (settings.noAlloc) {
      return false;
    }
    if (settings.update) {
      super.allocate(numInstances, state.updateRanges !== FULL);
      return true;
    }
    return false;
  }
  updateBuffer({ numInstances, data, props, context }) {
    if (!this.needsUpdate()) {
      return false;
    }
    const { state: { updateRanges }, settings: { update, noAlloc } } = this;
    let updated = true;
    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, { data, startRow, endRow, props, numInstances });
      }
      if (!this.value) {
      } else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({ startOffset, endOffset });
        }
      }
      this._checkAttributeArray();
    } else {
      updated = false;
    }
    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(value) {
    const isWebGPU = this.device.type === "webgpu";
    if (isWebGPU || value === void 0 || typeof value === "function") {
      return false;
    }
    const hasChanged = this.setData({ constant: true, value });
    if (hasChanged) {
      this.setNeedsRedraw();
    }
    this.clearNeedsUpdate();
    return true;
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(buffer) {
    const { state } = this;
    if (!buffer) {
      state.lastExternalBuffer = null;
      return false;
    }
    this.clearNeedsUpdate();
    if (state.lastExternalBuffer === buffer) {
      return true;
    }
    state.lastExternalBuffer = buffer;
    this.setNeedsRedraw();
    this.setData(buffer);
    return true;
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(buffer, startIndices = null) {
    const { state, settings } = this;
    if (!buffer) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }
    if (settings.noAlloc) {
      return false;
    }
    if (state.binaryValue === buffer) {
      this.clearNeedsUpdate();
      return true;
    }
    state.binaryValue = buffer;
    this.setNeedsRedraw();
    const needsUpdate = settings.transform || startIndices !== this.startIndices;
    if (needsUpdate) {
      if (ArrayBuffer.isView(buffer)) {
        buffer = { value: buffer };
      }
      const binaryValue = buffer;
      assert8(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
        size: binaryValue.size || this.size,
        stride: binaryValue.stride,
        offset: binaryValue.offset,
        startIndices,
        nested: needsNormalize
      });
      return false;
    }
    this.clearNeedsUpdate();
    this.setData(buffer);
    return true;
  }
  getVertexOffset(row) {
    const { startIndices } = this;
    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
    return vertexIndex * this.size;
  }
  getValue() {
    const shaderAttributeDefs = this.settings.shaderAttributes;
    const result = super.getValue();
    if (!shaderAttributeDefs) {
      return result;
    }
    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }
    return result;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(modelInfo) {
    this.state.layoutChanged = false;
    const shaderAttributeDefs = this.settings.shaderAttributes;
    const result = super._getBufferLayout();
    const { stepMode } = this.settings;
    if (stepMode === "dynamic") {
      result.stepMode = modelInfo ? modelInfo.isInstanced ? "instance" : "vertex" : "instance";
    } else {
      result.stepMode = stepMode ?? "vertex";
    }
    if (!shaderAttributeDefs) {
      return result;
    }
    for (const shaderAttributeName in shaderAttributeDefs) {
      const map3 = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);
      result.attributes.push(...map3.attributes);
    }
    return result;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(attribute, { data, startRow, endRow, props, numInstances }) {
    if (attribute.constant) {
      if (this.context.device.type !== "webgpu") {
        return;
      }
    }
    const { settings, state, value, size, startIndices } = attribute;
    const { accessor, transform } = settings;
    let accessorFunc = state.binaryAccessor || // @ts-ignore
    (typeof accessor === "function" ? accessor : props[accessor]);
    if (typeof accessorFunc !== "function") {
      accessorFunc = () => accessorFunc;
    }
    assert8(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
    let i3 = attribute.getVertexOffset(startRow);
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object, objectInfo);
      if (transform) {
        objectValue = transform.call(this, objectValue);
      }
      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i3;
          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);
            startIndex += size;
          }
        } else if (objectValue && objectValue.length > size) {
          value.set(objectValue, i3);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);
          fillArray({
            target: value,
            source: objectInfo.target,
            start: i3,
            count: numVertices
          });
        }
        i3 += numVertices * size;
      } else {
        attribute._normalizeValue(objectValue, value, i3);
        i3 += size;
      }
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === "function";
    if (!hasUpdater) {
      throw new Error(`Attribute ${this.id} missing update or accessor`);
    }
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value } = this;
    const limit = Math.min(4, this.size);
    if (value && value.length >= limit) {
      let valid = true;
      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);
        case 3:
          valid = valid && Number.isFinite(value[2]);
        case 2:
          valid = valid && Number.isFinite(value[1]);
        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;
        default:
          valid = false;
      }
      if (!valid) {
        throw new Error(`Illegal attribute generated for ${this.id}`);
      }
    }
  }
};

// node_modules/@deck.gl/core/dist/utils/array-utils.js
function padArrayChunk(options) {
  const { source: source3, target: target2, start = 0, size, getData } = options;
  const end = options.end || target2.length;
  const sourceLength = source3.length;
  const targetLength = end - start;
  if (sourceLength > targetLength) {
    target2.set(source3.subarray(0, targetLength), start);
    return;
  }
  target2.set(source3, start);
  if (!getData) {
    return;
  }
  let i3 = sourceLength;
  while (i3 < targetLength) {
    const datum = getData(i3, source3);
    for (let j2 = 0; j2 < size; j2++) {
      target2[start + i3] = datum[j2] || 0;
      i3++;
    }
  }
}
function padArray({ source: source3, target: target2, size, getData, sourceStartIndices, targetStartIndices }) {
  if (!sourceStartIndices || !targetStartIndices) {
    padArrayChunk({
      source: source3,
      target: target2,
      size,
      getData
    });
    return target2;
  }
  let sourceIndex = 0;
  let targetIndex = 0;
  const getChunkData = getData && ((i3, chunk) => getData(i3 + targetIndex, chunk));
  const n2 = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (let i3 = 1; i3 < n2; i3++) {
    const nextSourceIndex = sourceStartIndices[i3] * size;
    const nextTargetIndex = targetStartIndices[i3] * size;
    padArrayChunk({
      source: source3.subarray(sourceIndex, nextSourceIndex),
      target: target2,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target2.length) {
    padArrayChunk({
      // @ts-ignore
      source: [],
      target: target2,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }
  return target2;
}

// node_modules/@deck.gl/core/dist/transitions/gpu-transition-utils.js
function cloneAttribute(attribute) {
  const { device, settings, value } = attribute;
  const newAttribute = new Attribute(device, settings);
  newAttribute.setData({
    value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: settings.normalized
  });
  return newAttribute;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${size}"`);
  }
}
function getFloat32VertexFormat(size) {
  switch (size) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const { doublePrecision, settings, value, size } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  let maxVertexOffset = 0;
  const { shaderAttributes } = attribute.settings;
  if (shaderAttributes) {
    for (const shaderAttribute of Object.values(shaderAttributes)) {
      maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);
    }
  }
  return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;
}
function matchBuffer({ device, source: source3, target: target2 }) {
  if (!target2 || target2.byteLength < source3.byteLength) {
    target2?.destroy();
    target2 = device.createBuffer({
      byteLength: source3.byteLength,
      usage: source3.usage
    });
  }
  return target2;
}
function padBuffer({ device, buffer, attribute, fromLength, toLength, fromStartIndices, getData = (x2) => x2 }) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const isConstant = attribute.isConstant;
  if (!hasStartIndices && buffer && fromLength >= toLength) {
    return buffer;
  }
  const ArrayType = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;
  const toData = isConstant ? attribute.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new ArrayType(attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer)
  );
  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;
    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }
  const getMissingData = isConstant ? (i3, chunk) => getData(toData, chunk) : (i3, chunk) => getData(toData.subarray(i3 + byteOffset, i3 + byteOffset + size), chunk);
  const source3 = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);
  const target2 = new Float32Array(toLength);
  padArray({
    source: source3,
    target: target2,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });
  if (!buffer || buffer.byteLength < target2.byteLength + targetByteOffset) {
    buffer?.destroy();
    buffer = device.createBuffer({
      byteLength: target2.byteLength + targetByteOffset,
      usage: 35050
    });
  }
  buffer.write(target2, targetByteOffset);
  return buffer;
}

// node_modules/@deck.gl/core/dist/transitions/gpu-transition.js
var GPUTransitionBase = class {
  constructor({ device, attribute, timeline }) {
    this.buffers = [];
    this.currentLength = 0;
    this.device = device;
    this.transition = new Transition(timeline);
    this.attribute = attribute;
    this.attributeInTransition = cloneAttribute(attribute);
    this.currentStartIndices = attribute.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances, duration = Infinity) {
    this.settings = transitionSettings;
    this.currentStartIndices = this.attribute.startIndices;
    this.currentLength = getAttributeBufferLength(this.attribute, numInstances);
    this.transition.start({ ...transitionSettings, duration });
  }
  update() {
    const updated = this.transition.update();
    if (updated) {
      this.onUpdate();
    }
    return updated;
  }
  setBuffer(buffer) {
    this.attributeInTransition.setData({
      buffer,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const buffer of this.buffers) {
      buffer.destroy();
    }
    this.buffers.length = 0;
  }
};

// node_modules/@deck.gl/core/dist/transitions/gpu-interpolation-transition.js
var GPUInterpolationTransition = class extends GPUTransitionBase {
  constructor({ device, attribute, timeline }) {
    super({ device, attribute, timeline });
    this.type = "interpolation";
    this.transform = getTransform(device, attribute);
  }
  start(transitionSettings, numInstances) {
    const prevLength = this.currentLength;
    const prevStartIndices = this.currentStartIndices;
    super.start(transitionSettings, numInstances, transitionSettings.duration);
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers, attribute } = this;
    cycleBuffers(buffers);
    buffers[0] = padBuffer({
      device: this.device,
      buffer: buffers[0],
      attribute,
      fromLength: prevLength,
      toLength: this.currentLength,
      fromStartIndices: prevStartIndices,
      getData: transitionSettings.enter
    });
    buffers[1] = matchBuffer({
      device: this.device,
      source: buffers[0],
      target: buffers[1]
    });
    this.setBuffer(buffers[1]);
    const { transform } = this;
    const model = transform.model;
    let vertexCount = Math.floor(this.currentLength / attribute.size);
    if (useFp64(attribute)) {
      vertexCount /= 2;
    }
    model.setVertexCount(vertexCount);
    if (attribute.isConstant) {
      model.setAttributes({ aFrom: buffers[0] });
      model.setConstantAttributes({ aTo: attribute.value });
    } else {
      model.setAttributes({
        aFrom: buffers[0],
        aTo: attribute.getBuffer()
      });
    }
    transform.transformFeedback.setBuffers({ vCurrent: buffers[1] });
  }
  onUpdate() {
    const { duration, easing } = this.settings;
    const { time } = this.transition;
    let t2 = time / duration;
    if (easing) {
      t2 = easing(t2);
    }
    const { model } = this.transform;
    const interpolationProps = { time: t2 };
    model.shaderInputs.setProps({ interpolation: interpolationProps });
    this.transform.run({ discard: true });
  }
  delete() {
    super.delete();
    this.transform.destroy();
  }
};
var uniformBlock3 = `uniform interpolationUniforms {
  float time;
} interpolation;
`;
var interpolationUniforms = {
  name: "interpolation",
  vs: uniformBlock3,
  uniformTypes: {
    time: "f32"
  }
};
var vs5 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`;
var vs64 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function useFp64(attribute) {
  return attribute.doublePrecision && attribute.value instanceof Float64Array;
}
function getTransform(device, attribute) {
  const attributeSize = attribute.size;
  const attributeType = getAttributeTypeFromSize(attributeSize);
  const inputFormat = getFloat32VertexFormat(attributeSize);
  const bufferLayout = attribute.getBufferLayout();
  if (useFp64(attribute)) {
    return new BufferTransform(device, {
      vs: vs64,
      bufferLayout: [
        {
          name: "aFrom",
          byteStride: 8 * attributeSize,
          attributes: [
            { attribute: "aFrom", format: inputFormat, byteOffset: 0 },
            { attribute: "aFrom64Low", format: inputFormat, byteOffset: 4 * attributeSize }
          ]
        },
        {
          name: "aTo",
          byteStride: 8 * attributeSize,
          attributes: [
            { attribute: "aTo", format: inputFormat, byteOffset: 0 },
            { attribute: "aTo64Low", format: inputFormat, byteOffset: 4 * attributeSize }
          ]
        }
      ],
      // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
      modules: [fp64arithmetic, interpolationUniforms],
      defines: {
        ATTRIBUTE_TYPE: attributeType,
        ATTRIBUTE_SIZE: attributeSize
      },
      // Default uniforms are not set without this
      moduleSettings: {},
      varyings: ["vCurrent", "vCurrent64Low"],
      bufferMode: 35980,
      disableWarnings: true
    });
  }
  return new BufferTransform(device, {
    vs: vs5,
    bufferLayout: [
      { name: "aFrom", format: inputFormat },
      { name: "aTo", format: bufferLayout.attributes[0].format }
    ],
    modules: [interpolationUniforms],
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vCurrent"],
    // TODO investigate why this is needed
    disableWarnings: true
  });
}

// node_modules/@deck.gl/core/dist/transitions/gpu-spring-transition.js
var GPUSpringTransition = class extends GPUTransitionBase {
  constructor({ device, attribute, timeline }) {
    super({ device, attribute, timeline });
    this.type = "spring";
    this.texture = getTexture(device);
    this.framebuffer = getFramebuffer3(device, this.texture);
    this.transform = getTransform2(device, attribute);
  }
  start(transitionSettings, numInstances) {
    const prevLength = this.currentLength;
    const prevStartIndices = this.currentStartIndices;
    super.start(transitionSettings, numInstances);
    const { buffers, attribute } = this;
    for (let i3 = 0; i3 < 2; i3++) {
      buffers[i3] = padBuffer({
        device: this.device,
        buffer: buffers[i3],
        attribute,
        fromLength: prevLength,
        toLength: this.currentLength,
        fromStartIndices: prevStartIndices,
        getData: transitionSettings.enter
      });
    }
    buffers[2] = matchBuffer({
      device: this.device,
      source: buffers[0],
      target: buffers[2]
    });
    this.setBuffer(buffers[1]);
    const { model } = this.transform;
    model.setVertexCount(Math.floor(this.currentLength / attribute.size));
    if (attribute.isConstant) {
      model.setConstantAttributes({ aTo: attribute.value });
    } else {
      model.setAttributes({ aTo: attribute.getBuffer() });
    }
  }
  onUpdate() {
    const { buffers, transform, framebuffer, transition } = this;
    const settings = this.settings;
    transform.model.setAttributes({
      aPrev: buffers[0],
      aCur: buffers[1]
    });
    transform.transformFeedback.setBuffers({ vNext: buffers[2] });
    const springProps = {
      stiffness: settings.stiffness,
      damping: settings.damping
    };
    transform.model.shaderInputs.setProps({ spring: springProps });
    transform.run({
      framebuffer,
      discard: false,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    });
    cycleBuffers(buffers);
    this.setBuffer(buffers[1]);
    const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;
    if (!isTransitioning) {
      transition.end();
    }
  }
  delete() {
    super.delete();
    this.transform.destroy();
    this.texture.destroy();
    this.framebuffer.destroy();
  }
};
var uniformBlock4 = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`;
var springUniforms = {
  name: "spring",
  vs: uniformBlock4,
  uniformTypes: {
    damping: "f32",
    stiffness: "f32"
  }
};
var vs6 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`;
var fs4 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function getTransform2(device, attribute) {
  const attributeType = getAttributeTypeFromSize(attribute.size);
  const format = getFloat32VertexFormat(attribute.size);
  return new BufferTransform(device, {
    vs: vs6,
    fs: fs4,
    bufferLayout: [
      { name: "aPrev", format },
      { name: "aCur", format },
      { name: "aTo", format: attribute.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    modules: [springUniforms],
    defines: { ATTRIBUTE_TYPE: attributeType },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function getTexture(device) {
  return device.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: false,
    width: 1,
    height: 1
  });
}
function getFramebuffer3(device, texture) {
  return device.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [texture]
  });
}

// node_modules/@deck.gl/core/dist/lib/attribute/attribute-transition-manager.js
var TRANSITION_TYPES = {
  interpolation: GPUInterpolationTransition,
  spring: GPUSpringTransition
};
var AttributeTransitionManager = class {
  constructor(device, { id, timeline }) {
    if (!device)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = id;
    this.device = device;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
  }
  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes, transitions, numInstances }) {
    this.numInstances = numInstances || 1;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings)
        continue;
      this._updateAttribute(attributeName, attribute, settings);
    }
    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];
      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(attributeName) {
    const transition = this.transitions[attributeName];
    return transition && transition.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const animatedAttributes = {};
    for (const attributeName in this.transitions) {
      const transition = this.transitions[attributeName];
      if (transition.inProgress) {
        animatedAttributes[attributeName] = transition.attributeInTransition;
      }
    }
    return animatedAttributes;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0) {
      return false;
    }
    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();
      if (updated) {
        this.needsRedraw = true;
      }
    }
    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(attributeName) {
    this.transitions[attributeName].delete();
    delete this.transitions[attributeName];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(attributeName, attribute, settings) {
    const transition = this.transitions[attributeName];
    let isNew = !transition || transition.type !== settings.type;
    if (isNew) {
      if (transition) {
        this._removeTransition(attributeName);
      }
      const TransitionType = TRANSITION_TYPES[settings.type];
      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          device: this.device
        });
      } else {
        log_default.error(`unsupported transition type '${settings.type}'`)();
        isNew = false;
      }
    }
    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js
var TRACE_INVALIDATE = "attributeManager.invalidate";
var TRACE_UPDATE_START = "attributeManager.updateStart";
var TRACE_UPDATE_END = "attributeManager.updateEnd";
var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
var AttributeManager = class {
  constructor(device, { id = "attribute-manager", stats, timeline } = {}) {
    this.mergeBoundsMemoized = memoize(mergeBounds);
    this.id = id;
    this.device = device;
    this.attributes = {};
    this.updateTriggers = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new AttributeTransitionManager(device, {
      id: `${id}-transitions`,
      timeline
    });
    Object.seal(this);
  }
  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(opts = { clearRedrawFlags: false }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = true;
  }
  // Adds attributes
  add(attributes) {
    this._add(attributes);
  }
  // Adds attributes
  addInstanced(attributes) {
    this._add(attributes, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(attributeNameArray) {
    for (const name2 of attributeNameArray) {
      if (this.attributes[name2] !== void 0) {
        this.attributes[name2].delete();
        delete this.attributes[name2];
      }
    }
  }
  // Marks an attribute for update
  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }
  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }
    debug(TRACE_INVALIDATE, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data, numInstances, startIndices = null, transitions, props = {}, buffers = {}, context = {} }) {
    let updated = false;
    debug(TRACE_UPDATE_START, this);
    if (this.stats) {
      this.stats.get("Update Attributes").timeStart();
    }
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;
      if (props[attributeName]) {
        log_default.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
      }
      if (attribute.setExternalBuffer(buffers[attributeName])) {
      } else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {
      } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
      } else if (attribute.needsUpdate()) {
        updated = true;
        this._updateAttribute({
          attribute,
          numInstances,
          data,
          props,
          context
        });
      }
      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
    }
    if (updated) {
      debug(TRACE_UPDATE_END, this, numInstances);
    }
    if (this.stats) {
      this.stats.get("Update Attributes").timeEnd();
    }
    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(attributeNames) {
    const bounds = attributeNames.map((attributeName) => this.attributes[attributeName]?.getBounds());
    return this.mergeBoundsMemoized(bounds);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(opts = { clearChangedFlags: false }) {
    const { attributes, attributeTransitionManager } = this;
    const changedAttributes = { ...attributeTransitionManager.getAttributes() };
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }
    return changedAttributes;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(modelInfo) {
    return Object.values(this.getAttributes()).map((attribute) => attribute.getBufferLayout(modelInfo));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(attributes, overrideOptions) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const props = {
        ...attribute,
        id: attributeName,
        size: attribute.isIndexed && 1 || attribute.size || 1,
        ...overrideOptions
      };
      this.attributes[attributeName] = new Attribute(this.device, props);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const triggers = {};
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach((triggerName) => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }
        triggers[triggerName].push(attributeName);
      });
    }
    this.updateTriggers = triggers;
  }
  _invalidateTrigger(triggerName, dataRange) {
    const { attributes, updateTriggers } = this;
    const invalidatedAttributes = updateTriggers[triggerName];
    if (invalidatedAttributes) {
      invalidatedAttributes.forEach((name2) => {
        const attribute = attributes[name2];
        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }
    return invalidatedAttributes;
  }
  _updateAttribute(opts) {
    const { attribute, numInstances } = opts;
    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
    if (attribute.constant) {
      attribute.setConstantValue(attribute.value);
      return;
    }
    if (attribute.allocate(numInstances)) {
      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }
    const updated = attribute.updateBuffer(opts);
    if (updated) {
      this.needsRedraw = true;
      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }
};

// node_modules/@deck.gl/core/dist/transitions/cpu-interpolation-transition.js
var CPUInterpolationTransition = class extends Transition {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time, settings: { fromValue, toValue, duration, easing } } = this;
    const t2 = easing(time / duration);
    this._value = lerp(fromValue, toValue, t2);
  }
};

// node_modules/@deck.gl/core/dist/transitions/cpu-spring-transition.js
var EPSILON21 = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring2 = delta * stiffness;
  const damper = -velocity * damping;
  return spring2 + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];
    for (let i3 = 0; i3 < dest.length; i3++) {
      next[i3] = updateSpringElement(prev[i3], cur[i3], dest[i3], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance4(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;
    for (let i3 = 0; i3 < value1.length; i3++) {
      const d2 = value1[i3] - value2[i3];
      distanceSquare += d2 * d2;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value2);
}
var CPUSpringTransition = class extends Transition {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue, toValue, damping, stiffness } = this.settings;
    const { _prevValue = fromValue, _currValue = fromValue } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance4(nextValue, toValue);
    const velocity = distance4(nextValue, _currValue);
    if (delta < EPSILON21 && velocity < EPSILON21) {
      nextValue = toValue;
      this.end();
    }
    this._prevValue = _currValue;
    this._currValue = nextValue;
  }
};

// node_modules/@deck.gl/core/dist/lib/uniform-transition-manager.js
var TRANSITION_TYPES2 = {
  interpolation: CPUInterpolationTransition,
  spring: CPUSpringTransition
};
var UniformTransitionManager = class {
  constructor(timeline) {
    this.transitions = /* @__PURE__ */ new Map();
    this.timeline = timeline;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(key, fromValue, toValue, settings) {
    const { transitions } = this;
    if (transitions.has(key)) {
      const transition2 = transitions.get(key);
      const { value = transition2.settings.fromValue } = transition2;
      fromValue = value;
      this.remove(key);
    }
    settings = normalizeTransitionSettings(settings);
    if (!settings) {
      return;
    }
    const TransitionType = TRANSITION_TYPES2[settings.type];
    if (!TransitionType) {
      log_default.error(`unsupported transition type '${settings.type}'`)();
      return;
    }
    const transition = new TransitionType(this.timeline);
    transition.start({
      ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition);
  }
  remove(key) {
    const { transitions } = this;
    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }
  update() {
    const propsInTransition = {};
    for (const [key, transition] of this.transitions) {
      transition.update();
      propsInTransition[key] = transition.value;
      if (!transition.inProgress) {
        this.remove(key);
      }
    }
    return propsInTransition;
  }
  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }
};

// node_modules/@deck.gl/core/dist/lifecycle/props.js
function validateProps(props) {
  const propTypes = props[PROP_TYPES_SYMBOL];
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const { validate: validate2 } = propType;
    if (validate2 && !validate2(props[propName], propType)) {
      throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[PROP_TYPES_SYMBOL],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }
  const result = {};
  const propTypes = props[PROP_TYPES_SYMBOL];
  let changed = false;
  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === "number" || type === "color" || type === "array";
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }
  return changed ? result : false;
}
function compareProps({ newProps, oldProps, ignoreProps = {}, propTypes = {}, triggerName = "props" }) {
  if (oldProps === newProps) {
    return false;
  }
  if (typeof newProps !== "object" || newProps === null) {
    return `${triggerName} changed shallowly`;
  }
  if (typeof oldProps !== "object" || oldProps === null) {
    return `${triggerName} changed shallowly`;
  }
  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return `${triggerName}.${key} added`;
      }
      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
      if (changed) {
        return `${triggerName}.${key} ${changed}`;
      }
    }
  }
  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return `${triggerName}.${key} dropped`;
      }
      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return `${triggerName}.${key} ${changed}`;
        }
      }
    }
  }
  return false;
}
function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;
  if (equal && !equal(newProp, oldProp, propType)) {
    return "changed deeply";
  }
  if (!equal) {
    equal = newProp && oldProp && newProp.equals;
    if (equal && !equal.call(newProp, oldProp)) {
      return "changed deeply";
    }
  }
  if (!equal && oldProp !== newProp) {
    return "changed shallowly";
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  let dataChanged = false;
  const { dataComparator, _dataDiff } = props;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = "Data comparator detected a change";
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = "A new data container was supplied";
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return { all: true };
  }
  if ("all" in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, "all");
    if (diffReason) {
      return { all: true };
    }
  }
  const reason = {};
  let changed = false;
  for (const triggerName in props.updateTriggers) {
    if (triggerName !== "all") {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }
  return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }
  const oldExtensions = oldProps.extensions;
  const { extensions } = props;
  if (extensions === oldExtensions) {
    return false;
  }
  if (!oldExtensions || !extensions) {
    return true;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (let i3 = 0; i3 < extensions.length; i3++) {
    if (!extensions[i3].equals(oldExtensions[i3])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}

// node_modules/@deck.gl/core/dist/utils/count.js
var ERR_NOT_OBJECT = "count(): argument not an object";
var ERR_NOT_CONTAINER = "count(): argument not a container";
function count(container) {
  if (!isObject2(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === "function") {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && value.constructor === Object;
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}

// node_modules/@deck.gl/core/dist/utils/shader.js
function mergeShaders(target2, source3) {
  if (!source3) {
    return target2;
  }
  const result = { ...target2, ...source3 };
  if ("defines" in source3) {
    result.defines = { ...target2.defines, ...source3.defines };
  }
  if ("modules" in source3) {
    result.modules = (target2.modules || []).concat(source3.modules);
    if (source3.modules.some((module) => module.name === "project64")) {
      const index = result.modules.findIndex((module) => module.name === "project32");
      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }
  if ("inject" in source3) {
    if (!target2.inject) {
      result.inject = source3.inject;
    } else {
      const mergedInjection = { ...target2.inject };
      for (const key in source3.inject) {
        mergedInjection[key] = (mergedInjection[key] || "") + source3.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}

// node_modules/@deck.gl/core/dist/utils/texture.js
var DEFAULT_TEXTURE_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
var internalTextures = {};
function createTexture(owner, device, image, sampler) {
  if (image instanceof Texture) {
    return image;
  } else if (image.constructor && image.constructor.name !== "Object") {
    image = { data: image };
  }
  let samplerParameters = null;
  if (image.compressed) {
    samplerParameters = {
      minFilter: "linear",
      mipmapFilter: image.data.length > 1 ? "nearest" : "linear"
    };
  }
  const texture = device.createTexture({
    ...image,
    sampler: {
      ...DEFAULT_TEXTURE_PARAMETERS,
      ...samplerParameters,
      ...sampler
    },
    mipmaps: true
  });
  internalTextures[texture.id] = owner;
  return texture;
}
function destroyTexture(owner, texture) {
  if (!texture || !(texture instanceof Texture)) {
    return;
  }
  if (internalTextures[texture.id] === owner) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}

// node_modules/@deck.gl/core/dist/lifecycle/prop-types.js
var TYPE_DEFINITIONS = {
  boolean: {
    validate(value, propType) {
      return true;
    },
    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
    }
  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray3(value) && (value.length === 3 || value.length === 4);
    },
    equal(value1, value2, propType) {
      return deepEqual2(value1, value2, 1);
    }
  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf2(value);
      return valueType === "function" || valueType === getTypeOf2(propType.value);
    },
    equal(value1, value2, propType) {
      if (typeof value2 === "function") {
        return true;
      }
      return deepEqual2(value1, value2, 1);
    }
  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray3(value);
    },
    equal(value1, value2, propType) {
      const { compare } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual2(value1, value2, depth) : value1 === value2;
    }
  },
  object: {
    equal(value1, value2, propType) {
      if (propType.ignore) {
        return true;
      }
      const { compare } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? deepEqual2(value1, value2, depth) : value1 === value2;
    }
  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === "function";
    },
    equal(value1, value2, propType) {
      const shouldIgnore = !propType.compare && propType.ignore !== false;
      return shouldIgnore || value1 === value2;
    }
  },
  data: {
    transform: (value, propType, component) => {
      if (!value) {
        return value;
      }
      const { dataTransform } = component.props;
      if (dataTransform) {
        return dataTransform(value);
      }
      if (typeof value.shape === "string" && value.shape.endsWith("-table") && Array.isArray(value.data)) {
        return value.data;
      }
      return value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      const context = component.context;
      if (!context || !context.device) {
        return null;
      }
      return createTexture(component.id, context.device, value, {
        ...propType.parameters,
        ...component.props.textureParameters
      });
    },
    release: (value, propType, component) => {
      destroyTexture(component.id, value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  const defaultProps17 = {};
  const deprecatedProps = {};
  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef?.deprecatedFor;
    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps17[propName] = propType.value;
    }
  }
  return { propTypes, defaultProps: defaultProps17, deprecatedProps };
}
function parsePropType(name2, propDef) {
  switch (getTypeOf2(propDef)) {
    case "object":
      return normalizePropDefinition(name2, propDef);
    case "array":
      return normalizePropDefinition(name2, { type: "array", value: propDef, compare: false });
    case "boolean":
      return normalizePropDefinition(name2, { type: "boolean", value: propDef });
    case "number":
      return normalizePropDefinition(name2, { type: "number", value: propDef });
    case "function":
      return normalizePropDefinition(name2, { type: "function", value: propDef, compare: true });
    default:
      return { name: name2, type: "unknown", value: propDef };
  }
}
function normalizePropDefinition(name2, propDef) {
  if (!("type" in propDef)) {
    if (!("value" in propDef)) {
      return { name: name2, type: "object", value: propDef };
    }
    return { name: name2, type: getTypeOf2(propDef.value), ...propDef };
  }
  return { name: name2, ...TYPE_DEFINITIONS[propDef.type], ...propDef };
}
function isArray3(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf2(value) {
  if (isArray3(value)) {
    return "array";
  }
  if (value === null) {
    return "null";
  }
  return typeof value;
}

// node_modules/@deck.gl/core/dist/lifecycle/create-props.js
function createProps(component, propObjects) {
  let extensions;
  for (let i3 = propObjects.length - 1; i3 >= 0; i3--) {
    const props = propObjects[i3];
    if ("extensions" in props) {
      extensions = props.extensions;
    }
  }
  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[COMPONENT_SYMBOL] = component;
  propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
  for (let i3 = 0; i3 < propObjects.length; ++i3) {
    const props = propObjects[i3];
    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
function getPropsPrototype(componentClass, extensions) {
  if (!(componentClass instanceof component_default.constructor))
    return {};
  let cacheKey = MergedDefaultPropsCacheKey;
  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;
      if (ExtensionClass) {
        cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
      }
    }
  }
  const defaultProps17 = getOwnProperty(componentClass, cacheKey);
  if (!defaultProps17) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }
  return defaultProps17;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;
  if (!parent) {
    return null;
  }
  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
  const componentPropDefs = parsePropTypes(componentDefaultProps);
  const defaultProps17 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps?.[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);
    if (extensionDefaultProps) {
      Object.assign(defaultProps17, extensionDefaultProps);
      Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
    }
  }
  createPropsPrototype(defaultProps17, componentClass);
  addAsyncPropsToPropPrototype(defaultProps17, propTypes);
  addDeprecatedPropsToPropPrototype(defaultProps17, deprecatedProps);
  defaultProps17[PROP_TYPES_SYMBOL] = propTypes;
  defaultProps17[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
  if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
    componentClass._propTypes = propTypes;
  }
  return defaultProps17;
}
function createPropsPrototype(defaultProps17, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps17, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: true,
      value: id
    }
  });
}
function addDeprecatedPropsToPropPrototype(defaultProps17, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps17, propName, {
      enumerable: false,
      set(newValue) {
        const nameStr = `${this.id}: ${propName}`;
        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }
        log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
      }
    });
  }
}
function addAsyncPropsToPropPrototype(defaultProps17, propTypes) {
  const defaultValues = {};
  const descriptors = {};
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const { name: name2, value } = propType;
    if (propType.async) {
      defaultValues[name2] = value;
      descriptors[name2] = getDescriptorForAsyncProp(name2);
    }
  }
  defaultProps17[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps17[ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps17, descriptors);
}
function getDescriptorForAsyncProp(name2) {
  return {
    enumerable: true,
    // Save the provided value for async props in a special map
    set(newValue) {
      if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
        this[ASYNC_ORIGINAL_SYMBOL][name2] = newValue;
      } else {
        this[ASYNC_RESOLVED_SYMBOL][name2] = newValue;
      }
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[ASYNC_RESOLVED_SYMBOL]) {
        if (name2 in this[ASYNC_RESOLVED_SYMBOL]) {
          const value = this[ASYNC_RESOLVED_SYMBOL][name2];
          return value || this[ASYNC_DEFAULTS_SYMBOL][name2];
        }
        if (name2 in this[ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
          if (state && state.hasAsyncProp(name2)) {
            return state.getAsyncProp(name2) || this[ASYNC_DEFAULTS_SYMBOL][name2];
          }
        }
      }
      return this[ASYNC_DEFAULTS_SYMBOL][name2];
    }
  };
}
function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
  const componentName = componentClass.componentName;
  if (!componentName) {
    log_default.warn(`${componentClass.name}.componentName not specified`)();
  }
  return componentName || componentClass.name;
}

// node_modules/@deck.gl/core/dist/lifecycle/component.js
var counter = 0;
var Component = class {
  constructor(...propObjects) {
    this.props = createProps(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
  }
  // clone this layer with modified props
  clone(newProps) {
    const { props } = this;
    const asyncProps = {};
    for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
      }
    }
    return new this.constructor({ ...props, ...asyncProps, ...newProps });
  }
};
Component.componentName = "Component";
Component.defaultProps = {};
var component_default = Component;

// node_modules/@deck.gl/core/dist/lifecycle/component-state.js
var EMPTY_PROPS = Object.freeze({});
var ComponentState = class {
  constructor(component) {
    this.component = component;
    this.asyncProps = {};
    this.onAsyncPropUpdated = () => {
    };
    this.oldProps = null;
    this.oldAsyncProps = null;
  }
  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }
    this.asyncProps = {};
    this.component = null;
    this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }
  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }
  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }
    return false;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(props) {
    this.component = props[COMPONENT_SYMBOL] || this.component;
    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
      resolvedValues[propName] = this.getAsyncProp(propName);
    }
    for (const propName in originalValues) {
      const value = originalValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(propName, url) {
    return null;
  }
  _onResolve(propName, value) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(propName, error) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }
    if (typeof value === "string") {
      value = this._fetch(propName, value);
    }
    if (value instanceof Promise) {
      this._watchPromise(propName, value);
      return;
    }
    if (isAsyncIterable2(value)) {
      this._resolveAsyncIterable(propName, value);
      return;
    }
    this._setPropValue(propName, value);
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];
    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }
    asyncProp.lastValue = value;
    return true;
  }
  // Set normal, non-async value
  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
      this._freezeAsyncOldProps();
      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then((data) => {
        if (!this.component) {
          return;
        }
        data = this._postProcessValue(asyncProp, data);
        this._setAsyncPropValue(propName, data, loadCount);
        this._onResolve(propName, data);
      }).catch((error) => {
        this._onError(propName, error);
      });
    }
  }
  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== "data") {
      this._setPropValue(propName, iterable);
      return;
    }
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      return;
    }
    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data = [];
    let count2 = 0;
    for await (const chunk of iterable) {
      if (!this.component) {
        return;
      }
      const { dataTransform } = this.component.props;
      if (dataTransform) {
        data = dataTransform(chunk, data);
      } else {
        data = data.concat(chunk);
      }
      Object.defineProperty(data, "__diff", {
        enumerable: false,
        value: [{ startRow: count2, endRow: data.length }]
      });
      count2 = data.length;
      this._setAsyncPropValue(propName, data, loadCount);
    }
    this._onResolve(propName, data);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;
    if (propType && this.component) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }
      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }
    return value;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
      this.asyncProps[propName] = {
        type: propTypes && propTypes[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/layer-state.js
var LayerState = class extends ComponentState {
  constructor({ attributeManager, layer }) {
    super(layer);
    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.needsUpdate = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(propName, url) {
    const layer = this.layer;
    const fetch2 = layer?.props.fetch;
    if (fetch2) {
      return fetch2(url, { propName, layer });
    }
    return super._fetch(propName, url);
  }
  _onResolve(propName, value) {
    const layer = this.layer;
    if (layer) {
      const onDataLoad = layer.props.onDataLoad;
      if (propName === "data" && onDataLoad) {
        onDataLoad(value, { propName, layer });
      }
    }
  }
  _onError(propName, error) {
    const layer = this.layer;
    if (layer) {
      layer.raiseError(error, `loading ${propName} of ${this.layer}`);
    }
  }
};

// node_modules/@deck.gl/core/dist/lib/layer.js
var TRACE_CHANGE_FLAG = "layer.changeFlag";
var TRACE_INITIALIZE = "layer.initialize";
var TRACE_UPDATE = "layer.update";
var TRACE_FINALIZE = "layer.finalize";
var TRACE_MATCHED = "layer.matched";
var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
var EMPTY_ARRAY2 = Object.freeze([]);
var areViewportsEqual = memoize(({ oldViewport, viewport }) => {
  return oldViewport.equals(viewport);
});
var pickingColorCache = new Uint8ClampedArray(0);
var defaultProps2 = {
  // data: Special handling for null, see below
  data: { type: "data", value: EMPTY_ARRAY2, async: true },
  dataComparator: { type: "function", value: null, optional: true },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (data) => data && data.__diff,
    optional: true
  },
  dataTransform: { type: "function", value: null, optional: true },
  onDataLoad: { type: "function", value: null, optional: true },
  onError: { type: "function", value: null, optional: true },
  fetch: {
    type: "function",
    value: (url, { propName, layer, loaders, loadOptions, signal }) => {
      const { resourceManager } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;
      if (signal) {
        loadOptions = {
          ...loadOptions,
          fetch: {
            ...loadOptions?.fetch,
            signal
          }
        };
      }
      let inResourceManager = resourceManager.contains(url);
      if (!inResourceManager && !loadOptions) {
        resourceManager.add({ resourceId: url, data: load2(url, loaders), persistent: false });
        inResourceManager = true;
      }
      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: (data) => layer.internalState?.reloadAsyncProp(propName, data),
          consumerId: layer.id,
          requestId: propName
        });
      }
      return load2(url, loaders, loadOptions);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: true,
  pickable: false,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: true },
  onClick: { type: "function", value: null, optional: true },
  onDragStart: { type: "function", value: null, optional: true },
  onDrag: { type: "function", value: null, optional: true },
  onDragEnd: { type: "function", value: null, optional: true },
  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: true },
  modelMatrix: { type: "array", value: null, compare: true, optional: true },
  wrapLongitude: false,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: true, compare: 2 },
  loadOptions: { type: "object", value: null, optional: true, ignore: true },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: true, ignore: true },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex }) => [0, -layerIndex * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
var Layer = class extends component_default {
  constructor() {
    super(...arguments);
    this.internalState = null;
    this.lifecycle = LIFECYCLE.NO_STATE;
    this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let layer = this;
    while (layer.parent) {
      layer = layer.parent;
    }
    return layer;
  }
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return `${className}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(xyz) {
    assert8(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    const worldPosition = getWorldPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x2, y2, z2] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x2, y2] : [x2, y2, z2];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(xy) {
    assert8(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return viewport.unproject(xy);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(xyz, params) {
    assert8(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return projectPosition(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return false;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return true;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(partialState) {
    this.setChangeFlags({ stateChanged: true });
    Object.assign(this.state, partialState);
    this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    if (this.internalState) {
      this.internalState.needsRedraw = true;
    }
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    if (this.internalState) {
      this.context.layerManager.setNeedsUpdate(String(this));
      this.internalState.needsUpdate = true;
    }
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const state = this.state;
    return state && (state.models || state.model && [state.model]) || [];
  }
  /** Update shader input parameters */
  setShaderModuleProps(...props) {
    for (const model of this.getModels()) {
      model.shaderInputs.setProps(...props);
    }
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem } = this.props;
    return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
  }
  // Event handling
  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent) || false;
    }
    return false;
  }
  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent) || false;
    }
    return false;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(i3, target2 = []) {
    target2[0] = i3 + 1 & 255;
    target2[1] = i3 + 1 >> 8 & 255;
    target2[2] = i3 + 1 >> 8 >> 8 & 255;
    return target2;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(color) {
    assert8(color instanceof Uint8Array);
    const [i1, i22, i3] = color;
    const index = i1 + i22 * 256 + i3 * 65536 - 1;
    return index;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    if (Number.isFinite(this.props.numInstances)) {
      return this.props.numInstances;
    }
    if (this.state && this.state.numInstances !== void 0) {
      return this.state.numInstances;
    }
    return count(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    if (this.props.startIndices) {
      return this.props.startIndices;
    }
    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }
    return null;
  }
  // Default implementation
  getBounds() {
    return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
  }
  getShaders(shaders) {
    shaders = mergeShaders(shaders, {
      disableWarnings: true,
      modules: this.context.defaultShaderModules
    });
    for (const extension of this.props.extensions) {
      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
    }
    return shaders;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(params) {
    return params.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(params) {
    const attributeManager = this.getAttributeManager();
    const { dataChanged } = params.changeFlags;
    if (dataChanged && attributeManager) {
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }
    if (attributeManager) {
      const { props } = params;
      const hasPickingBuffer = this.internalState.hasPickingBuffer;
      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
      if (hasPickingBuffer !== needsPickingBuffer) {
        this.internalState.hasPickingBuffer = needsPickingBuffer;
        const { pickingColors, instancePickingColors } = attributeManager.attributes;
        const pickingColorsAttribute = pickingColors || instancePickingColors;
        if (pickingColorsAttribute) {
          if (needsPickingBuffer && pickingColorsAttribute.constant) {
            pickingColorsAttribute.constant = false;
            attributeManager.invalidate(pickingColorsAttribute.id);
          }
          if (!pickingColorsAttribute.value && !needsPickingBuffer) {
            pickingColorsAttribute.constant = true;
            pickingColorsAttribute.value = [0, 0, 0];
          }
        }
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(context) {
    for (const model of this.getModels()) {
      model.destroy();
    }
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.finalize();
    }
    if (this.context) {
      this.context.resourceManager.unsubscribe({ consumerId: this.id });
    }
    if (this.internalState) {
      this.internalState.uniformTransitions.clear();
      this.internalState.finalize();
    }
  }
  // If state has a model, draw it with supplied uniforms
  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts.renderPass);
    }
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info, mode, sourceLayer }) {
    const { index } = info;
    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }
    return info;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(error, message2) {
    if (message2) {
      error = new Error(`${message2}: ${error.message}`, { cause: error });
    }
    if (!this.props.onError?.(error)) {
      this.context?.onError?.(error, this);
    }
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(opts = { clearRedrawFlags: false }) {
    return this._getNeedsRedraw(opts);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    if (!this.internalState) {
      return false;
    }
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    return this.internalState?.uniformTransitions.active || false;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(viewport) {
    if (!this.internalState) {
      return;
    }
    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;
    if (!oldViewport || !areViewportsEqual({ oldViewport, viewport })) {
      this.setChangeFlags({ viewportChanged: true });
      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(name2 = "all") {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    if (name2 === "all") {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name2);
    }
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(changedAttributes) {
    let bufferLayoutChanged = false;
    for (const id in changedAttributes) {
      if (changedAttributes[id].layoutChanged()) {
        bufferLayoutChanged = true;
      }
    }
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);
    }
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    const props = this.props;
    const numInstances = this.getNumInstances();
    const startIndices = this.getStartIndices();
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: props.data.attributes,
      context: this
    });
    const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
    this.updateAttributes(changedAttributes);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions } = this.internalState;
    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);
      for (const key in propsInTransition) {
        Object.defineProperty(props, key, { value: propsInTransition[key] });
      }
      return props;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(attribute, { numInstances }) {
    if (attribute.constant) {
      return;
    }
    const cacheSize = Math.floor(pickingColorCache.length / 4);
    this.internalState.usesPickingColorCache = true;
    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
      }
      pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
        size: 4,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 4);
      const pickingColor = [0, 0, 0];
      for (let i3 = cacheSize; i3 < newCacheSize; i3++) {
        this.encodePickingColor(i3, pickingColor);
        pickingColorCache[i3 * 4 + 0] = pickingColor[0];
        pickingColorCache[i3 * 4 + 1] = pickingColor[1];
        pickingColorCache[i3 * 4 + 2] = pickingColor[2];
        pickingColorCache[i3 * 4 + 3] = 0;
      }
    }
    attribute.value = pickingColorCache.subarray(0, numInstances * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {
    if (!Object.keys(changedAttributes).length) {
      return;
    }
    if (bufferLayoutChanged) {
      const attributeManager = this.getAttributeManager();
      model.setBufferLayout(attributeManager.getBufferLayouts(model));
      changedAttributes = attributeManager.getAttributes();
    }
    const excludeAttributes = model.userData?.excludeAttributes || {};
    const attributeBuffers = {};
    const constantAttributes = {};
    for (const name2 in changedAttributes) {
      if (excludeAttributes[name2]) {
        continue;
      }
      const values = changedAttributes[name2].getValue();
      for (const attributeName in values) {
        const value = values[attributeName];
        if (value instanceof Buffer2) {
          if (changedAttributes[name2].settings.isIndexed) {
            model.setIndexBuffer(value);
          } else {
            attributeBuffers[attributeName] = value;
          }
        } else if (value) {
          constantAttributes[attributeName] = value;
        }
      }
    }
    model.setAttributes(attributeBuffers);
    model.setConstantAttributes(constantAttributes);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (!("attributes" in data)) {
      this._disablePickingIndex(objectIndex);
      return;
    }
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
    if (externalColorAttribute && externalColorAttribute.value) {
      const values = externalColorAttribute.value;
      const objectColor = this.encodePickingColor(objectIndex);
      for (let index = 0; index < data.length; index++) {
        const i3 = colors.getVertexOffset(index);
        if (values[i3] === objectColor[0] && values[i3 + 1] === objectColor[1] && values[i3 + 2] === objectColor[2]) {
          this._disablePickingIndex(index);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(objectIndex) {
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    const start = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.write(new Uint8Array(end - start), start);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    if (
      // @ts-ignore (TS2531) this method is only called internally with internalState defined
      this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer
    ) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }
    colors.updateSubBuffer({ startOffset: 0 });
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    assert8(!this.internalState);
    assert8(Number.isFinite(this.props.coordinateSystem));
    debug(TRACE_INITIALIZE, this);
    const attributeManager = this._getAttributeManager();
    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: "uint8",
          size: 4,
          noAlloc: true,
          // Updaters are always called with `this` pointing to the layer
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateInstancePickingColors
        }
      });
    }
    this.internalState = new LayerState({
      attributeManager,
      layer: this
    });
    this._clearChangeFlags();
    this.state = {};
    Object.defineProperty(this.state, "attributeManager", {
      get: () => {
        log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
        return attributeManager;
      }
    });
    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
    this.initializeState(this.context);
    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: true,
      extensionsChanged: true
    });
    this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(oldLayer) {
    debug(TRACE_MATCHED, this, this === oldLayer);
    const { state, internalState } = oldLayer;
    if (this === oldLayer) {
      return;
    }
    this.internalState = internalState;
    this.state = state;
    this.internalState.setAsyncProps(this.props);
    this._diffProps(this.props, this.internalState.getOldProps());
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    debug(TRACE_UPDATE, this, stateNeedsUpdate);
    if (!stateNeedsUpdate) {
      return;
    }
    const currentProps = this.props;
    const context = this.context;
    const internalState = this.internalState;
    const currentViewport = context.viewport;
    const propsInTransition = this._updateUniformTransition();
    internalState.propsInTransition = propsInTransition;
    context.viewport = internalState.viewport || currentViewport;
    this.props = propsInTransition;
    try {
      const updateParams = this._getUpdateParams();
      const oldModels = this.getModels();
      if (context.device) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {
        }
      }
      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }
      this.setNeedsRedraw();
      this._updateAttributes();
      const modelChanged = this.getModels()[0] !== oldModels[0];
      this._postUpdate(updateParams, modelChanged);
    } finally {
      context.viewport = currentViewport;
      this.props = currentProps;
      this._clearChangeFlags();
      internalState.needsUpdate = false;
      internalState.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    debug(TRACE_FINALIZE, this);
    this.finalizeState(this.context);
    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, this.context, extension);
    }
  }
  // Calculates uniforms
  _drawLayer({ renderPass, shaderModuleProps = null, uniforms = {}, parameters = {} }) {
    this._updateAttributeTransition();
    const currentProps = this.props;
    const context = this.context;
    this.props = this.internalState.propsInTransition || currentProps;
    try {
      if (shaderModuleProps) {
        this.setShaderModuleProps(shaderModuleProps);
      }
      const { getPolygonOffset } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      if (context.device instanceof WebGLDevice) {
        context.device.setParametersWebGL({ polygonOffset: offsets });
      }
      for (const model of this.getModels()) {
        if (model.device.type === "webgpu") {
          model.setParameters({ ...model.parameters, ...parameters });
        } else {
          model.setParameters(parameters);
        }
      }
      if (context.device instanceof WebGLDevice) {
        context.device.withParametersWebGL(parameters, () => {
          const opts = { renderPass, shaderModuleProps, uniforms, parameters, context };
          for (const extension of this.props.extensions) {
            extension.draw.call(this, opts, extension);
          }
          this.draw(opts);
        });
      } else {
        const opts = { renderPass, shaderModuleProps, uniforms, parameters, context };
        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }
        this.draw(opts);
      }
    } finally {
      this.props = currentProps;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    return this.internalState?.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(flags) {
    if (!this.internalState) {
      return;
    }
    const { changeFlags } = this.internalState;
    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;
        switch (key) {
          case "dataChanged":
            const dataChangedReason = flags[key];
            const prevDataChangedReason = changeFlags[key];
            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
              flagChanged = true;
            }
          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }
        }
        if (flagChanged) {
          debug(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }
    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(newProps, oldProps) {
    const changeFlags = diffProps(newProps, oldProps);
    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }
    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions?.[key]);
      }
    }
    return this.setChangeFlags(changeFlags);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    validateProps(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(info) {
    const picking2 = {
      // @ts-ignore
      highlightedObjectColor: info.picked ? info.color : null
    };
    const { highlightColor } = this.props;
    if (info.picked && typeof highlightColor === "function") {
      picking2.highlightColor = highlightColor(info);
    }
    this.setShaderModuleProps({ picking: picking2 });
    this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const context = this.context;
    return new AttributeManager(context.device, {
      id: this.props.id,
      stats: context.stats,
      timeline: context.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(updateParams, forceUpdate) {
    const { props, oldProps } = updateParams;
    const model = this.state.model;
    if (model?.isInstanced) {
      model.setInstanceCount(this.getNumInstances());
    }
    const { autoHighlight, highlightedObjectIndex, highlightColor } = props;
    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const picking2 = {};
      if (Array.isArray(highlightColor)) {
        picking2.highlightColor = highlightColor;
      }
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
        picking2.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }
      this.setShaderModuleProps({ picking: picking2 });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }
    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
    redraw = redraw || attributeManagerNeedsRedraw;
    if (redraw) {
      for (const extension of this.props.extensions) {
        extension.onNeedsRedraw.call(this, extension);
      }
    }
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    return redraw;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }
};
Layer.defaultProps = defaultProps2;
Layer.layerName = "Layer";
var layer_default = Layer;

// node_modules/@deck.gl/core/dist/lib/composite-layer.js
var TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
var CompositeLayer = class extends layer_default {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return true;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return false;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(context) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({ info }) {
    const { object } = info;
    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
    if (!isDataWrapped) {
      return info;
    }
    info.object = object.__source.object;
    info.index = object.__source.index;
    return info;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(context) {
    return true;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(subLayerId, data) {
    return data && data.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(subLayerId, DefaultLayerClass) {
    const { _subLayerProps: overridingProps } = this.props;
    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(accessor) {
    if (typeof accessor === "function") {
      const objectInfo = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (x2, i3) => {
        if (x2 && x2.__source) {
          objectInfo.index = x2.__source.index;
          return accessor(x2.__source.object, objectInfo);
        }
        return accessor(x2, i3);
      };
    }
    return accessor;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(sublayerProps = {}) {
    const { opacity, pickable, visible, parameters, getPolygonOffset, highlightedObjectIndex, autoHighlight, highlightColor, coordinateSystem, coordinateOrigin, wrapLongitude, positionFormat, modelMatrix, extensions, fetch: fetch2, operation, _subLayerProps: overridingProps } = this.props;
    const newProps = {
      id: "",
      updateTriggers: {},
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch: fetch2,
      operation
    };
    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || "sublayer";
    if (overridingSublayerProps) {
      const propTypes = this.props[PROP_TYPES_SYMBOL];
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes[key];
        if (propType && propType.type === "accessor") {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }
    Object.assign(
      newProps,
      sublayerProps,
      // experimental feature that allows users to override sublayer props via parent layer prop
      overridingSublayerProps
    );
    newProps.id = `${this.props.id}-${sublayerId}`;
    newProps.updateTriggers = {
      all: this.props.updateTriggers?.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };
    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);
      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }
    return newProps;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(updateParams, forceUpdate) {
    let subLayers = this.internalState.subLayers;
    const shouldUpdate = !subLayers || this.needsUpdate();
    if (shouldUpdate) {
      const subLayersList = this.renderLayers();
      subLayers = flatten(subLayersList, Boolean);
      this.internalState.subLayers = subLayers;
    }
    debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
    for (const layer of subLayers) {
      layer.parent = this;
    }
  }
};
CompositeLayer.layerName = "CompositeLayer";
var composite_layer_default = CompositeLayer;

// node_modules/@deck.gl/core/dist/viewports/globe-viewport.js
var DEGREES_TO_RADIANS5 = Math.PI / 180;
var RADIANS_TO_DEGREES3 = 180 / Math.PI;
var EARTH_RADIUS = 6370972;
var GLOBE_RADIUS = 256;
function getDistanceScales2() {
  const unitsPerMeter2 = GLOBE_RADIUS / EARTH_RADIUS;
  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter2, unitsPerMeter2, unitsPerMeter2],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter2, 1 / unitsPerMeter2, 1 / unitsPerMeter2],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter2],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter2]
  };
}
var GlobeViewport = class extends viewport_default {
  constructor(opts = {}) {
    const {
      longitude = 0,
      zoom = 0,
      // Matches Maplibre defaults
      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633
      nearZMultiplier = 0.5,
      farZMultiplier = 1,
      resolution = 10
    } = opts;
    let { latitude = 0, height, altitude = 1.5, fovy } = opts;
    latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);
    height = height || 1;
    if (fovy) {
      altitude = fovyToAltitude(fovy);
    } else {
      fovy = altitudeToFovy(altitude);
    }
    const scaleAdjust = 1 / Math.PI / Math.cos(latitude * Math.PI / 180);
    const scale7 = Math.pow(2, zoom) * scaleAdjust;
    const nearZ = opts.nearZ ?? nearZMultiplier;
    const farZ = opts.farZ ?? (altitude + GLOBE_RADIUS * 2 * scale7 / height) * farZMultiplier;
    const viewMatrix2 = new Matrix4().lookAt({ eye: [0, -altitude, 0], up: [0, 0, 1] });
    viewMatrix2.rotateX(latitude * DEGREES_TO_RADIANS5);
    viewMatrix2.rotateZ(-longitude * DEGREES_TO_RADIANS5);
    viewMatrix2.scale(scale7 / height);
    super({
      ...opts,
      // x, y, width,
      height,
      // view matrix
      viewMatrix: viewMatrix2,
      longitude,
      latitude,
      zoom,
      // projection matrix parameters
      distanceScales: getDistanceScales2(),
      fovy,
      focalDistance: altitude,
      near: nearZ,
      far: farZ
    });
    this.scale = scale7;
    this.latitude = latitude;
    this.longitude = longitude;
    this.resolution = resolution;
  }
  get projectionMode() {
    return PROJECTION_MODE.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds(options = {}) {
    const unprojectOption = { targetZ: options.z || 0 };
    const left = this.unproject([0, this.height / 2], unprojectOption);
    const top = this.unproject([this.width / 2, 0], unprojectOption);
    const right = this.unproject([this.width, this.height / 2], unprojectOption);
    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
    if (right[0] < this.longitude)
      right[0] += 360;
    if (left[0] > this.longitude)
      left[0] -= 360;
    return [
      Math.min(left[0], right[0], top[0], bottom[0]),
      Math.min(left[1], right[1], top[1], bottom[1]),
      Math.max(left[0], right[0], top[0], bottom[0]),
      Math.max(left[1], right[1], top[1], bottom[1])
    ];
  }
  unproject(xyz, { topLeft = true, targetZ } = {}) {
    const [x2, y2, z2] = xyz;
    const y22 = topLeft ? y2 : this.height - y2;
    const { pixelUnprojectionMatrix } = this;
    let coord;
    if (Number.isFinite(z2)) {
      coord = transformVector2(pixelUnprojectionMatrix, [x2, y22, z2, 1]);
    } else {
      const coord0 = transformVector2(pixelUnprojectionMatrix, [x2, y22, -1, 1]);
      const coord1 = transformVector2(pixelUnprojectionMatrix, [x2, y22, 1, 1]);
      const lt2 = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      const lSqr = vec3_exports.sqrLen(vec3_exports.sub([], coord0, coord1));
      const l0Sqr = vec3_exports.sqrLen(coord0);
      const l1Sqr = vec3_exports.sqrLen(coord1);
      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
      const dSqr = 4 * sSqr / lSqr;
      const r0 = Math.sqrt(l0Sqr - dSqr);
      const dr = Math.sqrt(Math.max(0, lt2 * lt2 - dSqr));
      const t2 = (r0 - dr) / Math.sqrt(lSqr);
      coord = vec3_exports.lerp([], coord0, coord1, t2);
    }
    const [X2, Y2, Z2] = this.unprojectPosition(coord);
    if (Number.isFinite(z2)) {
      return [X2, Y2, Z2];
    }
    return Number.isFinite(targetZ) ? [X2, Y2, targetZ] : [X2, Y2];
  }
  projectPosition(xyz) {
    const [lng, lat, Z2 = 0] = xyz;
    const lambda = lng * DEGREES_TO_RADIANS5;
    const phi = lat * DEGREES_TO_RADIANS5;
    const cosPhi = Math.cos(phi);
    const D3 = (Z2 / EARTH_RADIUS + 1) * GLOBE_RADIUS;
    return [Math.sin(lambda) * cosPhi * D3, -Math.cos(lambda) * cosPhi * D3, Math.sin(phi) * D3];
  }
  unprojectPosition(xyz) {
    const [x2, y2, z2] = xyz;
    const D3 = vec3_exports.len(xyz);
    const phi = Math.asin(z2 / D3);
    const lambda = Math.atan2(x2, -y2);
    const lng = lambda * RADIANS_TO_DEGREES3;
    const lat = phi * RADIANS_TO_DEGREES3;
    const Z2 = (D3 / GLOBE_RADIUS - 1) * EARTH_RADIUS;
    return [lng, lat, Z2];
  }
  projectFlat(xyz) {
    return xyz;
  }
  unprojectFlat(xyz) {
    return xyz;
  }
  panByPosition(coords, pixel) {
    const fromPosition = this.unproject(pixel);
    return {
      longitude: coords[0] - fromPosition[0] + this.longitude,
      latitude: coords[1] - fromPosition[1] + this.latitude
    };
  }
};
function transformVector2(matrix, vector) {
  const result = vec4_exports.transformMat4([], vector, matrix);
  vec4_exports.scale(result, result, 1 / result[3]);
  return result;
}

// node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js
var viewMatrix = new Matrix4().lookAt({ eye: [0, 0, 1] });
function getProjectionMatrix2({ width, height, near, far, padding }) {
  let left = -width / 2;
  let right = width / 2;
  let bottom = -height / 2;
  let top = height / 2;
  if (padding) {
    const { left: l2 = 0, right: r2 = 0, top: t2 = 0, bottom: b2 = 0 } = padding;
    const offsetX = clamp((l2 + width - r2) / 2, 0, width) - width / 2;
    const offsetY = clamp((t2 + height - b2) / 2, 0, height) - height / 2;
    left -= offsetX;
    right -= offsetX;
    bottom += offsetY;
    top += offsetY;
  }
  return new Matrix4().ortho({
    left,
    right,
    bottom,
    top,
    near,
    far
  });
}
var OrthographicViewport = class extends viewport_default {
  constructor(props) {
    const { width, height, near = 0.1, far = 1e3, zoom = 0, target: target2 = [0, 0, 0], padding = null, flipY = true } = props;
    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
    const zoom_ = Math.min(zoomX, zoomY);
    const scale7 = Math.pow(2, zoom_);
    let distanceScales;
    if (zoomX !== zoomY) {
      const scaleX2 = Math.pow(2, zoomX);
      const scaleY2 = Math.pow(2, zoomY);
      distanceScales = {
        unitsPerMeter: [scaleX2 / scale7, scaleY2 / scale7, 1],
        metersPerUnit: [scale7 / scaleX2, scale7 / scaleY2, 1]
      };
    }
    super({
      ...props,
      // in case viewState contains longitude/latitude values,
      // make sure that the base Viewport class does not treat this as a geospatial viewport
      longitude: void 0,
      position: target2,
      viewMatrix: viewMatrix.clone().scale([scale7, scale7 * (flipY ? -1 : 1), scale7]),
      projectionMatrix: getProjectionMatrix2({
        width: width || 1,
        height: height || 1,
        padding,
        near,
        far
      }),
      zoom: zoom_,
      distanceScales
    });
  }
  projectFlat([X2, Y2]) {
    const { unitsPerMeter: unitsPerMeter2 } = this.distanceScales;
    return [X2 * unitsPerMeter2[0], Y2 * unitsPerMeter2[1]];
  }
  unprojectFlat([x2, y2]) {
    const { metersPerUnit } = this.distanceScales;
    return [x2 * metersPerUnit[0], y2 * metersPerUnit[1]];
  }
  /* Needed by LinearInterpolator */
  panByPosition(coords, pixel) {
    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate3 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
    const newCenter = vec2_exports.add([], this.center, translate3);
    return { target: this.unprojectFlat(newCenter) };
  }
};

// node_modules/@deck.gl/core/dist/controllers/orbit-controller.js
var OrbitState = class extends ViewState {
  constructor(options) {
    const {
      /* Viewport arguments */
      width,
      // Width of viewport
      height,
      // Height of viewport
      rotationX = 0,
      // Rotation around x axis
      rotationOrbit = 0,
      // Rotation around orbit axis
      target: target2 = [0, 0, 0],
      zoom = 0,
      /* Viewport constraints */
      minRotationX = -90,
      maxRotationX = 90,
      minZoom = -Infinity,
      maxZoom = Infinity,
      /** Interaction states, required to calculate change during transform */
      // Model state when the pan operation first started
      startPanPosition,
      // Model state when the rotate operation first started
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      // Model state when the zoom operation first started
      startZoomPosition,
      startZoom
    } = options;
    super({
      width,
      height,
      rotationX,
      rotationOrbit,
      target: target2,
      zoom,
      minRotationX,
      maxRotationX,
      minZoom,
      maxZoom
    }, {
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    });
    this.makeViewport = options.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos }) {
    return this._getUpdatedState({
      startPanPosition: this._unproject(pos)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  pan({ pos, startPosition }) {
    const startPanPosition = this.getState().startPanPosition || startPosition;
    if (!startPanPosition) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanPosition, pos);
    return this._getUpdatedState(newProps);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  rotateStart({ pos }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startRotationX: this.getViewportProps().rotationX,
      startRotationOrbit: this.getViewportProps().rotationOrbit
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  rotate({ pos, deltaAngleX = 0, deltaAngleY = 0 }) {
    const { startRotatePos, startRotationX, startRotationOrbit } = this.getState();
    const { width, height } = this.getViewportProps();
    if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) {
      return this;
    }
    let newRotation;
    if (pos) {
      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      if (startRotationX < -90 || startRotationX > 90) {
        deltaScaleX *= -1;
      }
      newRotation = {
        rotationX: startRotationX + deltaScaleY * 180,
        rotationOrbit: startRotationOrbit + deltaScaleX * 180
      };
    } else {
      newRotation = {
        rotationX: startRotationX + deltaAngleY,
        rotationOrbit: startRotationOrbit + deltaAngleX
      };
    }
    return this._getUpdatedState(newRotation);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startRotationX: null,
      startRotationOrbit: null
    });
  }
  // shortest path between two view states
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps() };
    const { rotationOrbit } = props;
    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
    }
    return props;
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  zoomStart({ pos }) {
    return this._getUpdatedState({
      startZoomPosition: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current target is
   * @param {[Number, Number]} startPos - the target position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos, startPos, scale: scale7 }) {
    let { startZoom, startZoomPosition } = this.getState();
    if (!startZoomPosition) {
      startZoom = this.getViewportProps().zoom;
      startZoomPosition = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomPosition) {
      return this;
    }
    const newZoom = this._calculateNewZoom({ scale: scale7, startZoom });
    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom: newZoom });
    return this._getUpdatedState({
      zoom: newZoom,
      ...zoomedViewport.panByPosition(startZoomPosition, pos)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({ scale: speed })
    });
  }
  zoomOut(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({ scale: 1 / speed })
    });
  }
  moveLeft(speed = 50) {
    return this._panFromCenter([-speed, 0]);
  }
  moveRight(speed = 50) {
    return this._panFromCenter([speed, 0]);
  }
  moveUp(speed = 50) {
    return this._panFromCenter([0, -speed]);
  }
  moveDown(speed = 50) {
    return this._panFromCenter([0, speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX - speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX + speed
    });
  }
  /* Private methods */
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  // Calculates new zoom
  _calculateNewZoom({ scale: scale7, startZoom }) {
    const { maxZoom, minZoom } = this.getViewportProps();
    if (startZoom === void 0) {
      startZoom = this.getViewportProps().zoom;
    }
    const zoom = startZoom + Math.log2(scale7);
    return clamp(zoom, minZoom, maxZoom);
  }
  _panFromCenter(offset) {
    const { width, height, target: target2 } = this.getViewportProps();
    return this.pan({
      startPosition: target2,
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(props) {
    const { maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit } = props;
    props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
    if (rotationOrbit < -180 || rotationOrbit > 180) {
      props.rotationOrbit = mod2(rotationOrbit + 180, 360) - 180;
    }
    return props;
  }
};

// node_modules/@deck.gl/core/dist/controllers/orthographic-controller.js
var OrthographicState = class extends OrbitState {
  constructor(props) {
    super(props);
    this.zoomAxis = props.zoomAxis || "all";
  }
  _calculateNewZoom({ scale: scale7, startZoom }) {
    const { maxZoom, minZoom } = this.getViewportProps();
    if (startZoom === void 0) {
      startZoom = this.getViewportProps().zoom;
    }
    let deltaZoom = Math.log2(scale7);
    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;
      switch (this.zoomAxis) {
        case "X":
          newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
          break;
        case "Y":
          newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
          break;
        default:
          let z2 = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z2 < minZoom) {
            deltaZoom += minZoom - z2;
          }
          z2 = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z2 > maxZoom) {
            deltaZoom += maxZoom - z2;
          }
          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }
      return [newZoomX, newZoomY];
    }
    return clamp(startZoom + deltaZoom, minZoom, maxZoom);
  }
};
var OrthographicController = class extends Controller {
  constructor() {
    super(...arguments);
    this.ControllerState = OrthographicState;
    this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(["target", "zoom"])
    };
    this.dragMode = "pan";
  }
  _onPanRotate() {
    return false;
  }
};

// node_modules/@deck.gl/core/dist/views/orthographic-view.js
var OrthographicView = class extends View {
  constructor(props = {}) {
    super(props);
  }
  getViewportType() {
    return OrthographicViewport;
  }
  get ControllerType() {
    return OrthographicController;
  }
};
OrthographicView.displayName = "OrthographicView";
var orthographic_view_default = OrthographicView;

// node_modules/@deck.gl/core/dist/lib/layer-extension.js
var LayerExtension = class {
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
  }
  constructor(opts) {
    if (opts) {
      this.opts = opts;
    }
  }
  /** Returns true if two extensions are equivalent */
  equals(extension) {
    if (this === extension) {
      return true;
    }
    return this.constructor === extension.constructor && deepEqual2(this.opts, extension.opts, 1);
  }
  /** Only called if attached to a primitive layer */
  getShaders(extension) {
    return null;
  }
  /** Only called if attached to a CompositeLayer */
  getSubLayerProps(extension) {
    const { defaultProps: defaultProps17 } = extension.constructor;
    const newProps = {
      updateTriggers: {}
    };
    for (const key in defaultProps17) {
      if (key in this.props) {
        const propDef = defaultProps17[key];
        const propValue = this.props[key];
        newProps[key] = propValue;
        if (propDef && propDef.type === "accessor") {
          newProps.updateTriggers[key] = this.props.updateTriggers[key];
          if (typeof propValue === "function") {
            newProps[key] = this.getSubLayerAccessor(propValue);
          }
        }
      }
    }
    return newProps;
  }
  /* eslint-disable @typescript-eslint/no-empty-function */
  initializeState(context, extension) {
  }
  updateState(params, extension) {
  }
  onNeedsRedraw(extension) {
  }
  getNeedsPickingBuffer(extension) {
    return false;
  }
  draw(params, extension) {
  }
  finalizeState(context, extension) {
  }
};
LayerExtension.defaultProps = {};
LayerExtension.extensionName = "LayerExtension";
var layer_extension_default = LayerExtension;

// node_modules/@deck.gl/core/dist/utils/tesselator.js
var Tesselator = class {
  constructor(opts) {
    this.indexStarts = [0];
    this.vertexStarts = [0];
    this.vertexCount = 0;
    this.instanceCount = 0;
    const { attributes = {} } = opts;
    this.typedArrayManager = typed_array_manager_default;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
  }
  /* Public methods */
  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const { data, buffers = {}, getGeometry, geometryBuffer, positionFormat, dataChanged, normalize: normalize6 = true } = this.opts;
    this.data = data;
    this.getGeometry = getGeometry;
    this.positionSize = // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat
    geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize6;
    if (geometryBuffer) {
      assert8(data.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
      if (!normalize6) {
        buffers.vertexPositions = geometryBuffer;
      }
    }
    this.geometryBuffer = buffers.vertexPositions;
    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }
  updatePartialGeometry({ startRow, endRow }) {
    this._rebuildGeometry({ startRow, endRow });
  }
  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;
    if (!ArrayBuffer.isView(value)) {
      return null;
    }
    return getAccessorFromBuffer(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }
  /* Private utility methods */
  _allocate(instanceCount, copy6) {
    const { attributes, buffers, _attributeDefs, typedArrayManager } = this;
    for (const name2 in _attributeDefs) {
      if (name2 in buffers) {
        typedArrayManager.release(attributes[name2]);
        attributes[name2] = null;
      } else {
        const def = _attributeDefs[name2];
        def.copy = copy6;
        attributes[name2] = typedArrayManager.allocate(attributes[name2], instanceCount, def);
      }
    }
  }
  /**
   * Visit all objects
   * `data` is expected to be an iterable consistent with the base Layer expectation
   */
  _forEachGeometry(visitor, startRow, endRow) {
    const { data, getGeometry } = this;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;
      visitor(geometry, objectInfo.index);
    }
  }
  /* eslint-disable complexity,max-statements */
  _rebuildGeometry(dataRange) {
    if (!this.data) {
      return;
    }
    let { indexStarts, vertexStarts, instanceCount } = this;
    const { data, geometryBuffer } = this;
    const { startRow = 0, endRow = Infinity } = dataRange || {};
    const normalizedData = {};
    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }
    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
        normalizedData[dataIndex] = normalizedGeometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
      }, startRow, endRow);
      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else {
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || 0;
      if (ArrayBuffer.isView(geometryBuffer)) {
        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
      } else if (geometryBuffer instanceof Buffer2) {
        const byteStride = this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
      } else if (geometryBuffer.buffer) {
        const byteStride = geometryBuffer.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
      } else if (geometryBuffer.value) {
        const bufferValue = geometryBuffer.value;
        const elementStride = (
          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize
          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize
        );
        instanceCount = instanceCount || bufferValue.length / elementStride;
      }
    }
    this._allocate(instanceCount, Boolean(dataRange));
    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};
    this._forEachGeometry((geometry, dataIndex) => {
      const normalizedGeometry = normalizedData[dataIndex] || geometry;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(normalizedGeometry, context);
    }, startRow, endRow);
    this.vertexCount = indexStarts[indexStarts.length - 1];
  }
};

// node_modules/@vivjs/constants/dist/index.mjs
var MAX_COLOR_INTENSITY = 255;
var DEFAULT_COLOR_OFF = [0, 0, 0];
var MAX_CHANNELS = 6;
var DEFAULT_FONT_FAMILY = "-apple-system, 'Helvetica Neue', Arial, sans-serif";
var DTYPE_VALUES = {
  Uint8: {
    format: "r8uint",
    dataFormat: GLEnum.RED_INTEGER,
    type: GLEnum.UNSIGNED_BYTE,
    max: 2 ** 8 - 1,
    sampler: "usampler2D"
  },
  Uint16: {
    format: "r16uint",
    dataFormat: GLEnum.RED_INTEGER,
    type: GLEnum.UNSIGNED_SHORT,
    max: 2 ** 16 - 1,
    sampler: "usampler2D"
  },
  Uint32: {
    format: "r32uint",
    dataFormat: GLEnum.RED_INTEGER,
    type: GLEnum.UNSIGNED_INT,
    max: 2 ** 32 - 1,
    sampler: "usampler2D"
  },
  Float32: {
    format: "r32float",
    dataFormat: GLEnum.RED,
    type: GLEnum.FLOAT,
    // Not sure what to do about this one - a good use case for channel stats, I suppose:
    // https://en.wikipedia.org/wiki/Single-precision_floating-point_format.
    max: 3.4 * 10 ** 38,
    sampler: "sampler2D"
  },
  Int8: {
    format: "r8sint",
    dataFormat: GLEnum.RED_INTEGER,
    type: GLEnum.BYTE,
    max: 2 ** (8 - 1) - 1,
    sampler: "isampler2D"
  },
  Int16: {
    format: "r16sint",
    dataFormat: GLEnum.RED_INTEGER,
    type: GLEnum.SHORT,
    max: 2 ** (16 - 1) - 1,
    sampler: "isampler2D"
  },
  Int32: {
    format: "r32sint",
    dataFormat: GLEnum.RED_INTEGER,
    type: GLEnum.INT,
    max: 2 ** (32 - 1) - 1,
    sampler: "isampler2D"
  },
  // Cast Float64 as 32 bit float point so it can be rendered.
  Float64: {
    format: "r32float",
    dataFormat: GLEnum.RED,
    type: GLEnum.FLOAT,
    // Not sure what to do about this one - a good use case for channel stats, I suppose:
    // https://en.wikipedia.org/wiki/Single-precision_floating-point_format.
    max: 3.4 * 10 ** 38,
    sampler: "sampler2D",
    cast: (data) => new Float32Array(data)
  }
};

// node_modules/@vivjs/extensions/dist/index.mjs
var apply_transparent_color = `vec4 apply_transparent_color(vec3 color, vec3 transparentColor, bool useTransparentColor, float opacity){
  return vec4(color, (color == transparentColor && useTransparentColor) ? 0. : opacity);
}
`;
var alpha = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(1,1,1,0);
  const float e1 = 1.0;
  const vec4 v1 = vec4(1,1,1,1);
  float a0 = smoothstep(e0,e1,x);
  return mix(v0,v1,a0)*step(e0,x)*step(x,e1);
}
`;
var autumn = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(1,0,0,1);
  const float e1 = 1.0;
  const vec4 v1 = vec4(1,1,0,1);
  float a0 = smoothstep(e0,e1,x);
  return mix(v0,v1,a0)*step(e0,x)*step(x,e1);
}
`;
var bathymetry = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.1568627450980392,0.10196078431372549,0.17254901960784313,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.23137254901960785,0.19215686274509805,0.35294117647058826,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.25098039215686274,0.2980392156862745,0.5450980392156862,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.24705882352941178,0.43137254901960786,0.592156862745098,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.2823529411764706,0.5568627450980392,0.6196078431372549,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.3333333333333333,0.6823529411764706,0.6392156862745098,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.47058823529411764,0.807843137254902,0.6392156862745098,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.7333333333333333,0.9019607843137255,0.6745098039215687,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9921568627450981,0.996078431372549,0.8,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var blackbody = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0,1);
  const float e1 = 0.2;
  const vec4 v1 = vec4(0.9019607843137255,0,0,1);
  const float e2 = 0.4;
  const vec4 v2 = vec4(0.9019607843137255,0.8235294117647058,0,1);
  const float e3 = 0.7;
  const vec4 v3 = vec4(1,1,1,1);
  const float e4 = 1.0;
  const vec4 v4 = vec4(0.6274509803921569,0.7843137254901961,1,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),mix(v3,v4,a3)*step(e3,x)*step(x,e4)
  )));
}
`;
var bluered = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,1,1);
  const float e1 = 1.0;
  const vec4 v1 = vec4(1,0,0,1);
  float a0 = smoothstep(e0,e1,x);
  return mix(v0,v1,a0)*step(e0,x)*step(x,e1);
}
`;
var bone = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0,1);
  const float e1 = 0.376;
  const vec4 v1 = vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);
  const float e2 = 0.753;
  const vec4 v2 = vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);
  const float e3 = 1.0;
  const vec4 v3 = vec4(1,1,1,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),mix(v2,v3,a2)*step(e2,x)*step(x,e3)
  ));
}
`;
var cdom = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.1843137254901961,0.058823529411764705,0.24313725490196078,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.3411764705882353,0.09019607843137255,0.33725490196078434,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.5098039215686274,0.10980392156862745,0.38823529411764707,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.6705882352941176,0.1607843137254902,0.3764705882352941,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.807843137254902,0.2627450980392157,0.33725490196078434,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.9019607843137255,0.41568627450980394,0.32941176470588235,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.9490196078431372,0.5843137254901961,0.403921568627451,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.9764705882352941,0.7568627450980392,0.5294117647058824,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.996078431372549,0.9294117647058824,0.6901960784313725,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var chlorophyll = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.07058823529411765,0.1411764705882353,0.0784313725490196,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.09803921568627451,0.24705882352941178,0.1607843137254902,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.09411764705882353,0.3568627450980392,0.23137254901960785,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.050980392156862744,0.4666666666666667,0.2823529411764706,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.07058823529411765,0.5803921568627451,0.3137254901960784,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.3137254901960784,0.6784313725490196,0.34901960784313724,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.5176470588235295,0.7686274509803922,0.47843137254901963,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.6862745098039216,0.8666666666666667,0.6352941176470588,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.8431372549019608,0.9764705882352941,0.8156862745098039,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var cool = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.49019607843137253,0,0.7019607843137254,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.4549019607843137,0,0.8549019607843137,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0,0.8,0.7725490196078432,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0,0.9686274509803922,0.5725490196078431,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0,1,0.34509803921568627,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.1568627450980392,1,0.03137254901960784,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.5764705882352941,1,0,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var copper = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0,1);
  const float e1 = 0.804;
  const vec4 v1 = vec4(1,0.6274509803921569,0.4,1);
  const float e2 = 1.0;
  const vec4 v2 = vec4(1,0.7803921568627451,0.4980392156862745,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),mix(v1,v2,a1)*step(e1,x)*step(x,e2)
  );
}
`;
var cubehelix = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0,1);
  const float e1 = 0.07;
  const vec4 v1 = vec4(0.08627450980392157,0.0196078431372549,0.23137254901960785,1);
  const float e2 = 0.13;
  const vec4 v2 = vec4(0.23529411764705882,0.01568627450980392,0.4117647058823529,1);
  const float e3 = 0.2;
  const vec4 v3 = vec4(0.42745098039215684,0.00392156862745098,0.5294117647058824,1);
  const float e4 = 0.27;
  const vec4 v4 = vec4(0.6313725490196078,0,0.5764705882352941,1);
  const float e5 = 0.33;
  const vec4 v5 = vec4(0.8235294117647058,0.00784313725490196,0.5568627450980392,1);
  const float e6 = 0.4;
  const vec4 v6 = vec4(0.984313725490196,0.043137254901960784,0.4823529411764706,1);
  const float e7 = 0.47;
  const vec4 v7 = vec4(1,0.11372549019607843,0.3803921568627451,1);
  const float e8 = 0.53;
  const vec4 v8 = vec4(1,0.21176470588235294,0.27058823529411763,1);
  const float e9 = 0.6;
  const vec4 v9 = vec4(1,0.3333333333333333,0.1803921568627451,1);
  const float e10 = 0.67;
  const vec4 v10 = vec4(1,0.47058823529411764,0.13333333333333333,1);
  const float e11 = 0.73;
  const vec4 v11 = vec4(1,0.615686274509804,0.1450980392156863,1);
  const float e12 = 0.8;
  const vec4 v12 = vec4(0.9450980392156862,0.7490196078431373,0.2235294117647059,1);
  const float e13 = 0.87;
  const vec4 v13 = vec4(0.8784313725490196,0.8627450980392157,0.36470588235294116,1);
  const float e14 = 0.93;
  const vec4 v14 = vec4(0.8549019607843137,0.9450980392156862,0.5568627450980392,1);
  const float e15 = 1.0;
  const vec4 v15 = vec4(0.8901960784313725,0.9921568627450981,0.7764705882352941,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  float a8 = smoothstep(e8,e9,x);
  float a9 = smoothstep(e9,e10,x);
  float a10 = smoothstep(e10,e11,x);
  float a11 = smoothstep(e11,e12,x);
  float a12 = smoothstep(e12,e13,x);
  float a13 = smoothstep(e13,e14,x);
  float a14 = smoothstep(e14,e15,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),
    max(mix(v7,v8,a7)*step(e7,x)*step(x,e8),
    max(mix(v8,v9,a8)*step(e8,x)*step(x,e9),
    max(mix(v9,v10,a9)*step(e9,x)*step(x,e10),
    max(mix(v10,v11,a10)*step(e10,x)*step(x,e11),
    max(mix(v11,v12,a11)*step(e11,x)*step(x,e12),
    max(mix(v12,v13,a12)*step(e12,x)*step(x,e13),
    max(mix(v13,v14,a13)*step(e13,x)*step(x,e14),mix(v14,v15,a14)*step(e14,x)*step(x,e15)
  ))))))))))))));
}
`;
var density = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var earth = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0.5098039215686274,1);
  const float e1 = 0.1;
  const vec4 v1 = vec4(0,0.7058823529411765,0.7058823529411765,1);
  const float e2 = 0.2;
  const vec4 v2 = vec4(0.1568627450980392,0.8235294117647058,0.1568627450980392,1);
  const float e3 = 0.4;
  const vec4 v3 = vec4(0.9019607843137255,0.9019607843137255,0.19607843137254902,1);
  const float e4 = 0.6;
  const vec4 v4 = vec4(0.47058823529411764,0.27450980392156865,0.0784313725490196,1);
  const float e5 = 1.0;
  const vec4 v5 = vec4(1,1,1,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),mix(v4,v5,a4)*step(e4,x)*step(x,e5)
  ))));
}
`;
var electric = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0,1);
  const float e1 = 0.15;
  const vec4 v1 = vec4(0.11764705882352941,0,0.39215686274509803,1);
  const float e2 = 0.4;
  const vec4 v2 = vec4(0.47058823529411764,0,0.39215686274509803,1);
  const float e3 = 0.6;
  const vec4 v3 = vec4(0.6274509803921569,0.35294117647058826,0,1);
  const float e4 = 0.8;
  const vec4 v4 = vec4(0.9019607843137255,0.7843137254901961,0,1);
  const float e5 = 1.0;
  const vec4 v5 = vec4(1,0.9803921568627451,0.8627450980392157,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),mix(v4,v5,a4)*step(e4,x)*step(x,e5)
  ))));
}
`;
var freesurface_blue = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.11764705882352941,0.01568627450980392,0.43137254901960786,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.1843137254901961,0.054901960784313725,0.6901960784313725,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.1607843137254902,0.17647058823529413,0.9254901960784314,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.09803921568627451,0.38823529411764707,0.8313725490196079,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.26666666666666666,0.5137254901960784,0.7843137254901961,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.4470588235294118,0.611764705882353,0.7725490196078432,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.615686274509804,0.7098039215686275,0.796078431372549,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.7843137254901961,0.8156862745098039,0.8470588235294118,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var freesurface_red = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.23529411764705882,0.03529411764705882,0.07058823529411765,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.39215686274509803,0.06666666666666667,0.10588235294117647,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.5568627450980392,0.0784313725490196,0.11372549019607843,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.6941176470588235,0.16862745098039217,0.10588235294117647,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.7529411764705882,0.3411764705882353,0.24705882352941178,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.803921568627451,0.49019607843137253,0.4117647058823529,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.8470588235294118,0.6352941176470588,0.5803921568627451,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.8901960784313725,0.7803921568627451,0.7568627450980392,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var greens = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0.26666666666666666,0.10588235294117647,1);
  const float e1 = 0.125;
  const vec4 v1 = vec4(0,0.42745098039215684,0.17254901960784313,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.13725490196078433,0.5450980392156862,0.27058823529411763,1);
  const float e3 = 0.375;
  const vec4 v3 = vec4(0.2549019607843137,0.6705882352941176,0.36470588235294116,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.4549019607843137,0.7686274509803922,0.4627450980392157,1);
  const float e5 = 0.625;
  const vec4 v5 = vec4(0.6313725490196078,0.8509803921568627,0.6078431372549019,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.7803921568627451,0.9137254901960784,0.7529411764705882,1);
  const float e7 = 0.875;
  const vec4 v7 = vec4(0.8980392156862745,0.9607843137254902,0.8784313725490196,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9686274509803922,0.9882352941176471,0.9607843137254902,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var greys = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0,1);
  const float e1 = 1.0;
  const vec4 v1 = vec4(1,1,1,1);
  float a0 = smoothstep(e0,e1,x);
  return mix(v0,v1,a0)*step(e0,x)*step(x,e1);
}
`;
var hot = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0,1);
  const float e1 = 0.3;
  const vec4 v1 = vec4(0.9019607843137255,0,0,1);
  const float e2 = 0.6;
  const vec4 v2 = vec4(1,0.8235294117647058,0,1);
  const float e3 = 1.0;
  const vec4 v3 = vec4(1,1,1,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),mix(v2,v3,a2)*step(e2,x)*step(x,e3)
  ));
}
`;
var hsv = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(1,0,0,1);
  const float e1 = 0.169;
  const vec4 v1 = vec4(0.9921568627450981,1,0.00784313725490196,1);
  const float e2 = 0.173;
  const vec4 v2 = vec4(0.9686274509803922,1,0.00784313725490196,1);
  const float e3 = 0.337;
  const vec4 v3 = vec4(0,0.9882352941176471,0.01568627450980392,1);
  const float e4 = 0.341;
  const vec4 v4 = vec4(0,0.9882352941176471,0.0392156862745098,1);
  const float e5 = 0.506;
  const vec4 v5 = vec4(0.00392156862745098,0.9764705882352941,1,1);
  const float e6 = 0.671;
  const vec4 v6 = vec4(0.00784313725490196,0,0.9921568627450981,1);
  const float e7 = 0.675;
  const vec4 v7 = vec4(0.03137254901960784,0,0.9921568627450981,1);
  const float e8 = 0.839;
  const vec4 v8 = vec4(1,0,0.984313725490196,1);
  const float e9 = 0.843;
  const vec4 v9 = vec4(1,0,0.9607843137254902,1);
  const float e10 = 1.0;
  const vec4 v10 = vec4(1,0,0.023529411764705882,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  float a8 = smoothstep(e8,e9,x);
  float a9 = smoothstep(e9,e10,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),
    max(mix(v7,v8,a7)*step(e7,x)*step(x,e8),
    max(mix(v8,v9,a8)*step(e8,x)*step(x,e9),mix(v9,v10,a9)*step(e9,x)*step(x,e10)
  )))))))));
}
`;
var inferno = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0.01568627450980392,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.8901960784313725,0.34901960784313724,0.2,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9882352941176471,1,0.6431372549019608,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var jet = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0.5137254901960784,1);
  const float e1 = 0.125;
  const vec4 v1 = vec4(0,0.23529411764705882,0.6666666666666666,1);
  const float e2 = 0.375;
  const vec4 v2 = vec4(0.0196078431372549,1,1,1);
  const float e3 = 0.625;
  const vec4 v3 = vec4(1,1,0,1);
  const float e4 = 0.875;
  const vec4 v4 = vec4(0.9803921568627451,0,0,1);
  const float e5 = 1.0;
  const vec4 v5 = vec4(0.5019607843137255,0,0,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),mix(v4,v5,a4)*step(e4,x)*step(x,e5)
  ))));
}
`;
var magma = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,0.01568627450980392,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var oxygen = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.25098039215686274,0.0196078431372549,0.0196078431372549,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.41568627450980394,0.023529411764705882,0.058823529411764705,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.5647058823529412,0.10196078431372549,0.027450980392156862,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.6588235294117647,0.25098039215686274,0.011764705882352941,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.7372549019607844,0.39215686274509803,0.01568627450980392,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.807843137254902,0.5333333333333333,0.043137254901960784,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.8627450980392157,0.6823529411764706,0.09803921568627451,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.9058823529411765,0.8431372549019608,0.17254901960784313,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9725490196078431,0.996078431372549,0.4117647058823529,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var par = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.2,0.0784313725490196,0.09411764705882353,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.35294117647058826,0.12549019607843137,0.13725490196078433,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.5058823529411764,0.17254901960784313,0.13333333333333333,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.6235294117647059,0.26666666666666666,0.09803921568627451,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.7137254901960784,0.38823529411764707,0.07450980392156863,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.7803921568627451,0.5254901960784314,0.08627450980392157,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.8313725490196079,0.6705882352941176,0.13725490196078433,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.8666666666666667,0.8235294117647058,0.21176470588235294,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.8823529411764706,0.9921568627450981,0.29411764705882354,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var phase = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.7215686274509804,0.2784313725490196,0.14901960784313725,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.7294117647058823,0.22745098039215686,0.45098039215686275,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.6274509803921569,0.2784313725490196,0.7254901960784313,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.43137254901960786,0.3803921568627451,0.8549019607843137,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.19607843137254902,0.4823529411764706,0.6431372549019608,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.12156862745098039,0.5137254901960784,0.43137254901960786,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.30196078431372547,0.5058823529411764,0.13333333333333333,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var picnic = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,1,1);
  const float e1 = 0.1;
  const vec4 v1 = vec4(0.2,0.6,1,1);
  const float e2 = 0.2;
  const vec4 v2 = vec4(0.4,0.8,1,1);
  const float e3 = 0.3;
  const vec4 v3 = vec4(0.6,0.8,1,1);
  const float e4 = 0.4;
  const vec4 v4 = vec4(0.8,0.8,1,1);
  const float e5 = 0.5;
  const vec4 v5 = vec4(1,1,1,1);
  const float e6 = 0.6;
  const vec4 v6 = vec4(1,0.8,1,1);
  const float e7 = 0.7;
  const vec4 v7 = vec4(1,0.6,1,1);
  const float e8 = 0.8;
  const vec4 v8 = vec4(1,0.4,0.8,1);
  const float e9 = 0.9;
  const vec4 v9 = vec4(1,0.4,0.4,1);
  const float e10 = 1.0;
  const vec4 v10 = vec4(1,0,0,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  float a8 = smoothstep(e8,e9,x);
  float a9 = smoothstep(e9,e10,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),
    max(mix(v7,v8,a7)*step(e7,x)*step(x,e8),
    max(mix(v8,v9,a8)*step(e8,x)*step(x,e9),mix(v9,v10,a9)*step(e9,x)*step(x,e10)
  )))))))));
}
`;
var plasma = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var portland = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.047058823529411764,0.2,0.5137254901960784,1);
  const float e1 = 0.25;
  const vec4 v1 = vec4(0.0392156862745098,0.5333333333333333,0.7294117647058823,1);
  const float e2 = 0.5;
  const vec4 v2 = vec4(0.9490196078431372,0.8274509803921568,0.2196078431372549,1);
  const float e3 = 0.75;
  const vec4 v3 = vec4(0.9490196078431372,0.5607843137254902,0.2196078431372549,1);
  const float e4 = 1.0;
  const vec4 v4 = vec4(0.8509803921568627,0.11764705882352941,0.11764705882352941,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),mix(v3,v4,a3)*step(e3,x)*step(x,e4)
  )));
}
`;
var rainbow_soft = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.49019607843137253,0,0.7019607843137254,1);
  const float e1 = 0.1;
  const vec4 v1 = vec4(0.7803921568627451,0,0.7058823529411765,1);
  const float e2 = 0.2;
  const vec4 v2 = vec4(1,0,0.4745098039215686,1);
  const float e3 = 0.3;
  const vec4 v3 = vec4(1,0.4235294117647059,0,1);
  const float e4 = 0.4;
  const vec4 v4 = vec4(0.8705882352941177,0.7607843137254902,0,1);
  const float e5 = 0.5;
  const vec4 v5 = vec4(0.5882352941176471,1,0,1);
  const float e6 = 0.6;
  const vec4 v6 = vec4(0,1,0.21568627450980393,1);
  const float e7 = 0.7;
  const vec4 v7 = vec4(0,0.9647058823529412,0.5882352941176471,1);
  const float e8 = 0.8;
  const vec4 v8 = vec4(0.19607843137254902,0.6549019607843137,0.8705882352941177,1);
  const float e9 = 0.9;
  const vec4 v9 = vec4(0.403921568627451,0.2,0.9215686274509803,1);
  const float e10 = 1.0;
  const vec4 v10 = vec4(0.48627450980392156,0,0.7294117647058823,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  float a8 = smoothstep(e8,e9,x);
  float a9 = smoothstep(e9,e10,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),
    max(mix(v7,v8,a7)*step(e7,x)*step(x,e8),
    max(mix(v8,v9,a8)*step(e8,x)*step(x,e9),mix(v9,v10,a9)*step(e9,x)*step(x,e10)
  )))))))));
}
`;
var rainbow = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.5882352941176471,0,0.35294117647058826,1);
  const float e1 = 0.125;
  const vec4 v1 = vec4(0,0,0.7843137254901961,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0,0.09803921568627451,1,1);
  const float e3 = 0.375;
  const vec4 v3 = vec4(0,0.596078431372549,1,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.17254901960784313,1,0.5882352941176471,1);
  const float e5 = 0.625;
  const vec4 v5 = vec4(0.592156862745098,1,0,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(1,0.9176470588235294,0,1);
  const float e7 = 0.875;
  const vec4 v7 = vec4(1,0.43529411764705883,0,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(1,0,0,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var rdbu = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.0196078431372549,0.0392156862745098,0.6745098039215687,1);
  const float e1 = 0.35;
  const vec4 v1 = vec4(0.41568627450980394,0.5372549019607843,0.9686274509803922,1);
  const float e2 = 0.5;
  const vec4 v2 = vec4(0.7450980392156863,0.7450980392156863,0.7450980392156863,1);
  const float e3 = 0.6;
  const vec4 v3 = vec4(0.8627450980392157,0.6666666666666666,0.5176470588235295,1);
  const float e4 = 0.7;
  const vec4 v4 = vec4(0.9019607843137255,0.5686274509803921,0.35294117647058826,1);
  const float e5 = 1.0;
  const vec4 v5 = vec4(0.6980392156862745,0.0392156862745098,0.10980392156862745,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),mix(v4,v5,a4)*step(e4,x)*step(x,e5)
  ))));
}
`;
var salinity = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.16470588235294117,0.09411764705882353,0.4235294117647059,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.12941176470588237,0.19607843137254902,0.6352941176470588,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.058823529411764705,0.35294117647058826,0.5686274509803921,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.1568627450980392,0.4627450980392157,0.5372549019607843,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.23137254901960785,0.5725490196078431,0.5294117647058824,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.30980392156862746,0.6862745098039216,0.49411764705882355,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.47058823529411764,0.796078431372549,0.40784313725490196,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.7568627450980392,0.8666666666666667,0.39215686274509803,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9921568627450981,0.9372549019607843,0.6039215686274509,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var spring = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(1,0,1,1);
  const float e1 = 1.0;
  const vec4 v1 = vec4(1,1,0,1);
  float a0 = smoothstep(e0,e1,x);
  return mix(v0,v1,a0)*step(e0,x)*step(x,e1);
}
`;
var summer = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0.5019607843137255,0.4,1);
  const float e1 = 1.0;
  const vec4 v1 = vec4(1,1,0.4,1);
  float a0 = smoothstep(e0,e1,x);
  return mix(v0,v1,a0)*step(e0,x)*step(x,e1);
}
`;
var temperature = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.01568627450980392,0.13725490196078433,0.2,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.09019607843137255,0.2,0.47843137254901963,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.3333333333333333,0.23137254901960785,0.615686274509804,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.5058823529411764,0.30980392156862746,0.5607843137254902,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.6862745098039216,0.37254901960784315,0.5098039215686274,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.8705882352941177,0.4392156862745098,0.396078431372549,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.9764705882352941,0.5725490196078431,0.25882352941176473,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.9764705882352941,0.7686274509803922,0.2549019607843137,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9098039215686274,0.9803921568627451,0.3568627450980392,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var turbidity = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.13333333333333333,0.12156862745098039,0.10588235294117647,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.2549019607843137,0.19607843137254902,0.1607843137254902,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.3843137254901961,0.27058823529411763,0.20392156862745098,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.5137254901960784,0.34901960784313724,0.2235294117647059,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.6313725490196078,0.4392156862745098,0.23137254901960785,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.7254901960784313,0.5490196078431373,0.25882352941176473,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.792156862745098,0.6823529411764706,0.34509803921568627,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.8470588235294118,0.8196078431372549,0.49411764705882355,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9137254901960784,0.9647058823529412,0.6705882352941176,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var velocity_blue = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.06666666666666667,0.12549019607843137,0.25098039215686274,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.13725490196078433,0.20392156862745098,0.4549019607843137,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.11372549019607843,0.3176470588235294,0.611764705882353,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.12156862745098039,0.44313725490196076,0.6352941176470588,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.19607843137254902,0.5647058823529412,0.6627450980392157,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.3411764705882353,0.6784313725490196,0.6901960784313725,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.5843137254901961,0.7686274509803922,0.7411764705882353,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.796078431372549,0.8666666666666667,0.8274509803921568,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.996078431372549,0.984313725490196,0.9019607843137255,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var velocity_green = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.09019607843137255,0.13725490196078433,0.07450980392156863,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.09411764705882353,0.25098039215686274,0.14901960784313725,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.043137254901960784,0.37254901960784315,0.17647058823529413,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.15294117647058825,0.4823529411764706,0.13725490196078433,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.37254901960784315,0.5725490196078431,0.047058823529411764,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.596078431372549,0.6470588235294118,0.07058823529411765,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.788235294117647,0.7294117647058823,0.27058823529411763,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.9137254901960784,0.8470588235294118,0.5372549019607843,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(1,0.9921568627450981,0.803921568627451,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var viridis = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var warm = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.49019607843137253,0,0.7019607843137254,1);
  const float e1 = 0.13;
  const vec4 v1 = vec4(0.6745098039215687,0,0.7333333333333333,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.8588235294117647,0,0.6666666666666666,1);
  const float e3 = 0.38;
  const vec4 v3 = vec4(1,0,0.5098039215686274,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(1,0.24705882352941178,0.2901960784313726,1);
  const float e5 = 0.63;
  const vec4 v5 = vec4(1,0.4823529411764706,0,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.9176470588235294,0.6901960784313725,0,1);
  const float e7 = 0.88;
  const vec4 v7 = vec4(0.7450980392156863,0.8941176470588236,0,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(0.5764705882352941,1,0,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var winter = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0,0,1,1);
  const float e1 = 1.0;
  const vec4 v1 = vec4(0,1,0.5019607843137255,1);
  float a0 = smoothstep(e0,e1,x);
  return mix(v0,v1,a0)*step(e0,x)*step(x,e1);
}
`;
var yignbu = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.03137254901960784,0.11372549019607843,0.34509803921568627,1);
  const float e1 = 0.125;
  const vec4 v1 = vec4(0.1450980392156863,0.20392156862745098,0.5803921568627451,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.13333333333333333,0.3686274509803922,0.6588235294117647,1);
  const float e3 = 0.375;
  const vec4 v3 = vec4(0.11372549019607843,0.5686274509803921,0.7529411764705882,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.2549019607843137,0.7137254901960784,0.7686274509803922,1);
  const float e5 = 0.625;
  const vec4 v5 = vec4(0.4980392156862745,0.803921568627451,0.7333333333333333,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.7803921568627451,0.9137254901960784,0.7058823529411765,1);
  const float e7 = 0.875;
  const vec4 v7 = vec4(0.9294117647058824,0.9725490196078431,0.8509803921568627,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(1,1,0.8509803921568627,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var yiorrd = `vec4 apply_cmap (float x) {
  const float e0 = 0.0;
  const vec4 v0 = vec4(0.5019607843137255,0,0.14901960784313725,1);
  const float e1 = 0.125;
  const vec4 v1 = vec4(0.7411764705882353,0,0.14901960784313725,1);
  const float e2 = 0.25;
  const vec4 v2 = vec4(0.8901960784313725,0.10196078431372549,0.10980392156862745,1);
  const float e3 = 0.375;
  const vec4 v3 = vec4(0.9882352941176471,0.3058823529411765,0.16470588235294117,1);
  const float e4 = 0.5;
  const vec4 v4 = vec4(0.9921568627450981,0.5529411764705883,0.23529411764705882,1);
  const float e5 = 0.625;
  const vec4 v5 = vec4(0.996078431372549,0.6980392156862745,0.2980392156862745,1);
  const float e6 = 0.75;
  const vec4 v6 = vec4(0.996078431372549,0.8509803921568627,0.4627450980392157,1);
  const float e7 = 0.875;
  const vec4 v7 = vec4(1,0.9294117647058824,0.6274509803921569,1);
  const float e8 = 1.0;
  const vec4 v8 = vec4(1,1,0.8,1);
  float a0 = smoothstep(e0,e1,x);
  float a1 = smoothstep(e1,e2,x);
  float a2 = smoothstep(e2,e3,x);
  float a3 = smoothstep(e3,e4,x);
  float a4 = smoothstep(e4,e5,x);
  float a5 = smoothstep(e5,e6,x);
  float a6 = smoothstep(e6,e7,x);
  float a7 = smoothstep(e7,e8,x);
  return max(mix(v0,v1,a0)*step(e0,x)*step(x,e1),
    max(mix(v1,v2,a1)*step(e1,x)*step(x,e2),
    max(mix(v2,v3,a2)*step(e2,x)*step(x,e3),
    max(mix(v3,v4,a3)*step(e3,x)*step(x,e4),
    max(mix(v4,v5,a4)*step(e4,x)*step(x,e5),
    max(mix(v5,v6,a5)*step(e5,x)*step(x,e6),
    max(mix(v6,v7,a6)*step(e6,x)*step(x,e7),mix(v7,v8,a7)*step(e7,x)*step(x,e8)
  )))))));
}
`;
var cmaps = {
  __proto__: null,
  alpha,
  autumn,
  bathymetry,
  blackbody,
  bluered,
  bone,
  cdom,
  chlorophyll,
  cool,
  copper,
  cubehelix,
  density,
  earth,
  electric,
  freesurface_blue,
  freesurface_red,
  greens,
  greys,
  hot,
  hsv,
  inferno,
  jet,
  magma,
  oxygen,
  par,
  phase,
  picnic,
  plasma,
  portland,
  rainbow,
  rainbow_soft,
  rdbu,
  salinity,
  spring,
  summer,
  temperature,
  turbidity,
  velocity_blue,
  velocity_green,
  viridis,
  warm,
  winter,
  yignbu,
  yiorrd
};
function colormapModuleFactory(name2, apply_cmap) {
  return {
    name: `additive-colormap-${name2}`,
    fs: `uniform float opacity;
uniform bool useTransparentColor;

${apply_transparent_color}
${apply_cmap}

vec4 colormap(float intensity) {
  return vec4(apply_transparent_color(apply_cmap(min(1.,intensity)).xyz, apply_cmap(0.).xyz, useTransparentColor, opacity));
}`,
    inject: {
      "fs:DECKGL_MUTATE_COLOR": `  float intensityCombo = 0.;
  intensityCombo += max(0.,intensity0);
  intensityCombo += max(0.,intensity1);
  intensityCombo += max(0.,intensity2);
  intensityCombo += max(0.,intensity3);
  intensityCombo += max(0.,intensity4);
  intensityCombo += max(0.,intensity5);
  rgba = colormap(intensityCombo);`
    }
  };
}
var defaultProps$4 = {
  colormap: { type: "string", value: "viridis", compare: true },
  opacity: { type: "number", value: 1, compare: true },
  useTransparentColor: { type: "boolean", value: false, compare: true }
};
var AdditiveColormapExtension = class extends layer_extension_default {
  getShaders() {
    const name2 = this?.props?.colormap || defaultProps$4.colormap.value;
    const apply_cmap = cmaps[name2];
    if (!apply_cmap) {
      throw Error(`No colormap named ${name2} found in registry`);
    }
    return { modules: [colormapModuleFactory(name2, apply_cmap)] };
  }
  updateState({ props, oldProps, changeFlags, ...rest }) {
    super.updateState({ props, oldProps, changeFlags, ...rest });
    if (props.colormap !== oldProps.colormap) {
      const { device } = this.context;
      if (this.state.model) {
        this.state.model.destroy();
        this.setState({ model: this._getModel(device) });
      }
    }
  }
  draw() {
    const {
      useTransparentColor = defaultProps$4.useTransparentColor.value,
      opacity = defaultProps$4.opacity.value
    } = this.props;
    const uniforms = {
      opacity,
      useTransparentColor
    };
    this.state.model?.setUniforms(uniforms);
  }
};
AdditiveColormapExtension.extensionName = "AdditiveColormapExtension";
AdditiveColormapExtension.defaultProps = defaultProps$4;
function padWithDefault(arr, defaultValue, padWidth) {
  for (let i3 = 0; i3 < padWidth; i3 += 1) {
    arr.push(defaultValue);
  }
  return arr;
}
var COLOR_PALETTE = [
  [0, 0, 255],
  // blue
  [0, 255, 0],
  // green
  [255, 0, 255],
  // magenta
  [255, 255, 0],
  // yellow
  [255, 128, 0],
  // orange
  [0, 255, 255],
  // cyan
  [255, 255, 255],
  // white
  [255, 0, 0]
  // red
];
function getDefaultPalette(n2) {
  if (n2 > COLOR_PALETTE.length) {
    throw new Error("Too many colors");
  }
  return COLOR_PALETTE.slice(0, n2);
}
function padColors({ colors, channelsVisible }) {
  const newColors = colors.map(
    (color, i3) => channelsVisible[i3] ? color.map((c2) => c2 / MAX_COLOR_INTENSITY) : DEFAULT_COLOR_OFF
  );
  const padSize = MAX_CHANNELS - newColors.length;
  const paddedColors = padWithDefault(
    newColors,
    /** @type {Color} */
    DEFAULT_COLOR_OFF,
    padSize
  ).reduce((acc, val) => acc.concat(val), []);
  return paddedColors;
}
var fs$1 = `uniform vec3 transparentColor;
uniform bool useTransparentColor;
uniform float opacity;

uniform vec3 colors[6];

${apply_transparent_color}

void mutate_color(inout vec3 rgb, float intensity0, float intensity1, float intensity2, float intensity3, float intensity4, float intensity5) { 
  rgb += max(0.0, min(1.0, intensity0)) * vec3(colors[0]);
  rgb += max(0.0, min(1.0, intensity1)) * vec3(colors[1]);
  rgb += max(0.0, min(1.0, intensity2)) * vec3(colors[2]);
  rgb += max(0.0, min(1.0, intensity3)) * vec3(colors[3]);
  rgb += max(0.0, min(1.0, intensity4)) * vec3(colors[4]);
  rgb += max(0.0, min(1.0, intensity5)) * vec3(colors[5]);
}

vec4 apply_opacity(vec3 rgb) {
  return vec4(apply_transparent_color(rgb, transparentColor, useTransparentColor, opacity));
}
`;
var DECKGL_MUTATE_COLOR = `vec3 rgb = rgba.rgb;
mutate_color(rgb, intensity0, intensity1, intensity2, intensity3, intensity4, intensity5);
rgba = apply_opacity(rgb);
`;
var colorPalette = {
  name: "color-palette-module",
  fs: fs$1,
  inject: {
    "fs:DECKGL_MUTATE_COLOR": DECKGL_MUTATE_COLOR
  }
};
var defaultProps$3 = {
  colors: { type: "array", value: null, compare: true },
  opacity: { type: "number", value: 1, compare: true },
  transparentColor: { type: "array", value: null, compare: true },
  useTransparentColor: { type: "boolean", value: false, compare: true }
};
var ColorPaletteExtension = class extends layer_extension_default {
  getShaders() {
    return {
      ...super.getShaders(),
      modules: [colorPalette]
    };
  }
  draw() {
    const {
      colors,
      channelsVisible,
      opacity = defaultProps$3.opacity.value,
      transparentColor = defaultProps$3.transparentColor.value,
      useTransparentColor = defaultProps$3.useTransparentColor.value
    } = this.props;
    const paddedColors = padColors({
      channelsVisible: channelsVisible || this.selections.map(() => true),
      colors: colors || getDefaultPalette(this.props.selections.length)
    });
    const uniforms = {
      colors: paddedColors,
      opacity,
      transparentColor: (transparentColor || [0, 0, 0]).map((i3) => i3 / 255),
      useTransparentColor: Boolean(useTransparentColor)
    };
    this.state.model?.setUniforms(uniforms);
  }
};
ColorPaletteExtension.extensionName = "ColorPaletteExtension";
ColorPaletteExtension.defaultProps = defaultProps$3;
var fs5 = `// lens bounds for ellipse
uniform float majorLensAxis;
uniform float minorLensAxis;
uniform vec2 lensCenter;

// lens uniforms
uniform bool lensEnabled;
uniform int lensSelection;
uniform vec3 lensBorderColor;
uniform float lensBorderRadius;

// color palette
uniform vec3 colors[6];

bool frag_in_lens_bounds(vec2 vTexCoord) {
  // Check membership in what is (not visually, but effectively) an ellipse.
  // Since the fragment space is a unit square and the real coordinates could be longer than tall,
  // to get a circle visually we have to treat the check as that of an ellipse to get the effect of a circle.

  // Check membership in ellipse.
  return pow((lensCenter.x - vTexCoord.x) / majorLensAxis, 2.) + pow((lensCenter.y - vTexCoord.y) / minorLensAxis, 2.) < (1. - lensBorderRadius);
}

bool frag_on_lens_bounds(vec2 vTexCoord) {
  // Same as the above, except this checks the boundary.

  float ellipseDistance = pow((lensCenter.x - vTexCoord.x) / majorLensAxis, 2.) + pow((lensCenter.y - vTexCoord.y) / minorLensAxis, 2.);

  // Check membership on "bourndary" of ellipse.
  return ellipseDistance <= 1. && ellipseDistance >= (1. - lensBorderRadius);
}
// Return a float for boolean arithmetic calculation.
float get_use_color_float(vec2 vTexCoord, int channelIndex) {
  bool isFragInLensBounds = frag_in_lens_bounds(vTexCoord);
  bool inLensAndUseLens = lensEnabled && isFragInLensBounds;
  return float(int((inLensAndUseLens && channelIndex == lensSelection) || (!inLensAndUseLens)));
 
}
void mutate_color(inout vec3 rgb, float intensity0, float intensity1, float intensity2, float intensity3, float intensity4, float intensity5, vec2 vTexCoord){
  float useColorValue = 0.;

  useColorValue = get_use_color_float(vTexCoord, 0);
  rgb += max(0., min(1., intensity0)) * max(vec3(colors[0]), (1. - useColorValue) * vec3(1., 1., 1.));

  useColorValue = get_use_color_float(vTexCoord, 1);
  rgb += max(0., min(1., intensity1)) * max(vec3(colors[1]), (1. - useColorValue) * vec3(1., 1., 1.));

  useColorValue = get_use_color_float(vTexCoord, 2);
  rgb += max(0., min(1., intensity2)) * max(vec3(colors[2]), (1. - useColorValue) * vec3(1., 1., 1.));

  useColorValue = get_use_color_float(vTexCoord, 3);
  rgb += max(0., min(1., intensity3)) * max(vec3(colors[3]), (1. - useColorValue) * vec3(1., 1., 1.));

  useColorValue = get_use_color_float(vTexCoord, 4);
  rgb += max(0., min(1., intensity4)) * max(vec3(colors[4]), (1. - useColorValue) * vec3(1., 1., 1.));

  useColorValue = get_use_color_float(vTexCoord, 5);
  rgb += max(0., min(1., intensity5)) * max(vec3(colors[5]), (1. - useColorValue) * vec3(1., 1., 1.));
}
`;
var lens = {
  name: "lens-module",
  fs: fs5,
  inject: {
    "fs:DECKGL_MUTATE_COLOR": `
   vec3 rgb = rgba.rgb;
   mutate_color(rgb, intensity0, intensity1, intensity2, intensity3, intensity4, intensity5, vTexCoord);
   rgba = vec4(rgb, 1.);
  `,
    "fs:#main-end": `
      bool isFragOnLensBounds = frag_on_lens_bounds(vTexCoord);
      fragColor = (lensEnabled && isFragOnLensBounds) ? vec4(lensBorderColor, 1.) : fragColor;
  `
  }
};
var defaultProps$2 = {
  lensEnabled: { type: "boolean", value: false, compare: true },
  lensSelection: { type: "number", value: 0, compare: true },
  lensRadius: { type: "number", value: 100, compare: true },
  lensBorderColor: { type: "array", value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: "number", value: 0.02, compare: true },
  colors: { type: "array", value: null, compare: true }
};
var LensExtension = class extends layer_extension_default {
  getShaders() {
    return {
      ...super.getShaders(),
      modules: [lens]
    };
  }
  initializeState() {
    const layer = this.getCurrentLayer();
    if (layer.isComposite) {
      return;
    }
    const onMouseMove = () => {
      const { viewportId } = layer.props;
      const { lensRadius = defaultProps$2.lensRadius.value } = this.props;
      if (!viewportId) {
        layer.setState({ unprojectLensBounds: [0, 0, 0, 0] });
        return;
      }
      const { mousePosition } = layer.context;
      const layerView = layer.context.deck.viewManager.views.filter(
        (view) => view.id === viewportId
      )[0];
      const viewState = layer.context.deck.viewManager.viewState[viewportId];
      const viewport = layerView.makeViewport({
        ...viewState,
        viewState
      });
      if (mousePosition && viewport.containsPixel(mousePosition)) {
        const offsetMousePosition = {
          x: mousePosition.x - viewport.x,
          y: mousePosition.y - viewport.y
        };
        const mousePositionBounds = [
          // left
          [offsetMousePosition.x - lensRadius, offsetMousePosition.y],
          // bottom
          [offsetMousePosition.x, offsetMousePosition.y + lensRadius],
          // right
          [offsetMousePosition.x + lensRadius, offsetMousePosition.y],
          // top
          [offsetMousePosition.x, offsetMousePosition.y - lensRadius]
        ];
        const unprojectLensBounds = mousePositionBounds.map(
          (bounds, i3) => viewport.unproject(bounds)[i3 % 2]
        );
        layer.setState({ unprojectLensBounds });
      } else {
        layer.setState({ unprojectLensBounds: [0, 0, 0, 0] });
      }
    };
    if (this.context.deck) {
      this.context.deck.eventManager.on({
        pointermove: onMouseMove,
        pointerleave: onMouseMove,
        wheel: onMouseMove
      });
    }
    this.setState({ onMouseMove, unprojectLensBounds: [0, 0, 0, 0] });
  }
  draw() {
    const { unprojectLensBounds = [0, 0, 0, 0] } = this.state;
    const {
      bounds,
      lensEnabled = defaultProps$2.lensEnabled.value,
      lensSelection = defaultProps$2.lensSelection.value,
      lensBorderColor = defaultProps$2.lensBorderColor.value,
      lensBorderRadius = defaultProps$2.lensBorderRadius.value,
      colors,
      channelsVisible
    } = this.props;
    const [leftMouseBound, bottomMouseBound, rightMouseBound, topMouseBound] = unprojectLensBounds;
    const [left, bottom, right, top] = bounds;
    const leftMouseBoundScaled = (leftMouseBound - left) / (right - left);
    const bottomMouseBoundScaled = (bottomMouseBound - top) / (bottom - top);
    const rightMouseBoundScaled = (rightMouseBound - left) / (right - left);
    const topMouseBoundScaled = (topMouseBound - top) / (bottom - top);
    const paddedColors = padColors({
      channelsVisible: channelsVisible || this.selections.map(() => true),
      colors: colors || getDefaultPalette(this.props.selections.length)
    });
    const uniforms = {
      majorLensAxis: (rightMouseBoundScaled - leftMouseBoundScaled) / 2,
      minorLensAxis: (bottomMouseBoundScaled - topMouseBoundScaled) / 2,
      lensCenter: [
        (rightMouseBoundScaled + leftMouseBoundScaled) / 2,
        (bottomMouseBoundScaled + topMouseBoundScaled) / 2
      ],
      lensEnabled,
      lensSelection,
      lensBorderColor,
      lensBorderRadius,
      colors: paddedColors
    };
    this.state.model?.setUniforms(uniforms);
  }
  finalizeState() {
    if (this.context.deck) {
      this.context.deck.eventManager.off({
        pointermove: this.state?.onMouseMove,
        pointerleave: this.state?.onMouseMove,
        wheel: this.state?.onMouseMove
      });
    }
  }
};
LensExtension.extensionName = "LensExtension";
LensExtension.defaultProps = defaultProps$2;
function colormapModuleFactory3D(name2, apply_cmap) {
  const fs7 = `${apply_cmap}

vec4 colormap(float intensity, float opacity) {
  return vec4(apply_cmap(min(1.,intensity)).xyz, opacity);
}`;
  return {
    name: `additive-colormap-3d-${name2}`,
    fs: fs7
  };
}
var defaultProps$1 = {
  colormap: { type: "string", value: "viridis", compare: true }
};
var BaseExtension$1 = class BaseExtension extends layer_extension_default {
  constructor(...args) {
    super(args);
    this.opts = this.opts || {};
  }
  getShaders() {
    const name2 = this?.props?.colormap || defaultProps$1.colormap.value;
    const apply_cmap = cmaps[name2];
    return {
      ...super.getShaders(),
      modules: [colormapModuleFactory3D(name2, apply_cmap)]
    };
  }
  updateState({ props, oldProps, changeFlags, ...rest }) {
    super.updateState({ props, oldProps, changeFlags, ...rest });
    if (props.colormap !== oldProps.colormap) {
      const { device } = this.context;
      if (this.state.model) {
        this.state.model.destroy();
        this.setState({ model: this._getModel(device) });
      }
    }
  }
};
BaseExtension$1.extensionName = "BaseExtension";
BaseExtension$1.defaultProps = defaultProps$1;
var _BEFORE_RENDER$5 = "";
var _RENDER$5 = `  float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);
  float total = 0.0;

  for(int i = 0; i < 6; i++) {
    total += intensityArray[i];
  }
  // Do not go past 1 in opacity/colormap value.
  total = min(total, 1.0);

  vec4 val_color = colormap(total, total);

  // Opacity correction
  val_color.a = 1.0 - pow(1.0 - val_color.a, 1.0);
  color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;
  color.a += (1.0 - color.a) * val_color.a;
  if (color.a >= 0.95) {
    break;
  }
  p += ray_dir * dt;
`;
var _AFTER_RENDER$5 = "";
var AdditiveBlendExtension$1 = class AdditiveBlendExtension extends BaseExtension$1 {
  constructor(args) {
    super(args);
    this.rendering = { _BEFORE_RENDER: _BEFORE_RENDER$5, _RENDER: _RENDER$5, _AFTER_RENDER: _AFTER_RENDER$5 };
  }
};
AdditiveBlendExtension$1.extensionName = "AdditiveBlendExtension";
var _BEFORE_RENDER$4 = `  float maxVals[6] = float[6](-1.0, -1.0, -1.0, -1.0, -1.0, -1.0);
`;
var _RENDER$4 = `  float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

  for(int i = 0; i < 6; i++) {
    if(intensityArray[i] > maxVals[i]) {
      maxVals[i] = intensityArray[i];
    }
  }
`;
var _AFTER_RENDER$4 = `  float total = 0.0;
  for(int i = 0; i < 6; i++) {
    total += maxVals[i];
  }
  // Do not go past 1 in opacity/colormap value.
  total = min(total, 1.0);
  color = colormap(total, total);
`;
var MaximumIntensityProjectionExtension$1 = class MaximumIntensityProjectionExtension extends BaseExtension$1 {
  constructor(args) {
    super(args);
    this.rendering = { _BEFORE_RENDER: _BEFORE_RENDER$4, _RENDER: _RENDER$4, _AFTER_RENDER: _AFTER_RENDER$4 };
  }
};
MaximumIntensityProjectionExtension$1.extensionName = "MaximumIntensityProjectionExtension";
var _BEFORE_RENDER$3 = `  float minVals[6] = float[6](1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0.);
`;
var _RENDER$3 = `  float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

  for(int i = 0; i < 6; i++) {
    if(intensityArray[i] < minVals[i]) {
      minVals[i] = intensityArray[i];
    }
  }
`;
var _AFTER_RENDER$3 = `  float total = 0.0;
  for(int i = 0; i < 6; i++) {
    total += minVals[i];
  }
  // Do not go past 1 in opacity/colormap value.
  total = min(total, 1.0);
  color = colormap(total, total);
`;
var MinimumIntensityProjectionExtension$1 = class MinimumIntensityProjectionExtension extends BaseExtension$1 {
  constructor(args) {
    super(args);
    this.rendering = { _BEFORE_RENDER: _BEFORE_RENDER$3, _RENDER: _RENDER$3, _AFTER_RENDER: _AFTER_RENDER$3 };
  }
};
MinimumIntensityProjectionExtension$1.extensionName = "MinimumIntensityProjectionExtension";
var defaultProps3 = {
  colors: { type: "array", value: null, compare: true }
};
var BaseExtension2 = class extends layer_extension_default {
  constructor(...args) {
    super(args);
    this.opts = this.opts || {};
  }
  draw() {
    const { colors, channelsVisible } = this.props;
    const paddedColors = padColors({
      channelsVisible: channelsVisible || this.selections.map(() => true),
      colors: colors || getDefaultPalette(this.props.selections.length)
    });
    const uniforms = {
      colors: paddedColors
    };
    this.state.model?.setUniforms(uniforms);
  }
};
BaseExtension2.extensionName = "BaseExtension";
BaseExtension2.defaultProps = defaultProps3;
var _BEFORE_RENDER$2 = "";
var _RENDER$2 = `  vec3 rgbCombo = vec3(0.0);
  vec3 hsvCombo = vec3(0.0);
  float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);
  float total = 0.0;
  for(int i = 0; i < 6; i++) {
    float intensityValue = intensityArray[i];
    rgbCombo += max(0.0, min(1.0, intensityValue)) * colors[i];
    total += intensityValue;
  }
  // Do not go past 1 in opacity.
  total = min(total, 1.0);
  vec4 val_color = vec4(rgbCombo, total);
  // Opacity correction
  val_color.a = 1.0 - pow(1.0 - val_color.a, 1.0);
  color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;
  color.a += (1.0 - color.a) * val_color.a;
  if (color.a >= 0.95) {
    break;
  }
`;
var _AFTER_RENDER$2 = "";
var AdditiveBlendExtension2 = class extends BaseExtension2 {
  constructor(args) {
    super(args);
    this.rendering = { _BEFORE_RENDER: _BEFORE_RENDER$2, _RENDER: _RENDER$2, _AFTER_RENDER: _AFTER_RENDER$2 };
  }
};
AdditiveBlendExtension2.extensionName = "AdditiveBlendExtension";
var _BEFORE_RENDER$1 = `  float maxVals[6] = float[6](-1.0, -1.0, -1.0, -1.0, -1.0, -1.0);
`;
var _RENDER$1 = `  float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

  for(int i = 0; i < 6; i++) {
    if(intensityArray[i] > maxVals[i]) {
      maxVals[i] = intensityArray[i];
    }
  }
`;
var _AFTER_RENDER$1 = `  vec3 rgbCombo = vec3(0.0);
  for(int i = 0; i < 6; i++) {
    rgbCombo += max(0.0, min(1.0, maxVals[i])) * vec3(colors[i]);
  }
  color = vec4(rgbCombo, 1.0);
`;
var MaximumIntensityProjectionExtension2 = class extends BaseExtension2 {
  constructor(args) {
    super(args);
    this.rendering = { _BEFORE_RENDER: _BEFORE_RENDER$1, _RENDER: _RENDER$1, _AFTER_RENDER: _AFTER_RENDER$1 };
  }
};
MaximumIntensityProjectionExtension2.extensionName = "MaximumIntensityProjectionExtension";
var _BEFORE_RENDER = `  float minVals[6] = float[6](1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0., 1. / 0.);
`;
var _RENDER = `  float intensityArray[6] = float[6](intensityValue0, intensityValue1, intensityValue2, intensityValue3, intensityValue4, intensityValue5);

  for(int i = 0; i < 6; i++) {
    if(intensityArray[i] < minVals[i]) {
      minVals[i] = intensityArray[i];
    }
  }
`;
var _AFTER_RENDER = `  vec3 rgbCombo = vec3(0.0);
  for(int i = 0; i < 6; i++) {
    rgbCombo += max(0.0, min(1.0, minVals[i])) * vec3(colors[i]);
  }
  color = vec4(rgbCombo, 1.0);
`;
var MinimumIntensityProjectionExtension2 = class extends BaseExtension2 {
  constructor(args) {
    super(args);
    this.rendering = { _BEFORE_RENDER, _RENDER, _AFTER_RENDER };
  }
};
MinimumIntensityProjectionExtension2.extensionName = "MinimumIntensityProjectionExtension";
var ColorPalette3DExtensions = {
  BaseExtension: BaseExtension2,
  AdditiveBlendExtension: AdditiveBlendExtension2,
  MaximumIntensityProjectionExtension: MaximumIntensityProjectionExtension2,
  MinimumIntensityProjectionExtension: MinimumIntensityProjectionExtension2
};

// node_modules/@deck.gl/layers/dist/bitmap-layer/create-mesh.js
var DEFAULT_INDICES = new Uint32Array([0, 2, 1, 0, 3, 2]);
var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex2 = 0;
  let index = 0;
  for (let u2 = 0; u2 < uCount; u2++) {
    const ut2 = u2 / (uCount - 1);
    for (let v2 = 0; v2 < vCount; v2++) {
      const vt = v2 / (vCount - 1);
      const p2 = interpolateQuad(bounds, ut2, vt);
      positions[vertex2 * 3 + 0] = p2[0];
      positions[vertex2 * 3 + 1] = p2[1];
      positions[vertex2 * 3 + 2] = p2[2] || 0;
      texCoords[vertex2 * 2 + 0] = ut2;
      texCoords[vertex2 * 2 + 1] = 1 - vt;
      if (u2 > 0 && v2 > 0) {
        indices[index++] = vertex2 - vCount;
        indices[index++] = vertex2 - vCount - 1;
        indices[index++] = vertex2 - 1;
        indices[index++] = vertex2 - vCount;
        indices[index++] = vertex2 - 1;
        indices[index++] = vertex2;
      }
      vertex2++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i3 = 0; i3 < bounds.length; i3++) {
    positions[i3 * 3 + 0] = bounds[i3][0];
    positions[i3 * 3 + 1] = bounds[i3][1];
    positions[i3 * 3 + 2] = bounds[i3][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut2, vt) {
  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut2);
}

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-uniforms.js
var uniformBlock5 = `uniform bitmapUniforms {
  vec4 bounds;
  float coordinateConversion;
  float desaturate;
  vec3 tintColor;
  vec4 transparentColor;
} bitmap;
`;
var bitmapUniforms = {
  name: "bitmap",
  vs: uniformBlock5,
  fs: uniformBlock5,
  uniformTypes: {
    bounds: "vec4<f32>",
    coordinateConversion: "f32",
    desaturate: "f32",
    tintColor: "vec3<f32>",
    transparentColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (bitmap.coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project.commonOrigin.xy;
  } else if (bitmap.coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-fragment.js
var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
var bitmap_layer_fragment_default = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), bitmap.desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * bitmap.tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (bitmap.transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),
    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (bitmap.coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (bitmap.coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer.js
var defaultProps4 = {
  image: { type: "image", value: null, async: true },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  desaturate: { type: "number", min: 0, max: 1, value: 0 },
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: { type: "color", value: [0, 0, 0, 0] },
  tintColor: { type: "color", value: [255, 255, 255] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var BitmapLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default, bitmapUniforms] });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(["instancePickingColors"]);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: (attribute) => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        update: (attribute) => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: (attribute) => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }
  updateState({ props, oldProps, changeFlags }) {
    const attributeManager = this.getAttributeManager();
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;
      const mesh = this._createMesh();
      this.state.model.setVertexCount(mesh.vertexCount);
      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }
      this.setState({ mesh, ...this._getCoordinateUniforms() });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }
  getPickingInfo(params) {
    const { image } = this.props;
    const info = params.info;
    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }
    const { width, height } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    info.bitmap = {
      size: { width, height },
      uv,
      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
    };
    return info;
  }
  // Override base Layer multi-depth picking logic
  disablePickingIndex() {
    this.setState({ disablePicking: true });
  }
  restorePickingColors() {
    this.setState({ disablePicking: false });
  }
  _updateAutoHighlight(info) {
    super._updateAutoHighlight({
      ...info,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const { bounds } = this.props;
    let normalizedBounds = bounds;
    if (isRectangularBounds(bounds)) {
      normalizedBounds = [
        [bounds[0], bounds[1]],
        [bounds[0], bounds[3]],
        [bounds[2], bounds[3]],
        [bounds[2], bounds[1]]
      ];
    }
    return createMesh(normalizedBounds, this.context.viewport.resolution);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-list",
      isInstanced: false
    });
  }
  draw(opts) {
    const { shaderModuleProps } = opts;
    const { model, coordinateConversion, bounds, disablePicking } = this.state;
    const { image, desaturate, transparentColor, tintColor } = this.props;
    if (shaderModuleProps.picking.isActive && disablePicking) {
      return;
    }
    if (image && model) {
      const bitmapProps = {
        bitmapTexture: image,
        bounds,
        coordinateConversion,
        desaturate,
        tintColor: tintColor.slice(0, 3).map((x2) => x2 / 255),
        transparentColor: transparentColor.map((x2) => x2 / 255)
      };
      model.shaderInputs.setProps({ bitmap: bitmapProps });
      model.draw(this.context.renderPass);
    }
  }
  _getCoordinateUniforms() {
    const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
    let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
    if (imageCoordinateSystem !== DEFAULT) {
      const { bounds } = this.props;
      if (!isRectangularBounds(bounds)) {
        throw new Error("_imageCoordinateSystem only supports rectangular bounds");
      }
      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return { coordinateConversion: -1, bounds };
      }
      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
        const topRight = lngLatToWorld([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
};
BitmapLayer.layerName = "BitmapLayer";
BitmapLayer.defaultProps = defaultProps4;
var bitmap_layer_default = BitmapLayer;
function unpackUVsFromRGB(color) {
  const [u2, v2, fracUV] = color;
  const vFrac = (fracUV & 240) / 256;
  const uFrac = (fracUV & 15) / 16;
  return [(u2 + uFrac) / 256, (v2 + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-uniforms.js
var uniformBlock6 = `uniform iconUniforms {
  float sizeScale;
  vec2 iconsTextureDim;
  float sizeMinPixels;
  float sizeMaxPixels;
  bool billboard;
  highp int sizeUnits;
  float alphaCutoff;
} icon;
`;
var iconUniforms = {
  name: "icon",
  vs: uniformBlock6,
  fs: uniformBlock6,
  uniformTypes: {
    sizeScale: "f32",
    iconsTextureDim: "vec2<f32>",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    billboard: "f32",
    sizeUnits: "i32",
    alphaCutoff: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),
icon.sizeMinPixels, icon.sizeMaxPixels
);
float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (icon.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / icon.iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * layer.opacity * vColor.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-manager.js
var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;
var noop4 = () => {
};
var DEFAULT_SAMPLER_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  // LINEAR is the default value but explicitly set it here
  magFilter: "linear",
  // minimize texture boundary artifacts
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
var MISSING_ICON = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx2, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return { image: imageData, width, height };
  }
  ctx2.canvas.height = height;
  ctx2.canvas.width = width;
  ctx2.clearRect(0, 0, width, height);
  ctx2.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return { image: ctx2.canvas, width, height };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, sampler) {
  const { width: oldWidth, height: oldHeight, device } = texture;
  const newTexture = device.createTexture({
    format: "rgba8unorm",
    width,
    height,
    sampler,
    mipmaps: true
  });
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyTextureToTexture({
    sourceTexture: texture,
    destinationTexture: newTexture,
    width: oldWidth,
    height: oldHeight
  });
  commandEncoder.finish();
  texture.destroy();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i3 = 0; i3 < columns.length; i3++) {
    const { icon, xOffset } = columns[i3];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({ icons, buffer, mapping = {}, xOffset = 0, yOffset = 0, rowHeight = 0, canvasWidth }) {
  let columns = [];
  for (let i3 = 0; i3 < icons.length; i3++) {
    const icon = icons[i3];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const { height, width } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const { iterable, objectInfo } = createIterable(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index };
    }
  }
  return icons;
}
var IconManager = class {
  constructor(device, { onUpdate = noop4, onError = noop4 }) {
    this._loadOptions = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._samplerParameters = null;
    this._pendingCount = 0;
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._rowHeight = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
    this.device = device;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    this._texture?.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || MISSING_ICON;
  }
  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, textureParameters }) {
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== void 0) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      this._texture?.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._samplerParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    if (!this._autoPacking || typeof document === "undefined") {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = this.device.createTexture({
          format: "rgba8unorm",
          width: this._canvasWidth,
          height: this._canvasHeight,
          sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,
          mipmaps: true
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement("canvas");
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx2 = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      load2(icon.url, this._loadOptions).then((imageData) => {
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const { x: x2, y: y2, width: maxWidth, height: maxHeight } = iconDef;
        const { image, width, height } = resizeImage(ctx2, imageData, maxWidth, maxHeight);
        this._texture?.copyExternalImage({
          image,
          x: x2 + (maxWidth - width) / 2,
          y: y2 + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch((error) => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer.js
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps5 = {
  iconAtlas: { type: "image", value: null, async: true },
  iconMapping: { type: "object", value: {}, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  billboard: true,
  sizeUnits: "pixels",
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getIcon: { type: "accessor", value: (x2) => x2.icon },
  getColor: { type: "accessor", value: DEFAULT_COLOR },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  onIconError: { type: "function", value: null, optional: true },
  textureParameters: { type: "object", ignore: true, value: null }
};
var IconLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: icon_layer_vertex_glsl_default, fs: icon_layer_fragment_glsl_default, modules: [project32_default, picking_default, iconUniforms] });
  }
  initializeState() {
    this.state = {
      iconManager: new IconManager(this.context.device, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: "uint8",
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      }
    });
  }
  /* eslint-disable max-statements, complexity */
  updateState(params) {
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
    const { iconManager } = this.state;
    if (typeof iconAtlas === "string") {
      return;
    }
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate("getIcon");
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  /* eslint-enable max-statements, complexity */
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({ uniforms }) {
    const { sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
    const { iconManager } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      const model = this.state.model;
      const iconProps = {
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      };
      model.shaderInputs.setProps({ icon: iconProps });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          // The size must be explicitly passed here otherwise luma.gl
          // will default to assuming that positions are 3D (x,y,z)
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    const onIconError = this.getCurrentLayer()?.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      log_default.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const { width, height, anchorX = width / 2, anchorY = height / 2 } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const { x: x2, y: y2, width, height } = this.state.iconManager.getIconMapping(icon);
    return [x2, y2, width, height];
  }
};
IconLayer.defaultProps = defaultProps5;
IconLayer.layerName = "IconLayer";
var icon_layer_default = IconLayer;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-uniforms.js
var uniformBlockWGSL = (
  /* wgsl */
  `struct LineUniforms {
  widthScale: f32,
  widthMinPixels: f32,
  widthMaxPixels: f32,
  useShortestPath: f32,
  widthUnits: i32,
};

@group(0) @binding(1)
var<uniform> line: LineUniforms;
`
);
var uniformBlockGLSL = (
  /* glsl */
  `uniform lineUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float useShortestPath;
  highp int widthUnits;
} line;
`
);
var lineUniforms = {
  name: "line",
  source: uniformBlockWGSL,
  vs: uniformBlockGLSL,
  fs: uniformBlockGLSL,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    useShortestPath: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.wgsl.js
var shaderWGSL = (
  /* wgsl */
  `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)
struct LayerUniforms {
  opacity: f32,
};
var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// ---------- Helper Structures & Functions ----------

// Placeholder filter functions.
fn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {
  return offset;
}
fn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return p;
}
fn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return color;
}

// Compute an extrusion offset given a line direction (in clipspace),
// an offset direction (-1 or 1), and a width in pixels.
// Assumes a uniform "project" with a viewportSize field is available.
fn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {
  // project.viewportSize should be provided as a uniform (not shown here)
  let dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // Rotate by 90\xB0: (x,y) becomes (-y,x)
  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);
  return rotated * offset_direction * width / 2.0;
}

// Splits the line between two points at a given x coordinate.
// Interpolates the y and z components.
fn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {
  let t: f32 = (x - a.x) / (b.x - a.x);
  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));
}

// ---------- Uniforms & Global Structures ----------

// Uniforms for line, layer, and project are assumed to be defined elsewhere.
// For example:
//
// @group(0) @binding(0)
// var<uniform> line: LineUniform;
//
// struct LayerUniform {
//   opacity: f32,
// };
// @group(0) @binding(1)
// var<uniform> layer: LayerUniform;
//
// struct ProjectUniform {
//   viewportSize: vec2<f32>,
// };
// @group(0) @binding(2)
// var<uniform> project: ProjectUniform;



// ---------- Vertex Output Structure ----------

struct Varyings {
  @builtin(position) gl_Position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>,
};

// ---------- Vertex Shader Entry Point ----------

@vertex
fn vertexMain(
  @location(0) positions: vec3<f32>,
  @location(1) instanceSourcePositions: vec3<f32>,
  @location(2) instanceTargetPositions: vec3<f32>,
  @location(3) instanceSourcePositions64Low: vec3<f32>,
  @location(4) instanceTargetPositions64Low: vec3<f32>,
  @location(5) instanceColors: vec4<f32>,
  @location(6) instancePickingColors: vec3<f32>,
  @location(7) instanceWidths: f32
) -> Varyings {
  var geometry: Geometry;
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  var source_world: vec3<f32> = instanceSourcePositions;
  var target_world: vec3<f32> = instanceTargetPositions;
  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;
  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;

  // Apply shortest-path adjustments if needed.
  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;
    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;
    let deltaLng: f32 = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.0) {
      source_world.x = source_world.x + 360.0 * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (deltaLng * line.useShortestPath < -180.0) {
      target_world.x = target_world.x + 360.0 * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (line.useShortestPath < 0.0) {
      var abortOut: Varyings;
      abortOut.gl_Position = vec4<f32>(0.0);
      abortOut.vColor = vec4<f32>(0.0);
      abortOut.uv = vec2<f32>(0.0);
      return abortOut;
    }
  }

  // Project Pos and target positions to clip space.
  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));
  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));
  let sourcePos: vec4<f32> = sourceResult.clipPosition;
  let targetPos: vec4<f32> = targetResult.clipPosition;
  let source_commonspace: vec4<f32> = sourceResult.commonPosition;
  let target_commonspace: vec4<f32> = targetResult.commonPosition;

  // Interpolate along the line segment.
  let segmentIndex: f32 = positions.x;
  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);
  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);
  let uv: vec2<f32> = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Determine width in pixels.
  let widthPixels: f32 = clamp(
    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // Compute extrusion offset.
  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);
  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);

  // Apply deck.gl filter functions.
  let filteredOffset = deckgl_filter_size(offset, geometry);
  let filteredP = deckgl_filter_gl_position(p, geometry);

  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);
  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);

  // Compute color.
  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * layer.opacity);
  // vColor = deckgl_filter_color(vColor, geometry);

  var output: Varyings;
  output.gl_Position = finalPosition;
  output.vColor = vColor;
  output.uv = uv;
  return output;
}

@fragment
fn fragmentMain(
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>
) -> @location(0) vec4<f32> {
  // Create and initialize geometry with the provided uv.
  var geometry: Geometry;
  geometry.uv = uv;

  // Start with the input color.
  var fragColor: vec4<f32> = vColor;

  // Apply the deck.gl filter to the color.
  fragColor = deckgl_filter_color(fragColor, geometry);

  return fragColor;
}
`
);

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * line.useShortestPath > 180.) {
source_world.x += 360. * line.useShortestPath;
source_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * line.useShortestPath < -180.) {
target_world.x += 360. * line.useShortestPath;
target_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
target_world_64low = vec3(0.0);
} else if (line.useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
line.widthMinPixels, line.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.js
var DEFAULT_COLOR2 = [0, 0, 0, 255];
var defaultProps6 = {
  getSourcePosition: { type: "accessor", value: (x2) => x2.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x2) => x2.targetPosition },
  getColor: { type: "accessor", value: DEFAULT_COLOR2 },
  getWidth: { type: "accessor", value: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var LineLayer = class extends layer_default {
  getBounds() {
    return this.getAttributeManager()?.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: line_layer_vertex_glsl_default, fs: line_layer_fragment_glsl_default, source: shaderWGSL, modules: [project32_default, picking_default, lineUniforms] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
    const model = this.state.model;
    const lineProps = {
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    };
    model.shaderInputs.setProps({ line: lineProps });
    model.draw(this.context.renderPass);
    if (wrapLongitude) {
      model.shaderInputs.setProps({ line: { ...lineProps, useShortestPath: -1 } });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
LineLayer.layerName = "LineLayer";
LineLayer.defaultProps = defaultProps6;
var line_layer_default = LineLayer;

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-uniforms.js
var glslUniformBlock = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`;
var scatterplotUniforms = {
  name: "scatterplot",
  vs: glslUniformBlock,
  fs: glslUniformBlock,
  source: "",
  uniformTypes: {
    radiusScale: "f32",
    radiusMinPixels: "f32",
    radiusMaxPixels: "f32",
    lineWidthScale: "f32",
    lineWidthMinPixels: "f32",
    lineWidthMaxPixels: "f32",
    stroked: "f32",
    filled: "f32",
    antialiasing: "f32",
    billboard: "f32",
    radiusUnits: "i32",
    lineWidthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.wgsl.js
var scatterplot_layer_wgsl_default = (
  /* wgsl */
  `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)

struct LayerUniforms {
  opacity: f32,
};

var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    // discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        // discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    // discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR3 = [0, 0, 0, 255];
var defaultProps7 = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR3 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR3 },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var ScatterplotLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({
      vs: scatterplot_layer_vertex_glsl_default,
      fs: scatterplot_layer_fragment_glsl_default,
      source: scatterplot_layer_wgsl_default,
      modules: [project32_default, picking_default, scatterplotUniforms]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;
    const scatterplotProps = {
      stroked,
      filled,
      billboard,
      antialiasing,
      radiusUnits: UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    };
    const model = this.state.model;
    model.shaderInputs.setProps({ scatterplot: scatterplotProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
ScatterplotLayer.defaultProps = defaultProps7;
ScatterplotLayer.layerName = "ScatterplotLayer";
var scatterplot_layer_default = ScatterplotLayer;

// node_modules/@math.gl/polygon/dist/polygon-utils.js
var WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
var DimIndex = {
  x: 0,
  y: 1,
  z: 2
};
function getPolygonSignedArea(points, options = {}) {
  const { start = 0, end = points.length, plane = "xy" } = options;
  const dim = options.size || 2;
  let area = 0;
  const i0 = DimIndex[plane[0]];
  const i1 = DimIndex[plane[1]];
  for (let i3 = start, j2 = end - dim; i3 < end; i3 += dim) {
    area += (points[i3 + i0] - points[j2 + i0]) * (points[i3 + i1] + points[j2 + i1]);
    j2 = i3;
  }
  return area / 2;
}
function reversePolygon(points, options) {
  const { start = 0, end = points.length, size = 2 } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i3 = 0; i3 < numSwaps; ++i3) {
    const b1 = start + i3 * size;
    const b2 = start + (numPoints - 1 - i3) * size;
    for (let j2 = 0; j2 < size; ++j2) {
      const tmp = points[b1 + j2];
      points[b1 + j2] = points[b2 + j2];
      points[b2 + j2] = tmp;
    }
  }
}

// node_modules/@math.gl/polygon/dist/utils.js
function push(target2, source3) {
  const size = source3.length;
  const startIndex = target2.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i3 = 0; i3 < size; i3++) {
      if (target2[startIndex - size + i3] !== source3[i3]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i3 = 0; i3 < size; i3++) {
    target2[startIndex + i3] = source3[i3];
  }
  return true;
}
function copy5(target2, source3) {
  const size = source3.length;
  for (let i3 = 0; i3 < size; i3++) {
    target2[i3] = source3[i3];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i3 = 0; i3 < size; i3++) {
    out[i3] = positions[startI + i3];
  }
  return out;
}

// node_modules/@math.gl/polygon/dist/lineclip.js
function intersect(a2, b2, edge, bbox, out = []) {
  let t2;
  let snap;
  if (edge & 8) {
    t2 = (bbox[3] - a2[1]) / (b2[1] - a2[1]);
    snap = 3;
  } else if (edge & 4) {
    t2 = (bbox[1] - a2[1]) / (b2[1] - a2[1]);
    snap = 1;
  } else if (edge & 2) {
    t2 = (bbox[2] - a2[0]) / (b2[0] - a2[0]);
    snap = 2;
  } else if (edge & 1) {
    t2 = (bbox[0] - a2[0]) / (b2[0] - a2[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i3 = 0; i3 < a2.length; i3++) {
    out[i3] = (snap & 1) === i3 ? bbox[snap] : t2 * (b2[i3] - a2[i3]) + a2[i3];
  }
  return out;
}
function bitCode(p2, bbox) {
  let code = 0;
  if (p2[0] < bbox[0])
    code |= 1;
  else if (p2[0] > bbox[2])
    code |= 2;
  if (p2[1] < bbox[1])
    code |= 4;
  else if (p2[1] > bbox[3])
    code |= 8;
  return code;
}

// node_modules/@math.gl/polygon/dist/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a2 = getPointAtIndex(positions, 0, size, startIndex);
  let b2;
  let codeB;
  const cell = getGridCell(a2, gridResolution, gridOffset, []);
  const scratchPoint = [];
  push(part, a2);
  for (let i3 = 1; i3 < numPoints; i3++) {
    b2 = getPointAtIndex(positions, i3, size, startIndex, b2);
    codeB = bitCode(b2, cell);
    while (codeB) {
      intersect(a2, b2, codeB, cell, scratchPoint);
      const codeAlt = bitCode(scratchPoint, cell);
      if (codeAlt) {
        intersect(a2, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      push(part, scratchPoint);
      copy5(a2, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a2);
      }
      codeB = bitCode(b2, cell);
    }
    push(part, b2);
    copy5(a2, b2);
  }
  return broken ? result : result[0];
}
var TYPE_INSIDE = 0;
var TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
  const result = [];
  const queue = [
    {
      pos: positions,
      types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
      holes: holeIndices || []
    }
  ];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const { pos, types, holes } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
      const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
      queue.push(polygonLow, polygonHigh);
      for (let i3 = 0; i3 < holes.length; i3++) {
        parts = bisectPolygon(pos, types, size, holes[i3], holes[i3 + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = { positions: pos };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p2;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i3 = 0; i3 < numPoints; i3++) {
    p2 = getPointAtIndex(positions, i3, size, startIndex, p2);
    side = Math.sign(edge & 8 ? p2[1] - bbox[3] : p2[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i3];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p2, edge, bbox, scratchPoint);
      push(resultLow, scratchPoint) && typesLow.push(prevType);
      push(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p2) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p2) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy5(prev, p2);
    prevSide = side;
    prevType = type;
  }
  return [
    lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
    highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
  ];
}
function getGridCell(p2, gridResolution, gridOffset, out) {
  const left = Math.floor((p2[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p2[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i3 = 0; i3 < endIndex; i3 += size) {
    const x2 = positions[i3];
    const y2 = positions[i3 + 1];
    minX = x2 < minX ? x2 : minX;
    maxX = x2 > maxX ? x2 : maxX;
    minY = y2 < minY ? y2 : minY;
    maxY = y2 > maxY ? y2 : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
function concatInPlace(arr1, arr2) {
  for (let i3 = 0; i3 < arr2.length; i3++) {
    arr1.push(arr2[i3]);
  }
  return arr1;
}

// node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
var DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize6 = true } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize6) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const { size = 2, normalize: normalize6 = true, edgeTypes = false } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i3 = splitIndex; i3 < srcEndIndex; i3++) {
      newPositions[targetIndex++] = positions[i3];
    }
    for (let i3 = srcStartIndex; i3 < splitIndex; i3++) {
      newPositions[targetIndex++] = positions[i3];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize6) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i3 = startIndex + 1; i3 < endIndex; i3 += size) {
    const lat = Math.abs(positions[i3]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i3 - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p2 = getPointAtIndex(positions, 0, size, startIndex);
    p2[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p2);
    p2[1] = Math.sign(p2[1]) * maxLatitude;
    push(positions, p2);
    p2[0] = firstLng;
    push(positions, p2);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i3 = startIndex; i3 < endIndex; i3 += size) {
    lng = positions[i3];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i3] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i3 = 0; i3 < pointCount; i3++) {
    refLng = positions[i3 * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i3 = 0; i3 < pointCount; i3++) {
    positions[i3 * size] += delta;
  }
}

// node_modules/@deck.gl/layers/dist/path-layer/path.js
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length5 = path.length * size;
    flatPath = new Array(length5);
    for (let i3 = 0; i3 < path.length; i3++) {
      for (let j2 = 0; j2 < size; j2++) {
        flatPath[i3 * size + j2] = path[i3][j2] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, { size, gridResolution });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, { size });
  }
  return flatPath;
}

// node_modules/@deck.gl/layers/dist/path-layer/path-tesselator.js
var START_CAP = 1;
var END_CAP = 2;
var INVALID2 = 4;
var PathTesselator = class extends Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        // Padding covers shaderAttributes for last segment in largest case fp64
        // additional vertex + hi & low parts, 3 * 6
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: { size: 1, type: Uint8ClampedArray }
      }
    });
  }
  /** Get packed attribute by name */
  get(attributeName) {
    return this.attributes[attributeName];
  }
  /* Implement base Tesselator interface */
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /* Implement base Tesselator interface */
  normalizeGeometry(path) {
    if (this.normalize) {
      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  /* Implement base Tesselator interface */
  getGeometrySize(path) {
    if (isCut(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  /* Implement base Tesselator interface */
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const { vertexStart, geometrySize } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID2;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID2;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID2;
  }
  _updatePositions(path, context) {
    const { positions } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const { vertexStart, geometrySize } = context;
    const p2 = new Array(3);
    for (let i3 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i3++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p2);
      positions[i3 * 3] = p2[0];
      positions[i3 * 3 + 1] = p2[1];
      positions[i3 * 3 + 2] = p2[2];
    }
  }
  // Utilities
  /** Returns the number of points in the path */
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  /** Returns a point on the path at the specified index */
  getPointOnPath(path, index, target2 = []) {
    const { positionSize } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i3 = index * positionSize;
    target2[0] = path[i3];
    target2[1] = path[i3 + 1];
    target2[2] = positionSize === 3 && path[i3 + 2] || 0;
    return target2;
  }
  // Returns true if the first and last points are identical
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const { positionSize } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
};
function isCut(path) {
  return Array.isArray(path[0]);
}

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-uniforms.js
var uniformBlock7 = `uniform pathUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float jointType;
  float capType;
  float miterLimit;
  bool billboard;
  highp int widthUnits;
} path;
`;
var pathUniforms = {
  name: "path",
  vs: uniformBlock7,
  fs: uniformBlock7,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    jointType: "f32",
    capType: "f32",
    miterLimit: "f32",
    billboard: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = path.capType;
} else {
vJointType = path.jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),
path.widthMinPixels, path.widthMaxPixels) / 2.0);
vec3 width;
if (path.billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer.js
var DEFAULT_COLOR4 = [0, 0, 0, 255];
var defaultProps8 = {
  widthUnits: "meters",
  widthScale: { type: "number", min: 0, value: 1 },
  widthMinPixels: { type: "number", min: 0, value: 0 },
  widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  jointRounded: false,
  capRounded: false,
  miterLimit: { type: "number", min: 0, value: 4 },
  billboard: false,
  _pathType: null,
  getPath: { type: "accessor", value: (object) => object.path },
  getColor: { type: "accessor", value: DEFAULT_COLOR4 },
  getWidth: { type: "accessor", value: 1 },
  // deprecated props
  rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
};
var ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var PathLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: path_layer_vertex_glsl_default, fs: path_layer_fragment_glsl_default, modules: [project32_default, picking_default, pathUniforms] });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      vertexPositions: {
        size: 3,
        // Start filling buffer from 1 vertex in
        vertexOffset: 1,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getPath",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: "uint8",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        accessor: "getColor",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR4
      },
      instancePickingColors: {
        size: 4,
        type: "uint8",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new PathTesselator({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const { pathTesselator } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === "loop",
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d2) => d2.__source.index === index);
    }
    return info;
  }
  /** Override base Layer method */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i3 = 0; i3 < data.length; i3++) {
        if (data[i3].__source.index === objectIndex) {
          this._disablePickingIndex(i3);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { jointRounded, capRounded, billboard, miterLimit, widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
    const model = this.state.model;
    const pathProps = {
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    };
    model.shaderInputs.setProps({ path: pathProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const SEGMENT_INDICES = [
      // start corner
      0,
      1,
      2,
      // body
      1,
      4,
      2,
      1,
      3,
      4,
      // end corner
      3,
      5,
      4
    ];
    const SEGMENT_POSITIONS = [
      // bevel start corner
      0,
      0,
      // start inner corner
      0,
      -1,
      // start outer corner
      0,
      1,
      // end inner corner
      1,
      -1,
      // end outer corner
      1,
      1,
      // bevel end corner
      1,
      0
    ];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("positions");
  }
  calculateSegmentTypes(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("segmentTypes");
  }
};
PathLayer.defaultProps = defaultProps8;
PathLayer.layerName = "PathLayer";
var path_layer_default = PathLayer;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon.js
var import_earcut2 = __toESM(require_earcut(), 1);
var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
var windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i3 = 0; i3 < size; i3++) {
    if (positions[startIndex + i3] !== positions[endIndex - size + i3]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target2, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len4 = simplePolygon.length;
  for (let i3 = 0; i3 < len4; i3++) {
    for (let j2 = 0; j2 < size; j2++) {
      target2[targetIndex++] = simplePolygon[i3][j2] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j2 = 0; j2 < size; j2++) {
      target2[targetIndex++] = simplePolygon[0][j2] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target2, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target2, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i3 = 0; i3 < srcLength; i3++) {
    target2[targetIndex++] = positions[srcStartIndex + i3];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i3 = 0; i3 < size; i3++) {
      target2[targetIndex++] = positions[srcStartIndex + i3];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target2, windingDirection, windingOptions);
  return targetIndex;
}
function normalize5(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i3 = 0; i3 <= srcHoleIndices.length; i3++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i3 - 1], srcHoleIndices[i3], i3 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return { positions, holeIndices };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area = 0;
  for (let i3 = 0; i3 < numVerts; i3++) {
    const j2 = (i3 + 1) % numVerts;
    area += positions[i3 * 3 + xIndex] * positions[j2 * 3 + yIndex];
    area -= positions[j2 * 3 + xIndex] * positions[i3 * 3 + yIndex];
  }
  return Math.abs(area / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i3 = 0; i3 < numVerts; i3++) {
    const o3 = i3 * 3;
    const x2 = positions[o3 + 0];
    const y2 = positions[o3 + 1];
    const z2 = positions[o3 + 2];
    positions[o3 + xIndex] = x2;
    positions[o3 + yIndex] = y2;
    positions[o3 + zIndex] = z2;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n2 = positions.length;
    positions = positions.slice();
    const p2 = [];
    for (let i3 = 0; i3 < n2; i3 += positionSize) {
      p2[0] = positions[i3];
      p2[1] = positions[i3 + 1];
      if (is3d) {
        p2[2] = positions[i3 + 2];
      }
      const xy = preproject(p2);
      positions[i3] = xy[0];
      positions[i3 + 1] = xy[1];
      if (is3d) {
        positions[i3 + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {
    } else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 2, 0, 1);
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon-tesselator.js
var PolygonTesselator = class extends Tesselator {
  constructor(opts) {
    const { fp64: fp642, IndexType = Uint32Array } = opts;
    super({
      ...opts,
      attributes: {
        positions: { size: 3, type: fp642 ? Float64Array : Float32Array },
        vertexValid: { type: Uint16Array, size: 1 },
        indices: { type: IndexType, size: 1 }
      }
    });
  }
  /** Get attribute by name */
  get(attributeName) {
    const { attributes } = this;
    if (attributeName === "indices") {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  /** Override base Tesselator method */
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error("missing indices buffer");
    }
  }
  /** Implement base Tesselator interface */
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = normalize5(polygon, this.positionSize);
      if (this.opts.resolution) {
        return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  /** Implement base Tesselator interface */
  getGeometrySize(polygon) {
    if (isCut2(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return getPositions(polygon).length / this.positionSize;
  }
  /** Override base Tesselator method */
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /** Implement base Tesselator interface */
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut2(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      const normalizedPolygon = polygon;
      this._updateIndices(normalizedPolygon, context);
      this._updatePositions(normalizedPolygon, context);
      this._updateVertexValid(normalizedPolygon, context);
    }
  }
  // Flatten the indices array
  _updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
    const { attributes, indexStarts, typedArrayManager } = this;
    let target2 = attributes.indices;
    if (!target2 || !polygon) {
      return;
    }
    let i3 = indexStart;
    const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target2 = typedArrayManager.allocate(target2, indexStart + indices.length, {
      copy: true
    });
    for (let j2 = 0; j2 < indices.length; j2++) {
      target2[i3++] = indices[j2] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target2;
  }
  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(polygon, { vertexStart, geometrySize }) {
    const { attributes: { positions }, positionSize } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = getPositions(polygon);
    for (let i3 = vertexStart, j2 = 0; j2 < geometrySize; i3++, j2++) {
      const x2 = polygonPositions[j2 * positionSize];
      const y2 = polygonPositions[j2 * positionSize + 1];
      const z2 = positionSize > 2 ? polygonPositions[j2 * positionSize + 2] : 0;
      positions[i3 * 3] = x2;
      positions[i3 * 3 + 1] = y2;
      positions[i3 * 3 + 2] = z2;
    }
  }
  _updateVertexValid(polygon, { vertexStart, geometrySize }) {
    const { positionSize } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j2 = 0; j2 < holeIndices.length; j2++) {
        vertexValid[vertexStart + holeIndices[j2] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
};
function isCut2(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-uniforms.js
var uniformBlock8 = `uniform solidPolygonUniforms {
  bool extruded;
  bool isWireframe;
  float elevationScale;
} solidPolygon;
`;
var solidPolygonUniforms = {
  name: "solidPolygon",
  vs: uniformBlock8,
  fs: uniformBlock8,
  uniformTypes: {
    extruded: "f32",
    isWireframe: "f32",
    elevationScale: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default = `in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project.commonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (solidPolygon.extruded) {
pos.z += props.elevations * solidPolygon.elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (solidPolygon.extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * layer.opacity);
} else {
vColor = vec4(colors.rgb, colors.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR5 = [0, 0, 0, 255];
var defaultProps9 = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  _full3d: false,
  elevationScale: { type: "number", min: 0, value: 1 },
  getPolygon: { type: "accessor", value: (f2) => f2.polygon },
  getElevation: { type: "accessor", value: 1e3 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR5 },
  material: true
};
var ATTRIBUTE_TRANSITION2 = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var SolidPolygonLayer = class extends layer_default {
  getShaders(type) {
    return super.getShaders({
      vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
      fs: solid_polygon_layer_fragment_glsl_default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [project32_default, gouraudMaterial, picking_default, solidPolygonUniforms]
    });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const { viewport } = this.context;
    let { coordinateSystem } = this.props;
    const { _full3d } = this.props;
    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new PolygonTesselator({
        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
        // Provide a preproject function if the coordinates are in lnglat
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: Uint32Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(["instancePickingColors"]);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateIndices,
        noAlloc
      },
      vertexPositions: {
        size: 3,
        type: "float64",
        stepMode: "dynamic",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getPolygon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          nextVertexPositions: {
            vertexOffset: 1
          }
        }
      },
      instanceVertexValid: {
        size: 1,
        type: "uint16",
        stepMode: "instance",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getElevation"
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR5
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR5
      },
      pickingColors: {
        size: 4,
        type: "uint8",
        stepMode: "dynamic",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d2) => d2.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i3 = 0; i3 < data.length; i3++) {
        if (data[i3].__source.index === objectIndex) {
          this._disablePickingIndex(i3);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { extruded, filled, wireframe, elevationScale } = this.props;
    const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
    const renderUniforms = {
      extruded: Boolean(extruded),
      elevationScale,
      isWireframe: false
    };
    if (wireframeModel && wireframe) {
      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      wireframeModel.shaderInputs.setProps({ solidPolygon: { ...renderUniforms, isWireframe: true } });
      wireframeModel.draw(this.context.renderPass);
    }
    if (sideModel && filled) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      sideModel.draw(this.context.renderPass);
    }
    if (topModel && filled) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      topModel.draw(this.context.renderPass);
    }
  }
  updateState(updateParams) {
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const { props, oldProps, changeFlags } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      this.state.models?.forEach((model) => model.destroy());
      this.setState(this._getModels());
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({ props, oldProps, changeFlags }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const { polygonTesselator } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels() {
    const { id, filled, extruded } = this.props;
    let topModel;
    let sideModel;
    let wireframeModel;
    if (filled) {
      const shaders = this.getShaders("top");
      shaders.defines.NON_INSTANCED_MODEL = 1;
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: false });
      topModel = new Model(this.context.device, {
        ...shaders,
        id: `${id}-top`,
        topology: "triangle-list",
        bufferLayout,
        isIndexed: true,
        userData: {
          excludeAttributes: { instanceVertexValid: true }
        }
      });
    }
    if (extruded) {
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: true });
      sideModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-side`,
        bufferLayout,
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            // top right - top left - bottom right - bottom left
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
      wireframeModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-wireframe`,
        bufferLayout,
        geometry: new Geometry({
          topology: "line-strip",
          attributes: {
            // top right - top left - bottom left - bottom right
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
    }
    return {
      models: [sideModel, wireframeModel, topModel].filter(Boolean),
      topModel,
      sideModel,
      wireframeModel
    };
  }
  calculateIndices(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get("indices");
  }
  calculatePositions(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get("positions");
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get("vertexValid");
  }
};
SolidPolygonLayer.defaultProps = defaultProps9;
SolidPolygonLayer.layerName = "SolidPolygonLayer";
var solid_polygon_layer_default = SolidPolygonLayer;

// node_modules/@deck.gl/layers/dist/utils.js
function replaceInRange({ data, getIndex, dataRange, replace }) {
  const { startRow = 0, endRow = Infinity } = dataRange;
  const count2 = data.length;
  let replaceStart = count2;
  let replaceEnd = count2;
  for (let i3 = 0; i3 < count2; i3++) {
    const row = getIndex(data[i3]);
    if (replaceStart > i3 && row >= startRow) {
      replaceStart = i3;
    }
    if (row >= endRow) {
      replaceEnd = i3;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
  for (let i3 = 0; i3 < replace.length; i3++) {
    data[index++] = replace[i3];
  }
  if (endChunk) {
    for (let i3 = 0; i3 < endChunk.length; i3++) {
      data[index++] = endChunk[i3];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}

// node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js
var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultProps10 = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: { type: "accessor", value: (f2) => f2.polygon },
  // Polygon fill color
  getFillColor: { type: "accessor", value: defaultFillColor },
  // Point, line and polygon outline color
  getLineColor: { type: "accessor", value: defaultLineColor },
  // Line and polygon outline accessors
  getLineWidth: { type: "accessor", value: 1 },
  // Polygon extrusion accessor
  getElevation: { type: "accessor", value: 1e3 },
  // Optional material for 'lighting' shader module
  material: true
};
var PolygonLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      paths: [],
      pathsDiff: null
    };
    if (this.props.getLineDashArray) {
      log_default.removed("getLineDashArray", "PathStyleExtension")();
    }
  }
  updateState({ changeFlags }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
        data: paths,
        getIndex: (p2) => p2.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({ paths, pathsDiff });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const { data, getPolygon, positionFormat, _normalize } = this.props;
    const paths = [];
    const positionSize = positionFormat === "XY" ? 2 : 3;
    const { startRow, endRow } = dataRange;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);
      if (_normalize) {
        polygon = normalize5(polygon, positionSize);
      }
      const { holeIndices } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i3 = 0; i3 <= holeIndices.length; i3++) {
          const path = positions.slice(holeIndices[i3 - 1] || 0, holeIndices[i3] || positions.length);
          paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
      }
    }
    return paths;
  }
  /* eslint-disable complexity */
  renderLayers() {
    const { data, _dataDiff, stroked, filled, extruded, wireframe, _normalize, _windingOrder, elevationScale, transitions, positionFormat } = this.props;
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified } = this.props;
    const { getFillColor, getLineColor, getLineWidth, getLineDashArray, getElevation, getPolygon, updateTriggers, material } = this.props;
    const { paths, pathsDiff } = this.state;
    const FillLayer = this.getSubLayerClass("fill", solid_polygon_layer_default);
    const StrokeLayer = this.getSubLayerClass("stroke", path_layer_default);
    const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: "fill",
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        // using a legacy API to invalid lineColor attributes
        // if (extruded && wireframe) has changed
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      // Already normalized
      _pathType: "loop",
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: "stroke",
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: (x2) => x2.path
    });
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer,
      polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer
    ];
  }
};
PolygonLayer.layerName = "PolygonLayer";
PolygonLayer.defaultProps = defaultProps10;
var polygon_layer_default = PolygonLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-binary.js
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: { ...data.properties[propertiesIndex] }
  };
  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 4);
    const pickingColor = [];
    for (let i3 = 0; i3 < featureIds.length; i3++) {
      encodePickingColor(featureIds[i3], pickingColor);
      pickingColors[key][i3 * 4 + 0] = pickingColor[0];
      pickingColors[key][i3 * 4 + 1] = pickingColor[1];
      pickingColors[key][i3 * 4 + 2] = pickingColor[2];
      pickingColors[key][i3 * 4 + 3] = 255;
    }
  }
  return pickingColors;
}

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/sdf-uniforms.js
var uniformBlock9 = `uniform sdfUniforms {
  float gamma;
  bool enabled;
  float buffer;
  float outlineBuffer;
  vec4 outlineColor;
} sdf;
`;
var sdfUniforms = {
  name: "sdf",
  vs: uniformBlock9,
  fs: uniformBlock9,
  uniformTypes: {
    gamma: "f32",
    enabled: "f32",
    buffer: "f32",
    outlineBuffer: "f32",
    outlineColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf.enabled) {
float distance = alpha;
alpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);
if (sdf.outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);
color = mix(sdf.outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * layer.opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER2 = 192 / 256;
var EMPTY_ARRAY3 = [];
var defaultProps11 = {
  getIconOffsets: { type: "accessor", value: (x2) => x2.offsets },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: { type: "color", value: [0, 0, 0, 255] }
};
var MultiIconLayer = class extends icon_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    return { ...shaders, modules: [...shaders.modules, sdfUniforms], fs: multi_icon_layer_fragment_glsl_default };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: "uint8",
        size: 3,
        accessor: (object, { index, target: value }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    let { outlineColor } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map((x2) => x2 / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
    }
  }
  draw(params) {
    const { sdf, smoothing, outlineWidth } = this.props;
    const { outlineColor } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
    const model = this.state.model;
    const sdfProps = {
      buffer: DEFAULT_BUFFER2,
      outlineBuffer,
      gamma: smoothing,
      enabled: Boolean(sdf),
      outlineColor
    };
    model.shaderInputs.setProps({ sdf: sdfProps });
    super.draw(params);
    if (sdf && outlineWidth) {
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        model.shaderInputs.setProps({ sdf: { ...sdfProps, outlineBuffer: DEFAULT_BUFFER2 } });
        model.draw(this.context.renderPass);
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY3;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY3;
  }
};
MultiIconLayer.defaultProps = defaultProps11;
MultiIconLayer.layerName = "MultiIconLayer";
var multi_icon_layer_default = MultiIconLayer;

// node_modules/@mapbox/tiny-sdf/index.js
var INF = 1e20;
var TinySDF = class {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = "sans-serif",
    fontWeight = "normal",
    fontStyle = "normal",
    lang = null
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;
    this.lang = lang;
    const size = this.size = fontSize + buffer * 4;
    const canvas2 = this._createCanvas(size);
    const ctx2 = this.ctx = canvas2.getContext("2d", { willReadFrequently: true });
    ctx2.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx2.textBaseline = "alphabetic";
    ctx2.textAlign = "left";
    ctx2.fillStyle = "black";
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = canvas2.height = size;
    return canvas2;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len4 = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len4);
    const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
    if (glyphWidth === 0 || glyphHeight === 0)
      return glyph;
    const { ctx: ctx2, buffer, gridInner, gridOuter } = this;
    if (this.lang)
      ctx2.lang = this.lang;
    ctx2.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx2.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx2.getImageData(buffer, buffer, glyphWidth, glyphHeight);
    gridOuter.fill(INF, 0, len4);
    gridInner.fill(0, 0, len4);
    for (let y2 = 0; y2 < glyphHeight; y2++) {
      for (let x2 = 0; x2 < glyphWidth; x2++) {
        const a2 = imgData.data[4 * (y2 * glyphWidth + x2) + 3] / 255;
        if (a2 === 0)
          continue;
        const j2 = (y2 + buffer) * width + x2 + buffer;
        if (a2 === 1) {
          gridOuter[j2] = 0;
          gridInner[j2] = INF;
        } else {
          const d2 = 0.5 - a2;
          gridOuter[j2] = d2 > 0 ? d2 * d2 : 0;
          gridInner[j2] = d2 < 0 ? d2 * d2 : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i3 = 0; i3 < len4; i3++) {
      const d2 = Math.sqrt(gridOuter[i3]) - Math.sqrt(gridInner[i3]);
      data[i3] = Math.round(255 - 255 * (d2 / this.radius + this.cutoff));
    }
    return glyph;
  }
};
function edt(data, x0, y0, width, height, gridSize, f2, v2, z2) {
  for (let x2 = x0; x2 < x0 + width; x2++)
    edt1d(data, y0 * gridSize + x2, gridSize, height, f2, v2, z2);
  for (let y2 = y0; y2 < y0 + height; y2++)
    edt1d(data, y2 * gridSize + x0, 1, width, f2, v2, z2);
}
function edt1d(grid, offset, stride, length5, f2, v2, z2) {
  v2[0] = 0;
  z2[0] = -INF;
  z2[1] = INF;
  f2[0] = grid[offset];
  for (let q2 = 1, k2 = 0, s2 = 0; q2 < length5; q2++) {
    f2[q2] = grid[offset + q2 * stride];
    const q22 = q2 * q2;
    do {
      const r2 = v2[k2];
      s2 = (f2[q2] - f2[r2] + q22 - r2 * r2) / (q2 - r2) / 2;
    } while (s2 <= z2[k2] && --k2 > -1);
    k2++;
    v2[k2] = q2;
    z2[k2] = s2;
    z2[k2 + 1] = INF;
  }
  for (let q2 = 0, k2 = 0; q2 < length5; q2++) {
    while (z2[k2 + 1] < q2)
      k2++;
    const r2 = v2[k2];
    const qr = q2 - r2;
    grid[offset + q2 * stride] = f2[r2] + qr * qr;
  }
}

// node_modules/@deck.gl/layers/dist/text-layer/utils.js
var MISSING_CHAR_WIDTH = 32;
var SINGLE_LINE = [];
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2({ characterSet, getFontWidth, fontHeight, buffer, maxCanvasWidth, mapping = {}, xOffset = 0, yOffset = 0 }) {
  let row = 0;
  let x2 = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x2 + width + buffer * 2 > maxCanvasWidth) {
        x2 = 0;
        row++;
      }
      mapping[char] = {
        x: x2 + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x2 += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x2,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const character = text[i3];
    width += mapping[character]?.layoutWidth || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target2) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const textWidth = getTextWidth(text, i3, i3 + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i3) {
        target2.push(i3);
      }
      rowStartCharIndex = i3;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target2) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    if (text[i3] === " ") {
      groupEndCharIndex = i3 + 1;
    } else if (text[i3 + 1] === " " || i3 + 1 === endIndex) {
      groupEndCharIndex = i3 + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target2.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target2);
          rowStartCharIndex = target2[target2.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x2 = 0;
  let rowHeight = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const character = line[i3];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i3] = x2 + frame.layoutWidth / 2;
      x2 += frame.layoutWidth;
    } else {
      log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
      leftOffsets[i3] = x2;
      x2 += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x2;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x2 = new Array(numCharacters);
  const y2 = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i3 = 0; i3 <= numCharacters; i3++) {
    const char = characters[i3];
    if (char === "\n" || i3 === numCharacters) {
      lineEndIndex = i3;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x2, rowSize);
        for (let j2 = rowStart; j2 < rowEnd; j2++) {
          const rowOffsetLeft = x2[j2] - rowSize[0] / 2;
          const char2 = characters[j2];
          const layoutOffsetY = iconMapping[char2]?.layoutOffsetY || 0;
          y2[j2] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j2] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x2[lineStartIndex] = 0;
      y2[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return { x: x2, y: y2, rowWidth, size };
}
function getTextFromBuffer({ value, length: length5, stride, offset, startIndices, characterSet }) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length5] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length5);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i3 = 0; i3 < characterCount; i3++) {
      codes[i3] = value[i3 * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length5; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return { texts, characterCount };
}

// node_modules/@deck.gl/layers/dist/text-layer/lru-cache.js
var LRUCache = class {
  constructor(limit = 5) {
    this._cache = {};
    this._order = [];
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i3 = 32; i3 < 128; i3++) {
    charSet.push(String.fromCharCode(i3));
  }
  return charSet;
}
var DEFAULT_FONT_SETTINGS = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache2 = new LRUCache(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache2.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i3 = 0; i3 < alphaChannel.length; i3++) {
    imageData.data[4 * i3 + 3] = alphaChannel[i3];
  }
}
function setTextStyle(ctx2, fontFamily, fontSize, fontWeight) {
  ctx2.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx2.fillStyle = "#000";
  ctx2.textBaseline = "alphabetic";
  ctx2.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache2 = new LRUCache(limit);
}
var FontAtlasManager = class {
  constructor() {
    this.props = { ...DEFAULT_FONT_SETTINGS };
  }
  get atlas() {
    return this._atlas;
  }
  // TODO - cut during v9 porting as types reveal this is not correct
  // get texture(): Texture | undefined {
  //   return this._atlas;
  // }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const { fontSize, buffer } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache2.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache2.set(this._key, fontAtlas);
  }
  // eslint-disable-next-line max-statements
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    let canvas2 = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      canvas2.width = MAX_CANVAS_WIDTH;
    }
    const ctx2 = canvas2.getContext("2d", { willReadFrequently: true });
    setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
    const { mapping, canvasHeight, xOffset, yOffset } = buildMapping2({
      getFontWidth: (char) => ctx2.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    });
    if (canvas2.height !== canvasHeight) {
      const imageData = ctx2.getImageData(0, 0, canvas2.width, canvas2.height);
      canvas2.height = canvasHeight;
      ctx2.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new TinySDF({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: `${fontWeight}`
      });
      for (const char of characterSet) {
        const { data, width, height, glyphTop } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx2.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx2.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx2.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas2,
      width: canvas2.width,
      height: canvas2.height
    };
  }
  _getKey() {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    if (sdf) {
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
    }
    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-uniforms.js
var uniformBlock10 = `uniform textBackgroundUniforms {
  bool billboard;
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  vec4 borderRadius;
  vec4 padding;
  highp int sizeUnits;
  bool stroked;
} textBackground;
`;
var textBackgroundUniforms = {
  name: "textBackground",
  vs: uniformBlock10,
  fs: uniformBlock10,
  uniformTypes: {
    billboard: "f32",
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    borderRadius: "vec4<f32>",
    padding: "vec4<f32>",
    sizeUnits: "i32",
    stroked: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),
textBackground.sizeMinPixels, textBackground.sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (textBackground.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
float round_rect(vec2 p, vec2 size, vec4 radii) {
vec2 pixelPositionCB = (p - 0.5) * size;
vec2 sizeCB = size * 0.5;
float maxBorderRadius = min(size.x, size.y) * 0.5;
vec4 borderRadius = vec4(min(radii, maxBorderRadius));
borderRadius.xy =
(pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;
borderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;
vec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;
return -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);
}
float rect(vec2 p, vec2 size) {
vec2 pixelPosition = p * size;
return min(min(pixelPosition.x, size.x - pixelPosition.x),
min(pixelPosition.y, size.y - pixelPosition.y));
}
vec4 get_stroked_fragColor(float dist) {
float isBorder = smoothedge(dist, vLineWidth);
return mix(vFillColor, vLineColor, isBorder);
}
void main(void) {
geometry.uv = uv;
if (textBackground.borderRadius != vec4(0.0)) {
float distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);
if (textBackground.stroked) {
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
float shapeAlpha = smoothedge(-distToEdge, 0.0);
fragColor.a *= shapeAlpha;
} else {
if (textBackground.stroked) {
float distToEdge = rect(uv, dimensions);
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer.js
var defaultProps12 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  borderRadius: { type: "object", value: 0 },
  padding: { type: "array", value: [0, 0, 0, 0] },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
  getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineWidth: { type: "accessor", value: 1 }
};
var TextBackgroundLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: text_background_layer_vertex_glsl_default, fs: text_background_layer_fragment_glsl_default, modules: [project32_default, picking_default, textBackgroundUniforms] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { changeFlags } = params;
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
    let { padding, borderRadius } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    if (!Array.isArray(borderRadius)) {
      borderRadius = [borderRadius, borderRadius, borderRadius, borderRadius];
    }
    const model = this.state.model;
    const textBackgroundProps = {
      billboard,
      stroked: Boolean(getLineWidth),
      borderRadius,
      padding,
      sizeUnits: UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    };
    model.shaderInputs.setProps({ textBackground: textBackgroundProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [0, 0, 1, 0, 0, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        vertexCount: 4,
        attributes: {
          positions: { size: 2, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
TextBackgroundLayer.defaultProps = defaultProps12;
TextBackgroundLayer.layerName = "TextBackgroundLayer";
var text_background_layer_default = TextBackgroundLayer;

// node_modules/@deck.gl/layers/dist/text-layer/text-layer.js
var TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
var ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
var DEFAULT_COLOR6 = [0, 0, 0, 255];
var DEFAULT_LINE_HEIGHT = 1;
var defaultProps13 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
  getBorderColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getBorderWidth: { type: "accessor", value: 0 },
  backgroundBorderRadius: { type: "object", value: 0 },
  backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
  characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: { type: "number", value: 0, min: 0 },
  outlineColor: { type: "color", value: DEFAULT_COLOR6 },
  fontSettings: { type: "object", value: {}, compare: 1 },
  // auto wrapping options
  wordBreak: "break-word",
  maxWidth: { type: "number", value: -1 },
  getText: { type: "accessor", value: (x2) => x2.text },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getSize: { type: "accessor", value: 32 },
  getAngle: { type: "accessor", value: 0 },
  getTextAnchor: { type: "accessor", value: "middle" },
  getAlignmentBaseline: { type: "accessor", value: "center" },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  // deprecated
  backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
var TextLayer = class extends composite_layer_default {
  constructor() {
    super(...arguments);
    this.getBoundingRect = (object, objectInfo) => {
      let { size: [width, height] } = this.transformParagraph(object, objectInfo);
      const { fontSize } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    };
    this.getIconOffsets = (object, objectInfo) => {
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const { x: x2, y: y2, rowWidth, size: [width, height] } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x2.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i3 = 0; i3 < numCharacters; i3++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i3]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x2[i3];
        offsets[index++] = (anchorY - 1) * height / 2 + y2[i3];
      }
      return offsets;
    };
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new FontAtlasManager()
    };
    if (this.props.maxWidth > 0) {
      log_default.once(1, "v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
    }
  }
  // eslint-disable-next-line complexity
  updateState(params) {
    const { props, oldProps, changeFlags } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({ info }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  /** Returns true if font has changed */
  _updateFontAtlas() {
    const { fontSettings, fontFamily, fontWeight } = this.props;
    const { fontAtlasManager, characterSet } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  // Text strings are variable width objects
  // Count characters and start offsets
  _updateText() {
    const { data, characterSet } = this.props;
    const textBuffer = data.attributes?.getText;
    let { getText } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
    if (textBuffer && startIndices) {
      const { texts, characterCount } = getTextFromBuffer({
        ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
        // @ts-ignore if data.attribute is defined then length is expected
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_2, { index }) => texts[index];
    } else {
      const { iterable, objectInfo } = createIterable(data);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || "");
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  /** There are two size systems in this layer:
  
      + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
        The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
        in layer props is roughly equivalent to font-size: 24px in CSS.
      + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
        which depends on how large each character is drawn into the font atlas. This is controlled by
        fontSettings.fontSize (default 64) and most users do not set it manually.
        These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
  
      All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
  /** Calculate the size and position of each character in a text string.
   * Values are in texture size */
  transformParagraph(object, objectInfo) {
    const { fontAtlasManager } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const { wordBreak, lineHeight, maxWidth } = this.props;
    const paragraph = getText(object, objectInfo) || "";
    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const { startIndices, numInstances, getText, fontAtlasManager: { scale: scale7, atlas, mapping }, styleVersion } = this.state;
    const { data, _dataDiff, getPosition: getPosition3, getColor: getColor2, getSize, getAngle, getPixelOffset, getBackgroundColor, getBorderColor, getBorderWidth, backgroundBorderRadius, backgroundPadding, background, billboard, fontSettings, outlineWidth, outlineColor, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, transitions, updateTriggers } = this.props;
    const CharactersLayerClass = this.getSubLayerClass("characters", multi_icon_layer_default);
    const BackgroundLayerClass = this.getSubLayerClass("background", text_background_layer_default);
    return [
      background && new BackgroundLayerClass({
        // background props
        getFillColor: getBackgroundColor,
        getLineColor: getBorderColor,
        getLineWidth: getBorderWidth,
        borderRadius: backgroundBorderRadius,
        padding: backgroundPadding,
        // props shared with characters layer
        getPosition: getPosition3,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getSize: transitions.getSize,
          getFillColor: transitions.getBackgroundColor,
          getLineColor: transitions.getBorderColor,
          getLineWidth: transitions.getBorderWidth,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getSize: updateTriggers.getSize,
          getFillColor: updateTriggers.getBackgroundColor,
          getLineColor: updateTriggers.getBorderColor,
          getLineWidth: updateTriggers.getBorderWidth,
          getPixelOffset: updateTriggers.getPixelOffset,
          getBoundingRect: {
            getText: updateTriggers.getText,
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data: (
          // @ts-ignore (2339) attribute is not defined on all data types
          data.attributes && data.attributes.background ? (
            // @ts-ignore (2339) attribute is not defined on all data types
            { length: data.length, attributes: data.attributes.background }
          ) : data
        ),
        _dataDiff,
        // Maintain the same background behavior as <=8.3. Remove in v9?
        autoHighlight: false,
        getBoundingRect: this.getBoundingRect
      }),
      new CharactersLayerClass({
        sdf: fontSettings.sdf,
        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
        outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
        outlineColor,
        iconAtlas: atlas,
        iconMapping: mapping,
        getPosition: getPosition3,
        getColor: getColor2,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale: sizeScale * scale7,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale7,
        sizeMaxPixels: sizeMaxPixels * scale7,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: updateTriggers.getText,
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data,
        _dataDiff,
        startIndices,
        numInstances,
        getIconOffsets: this.getIconOffsets,
        getIcon: getText
      })
    ];
  }
  static set fontAtlasCacheLimit(limit) {
    setFontAtlasCacheLimit(limit);
  }
};
TextLayer.defaultProps = defaultProps13;
TextLayer.layerName = "TextLayer";
var text_layer_default = TextLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/sub-layer-map.js
var POINT_LAYER = {
  circle: {
    type: scatterplot_layer_default,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: icon_layer_default,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: text_layer_default,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
};
var LINE_LAYER = {
  type: path_layer_default,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
};
var POLYGON_LAYER = {
  type: solid_polygon_layer_default,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function getDefaultProps({ type, props }) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const { transitions, updateTriggers } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{ geometry: geojson }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const { startRow = 0, endRow = features.length } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const { geometry } = feature;
    if (!geometry) {
      continue;
    }
    if (geometry.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
      const { geometries } = geometry;
      for (let i3 = 0; i3 < geometries.length; i3++) {
        const subGeometry = geometries[i3];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const { type, coordinates } = geometry;
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn(`${type} coordinates are malformed`)();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point) => {
        pointFeatures.push(wrapFeature({
          geometry: { type: "Point", coordinates: point }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: { type: "Polygon", coordinates: polygon }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: { type: "LineString", coordinates: path }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
var COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f2) {
  return f2.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const { points, lines, polygons } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js
var FEATURE_TYPES = ["points", "linestrings", "polygons"];
var defaultProps14 = {
  ...getDefaultProps(POINT_LAYER.circle),
  ...getDefaultProps(POINT_LAYER.icon),
  ...getDefaultProps(POINT_LAYER.text),
  ...getDefaultProps(LINE_LAYER),
  ...getDefaultProps(POLYGON_LAYER),
  // Overwrite sub layer defaults
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: { type: "object", value: null },
  iconMapping: { type: "object", value: {} },
  getIcon: { type: "accessor", value: (f2) => f2.properties.icon },
  getText: { type: "accessor", value: (f2) => f2.properties.text },
  // Self props
  pointType: "circle",
  // TODO: deprecated, remove in v9
  getRadius: { deprecatedFor: "getPointRadius" }
};
var GeoJsonLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {},
      featuresDiff: {}
    };
  }
  updateState({ props, changeFlags }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const { data } = this.props;
    const binary = data && "points" in data && "polygons" in data && "lines" in data;
    this.setState({ binary });
    if (binary) {
      this._updateStateBinary({ props, changeFlags });
    } else {
      this._updateStateJSON({ props, changeFlags });
    }
  }
  _updateStateBinary({ props, changeFlags }) {
    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
    this.setState({ layerProps });
  }
  _updateStateJSON({ props, changeFlags }) {
    const features = getGeojsonFeatures(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push(replaceInRange({
            data: newFeatures[key],
            getIndex: (f2) => f2.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = separateGeojsonFeatures(features, wrapFeature);
    }
    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index, sourceLayer } = info;
    info.featureType = FEATURE_TYPES.find((ft2) => sourceLayer.id.startsWith(`${this.id}-${ft2}-`));
    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = `${this.id}-points-`;
    const sourceIsPoints = info.featureType === "points";
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    const { extruded, wireframe } = this.props;
    const { layerProps } = this.state;
    const id = "polygons-fill";
    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    const { extruded, stroked } = this.props;
    const { layerProps } = this.state;
    const polygonStrokeLayerId = "polygons-stroke";
    const lineStringsLayerId = "linestrings";
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = forwardProps(this, LINE_LAYER.props);
      return [
        PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
          id: polygonStrokeLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygonsOutline),
        LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
          id: lineStringsLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.lines)
      ];
    }
    return null;
  }
  _renderPointLayers() {
    const { pointType } = this.props;
    const { layerProps, binary } = this.state;
    let { highlightedObjectIndex } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex((d2) => d2.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split("+"));
    const pointLayers = [];
    for (const type of types) {
      const id = `points-${type}`;
      const PointLayerMapping = POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = forwardProps(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === "text" && binary) {
          const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            // @ts-expect-error TODO - type binary data
            data: { ...pointsLayerProps.data, attributes: rest }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const { extruded } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer,
      lineLayers,
      pointLayers,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer
    ];
  }
  getSubLayerAccessor(accessor) {
    const { binary } = this.state;
    if (!binary || typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const { data, index } = info;
      const feature = binaryToFeatureForAccesor(data, index);
      return accessor(feature, info);
    };
  }
};
GeoJsonLayer.layerName = "GeoJsonLayer";
GeoJsonLayer.defaultProps = defaultProps14;
var geojson_layer_default = GeoJsonLayer;

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js
var Tile2DHeader = class {
  constructor(index) {
    this.index = index;
    this.isVisible = false;
    this.isSelected = false;
    this.parent = null;
    this.children = [];
    this.content = null;
    this._loader = void 0;
    this._abortController = null;
    this._loaderId = 0;
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
  }
  /** @deprecated use `boundingBox` instead */
  get bbox() {
    return this._bbox;
  }
  // TODO - remove in v9
  set bbox(value) {
    if (this._bbox)
      return;
    this._bbox = value;
    if ("west" in value) {
      this.boundingBox = [
        [value.west, value.south],
        [value.east, value.north]
      ];
    } else {
      this.boundingBox = [
        [value.left, value.top],
        [value.right, value.bottom]
      ];
    }
  }
  get data() {
    return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
  }
  get isLoaded() {
    return this._isLoaded && !this._needsReload;
  }
  get isLoading() {
    return Boolean(this._loader) && !this._isCancelled;
  }
  get needsReload() {
    return this._needsReload || this._isCancelled;
  }
  get byteLength() {
    const result = this.content ? this.content.byteLength : 0;
    if (!Number.isFinite(result)) {
      console.error("byteLength not defined in tile data");
    }
    return result;
  }
  /* eslint-disable max-statements */
  async _loadData({ getData, requestScheduler, onLoad, onError }) {
    const { index, id, bbox, userData, zoom } = this;
    const loaderId = this._loaderId;
    this._abortController = new AbortController();
    const { signal } = this._abortController;
    const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
      return tile.isSelected ? 1 : -1;
    });
    if (!requestToken) {
      this._isCancelled = true;
      return;
    }
    if (this._isCancelled) {
      requestToken.done();
      return;
    }
    let tileData = null;
    let error;
    try {
      tileData = await getData({ index, id, bbox, userData, zoom, signal });
    } catch (err2) {
      error = err2 || true;
    } finally {
      requestToken.done();
    }
    if (loaderId !== this._loaderId) {
      return;
    }
    this._loader = void 0;
    this.content = tileData;
    if (this._isCancelled && !tileData) {
      this._isLoaded = false;
      return;
    }
    this._isLoaded = true;
    this._isCancelled = false;
    if (error) {
      onError(error, this);
    } else {
      onLoad(this);
    }
  }
  loadData(opts) {
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
    this._loaderId++;
    this._loader = this._loadData(opts);
    return this._loader;
  }
  setNeedsReload() {
    if (this.isLoading) {
      this.abort();
      this._loader = void 0;
    }
    this._needsReload = true;
  }
  abort() {
    if (this.isLoaded) {
      return;
    }
    this._isCancelled = true;
    this._abortController?.abort();
  }
};

// node_modules/@math.gl/culling/dist/constants.js
var INTERSECTION = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js
var scratchVector2 = new Vector3();
var scratchNormal = new Vector3();
var AxisAlignedBoundingBox = class _AxisAlignedBoundingBox {
  /**
   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.
   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.
   * @param center The center of the box; automatically computed if not supplied.
   */
  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {
    center = center || scratchVector2.copy(minimum).add(maximum).scale(0.5);
    this.center = new Vector3(center);
    this.halfDiagonal = new Vector3(maximum).subtract(this.center);
    this.minimum = new Vector3(minimum);
    this.maximum = new Vector3(maximum);
  }
  /**
   * Duplicates a AxisAlignedBoundingBox instance.
   *
   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.
   */
  clone() {
    return new _AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
  }
  /**
   * Compares the provided AxisAlignedBoundingBox componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.
   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(right) {
    return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(transform) {
    this.center.transformAsPoint(transform);
    this.halfDiagonal.transform(transform);
    this.minimum.transform(transform);
    this.maximum.transform(transform);
    return this;
  }
  /**
   * Determines which side of a plane a box is located.
   */
  intersectPlane(plane) {
    const { halfDiagonal } = this;
    const normal = scratchNormal.from(plane.normal);
    const e2 = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
    const s2 = this.center.dot(normal) + plane.distance;
    if (s2 - e2 > 0) {
      return INTERSECTION.INSIDE;
    }
    if (s2 + e2 < 0) {
      return INTERSECTION.OUTSIDE;
    }
    return INTERSECTION.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(point) {
    return Math.sqrt(this.distanceSquaredTo(point));
  }
  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */
  distanceSquaredTo(point) {
    const offset = scratchVector2.from(point).subtract(this.center);
    const { halfDiagonal } = this;
    let distanceSquared = 0;
    let d2;
    d2 = Math.abs(offset.x) - halfDiagonal.x;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.y) - halfDiagonal.y;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.z) - halfDiagonal.z;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    return distanceSquared;
  }
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js
var scratchVector3 = new Vector3();
var scratchVector22 = new Vector3();
var BoundingSphere = class _BoundingSphere {
  /** Creates a bounding sphere */
  constructor(center = [0, 0, 0], radius = 0) {
    this.radius = -0;
    this.center = new Vector3();
    this.fromCenterRadius(center, radius);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(center, radius) {
    this.center.from(center);
    this.radius = radius;
    return this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(corner, oppositeCorner) {
    oppositeCorner = scratchVector3.from(oppositeCorner);
    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
    this.radius = this.center.distance(oppositeCorner);
    return this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(right) {
    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new _BoundingSphere(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(boundingSphere) {
    const leftCenter = this.center;
    const leftRadius = this.radius;
    const rightCenter = boundingSphere.center;
    const rightRadius = boundingSphere.radius;
    const toRightCenter = scratchVector3.copy(rightCenter).subtract(leftCenter);
    const centerSeparation = toRightCenter.magnitude();
    if (leftRadius >= centerSeparation + rightRadius) {
      return this.clone();
    }
    if (rightRadius >= centerSeparation + leftRadius) {
      return boundingSphere.clone();
    }
    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
    scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
    this.center.copy(scratchVector22);
    this.radius = halfDistanceBetweenTangentPoints;
    return this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(point) {
    const scratchPoint = scratchVector3.from(point);
    const radius = scratchPoint.subtract(this.center).magnitude();
    if (radius > this.radius) {
      this.radius = radius;
    }
    return this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(transform) {
    this.center.transform(transform);
    const scale7 = mat4_exports.getScaling(scratchVector3, transform);
    this.radius = Math.max(scale7[0], Math.max(scale7[1], scale7[2])) * this.radius;
    return this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(point) {
    const d2 = this.distanceTo(point);
    return d2 * d2;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(point) {
    const scratchPoint = scratchVector3.from(point);
    const delta = scratchPoint.subtract(this.center);
    return Math.max(0, delta.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(plane) {
    const center = this.center;
    const radius = this.radius;
    const normal = plane.normal;
    const distanceToPlane = normal.dot(center) + plane.distance;
    if (distanceToPlane < -radius) {
      return INTERSECTION.OUTSIDE;
    }
    if (distanceToPlane < radius) {
      return INTERSECTION.INTERSECTING;
    }
    return INTERSECTION.INSIDE;
  }
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js
var scratchVector32 = new Vector3();
var scratchOffset = new Vector3();
var scratchVectorU = new Vector3();
var scratchVectorV = new Vector3();
var scratchVectorW = new Vector3();
var scratchCorner = new Vector3();
var scratchToCenter = new Vector3();
var MATRIX3 = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
var OrientedBoundingBox = class _OrientedBoundingBox {
  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new Vector3().from(center);
    this.halfAxes = new Matrix3(halfAxes);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const xAxis = this.halfAxes.getColumn(0);
    const yAxis = this.halfAxes.getColumn(1);
    const zAxis = this.halfAxes.getColumn(2);
    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const xAxis = this.halfAxes.getColumn(0);
    const yAxis = this.halfAxes.getColumn(1);
    const zAxis = this.halfAxes.getColumn(2);
    const normXAxis = new Vector3(xAxis).normalize();
    const normYAxis = new Vector3(yAxis).normalize();
    const normZAxis = new Vector3(zAxis).normalize();
    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {
    const quaternionObject = new Quaternion(quaternion);
    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
    this.center = new Vector3().from(center);
    this.halfAxes = directionsMatrix;
    return this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new _OrientedBoundingBox(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(right) {
    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(result = new BoundingSphere()) {
    const halfAxes = this.halfAxes;
    const u2 = halfAxes.getColumn(0, scratchVectorU);
    const v2 = halfAxes.getColumn(1, scratchVectorV);
    const w3 = halfAxes.getColumn(2, scratchVectorW);
    const cornerVector = scratchVector32.copy(u2).add(v2).add(w3);
    result.center.copy(this.center);
    result.radius = cornerVector.magnitude();
    return result;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(plane) {
    const center = this.center;
    const normal = plane.normal;
    const halfAxes = this.halfAxes;
    const normalX = normal.x;
    const normalY = normal.y;
    const normalZ = normal.z;
    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
    const distanceToPlane = normal.dot(center) + plane.distance;
    if (distanceToPlane <= -radEffective) {
      return INTERSECTION.OUTSIDE;
    } else if (distanceToPlane >= radEffective) {
      return INTERSECTION.INSIDE;
    }
    return INTERSECTION.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(point) {
    return Math.sqrt(this.distanceSquaredTo(point));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(point) {
    const offset = scratchOffset.from(point).subtract(this.center);
    const halfAxes = this.halfAxes;
    const u2 = halfAxes.getColumn(0, scratchVectorU);
    const v2 = halfAxes.getColumn(1, scratchVectorV);
    const w3 = halfAxes.getColumn(2, scratchVectorW);
    const uHalf = u2.magnitude();
    const vHalf = v2.magnitude();
    const wHalf = w3.magnitude();
    u2.normalize();
    v2.normalize();
    w3.normalize();
    let distanceSquared = 0;
    let d2;
    d2 = Math.abs(offset.dot(u2)) - uHalf;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.dot(v2)) - vHalf;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.dot(w3)) - wHalf;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    return distanceSquared;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(position, direction, result = [-0, -0]) {
    let minDist = Number.POSITIVE_INFINITY;
    let maxDist = Number.NEGATIVE_INFINITY;
    const center = this.center;
    const halfAxes = this.halfAxes;
    const u2 = halfAxes.getColumn(0, scratchVectorU);
    const v2 = halfAxes.getColumn(1, scratchVectorV);
    const w3 = halfAxes.getColumn(2, scratchVectorW);
    const corner = scratchCorner.copy(u2).add(v2).add(w3).add(center);
    const toCenter = scratchToCenter.copy(corner).subtract(position);
    let mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center).add(u2).add(v2).subtract(w3);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center).add(u2).subtract(v2).add(w3);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center).add(u2).subtract(v2).subtract(w3);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u2).add(v2).add(w3);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u2).add(v2).subtract(w3);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u2).subtract(v2).add(w3);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u2).subtract(v2).subtract(w3);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    result[0] = minDist;
    result[1] = maxDist;
    return result;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(transformation) {
    this.center.transformAsPoint(transformation);
    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
    xAxis.transformAsPoint(transformation);
    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
    yAxis.transformAsPoint(transformation);
    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
    zAxis.transformAsPoint(transformation);
    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
    return this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
};

// node_modules/@math.gl/culling/dist/lib/plane.js
var scratchPosition = new Vector3();
var scratchNormal2 = new Vector3();
var Plane = class _Plane {
  constructor(normal = [0, 0, 1], distance5 = 0) {
    this.normal = new Vector3();
    this.distance = -0;
    this.fromNormalDistance(normal, distance5);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(normal, distance5) {
    assert6(Number.isFinite(distance5));
    this.normal.from(normal).normalize();
    this.distance = distance5;
    return this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(point, normal) {
    point = scratchPosition.from(point);
    this.normal.from(normal).normalize();
    const distance5 = -this.normal.dot(point);
    this.distance = distance5;
    return this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(a2, b2, c2, d2) {
    this.normal.set(a2, b2, c2);
    assert6(equals(this.normal.len(), 1));
    this.distance = d2;
    return this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new _Plane(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(right) {
    return equals(this.distance, right.distance) && equals(this.normal, right.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(point) {
    return this.normal.dot(point) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(matrix4) {
    const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
    const point = this.normal.scale(-this.distance).transform(matrix4);
    return this.fromPointNormal(point, normal);
  }
  projectPointOntoPlane(point, result = [0, 0, 0]) {
    const scratchPoint = scratchPosition.from(point);
    const pointDistance = this.getPointDistance(scratchPoint);
    const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
    return scratchPoint.subtract(scaledNormal).to(result);
  }
};

// node_modules/@math.gl/culling/dist/lib/culling-volume.js
var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
var scratchPlaneCenter = new Vector3();
var scratchPlaneNormal = new Vector3();
var CullingVolume = class _CullingVolume {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(planes = []) {
    this.planes = planes;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(boundingSphere) {
    this.planes.length = 2 * faces.length;
    const center = boundingSphere.center;
    const radius = boundingSphere.radius;
    let planeIndex = 0;
    for (const faceNormal of faces) {
      let plane0 = this.planes[planeIndex];
      let plane1 = this.planes[planeIndex + 1];
      if (!plane0) {
        plane0 = this.planes[planeIndex] = new Plane();
      }
      if (!plane1) {
        plane1 = this.planes[planeIndex + 1] = new Plane();
      }
      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
      plane0.fromPointNormal(plane0Center, faceNormal);
      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
      plane1.fromPointNormal(plane1Center, negatedFaceNormal);
      planeIndex += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(boundingVolume) {
    let intersect2 = INTERSECTION.INSIDE;
    for (const plane of this.planes) {
      const result = boundingVolume.intersectPlane(plane);
      switch (result) {
        case INTERSECTION.OUTSIDE:
          return INTERSECTION.OUTSIDE;
        case INTERSECTION.INTERSECTING:
          intersect2 = INTERSECTION.INTERSECTING;
          break;
        default:
      }
    }
    return intersect2;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
    assert6(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
    if (parentPlaneMask === _CullingVolume.MASK_OUTSIDE || parentPlaneMask === _CullingVolume.MASK_INSIDE) {
      return parentPlaneMask;
    }
    let mask = _CullingVolume.MASK_INSIDE;
    const planes = this.planes;
    for (let k2 = 0; k2 < this.planes.length; ++k2) {
      const flag = k2 < 31 ? 1 << k2 : 0;
      if (k2 < 31 && (parentPlaneMask & flag) === 0) {
        continue;
      }
      const plane = planes[k2];
      const result = boundingVolume.intersectPlane(plane);
      if (result === INTERSECTION.OUTSIDE) {
        return _CullingVolume.MASK_OUTSIDE;
      } else if (result === INTERSECTION.INTERSECTING) {
        mask |= flag;
      }
    }
    return mask;
  }
};
CullingVolume.MASK_OUTSIDE = 4294967295;
CullingVolume.MASK_INSIDE = 0;
CullingVolume.MASK_INDETERMINATE = 2147483647;

// node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js
var scratchPlaneUpVector = new Vector3();
var scratchPlaneRightVector = new Vector3();
var scratchPlaneNearCenter = new Vector3();
var scratchPlaneFarCenter = new Vector3();
var scratchPlaneNormal2 = new Vector3();

// node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js
var fromPointsXMin = new Vector3();
var fromPointsYMin = new Vector3();
var fromPointsZMin = new Vector3();
var fromPointsXMax = new Vector3();
var fromPointsYMax = new Vector3();
var fromPointsZMax = new Vector3();
var fromPointsCurrentPos = new Vector3();
var fromPointsScratch = new Vector3();
var fromPointsRitterCenter = new Vector3();
var fromPointsMinBoxPt = new Vector3();
var fromPointsMaxBoxPt = new Vector3();
var fromPointsNaiveCenterScratch = new Vector3();

// node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js
var scratchMatrix = new Matrix3();
var scratchUnitary = new Matrix3();
var scratchDiagonal = new Matrix3();
var jMatrix = new Matrix3();
var jMatrixTranspose = new Matrix3();
function computeEigenDecomposition(matrix, result = {}) {
  const EIGEN_TOLERANCE = math_utils_exports.EPSILON20;
  const EIGEN_MAX_SWEEPS = 10;
  let count2 = 0;
  let sweep = 0;
  const unitaryMatrix = scratchUnitary;
  const diagonalMatrix = scratchDiagonal;
  unitaryMatrix.identity();
  diagonalMatrix.copy(matrix);
  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
    shurDecomposition(diagonalMatrix, jMatrix);
    jMatrixTranspose.copy(jMatrix).transpose();
    diagonalMatrix.multiplyRight(jMatrix);
    diagonalMatrix.multiplyLeft(jMatrixTranspose);
    unitaryMatrix.multiplyRight(jMatrix);
    if (++count2 > 2) {
      ++sweep;
      count2 = 0;
    }
  }
  result.unitary = unitaryMatrix.toTarget(result.unitary);
  result.diagonal = diagonalMatrix.toTarget(result.diagonal);
  return result;
}
function computeFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i3 = 0; i3 < 9; ++i3) {
    const temp = matrix[i3];
    norm += temp * temp;
  }
  return Math.sqrt(norm);
}
var rowVal = [1, 0, 0];
var colVal = [2, 2, 1];
function offDiagonalFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i3 = 0; i3 < 3; ++i3) {
    const temp = matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])];
    norm += 2 * temp * temp;
  }
  return Math.sqrt(norm);
}
function shurDecomposition(matrix, result) {
  const tolerance = math_utils_exports.EPSILON15;
  let maxDiagonal = 0;
  let rotAxis = 1;
  for (let i3 = 0; i3 < 3; ++i3) {
    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])]);
    if (temp > maxDiagonal) {
      rotAxis = i3;
      maxDiagonal = temp;
    }
  }
  const p2 = rowVal[rotAxis];
  const q2 = colVal[rotAxis];
  let c2 = 1;
  let s2 = 0;
  if (Math.abs(matrix[scratchMatrix.getElementIndex(q2, p2)]) > tolerance) {
    const qq = matrix[scratchMatrix.getElementIndex(q2, q2)];
    const pp = matrix[scratchMatrix.getElementIndex(p2, p2)];
    const qp = matrix[scratchMatrix.getElementIndex(q2, p2)];
    const tau = (qq - pp) / 2 / qp;
    let t2;
    if (tau < 0) {
      t2 = -1 / (-tau + Math.sqrt(1 + tau * tau));
    } else {
      t2 = 1 / (tau + Math.sqrt(1 + tau * tau));
    }
    c2 = 1 / Math.sqrt(1 + t2 * t2);
    s2 = t2 * c2;
  }
  Matrix3.IDENTITY.to(result);
  result[scratchMatrix.getElementIndex(p2, p2)] = result[scratchMatrix.getElementIndex(q2, q2)] = c2;
  result[scratchMatrix.getElementIndex(q2, p2)] = s2;
  result[scratchMatrix.getElementIndex(p2, q2)] = -s2;
  return result;
}

// node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js
var scratchVector23 = new Vector3();
var scratchVector33 = new Vector3();
var scratchVector4 = new Vector3();
var scratchVector5 = new Vector3();
var scratchVector6 = new Vector3();
var scratchCovarianceResult = new Matrix3();
var scratchEigenResult = {
  diagonal: new Matrix3(),
  unitary: new Matrix3()
};
function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
  if (!positions || positions.length === 0) {
    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    result.center = new Vector3();
    return result;
  }
  const length5 = positions.length;
  const meanPoint = new Vector3(0, 0, 0);
  for (const position of positions) {
    meanPoint.add(position);
  }
  const invLength = 1 / length5;
  meanPoint.multiplyByScalar(invLength);
  let exx = 0;
  let exy = 0;
  let exz = 0;
  let eyy = 0;
  let eyz = 0;
  let ezz = 0;
  for (const position of positions) {
    const p2 = scratchVector23.copy(position).subtract(meanPoint);
    exx += p2.x * p2.x;
    exy += p2.x * p2.y;
    exz += p2.x * p2.z;
    eyy += p2.y * p2.y;
    eyz += p2.y * p2.z;
    ezz += p2.z * p2.z;
  }
  exx *= invLength;
  exy *= invLength;
  exz *= invLength;
  eyy *= invLength;
  eyz *= invLength;
  ezz *= invLength;
  const covarianceMatrix = scratchCovarianceResult;
  covarianceMatrix[0] = exx;
  covarianceMatrix[1] = exy;
  covarianceMatrix[2] = exz;
  covarianceMatrix[3] = exy;
  covarianceMatrix[4] = eyy;
  covarianceMatrix[5] = eyz;
  covarianceMatrix[6] = exz;
  covarianceMatrix[7] = eyz;
  covarianceMatrix[8] = ezz;
  const { unitary } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
  const rotation = result.halfAxes.copy(unitary);
  let v1 = rotation.getColumn(0, scratchVector4);
  let v2 = rotation.getColumn(1, scratchVector5);
  let v3 = rotation.getColumn(2, scratchVector6);
  let u1 = -Number.MAX_VALUE;
  let u2 = -Number.MAX_VALUE;
  let u3 = -Number.MAX_VALUE;
  let l1 = Number.MAX_VALUE;
  let l2 = Number.MAX_VALUE;
  let l3 = Number.MAX_VALUE;
  for (const position of positions) {
    scratchVector23.copy(position);
    u1 = Math.max(scratchVector23.dot(v1), u1);
    u2 = Math.max(scratchVector23.dot(v2), u2);
    u3 = Math.max(scratchVector23.dot(v3), u3);
    l1 = Math.min(scratchVector23.dot(v1), l1);
    l2 = Math.min(scratchVector23.dot(v2), l2);
    l3 = Math.min(scratchVector23.dot(v3), l3);
  }
  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
  result.center.copy(v1).add(v2).add(v3);
  const scale7 = scratchVector33.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
  const scaleMatrix = new Matrix3([scale7[0], 0, 0, 0, scale7[1], 0, 0, 0, scale7[2]]);
  result.halfAxes.multiplyRight(scaleMatrix);
  return result;
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js
var TILE_SIZE3 = 512;
var MAX_MAPS = 3;
var REF_POINTS_5 = [
  [0.5, 0.5],
  [0, 0],
  [0, 1],
  [1, 0],
  [1, 1]
];
var REF_POINTS_9 = REF_POINTS_5.concat([
  [0, 0.5],
  [0.5, 0],
  [1, 0.5],
  [0.5, 1]
]);
var REF_POINTS_11 = REF_POINTS_9.concat([
  [0.25, 0.5],
  [0.75, 0.5]
]);
var OSMNode = class _OSMNode {
  constructor(x2, y2, z2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  get children() {
    if (!this._children) {
      const x2 = this.x * 2;
      const y2 = this.y * 2;
      const z2 = this.z + 1;
      this._children = [
        new _OSMNode(x2, y2, z2),
        new _OSMNode(x2, y2 + 1, z2),
        new _OSMNode(x2 + 1, y2, z2),
        new _OSMNode(x2 + 1, y2 + 1, z2)
      ];
    }
    return this._children;
  }
  // eslint-disable-next-line complexity
  update(params) {
    const { viewport, cullingVolume, elevationBounds, minZ, maxZ, bounds, offset, project } = params;
    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);
    if (bounds && !this.insideBounds(bounds)) {
      return false;
    }
    const isInside = cullingVolume.computeVisibility(boundingVolume);
    if (isInside < 0) {
      return false;
    }
    if (!this.childVisible) {
      let { z: z2 } = this;
      if (z2 < maxZ && z2 >= minZ) {
        const distance5 = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
        z2 += Math.floor(Math.log2(distance5));
      }
      if (z2 >= maxZ) {
        this.selected = true;
        return true;
      }
    }
    this.selected = false;
    this.childVisible = true;
    for (const child of this.children) {
      child.update(params);
    }
    return true;
  }
  getSelected(result = []) {
    if (this.selected) {
      result.push(this);
    }
    if (this._children) {
      for (const node of this._children) {
        node.getSelected(result);
      }
    }
    return result;
  }
  insideBounds([minX, minY, maxX, maxY]) {
    const scale7 = Math.pow(2, this.z);
    const extent = TILE_SIZE3 / scale7;
    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
  }
  getBoundingVolume(zRange, worldOffset, project) {
    if (project) {
      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
      const refPointPositions = [];
      for (const p2 of refPoints) {
        const lngLat = osmTile2lngLat(this.x + p2[0], this.y + p2[1], this.z);
        lngLat[2] = zRange[0];
        refPointPositions.push(project(lngLat));
        if (zRange[0] !== zRange[1]) {
          lngLat[2] = zRange[1];
          refPointPositions.push(project(lngLat));
        }
      }
      return makeOrientedBoundingBoxFromPoints(refPointPositions);
    }
    const scale7 = Math.pow(2, this.z);
    const extent = TILE_SIZE3 / scale7;
    const originX = this.x * extent + worldOffset * TILE_SIZE3;
    const originY = TILE_SIZE3 - (this.y + 1) * extent;
    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
  }
};
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
  const project = viewport instanceof GlobeViewport && viewport.resolution ? (
    // eslint-disable-next-line @typescript-eslint/unbound-method
    viewport.projectPosition
  ) : null;
  const planes = Object.values(viewport.getFrustumPlanes()).map(({ normal, distance: distance5 }) => new Plane(normal.clone().negate(), distance5));
  const cullingVolume = new CullingVolume(planes);
  const unitsPerMeter2 = viewport.distanceScales.unitsPerMeter[2];
  const elevationMin = zRange && zRange[0] * unitsPerMeter2 || 0;
  const elevationMax = zRange && zRange[1] * unitsPerMeter2 || 0;
  const minZ = viewport instanceof web_mercator_viewport_default && viewport.pitch <= 60 ? maxZ : 0;
  if (bounds) {
    const [minLng, minLat, maxLng, maxLat] = bounds;
    const topLeft = lngLatToWorld([minLng, maxLat]);
    const bottomRight = lngLatToWorld([maxLng, minLat]);
    bounds = [topLeft[0], TILE_SIZE3 - topLeft[1], bottomRight[0], TILE_SIZE3 - bottomRight[1]];
  }
  const root2 = new OSMNode(0, 0, 0);
  const traversalParams = {
    viewport,
    project,
    cullingVolume,
    elevationBounds: [elevationMin, elevationMax],
    minZ,
    maxZ,
    bounds,
    // num. of worlds from the center. For repeated maps
    offset: 0
  };
  root2.update(traversalParams);
  if (viewport instanceof web_mercator_viewport_default && viewport.subViewports && viewport.subViewports.length > 1) {
    traversalParams.offset = -1;
    while (root2.update(traversalParams)) {
      if (--traversalParams.offset < -MAX_MAPS) {
        break;
      }
    }
    traversalParams.offset = 1;
    while (root2.update(traversalParams)) {
      if (++traversalParams.offset > MAX_MAPS) {
        break;
      }
    }
  }
  return root2.getSelected();
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js
var TILE_SIZE4 = 512;
var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
var urlType = {
  type: "object",
  value: null,
  validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
  equal: (value1, value2) => {
    if (value1 === value2) {
      return true;
    }
    if (!Array.isArray(value1) || !Array.isArray(value2)) {
      return false;
    }
    const len4 = value1.length;
    if (len4 !== value2.length) {
      return false;
    }
    for (let i3 = 0; i3 < len4; i3++) {
      if (value1[i3] !== value2[i3]) {
        return false;
      }
    }
    return true;
  }
};
function transformBox(bbox, modelMatrix) {
  const transformedCoords = [
    // top-left
    modelMatrix.transformAsPoint([bbox[0], bbox[1]]),
    // top-right
    modelMatrix.transformAsPoint([bbox[2], bbox[1]]),
    // bottom-left
    modelMatrix.transformAsPoint([bbox[0], bbox[3]]),
    // bottom-right
    modelMatrix.transformAsPoint([bbox[2], bbox[3]])
  ];
  const transformedBox = [
    // Minimum x coord
    Math.min(...transformedCoords.map((i3) => i3[0])),
    // Minimum y coord
    Math.min(...transformedCoords.map((i3) => i3[1])),
    // Max x coord
    Math.max(...transformedCoords.map((i3) => i3[0])),
    // Max y coord
    Math.max(...transformedCoords.map((i3) => i3[1]))
  ];
  return transformedBox;
}
function stringHash(s2) {
  return Math.abs(s2.split("").reduce((a2, b2) => (a2 << 5) - a2 + b2.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
  if (!template || !template.length) {
    return null;
  }
  const { index, id } = tile;
  if (Array.isArray(template)) {
    const i3 = stringHash(id) % template.length;
    template = template[i3];
  }
  let url = template;
  for (const key of Object.keys(index)) {
    const regex = new RegExp(`{${key}}`, "g");
    url = url.replace(regex, String(index[key]));
  }
  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
  }
  return url;
}
function getBoundingBox2(viewport, zRange, extent) {
  let bounds;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({ z: minZ });
    const bounds1 = viewport.getBounds({ z: maxZ });
    bounds = [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  } else {
    bounds = viewport.getBounds();
  }
  if (!viewport.isGeospatial) {
    return [
      // Top corner should not be more then bottom corner in either direction
      Math.max(Math.min(bounds[0], extent[2]), extent[0]),
      Math.max(Math.min(bounds[1], extent[3]), extent[1]),
      // Bottom corner should not be less then top corner in either direction
      Math.min(Math.max(bounds[2], extent[0]), extent[2]),
      Math.min(Math.max(bounds[3], extent[1]), extent[3])
    ];
  }
  return [
    Math.max(bounds[0], extent[0]),
    Math.max(bounds[1], extent[1]),
    Math.min(bounds[2], extent[2]),
    Math.min(bounds[3], extent[3])
  ];
}
function getCullBounds({ viewport, z: z2, cullRect }) {
  const subViewports = viewport.subViewports || [viewport];
  return subViewports.map((v2) => getCullBoundsInViewport(v2, z2 || 0, cullRect));
}
function getCullBoundsInViewport(viewport, z2, cullRect) {
  if (!Array.isArray(z2)) {
    const x2 = cullRect.x - viewport.x;
    const y2 = cullRect.y - viewport.y;
    const { width, height } = cullRect;
    const unprojectOption = { targetZ: z2 };
    const topLeft = viewport.unproject([x2, y2], unprojectOption);
    const topRight = viewport.unproject([x2 + width, y2], unprojectOption);
    const bottomLeft = viewport.unproject([x2, y2 + height], unprojectOption);
    const bottomRight = viewport.unproject([x2 + width, y2 + height], unprojectOption);
    return [
      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
    ];
  }
  const bounds0 = getCullBoundsInViewport(viewport, z2[0], cullRect);
  const bounds1 = getCullBoundsInViewport(viewport, z2[1], cullRect);
  return [
    Math.min(bounds0[0], bounds1[0]),
    Math.min(bounds0[1], bounds1[1]),
    Math.max(bounds0[2], bounds1[2]),
    Math.max(bounds0[3], bounds1[3])
  ];
}
function getIndexingCoords(bbox, scale7, modelMatrixInverse) {
  if (modelMatrixInverse) {
    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i3) => i3 * scale7 / TILE_SIZE4);
    return transformedTileIndex;
  }
  return bbox.map((i3) => i3 * scale7 / TILE_SIZE4);
}
function getScale2(z2, tileSize) {
  return Math.pow(2, z2) * TILE_SIZE4 / tileSize;
}
function osmTile2lngLat(x2, y2, z2) {
  const scale7 = getScale2(z2, TILE_SIZE4);
  const lng = x2 / scale7 * 360 - 180;
  const n2 = Math.PI - 2 * Math.PI * y2 / scale7;
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2)));
  return [lng, lat];
}
function tile2XY(x2, y2, z2, tileSize) {
  const scale7 = getScale2(z2, tileSize);
  return [x2 / scale7 * TILE_SIZE4, y2 / scale7 * TILE_SIZE4];
}
function tileToBoundingBox(viewport, x2, y2, z2, tileSize = TILE_SIZE4) {
  if (viewport.isGeospatial) {
    const [west, north] = osmTile2lngLat(x2, y2, z2);
    const [east, south] = osmTile2lngLat(x2 + 1, y2 + 1, z2);
    return { west, north, east, south };
  }
  const [left, top] = tile2XY(x2, y2, z2, tileSize);
  const [right, bottom] = tile2XY(x2 + 1, y2 + 1, z2, tileSize);
  return { left, top, right, bottom };
}
function getIdentityTileIndices(viewport, z2, tileSize, extent, modelMatrixInverse) {
  const bbox = getBoundingBox2(viewport, null, extent);
  const scale7 = getScale2(z2, tileSize);
  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale7, modelMatrixInverse);
  const indices = [];
  for (let x2 = Math.floor(minX); x2 < maxX; x2++) {
    for (let y2 = Math.floor(minY); y2 < maxY; y2++) {
      indices.push({ x: x2, y: y2, z: z2 });
    }
  }
  return indices;
}
function getTileIndices({ viewport, maxZoom, minZoom, zRange, extent, tileSize = TILE_SIZE4, modelMatrix, modelMatrixInverse, zoomOffset = 0 }) {
  let z2 = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE4 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
  if (typeof minZoom === "number" && Number.isFinite(minZoom) && z2 < minZoom) {
    if (!extent) {
      return [];
    }
    z2 = minZoom;
  }
  if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z2 > maxZoom) {
    z2 = maxZoom;
  }
  let transformedExtent = extent;
  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {
    transformedExtent = transformBox(extent, modelMatrix);
  }
  return viewport.isGeospatial ? getOSMTileIndices(viewport, z2, zRange, extent) : getIdentityTileIndices(viewport, z2, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual2(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
function isEqual2(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (Array.isArray(a2)) {
    const len4 = a2.length;
    if (!b2 || b2.length !== len4) {
      return false;
    }
    for (let i3 = 0; i3 < len4; i3++) {
      if (a2[i3] !== b2[i3]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js
var TILE_STATE_VISITED = 1;
var TILE_STATE_VISIBLE = 2;
var STRATEGY_NEVER = "never";
var STRATEGY_REPLACE = "no-overlap";
var STRATEGY_DEFAULT = "best-available";
var DEFAULT_CACHE_SCALE = 5;
var STRATEGIES = {
  [STRATEGY_DEFAULT]: updateTileStateDefault,
  [STRATEGY_REPLACE]: updateTileStateReplace,
  [STRATEGY_NEVER]: () => {
  }
};
var DEFAULT_TILESET2D_PROPS = {
  extent: null,
  tileSize: 512,
  maxZoom: null,
  minZoom: null,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: "best-available",
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0,
  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  }
};
var Tileset2D = class {
  /**
   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
   * Cache size defaults to 5 * number of tiles in the current viewport
   */
  constructor(opts) {
    this._getCullBounds = memoize2(getCullBounds);
    this.opts = { ...DEFAULT_TILESET2D_PROPS, ...opts };
    this.setOptions(this.opts);
    this.onTileLoad = (tile) => {
      this.opts.onTileLoad?.(tile);
      if (this.opts.maxCacheByteSize !== null) {
        this._cacheByteSize += tile.byteLength;
        this._resizeCache();
      }
    };
    this._requestScheduler = new RequestScheduler({
      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
      maxRequests: this.opts.maxRequests,
      debounceTime: this.opts.debounceTime
    });
    this._cache = /* @__PURE__ */ new Map();
    this._tiles = [];
    this._dirty = false;
    this._cacheByteSize = 0;
    this._viewport = null;
    this._zRange = null;
    this._selectedTiles = null;
    this._frameNumber = 0;
    this._modelMatrix = new Matrix4();
    this._modelMatrixInverse = new Matrix4();
  }
  /* Public API */
  get tiles() {
    return this._tiles;
  }
  get selectedTiles() {
    return this._selectedTiles;
  }
  get isLoaded() {
    return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
  }
  get needsReload() {
    return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
  }
  setOptions(opts) {
    Object.assign(this.opts, opts);
    if (Number.isFinite(opts.maxZoom)) {
      this._maxZoom = Math.floor(opts.maxZoom);
    }
    if (Number.isFinite(opts.minZoom)) {
      this._minZoom = Math.ceil(opts.minZoom);
    }
  }
  // Clean up any outstanding tile requests.
  finalize() {
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        tile.abort();
      }
    }
    this._cache.clear();
    this._tiles = [];
    this._selectedTiles = null;
  }
  reloadAll() {
    for (const id of this._cache.keys()) {
      const tile = this._cache.get(id);
      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
        this._cache.delete(id);
      } else {
        tile.setNeedsReload();
      }
    }
  }
  /**
   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
   */
  update(viewport, { zRange, modelMatrix } = {
    zRange: null,
    modelMatrix: null
  }) {
    const modelMatrixAsMatrix4 = modelMatrix ? new Matrix4(modelMatrix) : new Matrix4();
    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
      if (isModelMatrixNew) {
        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
        this._modelMatrix = modelMatrixAsMatrix4;
      }
      this._viewport = viewport;
      this._zRange = zRange;
      const tileIndices = this.getTileIndices({
        viewport,
        maxZoom: this._maxZoom,
        minZoom: this._minZoom,
        zRange,
        modelMatrix: this._modelMatrix,
        modelMatrixInverse: this._modelMatrixInverse
      });
      this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
      if (this._dirty) {
        this._rebuildTree();
      }
    } else if (this.needsReload) {
      this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
    }
    const changed = this.updateTileStates();
    this._pruneRequests();
    if (this._dirty) {
      this._resizeCache();
    }
    if (changed) {
      this._frameNumber++;
    }
    return this._frameNumber;
  }
  // eslint-disable-next-line complexity
  isTileVisible(tile, cullRect) {
    if (!tile.isVisible) {
      return false;
    }
    if (cullRect && this._viewport) {
      const boundsArr = this._getCullBounds({
        viewport: this._viewport,
        z: this._zRange,
        cullRect
      });
      const { bbox } = tile;
      for (const [minX, minY, maxX, maxY] of boundsArr) {
        let overlaps;
        if ("west" in bbox) {
          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
        } else {
          const y0 = Math.min(bbox.top, bbox.bottom);
          const y1 = Math.max(bbox.top, bbox.bottom);
          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
        }
        if (overlaps) {
          return true;
        }
      }
      return false;
    }
    return true;
  }
  /* Public interface for subclassing */
  /** Returns array of tile indices in the current viewport */
  getTileIndices({ viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse }) {
    const { tileSize, extent, zoomOffset } = this.opts;
    return getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      tileSize,
      extent,
      modelMatrix,
      modelMatrixInverse,
      zoomOffset
    });
  }
  /** Returns unique string key for a tile index */
  getTileId(index) {
    return `${index.x}-${index.y}-${index.z}`;
  }
  /** Returns a zoom level for a tile index */
  getTileZoom(index) {
    return index.z;
  }
  /** Returns additional metadata to add to tile, bbox by default */
  getTileMetadata(index) {
    const { tileSize } = this.opts;
    return { bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize) };
  }
  /** Returns index of the parent tile */
  getParentIndex(index) {
    const x2 = Math.floor(index.x / 2);
    const y2 = Math.floor(index.y / 2);
    const z2 = index.z - 1;
    return { x: x2, y: y2, z: z2 };
  }
  // Returns true if any tile's visibility changed
  updateTileStates() {
    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
    const visibilities = new Array(this._cache.size);
    let i3 = 0;
    for (const tile of this._cache.values()) {
      visibilities[i3++] = tile.isVisible;
      tile.isSelected = false;
      tile.isVisible = false;
    }
    for (const tile of this._selectedTiles) {
      tile.isSelected = true;
      tile.isVisible = true;
    }
    (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
    i3 = 0;
    for (const tile of this._cache.values()) {
      if (visibilities[i3++] !== tile.isVisible) {
        return true;
      }
    }
    return false;
  }
  _pruneRequests() {
    const { maxRequests = 0 } = this.opts;
    const abortCandidates = [];
    let ongoingRequestCount = 0;
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        ongoingRequestCount++;
        if (!tile.isSelected && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abort();
      ongoingRequestCount--;
    }
  }
  // This needs to be called every time some tiles have been added/removed from cache
  _rebuildTree() {
    const { _cache } = this;
    for (const tile of _cache.values()) {
      tile.parent = null;
      if (tile.children) {
        tile.children.length = 0;
      }
    }
    for (const tile of _cache.values()) {
      const parent = this._getNearestAncestor(tile);
      tile.parent = parent;
      if (parent?.children) {
        parent.children.push(tile);
      }
    }
  }
  /**
   * Clear tiles that are not visible when the cache is full
   */
  /* eslint-disable complexity */
  _resizeCache() {
    const { _cache, opts } = this;
    const maxCacheSize = opts.maxCacheSize ?? // @ts-expect-error called only when selectedTiles is initialized
    (opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
    const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;
    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
    if (overflown) {
      for (const [id, tile] of _cache) {
        if (!tile.isVisible && !tile.isSelected) {
          this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;
          _cache.delete(id);
          this.opts.onTileUnload?.(tile);
        }
        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
          break;
        }
      }
      this._rebuildTree();
      this._dirty = true;
    }
    if (this._dirty) {
      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
      this._dirty = false;
    }
  }
  _getTile(index, create7) {
    const id = this.getTileId(index);
    let tile = this._cache.get(id);
    let needsReload = false;
    if (!tile && create7) {
      tile = new Tile2DHeader(index);
      Object.assign(tile, this.getTileMetadata(tile.index));
      Object.assign(tile, { id, zoom: this.getTileZoom(tile.index) });
      needsReload = true;
      this._cache.set(id, tile);
      this._dirty = true;
    } else if (tile && tile.needsReload) {
      needsReload = true;
    }
    if (tile && needsReload) {
      tile.loadData({
        getData: this.opts.getTileData,
        requestScheduler: this._requestScheduler,
        onLoad: this.onTileLoad,
        onError: this.opts.onTileError
      });
    }
    return tile;
  }
  _getNearestAncestor(tile) {
    const { _minZoom = 0 } = this;
    let index = tile.index;
    while (this.getTileZoom(index) > _minZoom) {
      index = this.getParentIndex(index);
      const parent = this._getTile(index);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};
function updateTileStateDefault(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  }
  for (const tile of allTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
  }
}
function updateTileStateReplace(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected) {
      getPlaceholderInAncestors(tile);
    }
  }
  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
  for (const tile of sortedTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
      for (const child of tile.children) {
        child.state = TILE_STATE_VISITED;
      }
    } else if (tile.isSelected) {
      getPlaceholderInChildren(tile);
    }
  }
}
function getPlaceholderInAncestors(startTile) {
  let tile = startTile;
  while (tile) {
    if (tile.isLoaded || tile.content) {
      tile.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  for (const child of tile.children) {
    if (child.isLoaded || child.content) {
      child.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  }
}

// node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js
var defaultProps15 = {
  TilesetClass: Tileset2D,
  data: { type: "data", value: [] },
  dataComparator: urlType.equal,
  renderSubLayers: { type: "function", value: (props) => new geojson_layer_default(props) },
  getTileData: { type: "function", optional: true, value: null },
  // TODO - change to onViewportLoad to align with Tile3DLayer
  onViewportLoad: { type: "function", optional: true, value: null },
  onTileLoad: { type: "function", value: (tile) => {
  } },
  onTileUnload: { type: "function", value: (tile) => {
  } },
  // eslint-disable-next-line
  onTileError: { type: "function", value: (err2) => console.error(err2) },
  extent: { type: "array", optional: true, value: null, compare: true },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: STRATEGY_DEFAULT,
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0
};
var TileLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      tileset: null,
      isLoaded: false
    };
  }
  finalizeState() {
    this.state?.tileset?.finalize();
  }
  get isLoaded() {
    return Boolean(this.state?.tileset?.selectedTiles?.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded)));
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState({ changeFlags }) {
    let { tileset } = this.state;
    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
    if (!tileset) {
      tileset = new this.props.TilesetClass(this._getTilesetOptions());
      this.setState({ tileset });
    } else if (propsChanged) {
      tileset.setOptions(this._getTilesetOptions());
      if (dataChanged) {
        tileset.reloadAll();
      } else {
        tileset.tiles.forEach((tile) => {
          tile.layers = null;
        });
      }
    }
    this._updateTileset();
  }
  _getTilesetOptions() {
    const { tileSize, maxCacheSize, maxCacheByteSize, refinementStrategy, extent, maxZoom, minZoom, maxRequests, debounceTime, zoomOffset } = this.props;
    return {
      maxCacheSize,
      maxCacheByteSize,
      maxZoom,
      minZoom,
      tileSize,
      refinementStrategy,
      extent,
      maxRequests,
      debounceTime,
      zoomOffset,
      getTileData: this.getTileData.bind(this),
      onTileLoad: this._onTileLoad.bind(this),
      onTileError: this._onTileError.bind(this),
      onTileUnload: this._onTileUnload.bind(this)
    };
  }
  _updateTileset() {
    const tileset = this.state.tileset;
    const { zRange, modelMatrix } = this.props;
    const frameNumber = tileset.update(this.context.viewport, { zRange, modelMatrix });
    const { isLoaded } = tileset;
    const loadingStateChanged = this.state.isLoaded !== isLoaded;
    const tilesetChanged = this.state.frameNumber !== frameNumber;
    if (isLoaded && (loadingStateChanged || tilesetChanged)) {
      this._onViewportLoad();
    }
    if (tilesetChanged) {
      this.setState({ frameNumber });
    }
    this.state.isLoaded = isLoaded;
  }
  _onViewportLoad() {
    const { tileset } = this.state;
    const { onViewportLoad } = this.props;
    if (onViewportLoad) {
      onViewportLoad(tileset.selectedTiles);
    }
  }
  _onTileLoad(tile) {
    this.props.onTileLoad(tile);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileError(error, tile) {
    this.props.onTileError(error);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileUnload(tile) {
    this.props.onTileUnload(tile);
  }
  // Methods for subclass to override
  getTileData(tile) {
    const { data, getTileData, fetch: fetch2 } = this.props;
    const { signal } = tile;
    tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
    if (getTileData) {
      return getTileData(tile);
    }
    if (fetch2 && tile.url) {
      return fetch2(tile.url, { propName: "data", layer: this, signal });
    }
    return null;
  }
  renderSubLayers(props) {
    return this.props.renderSubLayers(props);
  }
  getSubLayerPropsByTile(tile) {
    return null;
  }
  getPickingInfo(params) {
    const sourceLayer = params.sourceLayer;
    const sourceTile = sourceLayer.props.tile;
    const info = params.info;
    if (info.picked) {
      info.tile = sourceTile;
    }
    info.sourceTile = sourceTile;
    info.sourceTileSubLayer = sourceLayer;
    return info;
  }
  _updateAutoHighlight(info) {
    info.sourceTileSubLayer.updateAutoHighlight(info);
  }
  renderLayers() {
    return this.state.tileset.tiles.map((tile) => {
      const subLayerProps = this.getSubLayerPropsByTile(tile);
      if (!tile.isLoaded && !tile.content) {
      } else if (!tile.layers) {
        const layers = this.renderSubLayers({
          ...this.props,
          ...this.getSubLayerProps({
            id: tile.id,
            updateTriggers: this.props.updateTriggers
          }),
          data: tile.content,
          _offset: 0,
          tile
        });
        tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
          tile,
          ...subLayerProps
        }));
      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
        tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
      }
      return tile.layers;
    });
  }
  filterSubLayer({ layer, cullRect }) {
    const { tile } = layer.props;
    return this.state.tileset.isTileVisible(tile, cullRect);
  }
};
TileLayer.defaultProps = defaultProps15;
TileLayer.layerName = "TileLayer";
var tile_layer_default = TileLayer;

// node_modules/@vivjs/layers/dist/index.mjs
function range2(len4) {
  return [...Array(len4).keys()];
}
function padWithDefault2(arr, defaultValue, padWidth) {
  for (let i3 = 0; i3 < padWidth; i3 += 1) {
    arr.push(defaultValue);
  }
  return arr;
}
function getDtypeValues(dtype) {
  const normalizedDtype = dtype.charAt(0).toUpperCase() + dtype.slice(1).toLowerCase();
  const values = DTYPE_VALUES[normalizedDtype];
  if (!values) {
    const valid = Object.keys(DTYPE_VALUES);
    throw Error(`Dtype not supported, got ${dtype}. Must be one of ${valid}.`);
  }
  return values;
}
function padContrastLimits({
  contrastLimits = [],
  channelsVisible,
  domain,
  dtype
}) {
  const maxSliderValue = domain?.[1] || getDtypeValues(dtype).max;
  const newContrastLimits = contrastLimits.map(
    (slider, i3) => channelsVisible[i3] ? slider : (
      /** @type {[number, number]} */
      [maxSliderValue, maxSliderValue]
    )
  );
  const padSize = MAX_CHANNELS - newContrastLimits.length;
  if (padSize < 0) {
    throw Error(
      `${newContrastLimits.lengths} channels passed in, but only 6 are allowed.`
    );
  }
  const paddedContrastLimits = padWithDefault2(
    newContrastLimits,
    [maxSliderValue, maxSliderValue],
    padSize
  ).reduce((acc, val) => acc.concat(val), []);
  return paddedContrastLimits;
}
function getPhysicalSizeScalingMatrix(loader) {
  const { x: x2, y: y2, z: z2 } = loader?.meta?.physicalSizes ?? {};
  if (x2?.size && y2?.size && z2?.size) {
    const min4 = Math.min(z2.size, x2.size, y2.size);
    const ratio = [x2.size / min4, y2.size / min4, z2.size / min4];
    return new Matrix4().scale(ratio);
  }
  return new Matrix4().identity();
}
function makeBoundingBox(viewState) {
  const viewport = new orthographic_view_default().makeViewport({
    // From the current `detail` viewState, we need its projection matrix (actually the inverse).
    viewState,
    height: viewState.height,
    width: viewState.width
  });
  return [
    viewport.unproject([0, 0]),
    viewport.unproject([viewport.width, 0]),
    viewport.unproject([viewport.width, viewport.height]),
    viewport.unproject([0, viewport.height])
  ];
}
var TARGETS = [1, 2, 3, 4, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1e3];
var MIN_TARGET = TARGETS[0];
var MAX_TARGET = TARGETS[TARGETS.length - 1];
var SI_PREFIXES = [
  { symbol: "Y", exponent: 24 },
  { symbol: "Z", exponent: 21 },
  { symbol: "E", exponent: 18 },
  { symbol: "P", exponent: 15 },
  { symbol: "T", exponent: 12 },
  { symbol: "G", exponent: 9 },
  { symbol: "M", exponent: 6 },
  { symbol: "k", exponent: 3 },
  { symbol: "h", exponent: 2 },
  { symbol: "da", exponent: 1 },
  { symbol: "", exponent: 0 },
  { symbol: "d", exponent: -1 },
  { symbol: "c", exponent: -2 },
  { symbol: "m", exponent: -3 },
  { symbol: "\xB5", exponent: -6 },
  { symbol: "n", exponent: -9 },
  { symbol: "p", exponent: -12 },
  { symbol: "f", exponent: -15 },
  { symbol: "a", exponent: -18 },
  { symbol: "z", exponent: -21 },
  { symbol: "y", exponent: -24 }
];
function sizeToMeters(size, unit) {
  if (!unit || unit === "m") {
    return size;
  }
  if (unit.length > 1) {
    let unitPrefix = unit.substring(0, unit.length - 1);
    if (unitPrefix === "u") {
      unitPrefix = "\xB5";
    }
    const unitObj = SI_PREFIXES.find((p2) => p2.symbol === unitPrefix);
    if (unitObj) {
      return size * 10 ** unitObj.exponent;
    }
  }
  throw new Error("Received unknown unit");
}
function snapValue(value) {
  let magnitude = 0;
  if (value < MIN_TARGET || value > MAX_TARGET) {
    magnitude = Math.floor(Math.log10(value));
  }
  let snappedUnit = SI_PREFIXES.find(
    (p2) => p2.exponent % 3 === 0 && p2.exponent <= magnitude
  );
  let adjustedValue = value / 10 ** snappedUnit.exponent;
  if (adjustedValue > 500 && adjustedValue <= 1e3) {
    snappedUnit = SI_PREFIXES.find(
      (p2) => p2.exponent % 3 === 0 && p2.exponent <= magnitude + 3
    );
    adjustedValue = value / 10 ** snappedUnit.exponent;
  }
  const targetNewUnits = TARGETS.find((t2) => t2 > adjustedValue);
  const targetOrigUnits = targetNewUnits * 10 ** snappedUnit.exponent;
  return [targetOrigUnits, targetNewUnits, snappedUnit.symbol];
}
function addAlpha(array) {
  if (!(array instanceof Uint8Array)) {
    throw new Error("Expected Uint8Array");
  }
  const alphaArray = new Uint8Array(array.length + array.length / 3);
  for (let i3 = 0; i3 < array.length / 3; i3 += 1) {
    alphaArray[i3 * 4] = array[i3 * 3];
    alphaArray[i3 * 4 + 1] = array[i3 * 3 + 1];
    alphaArray[i3 * 4 + 2] = array[i3 * 3 + 2];
    alphaArray[i3 * 4 + 3] = 255;
  }
  return alphaArray;
}
var PHOTOMETRIC_INTERPRETATIONS = {
  WhiteIsZero: 0,
  BlackIsZero: 1,
  RGB: 2,
  Palette: 3,
  TransparencyMask: 4,
  CMYK: 5,
  YCbCr: 6,
  CIELab: 8,
  ICCLab: 9
};
var defaultProps$8 = {
  ...bitmap_layer_default.defaultProps,
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN
};
var getPhotometricInterpretationShader = (photometricInterpretation, transparentColorInHook) => {
  const useTransparentColor = transparentColorInHook ? "true" : "false";
  const transparentColorVector = `vec3(${(transparentColorInHook || [0, 0, 0]).map((i3) => String(i3 / 255)).join(",")})`;
  switch (photometricInterpretation) {
    case PHOTOMETRIC_INTERPRETATIONS.RGB:
      return `color[3] = (${useTransparentColor} && (color.rgb == ${transparentColorVector})) ? 0.0 : color.a;`;
    case PHOTOMETRIC_INTERPRETATIONS.WhiteIsZero:
      return `          float value = 1.0 - (color.r / 256.0);
          color = vec4(value, value, value, (${useTransparentColor} && vec3(value, value, value) == ${transparentColorVector}) ? 0.0 : color.a);
        `;
    case PHOTOMETRIC_INTERPRETATIONS.BlackIsZero:
      return `          float value = (color.r / 256.0);
          color = vec4(value, value, value, (${useTransparentColor} && vec3(value, value, value) == ${transparentColorVector}) ? 0.0 : color.a);
        `;
    case PHOTOMETRIC_INTERPRETATIONS.YCbCr:
      return `          float y = color[0];
          float cb = color[1];
          float cr = color[2];
          color[0] = (y + (1.40200 * (cr - .5)));
          color[1] = (y - (0.34414 * (cb - .5)) - (0.71414 * (cr - .5)));
          color[2] = (y + (1.77200 * (cb - .5)));
          color[3] = (${useTransparentColor} && distance(color.rgb, ${transparentColorVector}) < 0.01) ? 0.0 : color.a;
        `;
    default:
      console.error(
        "Unsupported photometric interpretation or none provided.  No transformation will be done to image data"
      );
      return "";
  }
};
var getTransparentColor = (photometricInterpretation) => {
  switch (photometricInterpretation) {
    case PHOTOMETRIC_INTERPRETATIONS.RGB:
      return [0, 0, 0, 0];
    case PHOTOMETRIC_INTERPRETATIONS.WhiteIsZero:
      return [255, 255, 255, 0];
    case PHOTOMETRIC_INTERPRETATIONS.BlackIsZero:
      return [0, 0, 0, 0];
    case PHOTOMETRIC_INTERPRETATIONS.YCbCr:
      return [16, 128, 128, 0];
    default:
      console.error(
        "Unsupported photometric interpretation or none provided.  No transformation will be done to image data"
      );
      return [0, 0, 0, 0];
  }
};
var BitmapLayerWrapper = class extends bitmap_layer_default {
  _getModel(gl) {
    const { photometricInterpretation, transparentColorInHook } = this.props;
    const photometricInterpretationShader = getPhotometricInterpretationShader(
      photometricInterpretation,
      transparentColorInHook
    );
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-list",
      isInstanced: false,
      inject: {
        "fs:DECKGL_FILTER_COLOR": photometricInterpretationShader
      }
    });
  }
};
var BitmapLayer2 = class extends composite_layer_default {
  initializeState(args) {
    const { device } = this.context;
    device.setParametersWebGL({
      [GLEnum.UNPACK_ALIGNMENT]: 1,
      [GLEnum.PACK_ALIGNMENT]: 1
    });
    super.initializeState(args);
  }
  renderLayers() {
    const {
      photometricInterpretation,
      transparentColor: transparentColorInHook
    } = this.props;
    const transparentColor = getTransparentColor(photometricInterpretation);
    this.props.image.data = addAlpha(this.props.image.data);
    return new BitmapLayerWrapper(this.props, {
      // transparentColor is a prop applied to the original image data by deck.gl's
      // BitmapLayer and needs to be in the original colorspace.  It is used to determine
      // what color is "transparent" in the original color space (i.e what shows when opacity is 0).
      transparentColor,
      // This is our transparentColor props which needs to be applied in the hook that converts to the RGB space.
      transparentColorInHook,
      id: `${this.props.id}-wrapped`
    });
  }
};
BitmapLayer2.layerName = "BitmapLayer";
BitmapLayer2.PHOTOMETRIC_INTERPRETATIONS = PHOTOMETRIC_INTERPRETATIONS;
BitmapLayer2.defaultProps = {
  ...defaultProps$8,
  // We don't want this layer to bind the texture so the type should not be `image`.
  image: { type: "object", value: {}, compare: true },
  transparentColor: { type: "array", value: [0, 0, 0], compare: true },
  photometricInterpretation: { type: "number", value: 2, compare: true }
};
BitmapLayerWrapper.defaultProps = defaultProps$8;
BitmapLayerWrapper.layerName = "BitmapLayerWrapper";
var fs$2 = `float apply_contrast_limits(float intensity, vec2 contrastLimits) {
    return  max(0., (intensity - contrastLimits[0]) / max(0.0005, (contrastLimits[1] - contrastLimits[0])));
}
`;
var channels = {
  name: "channel-intensity",
  defines: {
    SAMPLER_TYPE: "usampler2D",
    COLORMAP_FUNCTION: ""
  },
  fs: fs$2
};
var fs$12 = `#version 300 es
#define SHADER_NAME xr-layer-fragment-shader

precision highp float;
precision highp int;
precision highp SAMPLER_TYPE;

// our texture
uniform SAMPLER_TYPE channel0;
uniform SAMPLER_TYPE channel1;
uniform SAMPLER_TYPE channel2;
uniform SAMPLER_TYPE channel3;
uniform SAMPLER_TYPE channel4;
uniform SAMPLER_TYPE channel5;

in vec2 vTexCoord;

// range
uniform vec2 contrastLimits[6];

out vec4 fragColor;

void main() {

  float intensity0 = float(texture(channel0, vTexCoord).r);
  DECKGL_PROCESS_INTENSITY(intensity0, contrastLimits[0], 0);
  float intensity1 = float(texture(channel1, vTexCoord).r);
  DECKGL_PROCESS_INTENSITY(intensity1, contrastLimits[1], 1);
  float intensity2 = float(texture(channel2, vTexCoord).r);
  DECKGL_PROCESS_INTENSITY(intensity2, contrastLimits[2], 2);
  float intensity3 = float(texture(channel3, vTexCoord).r);
  DECKGL_PROCESS_INTENSITY(intensity3, contrastLimits[3], 3);
  float intensity4 = float(texture(channel4, vTexCoord).r);
  DECKGL_PROCESS_INTENSITY(intensity4, contrastLimits[4], 4);
  float intensity5 = float(texture(channel5, vTexCoord).r);
  DECKGL_PROCESS_INTENSITY(intensity5, contrastLimits[5], 5);

  DECKGL_MUTATE_COLOR(fragColor, intensity0, intensity1, intensity2, intensity3, intensity4, intensity5, vTexCoord);


  geometry.uv = vTexCoord;
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
var vs$1 = `#version 300 es
#define SHADER_NAME xr-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;
in vec3 instancePickingColors;
out vec2 vTexCoord;

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;
  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  vTexCoord = texCoords;
  vec4 color = vec4(0.);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;
var coreShaderModule = { fs: fs$12, vs: vs$1 };
function getRenderingAttrs$1(dtype, interpolation) {
  const isLinear = interpolation === "linear";
  const values = getDtypeValues(isLinear ? "Float32" : dtype);
  return {
    shaderModule: coreShaderModule,
    filter: interpolation,
    cast: isLinear ? (data) => new Float32Array(data) : (data) => data,
    ...values
  };
}
var defaultProps$7 = {
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  channelData: { type: "object", value: {}, compare: true },
  bounds: { type: "array", value: [0, 0, 1, 1], compare: true },
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  dtype: { type: "string", value: "Uint16", compare: true },
  interpolation: {
    type: "string",
    value: "nearest",
    compare: true
  }
};
var XRLayer = class extends layer_default {
  /**
   * This function replaces `usampler` with `sampler` if the data is not an unsigned integer
   * and adds a standard ramp function default for DECKGL_PROCESS_INTENSITY.
   */
  getShaders() {
    const { dtype, interpolation } = this.props;
    const { shaderModule, sampler } = getRenderingAttrs$1(dtype, interpolation);
    const extensionDefinesDeckglProcessIntensity = this._isHookDefinedByExtensions("fs:DECKGL_PROCESS_INTENSITY");
    const newChannelsModule = { ...channels, inject: {} };
    if (!extensionDefinesDeckglProcessIntensity) {
      newChannelsModule.inject["fs:DECKGL_PROCESS_INTENSITY"] = `
        intensity = apply_contrast_limits(intensity, contrastLimits);
      `;
    }
    return super.getShaders({
      ...shaderModule,
      defines: {
        SAMPLER_TYPE: sampler
      },
      modules: [project32_default, picking_default, newChannelsModule]
    });
  }
  _isHookDefinedByExtensions(hookName) {
    const { extensions } = this.props;
    return extensions?.some((e2) => {
      const shaders = e2.getShaders();
      const { inject = {}, modules = [] } = shaders;
      const definesInjection = inject[hookName];
      const moduleDefinesInjection = modules.some((m2) => m2?.inject[hookName]);
      return definesInjection || moduleDefinesInjection;
    });
  }
  /**
   * This function initializes the internal state.
   */
  initializeState() {
    const { device } = this.context;
    device.setParametersWebGL({
      [GLEnum.UNPACK_ALIGNMENT]: 1,
      [GLEnum.PACK_ALIGNMENT]: 1
    });
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        update: this.calculatePositions,
        noAlloc: true
      }
    });
    this.setState({
      numInstances: 1,
      positions: new Float64Array(12)
    });
    const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();
    const mutateStr = "fs:DECKGL_MUTATE_COLOR(inout vec4 rgba, float intensity0, float intensity1, float intensity2, float intensity3, float intensity4, float intensity5, vec2 vTexCoord)";
    const processStr = "fs:DECKGL_PROCESS_INTENSITY(inout float intensity, vec2 contrastLimits, int channelIndex)";
    if (!shaderAssembler._hookFunctions.includes(mutateStr)) {
      shaderAssembler.addShaderHook(mutateStr);
    }
    if (!shaderAssembler._hookFunctions.includes(processStr)) {
      shaderAssembler.addShaderHook(processStr);
    }
  }
  /**
   * This function finalizes state by clearing all textures from the WebGL context
   */
  finalizeState() {
    super.finalizeState();
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex?.delete());
    }
  }
  /**
   * This function updates state by retriggering model creation (shader compilation and attribute binding)
   * and loading any textures that need be loading.
   */
  updateState({ props, oldProps, changeFlags, ...rest }) {
    super.updateState({ props, oldProps, changeFlags, ...rest });
    if (changeFlags.extensionsChanged || props.interpolation !== oldProps.interpolation) {
      const { device } = this.context;
      if (this.state.model) {
        this.state.model.destroy();
      }
      this.setState({ model: this._getModel(device) });
      this.getAttributeManager().invalidateAll();
    }
    if (props.channelData !== oldProps.channelData && props.channelData?.data !== oldProps.channelData?.data || props.interpolation !== oldProps.interpolation) {
      this.loadChannelTextures(props.channelData);
    }
    const attributeManager = this.getAttributeManager();
    if (props.bounds !== oldProps.bounds) {
      attributeManager.invalidate("positions");
    }
  }
  /**
   * This function creates the luma.gl model.
   */
  _getModel(gl) {
    if (!gl) {
      return null;
    }
    return new Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new Geometry({
        topology: "triangle-list",
        vertexCount: 6,
        indices: new Uint16Array([0, 1, 3, 1, 2, 3]),
        attributes: {
          texCoords: {
            value: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]),
            size: 2
          }
        }
      }),
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      isInstanced: false
    });
  }
  /**
   * This function generates view positions for use as a vec3 in the shader
   */
  calculatePositions(attributes) {
    const { positions } = this.state;
    const { bounds } = this.props;
    positions[0] = bounds[0];
    positions[1] = bounds[1];
    positions[2] = 0;
    positions[3] = bounds[0];
    positions[4] = bounds[3];
    positions[5] = 0;
    positions[6] = bounds[2];
    positions[7] = bounds[3];
    positions[8] = 0;
    positions[9] = bounds[2];
    positions[10] = bounds[1];
    positions[11] = 0;
    attributes.value = positions;
  }
  /**
   * This function runs the shaders and draws to the canvas
   */
  draw(opts) {
    const { uniforms } = opts;
    const { textures, model } = this.state;
    if (textures && model) {
      const { contrastLimits, domain, dtype, channelsVisible } = this.props;
      const numTextures = Object.values(textures).filter((t2) => t2).length;
      const paddedContrastLimits = padContrastLimits({
        contrastLimits: contrastLimits.slice(0, numTextures),
        channelsVisible: channelsVisible.slice(0, numTextures),
        domain,
        dtype
      });
      model.setUniforms(
        {
          ...uniforms,
          contrastLimits: paddedContrastLimits
        },
        { disableWarnings: false }
      );
      model.setBindings(textures);
      model.draw(this.context.renderPass);
    }
  }
  /**
   * This function loads all channel textures from incoming resolved promises/data from the loaders by calling `dataToTexture`
   */
  loadChannelTextures(channelData) {
    const textures = {
      channel0: null,
      channel1: null,
      channel2: null,
      channel3: null,
      channel4: null,
      channel5: null
    };
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex?.delete());
    }
    if (channelData && Object.keys(channelData).length > 0 && channelData.data) {
      channelData.data.forEach((d2, i3) => {
        textures[`channel${i3}`] = this.dataToTexture(
          d2,
          channelData.width,
          channelData.height
        );
      }, this);
      for (const key in textures) {
        if (!textures.channel0)
          throw new Error("Bad texture state!");
        if (!textures[key])
          textures[key] = textures.channel0;
      }
      this.setState({ textures });
    }
  }
  /**
   * This function creates textures from the data
   */
  dataToTexture(data, width, height) {
    const { interpolation } = this.props;
    const attrs = getRenderingAttrs$1(this.props.dtype, interpolation);
    return this.context.device.createTexture({
      width,
      height,
      dimension: "2d",
      data: attrs.cast?.(data) ?? data,
      // we don't want or need mimaps
      mipmaps: false,
      sampler: {
        // NEAREST for integer data
        minFilter: attrs.filter,
        magFilter: attrs.filter,
        // CLAMP_TO_EDGE to remove tile artifacts
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      format: attrs.format
    });
  }
};
XRLayer.layerName = "XRLayer";
XRLayer.defaultProps = defaultProps$7;
var defaultProps$6 = {
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  selections: { type: "array", value: [], compare: true },
  domain: { type: "array", value: [], compare: true },
  viewportId: { type: "string", value: "", compare: true },
  loader: {
    type: "object",
    value: {
      getRaster: async () => ({ data: [], height: 0, width: 0 }),
      dtype: "Uint16",
      shape: []
    },
    compare: true
  },
  onClick: { type: "function", value: null, compare: true },
  onViewportLoad: { type: "function", value: null, compare: true },
  interpolation: {
    type: "number",
    value: "nearest",
    compare: true
  },
  extensions: {
    type: "array",
    value: [new ColorPaletteExtension()],
    compare: true
  }
};
var ImageLayer = class extends composite_layer_default {
  finalizeState() {
    this.state.abortController.abort();
  }
  updateState({ props, oldProps }) {
    const loaderChanged = props.loader !== oldProps.loader;
    const selectionsChanged = props.selections !== oldProps.selections;
    if (loaderChanged || selectionsChanged) {
      const { loader, selections = [], onViewportLoad } = this.props;
      const abortController = new AbortController();
      this.setState({ abortController });
      const { signal } = abortController;
      const getRaster = (selection) => loader.getRaster({ selection, signal });
      const dataPromises = selections.map(getRaster);
      Promise.all(dataPromises).then((rasters) => {
        const raster = {
          data: rasters.map((d2) => d2.data),
          width: rasters[0]?.width,
          height: rasters[0]?.height
        };
        if (isInterleaved(loader.shape)) {
          raster.data = raster.data[0];
          if (raster.data.length === raster.width * raster.height * 3) {
            raster.format = "rgba8unorm";
          }
        }
        if (onViewportLoad) {
          onViewportLoad(raster);
        }
        this.setState({ ...raster });
      }).catch((e2) => {
        if (e2 !== SIGNAL_ABORTED) {
          throw e2;
        }
      });
    }
  }
  getPickingInfo({ info, sourceLayer }) {
    info.sourceLayer = sourceLayer;
    info.tile = sourceLayer.props.tile;
    return info;
  }
  renderLayers() {
    const { loader, id } = this.props;
    const { dtype } = loader;
    const { width, height, data } = this.state;
    if (!(width && height))
      return null;
    const bounds = [0, height, width, 0];
    if (isInterleaved(loader.shape)) {
      const { photometricInterpretation = 2 } = loader.meta;
      return new BitmapLayer2(this.props, {
        image: this.state,
        photometricInterpretation,
        // Shared props with XRLayer:
        bounds,
        id: `image-sub-layer-${bounds}-${id}`,
        extensions: []
      });
    }
    return new XRLayer(this.props, {
      channelData: { data, height, width },
      // Shared props with BitmapLayer:
      bounds,
      id: `image-sub-layer-${bounds}-${id}`,
      dtype
    });
  }
};
ImageLayer.layerName = "ImageLayer";
ImageLayer.defaultProps = defaultProps$6;
function renderSubLayers(props) {
  const {
    bbox: { left, top, right, bottom },
    index: { x: x2, y: y2, z: z2 }
  } = props.tile;
  const { data, id, loader, maxZoom } = props;
  if ([left, bottom, right, top].some((v2) => v2 < 0) || !data) {
    return null;
  }
  const base = loader[0];
  const { height, width } = getImageSize(base);
  const bounds = [
    left,
    data.height < base.tileSize ? height : bottom,
    data.width < base.tileSize ? width : right,
    top
  ];
  if (isInterleaved(base.shape)) {
    const { photometricInterpretation = 2 } = base.meta;
    return new BitmapLayer2(props, {
      image: data,
      photometricInterpretation,
      // Shared props with XRLayer:
      bounds,
      id: `tile-sub-layer-${bounds}-${id}`,
      tileId: { x: x2, y: y2, z: z2 },
      extensions: []
    });
  }
  return new XRLayer(props, {
    channelData: data,
    // Uncomment to help debugging - shades the tile being hovered over.
    // autoHighlight: true,
    // highlightColor: [80, 80, 80, 50],
    // Shared props with BitmapLayer:
    bounds,
    id: `tile-sub-layer-${bounds}-${id}`,
    tileId: { x: x2, y: y2, z: z2 },
    // The auto setting is NEAREST at the highest resolution but LINEAR otherwise.
    interpolation: z2 === maxZoom ? "nearest" : "linear"
  });
}
var defaultProps$5 = {
  pickable: { type: "boolean", value: true, compare: true },
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  renderSubLayers: { type: "function", value: renderSubLayers, compare: false },
  dtype: { type: "string", value: "Uint16", compare: true },
  domain: { type: "array", value: [], compare: true },
  viewportId: { type: "string", value: "", compare: true },
  interpolation: { type: "number", value: null, compare: true }
};
var MultiscaleImageLayerBase = class extends tile_layer_default {
  /**
   * This function allows us to controls which viewport gets to update the Tileset2D.
   * This is a uniquely TileLayer issue since it updates based on viewport updates thanks
   * to its ability to handle zoom-pan loading.  Essentially, with a picture-in-picture,
   * this prevents it from detecting the update of some other viewport that is unwanted.
   */
  _updateTileset() {
    if (!this.props.viewportId) {
      super._updateTileset();
    }
    if (this.props.viewportId && this.context.viewport.id === this.props.viewportId || // I don't know why, but DeckGL doesn't recognize multiple views on the first pass
    // so we force update on the first pass by checking if there is a viewport in the tileset.
    !this.state.tileset._viewport) {
      super._updateTileset();
    }
  }
};
MultiscaleImageLayerBase.layerName = "MultiscaleImageLayerBase";
MultiscaleImageLayerBase.defaultProps = defaultProps$5;
var defaultProps$42 = {
  pickable: { type: "boolean", value: true, compare: true },
  onHover: { type: "function", value: null, compare: false },
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  domain: { type: "array", value: [], compare: true },
  viewportId: { type: "string", value: "", compare: true },
  maxRequests: { type: "number", value: 10, compare: true },
  onClick: { type: "function", value: null, compare: true },
  refinementStrategy: { type: "string", value: null, compare: true },
  excludeBackground: { type: "boolean", value: false, compare: true },
  extensions: {
    type: "array",
    value: [new ColorPaletteExtension()],
    compare: true
  }
};
var MultiscaleImageLayer = class extends composite_layer_default {
  renderLayers() {
    const {
      loader,
      selections,
      opacity,
      viewportId,
      onTileError,
      onHover,
      id,
      onClick,
      modelMatrix,
      excludeBackground,
      refinementStrategy
    } = this.props;
    const { tileSize, dtype } = loader[0];
    const getTileData = async ({ index: { x: x2, y: y2, z: z2 }, signal }) => {
      if (!selections || selections.length === 0) {
        return null;
      }
      const resolution = Math.round(-z2);
      const getTile = (selection) => {
        const config2 = { x: x2, y: y2, selection, signal };
        return loader[resolution].getTile(config2);
      };
      try {
        const tiles = await Promise.all(selections.map(getTile));
        const tile = {
          data: tiles.map((d2) => d2.data),
          width: tiles[0].width,
          height: tiles[0].height
        };
        if (isInterleaved(loader[resolution].shape)) {
          tile.data = tile.data[0];
          if (tile.data.length === tile.width * tile.height * 3) {
            tile.format = "rgba8unorm";
          }
          return tile;
        }
        return tile;
      } catch (err2) {
        if (err2 === SIGNAL_ABORTED) {
          return null;
        }
        throw err2;
      }
    };
    const { height, width } = getImageSize(loader[0]);
    const tiledLayer = new MultiscaleImageLayerBase(this.props, {
      id: `Tiled-Image-${id}`,
      getTileData,
      dtype,
      tileSize,
      // If you scale a matrix up or down, that is like zooming in or out.  zoomOffset controls
      // how the zoom level you fetch tiles at is offset, allowing us to fetch higher resolution tiles
      // while at a lower "absolute" zoom level.  If you didn't use this prop, an image that is scaled
      // up would always look "low resolution" no matter the level of the image pyramid you are looking at.
      zoomOffset: Math.round(
        Math.log2(modelMatrix ? modelMatrix.getScale()[0] : 1)
      ),
      extent: [0, 0, width, height],
      // See the above note within for why the use of zoomOffset and the rounding necessary.
      minZoom: Math.round(-(loader.length - 1)),
      maxZoom: 0,
      // We want a no-overlap caching strategy with an opacity < 1 to prevent
      // multiple rendered sublayers (some of which have been cached) from overlapping
      refinementStrategy: refinementStrategy || (opacity === 1 ? "best-available" : "no-overlap"),
      // TileLayer checks `changeFlags.updateTriggersChanged.getTileData` to see if tile cache
      // needs to be re-created. We want to trigger this behavior if the loader changes.
      // https://github.com/uber/deck.gl/blob/3f67ea6dfd09a4d74122f93903cb6b819dd88d52/modules/geo-layers/src/tile-layer/tile-layer.js#L50
      updateTriggers: {
        getTileData: [loader, selections]
      },
      onTileError: onTileError || loader[0].onTileError
    });
    const lowestResolution = loader[loader.length - 1];
    const implementsGetRaster = typeof lowestResolution.getRaster === "function";
    const layerModelMatrix = modelMatrix ? modelMatrix.clone() : new Matrix4();
    const baseLayer = implementsGetRaster && !excludeBackground && new ImageLayer(this.props, {
      id: `Background-Image-${id}`,
      loader: lowestResolution,
      modelMatrix: layerModelMatrix.scale(2 ** (loader.length - 1)),
      visible: !viewportId || this.context.viewport.id === viewportId,
      onHover,
      onClick,
      // Background image is nicest when LINEAR in my opinion.
      interpolation: "linear",
      onViewportLoad: null
    });
    const layers = [baseLayer, tiledLayer];
    return layers;
  }
};
MultiscaleImageLayer.layerName = "MultiscaleImageLayer";
MultiscaleImageLayer.defaultProps = defaultProps$42;
var defaultProps$32 = {
  pickable: { type: "boolean", value: true, compare: true },
  loader: {
    type: "object",
    value: {
      getRaster: async () => ({ data: [], height: 0, width: 0 }),
      getRasterSize: () => ({ height: 0, width: 0 }),
      dtype: "<u2"
    },
    compare: true
  },
  id: { type: "string", value: "", compare: true },
  boundingBox: {
    type: "array",
    value: [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ],
    compare: true
  },
  boundingBoxColor: { type: "array", value: [255, 0, 0], compare: true },
  boundingBoxOutlineWidth: { type: "number", value: 1, compare: true },
  viewportOutlineColor: { type: "array", value: [255, 190, 0], compare: true },
  viewportOutlineWidth: { type: "number", value: 2, compare: true },
  overviewScale: { type: "number", value: 1, compare: true },
  zoom: { type: "number", value: 1, compare: true },
  extensions: {
    type: "array",
    value: [new ColorPaletteExtension()],
    compare: true
  }
};
var OverviewLayer = class extends composite_layer_default {
  renderLayers() {
    const {
      loader,
      id,
      zoom,
      boundingBox,
      boundingBoxColor,
      boundingBoxOutlineWidth,
      viewportOutlineColor,
      viewportOutlineWidth,
      overviewScale
    } = this.props;
    const { width, height } = getImageSize(loader[0]);
    const z2 = loader.length - 1;
    const lowestResolution = loader[z2];
    const overview = new ImageLayer(this.props, {
      id: `viewport-${id}`,
      modelMatrix: new Matrix4().scale(2 ** z2 * overviewScale),
      loader: lowestResolution
    });
    const boundingBoxOutline = new polygon_layer_default({
      id: `bounding-box-overview-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [boundingBox],
      getPolygon: (f2) => f2,
      filled: false,
      stroked: true,
      getLineColor: boundingBoxColor,
      getLineWidth: boundingBoxOutlineWidth * 2 ** zoom
    });
    const viewportOutline = new polygon_layer_default({
      id: `viewport-outline-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [0, 0],
          [width * overviewScale, 0],
          [width * overviewScale, height * overviewScale],
          [0, height * overviewScale]
        ]
      ],
      getPolygon: (f2) => f2,
      filled: false,
      stroked: true,
      getLineColor: viewportOutlineColor,
      getLineWidth: viewportOutlineWidth * 2 ** zoom
    });
    const layers = [overview, boundingBoxOutline, viewportOutline];
    return layers;
  }
};
OverviewLayer.layerName = "OverviewLayer";
OverviewLayer.defaultProps = defaultProps$32;
function getPosition2(boundingBox, position, length5) {
  const viewWidth = boundingBox[2][0] - boundingBox[0][0];
  const viewHeight = boundingBox[2][1] - boundingBox[0][1];
  switch (position) {
    case "bottom-right": {
      const yCoord = boundingBox[2][1] - viewHeight * length5;
      const xLeftCoord = boundingBox[2][0] - viewWidth * length5;
      return [yCoord, xLeftCoord];
    }
    case "top-right": {
      const yCoord = boundingBox[0][1] + viewHeight * length5;
      const xLeftCoord = boundingBox[2][0] - viewWidth * length5;
      return [yCoord, xLeftCoord];
    }
    case "top-left": {
      const yCoord = boundingBox[0][1] + viewHeight * length5;
      const xLeftCoord = boundingBox[0][0] + viewWidth * length5;
      return [yCoord, xLeftCoord];
    }
    case "bottom-left": {
      const yCoord = boundingBox[2][1] - viewHeight * length5;
      const xLeftCoord = boundingBox[0][0] + viewWidth * length5;
      return [yCoord, xLeftCoord];
    }
    default: {
      throw new Error(`Position ${position} not found`);
    }
  }
}
var defaultProps$22 = {
  pickable: { type: "boolean", value: true, compare: true },
  viewState: {
    type: "object",
    value: { zoom: 0, target: [0, 0, 0], width: 1, height: 1 },
    compare: true
  },
  unit: { type: "string", value: "", compare: true },
  size: { type: "number", value: 1, compare: true },
  position: { type: "string", value: "bottom-right", compare: true },
  length: { type: "number", value: 0.085, compare: true },
  snap: { type: "boolean", value: false, compare: true }
};
var ScaleBarLayer = class extends composite_layer_default {
  renderLayers() {
    const { id, unit, size, position, viewState, length: length5, snap } = this.props;
    const boundingBox = makeBoundingBox(viewState);
    const { zoom } = viewState;
    const viewLength = boundingBox[2][0] - boundingBox[0][0];
    const barLength = viewLength * 0.05;
    const barHeight = Math.max(
      2 ** (-zoom + 1.5),
      (boundingBox[2][1] - boundingBox[0][1]) * 7e-3
    );
    let adjustedBarLength = barLength;
    let displayNumber = (barLength * size).toPrecision(5);
    let displayUnit = unit;
    if (snap) {
      const meterSize = sizeToMeters(size, unit);
      const numUnits = barLength * meterSize;
      const [snappedOrigUnits, snappedNewUnits, snappedUnitPrefix] = snapValue(numUnits);
      adjustedBarLength = snappedOrigUnits / meterSize;
      displayNumber = snappedNewUnits;
      displayUnit = `${snappedUnitPrefix}m`;
    }
    const [yCoord, xLeftCoord] = getPosition2(boundingBox, position, length5);
    const xRightCoord = xLeftCoord + barLength;
    const isLeft = position.endsWith("-left");
    const lengthBar = new line_layer_default({
      id: `scale-bar-length-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [isLeft ? xLeftCoord : xRightCoord - adjustedBarLength, yCoord],
          [isLeft ? xLeftCoord + adjustedBarLength : xRightCoord, yCoord]
        ]
      ],
      getSourcePosition: (d2) => d2[0],
      getTargetPosition: (d2) => d2[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const tickBoundsLeft = new line_layer_default({
      id: `scale-bar-height-left-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [
            isLeft ? xLeftCoord : xRightCoord - adjustedBarLength,
            yCoord - barHeight
          ],
          [
            isLeft ? xLeftCoord : xRightCoord - adjustedBarLength,
            yCoord + barHeight
          ]
        ]
      ],
      getSourcePosition: (d2) => d2[0],
      getTargetPosition: (d2) => d2[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const tickBoundsRight = new line_layer_default({
      id: `scale-bar-height-right-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [
            isLeft ? xLeftCoord + adjustedBarLength : xRightCoord,
            yCoord - barHeight
          ],
          [
            isLeft ? xLeftCoord + adjustedBarLength : xRightCoord,
            yCoord + barHeight
          ]
        ]
      ],
      getSourcePosition: (d2) => d2[0],
      getTargetPosition: (d2) => d2[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const textLayer = new text_layer_default({
      id: `units-label-layer-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        {
          text: `${displayNumber}${displayUnit}`,
          position: [
            isLeft ? xLeftCoord + barLength * 0.5 : xRightCoord - barLength * 0.5,
            yCoord + barHeight * 4
          ]
        }
      ],
      getColor: [220, 220, 220, 255],
      getSize: 12,
      fontFamily: DEFAULT_FONT_FAMILY,
      sizeUnits: "meters",
      sizeScale: 2 ** -zoom,
      characterSet: [
        ...displayUnit.split(""),
        ...range2(10).map((i3) => String(i3)),
        ".",
        "e",
        "+"
      ]
    });
    return [lengthBar, tickBoundsLeft, tickBoundsRight, textLayer];
  }
};
ScaleBarLayer.layerName = "ScaleBarLayer";
ScaleBarLayer.defaultProps = defaultProps$22;
var fs6 = `#version 300 es
precision highp int;
precision highp float;
precision highp SAMPLER_TYPE;

uniform highp SAMPLER_TYPE volume0;
uniform highp SAMPLER_TYPE volume1;
uniform highp SAMPLER_TYPE volume2;
uniform highp SAMPLER_TYPE volume3;
uniform highp SAMPLER_TYPE volume4;
uniform highp SAMPLER_TYPE volume5;

uniform vec3 scaledDimensions;

uniform mat4 scale;

uniform vec3 normals[NUM_PLANES];
uniform float distances[NUM_PLANES];

// color
uniform vec3 colors[6];

// slices
uniform vec2 xSlice;
uniform vec2 ySlice;
uniform vec2 zSlice;

// range
uniform vec2 contrastLimits[6];

in vec3 vray_dir;
flat in vec3 transformed_eye;
out vec4 color;

vec2 intersect_box(vec3 orig, vec3 dir) {
	vec3 box_min = vec3(xSlice[0], ySlice[0], zSlice[0]);
	vec3 box_max = vec3(xSlice[1], ySlice[1], zSlice[1]);
	vec3 inv_dir = 1. / dir;
	vec3 tmin_tmp = (box_min - orig) * inv_dir;
	vec3 tmax_tmp = (box_max - orig) * inv_dir;
	vec3 tmin = min(tmin_tmp, tmax_tmp);
	vec3 tmax = max(tmin_tmp, tmax_tmp);
	float t0 = max(tmin.x, max(tmin.y, tmin.z));
  float t1 = min(tmax.x, min(tmax.y, tmax.z));
  vec2 val = vec2(t0, t1);
	return val;
}

float linear_to_srgb(float x) {
	if (x <= 0.0031308f) {
		return 12.92f * x;
	}
	return 1.055f * pow(x, 1.f / 2.4f) - 0.055f;
}

// Pseudo-random number gen from
// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
// with some tweaks for the range of values
float wang_hash(int seed) {
	seed = (seed ^ 61) ^ (seed >> 16);
	seed *= 9;
	seed = seed ^ (seed >> 4);
	seed *= 0x27d4eb2d;
	seed = seed ^ (seed >> 15);
	return float(seed % 2147483647) / float(2147483647);
}


void main(void) {
	// Step 1: Normalize the view ray
	vec3 ray_dir = normalize(vray_dir);

	// Step 2: Intersect the ray with the volume bounds to find the interval
	// along the ray overlapped by the volume.
	vec2 t_hit = intersect_box(transformed_eye, ray_dir);
	if (t_hit.x > t_hit.y) {
		discard;
	}
	// We don't want to sample voxels behind the eye if it's
	// inside the volume, so keep the starting point at or in front
	// of the eye
	t_hit.x = max(t_hit.x, 0.);

	// Step 3: Compute the step size to march through the volume grid
	vec3 dt_vec = 1. / (scale * vec4(abs(ray_dir), 1.)).xyz;
	float dt = 1. * min(dt_vec.x, min(dt_vec.y, dt_vec.z));

	float offset = wang_hash(int(gl_FragCoord.x + 640. * gl_FragCoord.y));

	// Step 4: Starting from the entry point, march the ray through the volume
	// and sample it
	vec3 p = transformed_eye + (t_hit.x + offset * dt) * ray_dir;

	// TODO: Probably want to stop this process at some point to improve performance when marching down the edges.
	_BEFORE_RENDER
	for (float t = t_hit.x; t < t_hit.y; t += dt) {
		// Check if this point is on the "positive" side or "negative" side of the plane - only show positive.
		float canShow = 1.;
		for (int i = 0; i < NUM_PLANES; i += 1) {
			canShow *= max(0., sign(dot(normals[i], p) + distances[i]));
		}
		// Do not show coordinates outside 0-1 box.
		// Something about the undefined behavior outside the box causes the additive blender to 
		// render some very odd artifacts.
		float canShowXCoordinate = max(p.x - 0., 0.) * max(1. - p.x , 0.);
		float canShowYCoordinate = max(p.y - 0., 0.) * max(1. - p.y , 0.);
		float canShowZCoordinate = max(p.z - 0., 0.) * max(1. - p.z , 0.);
		float canShowCoordinate = float(ceil(canShowXCoordinate * canShowYCoordinate * canShowZCoordinate));
		canShow = canShowCoordinate * canShow;
		float intensityValue0 = float(texture(volume0, p).r);
		DECKGL_PROCESS_INTENSITY(intensityValue0, contrastLimits[0], 0);
		intensityValue0 = canShow * intensityValue0;
		float intensityValue1 = float(texture(volume1, p).r);
		DECKGL_PROCESS_INTENSITY(intensityValue1, contrastLimits[1], 1);
		intensityValue1 = canShow * intensityValue1;
		float intensityValue2 = float(texture(volume2, p).r);
  		DECKGL_PROCESS_INTENSITY(intensityValue2, contrastLimits[2], 2);
		intensityValue2 = canShow * intensityValue2;
		float intensityValue3 = float(texture(volume3, p).r);
  		DECKGL_PROCESS_INTENSITY(intensityValue3, contrastLimits[3], 3);
		intensityValue3 = canShow * intensityValue3;
    	float intensityValue4 = float(texture(volume4, p).r);
  		DECKGL_PROCESS_INTENSITY(intensityValue4, contrastLimits[4], 4);
		intensityValue4 = canShow * intensityValue4;
		float intensityValue5 = float(texture(volume5, p).r);
  		DECKGL_PROCESS_INTENSITY(intensityValue5, contrastLimits[5], 5);
		intensityValue5 = canShow * intensityValue5;

		_RENDER

		p += ray_dir * dt;
	}
	_AFTER_RENDER
  color.r = linear_to_srgb(color.r);
  color.g = linear_to_srgb(color.g);
  color.b = linear_to_srgb(color.b);
}
`;
var vs7 = `#version 300 es
#define SHADER_NAME xr-layer-vertex-shader

// Unit-cube vertices
in vec3 positions;

// Eye position - last column of the inverted view matrix
uniform vec3 eye_pos;
// Projection matrix
uniform mat4 proj;
// Model Matrix
uniform mat4 model;
// View Matrix
uniform mat4 view;
// A matrix for scaling in the model space before any transformations.
// This projects the unit cube up to match the "pixel size" multiplied by the physical size ratio, if provided.
uniform mat4 scale;
uniform mat4 resolution;


out vec3 vray_dir;
flat out vec3 transformed_eye;

void main() {

  // Step 1: Standard MVP transformation (+ the scale matrix) to place the positions on your 2D screen ready for rasterization + fragment processing.
  gl_Position = proj * view * model * scale * resolution * vec4(positions, 1.);

  // Step 2: Invert the eye back from world space to the normalized 0-1 cube world space because ray casting on the fragment shader runs in 0-1 space.
  // Geometrically, the transformed_eye is a position relative to the 0-1 normalized vertices, which themselves are the inverse of the model + scale trasnformation.
  // See below for an example which does not involve a scale transformation, for simplicity, but motivates geometrically the needed transformation on eye_pos.
  /*
  This first diagram is a skewed volume (i.e a "shear" model matrix applied) top down with the eye marked as #, all in world space
       ^
    ___|__
    \\  |  \\
     \\ |   \\
      \\|____\\
       | 
       | 
       |
       #

  This next diagram shows the volume after the inverse model matrix has placed it back in model coordinates, but the eye still in world space. 
       ^
    ___|___
    |  |  |
    |  |  |
    |__|__|
       |
       |
       |
       #

  Finally, we apply the inverse model matrix transformation to the eye as well to bring it too into world space.
  Notice that the ray here matches the "voxels" through which the first ray also passes, as desired.
         ^
    ____/__
    |  /  |
    | /   |
    |/____|
    /
   /
  /
 #
  */
  transformed_eye = (inverse(resolution) * inverse(scale) * inverse(model) * (vec4(eye_pos, 1.))).xyz;

  // Step 3: Rays are from eye to vertices so that they get interpolated over the fragments.
  vray_dir = positions - transformed_eye;
}
`;
var channelsModule = {
  name: "channel-intensity-module",
  fs: `    float apply_contrast_limits(float intensity, vec2 contrastLimits) {
      float contrastLimitsAppliedToIntensity = (intensity - contrastLimits[0]) / max(0.0005, (contrastLimits[1] - contrastLimits[0]));
      return max(0., contrastLimitsAppliedToIntensity);
    }
  `
};
var CUBE_STRIP = [
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0
];
var NUM_PLANES_DEFAULT = 1;
var defaultProps$12 = {
  pickable: false,
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  channelData: { type: "object", value: {}, compare: true },
  contrastLimits: { type: "array", value: [], compare: true },
  dtype: { type: "string", value: "Uint8", compare: true },
  xSlice: { type: "array", value: null, compare: true },
  ySlice: { type: "array", value: null, compare: true },
  zSlice: { type: "array", value: null, compare: true },
  clippingPlanes: { type: "array", value: [], compare: true },
  resolutionMatrix: { type: "object", value: new Matrix4(), compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  extensions: {
    type: "array",
    value: [new ColorPalette3DExtensions.AdditiveBlendExtension()],
    compare: true
  }
};
function getRenderingAttrs() {
  const values = getDtypeValues("Float32");
  return {
    ...values,
    sampler: values.sampler.replace("2D", "3D"),
    cast: (data) => new Float32Array(data)
  };
}
function getRenderingFromExtensions(extensions) {
  let rendering = {};
  extensions.forEach((extension) => {
    rendering = extension.rendering;
  });
  if (!rendering._RENDER) {
    throw new Error(
      "XR3DLayer requires at least one extension to define opts.rendering as an object with _RENDER as a property at the minimum."
    );
  }
  return rendering;
}
var XR3DLayer = class extends layer_default {
  initializeState() {
    const { device } = this.context;
    device.setParametersWebGL({
      [GLEnum.UNPACK_ALIGNMENT]: 1,
      [GLEnum.PACK_ALIGNMENT]: 1
    });
    const programManager = ShaderAssembler.getDefaultShaderAssembler();
    const processStr = "fs:DECKGL_PROCESS_INTENSITY(inout float intensity, vec2 contrastLimits, int channelIndex)";
    if (!programManager._hookFunctions.includes(processStr)) {
      programManager.addShaderHook(processStr);
    }
  }
  _isHookDefinedByExtensions(hookName) {
    const { extensions } = this.props;
    return extensions?.some((e2) => {
      const shaders = e2.getShaders();
      if (shaders) {
        const { inject = {}, modules = [] } = shaders;
        const definesInjection = inject[hookName];
        const moduleDefinesInjection = modules.some((m2) => m2?.inject?.[hookName]);
        return definesInjection || moduleDefinesInjection;
      }
      return false;
    });
  }
  /**
   * This function compiles the shaders and the projection module.
   */
  getShaders() {
    const { clippingPlanes, extensions } = this.props;
    const { sampler } = getRenderingAttrs();
    const { _BEFORE_RENDER: _BEFORE_RENDER2, _RENDER: _RENDER2, _AFTER_RENDER: _AFTER_RENDER2 } = getRenderingFromExtensions(extensions);
    const extensionDefinesDeckglProcessIntensity = this._isHookDefinedByExtensions("fs:DECKGL_PROCESS_INTENSITY");
    const newChannelsModule = { inject: {}, ...channelsModule };
    if (!extensionDefinesDeckglProcessIntensity) {
      newChannelsModule.inject["fs:DECKGL_PROCESS_INTENSITY"] = `
        intensity = apply_contrast_limits(intensity, contrastLimits);
      `;
    }
    return super.getShaders({
      vs: vs7,
      fs: fs6.replace("_BEFORE_RENDER", _BEFORE_RENDER2).replace("_RENDER", _RENDER2).replace("_AFTER_RENDER", _AFTER_RENDER2),
      defines: {
        SAMPLER_TYPE: sampler,
        NUM_PLANES: String(clippingPlanes.length || NUM_PLANES_DEFAULT)
      },
      modules: [newChannelsModule]
    });
  }
  /**
   * This function finalizes state by clearing all textures from the WebGL context
   */
  finalizeState() {
    super.finalizeState();
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex?.delete());
    }
  }
  /**
   * This function updates state by retriggering model creation (shader compilation and attribute binding)
   * and loading any textures that need be loading.
   */
  updateState({ props, oldProps, changeFlags }) {
    if (changeFlags.extensionsChanged || props.colormap !== oldProps.colormap || props.renderingMode !== oldProps.renderingMode || props.clippingPlanes.length !== oldProps.clippingPlanes.length) {
      const { device } = this.context;
      if (this.state.model) {
        this.state.model.destroy();
      }
      this.setState({ model: this._getModel(device) });
    }
    if (props.channelData && props?.channelData?.data !== oldProps?.channelData?.data) {
      this.loadTexture(props.channelData);
    }
  }
  /**
   * This function creates the luma.gl model.
   */
  _getModel(gl) {
    if (!gl) {
      return null;
    }
    return new Model(gl, {
      ...this.getShaders(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: new Float32Array(CUBE_STRIP)
        }
      })
    });
  }
  /**
   * This function runs the shaders and draws to the canvas
   */
  draw(opts) {
    const { uniforms } = opts;
    const { textures, model, scaleMatrix } = this.state;
    const {
      contrastLimits,
      xSlice,
      ySlice,
      zSlice,
      modelMatrix,
      channelsVisible,
      domain,
      dtype,
      clippingPlanes,
      resolutionMatrix
    } = this.props;
    const { viewMatrix: viewMatrix2, viewMatrixInverse, projectionMatrix } = this.context.viewport;
    if (textures && model && scaleMatrix) {
      const paddedContrastLimits = padContrastLimits({
        contrastLimits,
        channelsVisible,
        domain,
        dtype
      });
      const invertedScaleMatrix = scaleMatrix.clone().invert();
      const invertedResolutionMatrix = resolutionMatrix.clone().invert();
      const paddedClippingPlanes = padWithDefault2(
        clippingPlanes.map(
          (p2) => p2.clone().transform(invertedScaleMatrix).transform(invertedResolutionMatrix)
        ),
        new Plane([1, 0, 0]),
        clippingPlanes.length || NUM_PLANES_DEFAULT
      );
      const normals = paddedClippingPlanes.flatMap((plane) => plane.normal);
      const distances = paddedClippingPlanes.map((plane) => plane.distance);
      model.setUniforms(
        {
          ...uniforms,
          contrastLimits: paddedContrastLimits,
          xSlice: new Float32Array(
            xSlice ? xSlice.map((i3) => i3 / scaleMatrix[0] / resolutionMatrix[0]) : [0, 1]
          ),
          ySlice: new Float32Array(
            ySlice ? ySlice.map((i3) => i3 / scaleMatrix[5] / resolutionMatrix[5]) : [0, 1]
          ),
          zSlice: new Float32Array(
            zSlice ? zSlice.map((i3) => i3 / scaleMatrix[10] / resolutionMatrix[10]) : [0, 1]
          ),
          eye_pos: new Float32Array([
            viewMatrixInverse[12],
            viewMatrixInverse[13],
            viewMatrixInverse[14]
          ]),
          view: viewMatrix2,
          proj: projectionMatrix,
          scale: scaleMatrix,
          resolution: resolutionMatrix,
          model: modelMatrix || new Matrix4(),
          normals,
          distances
        },
        { disableWanings: false }
      );
      model.setBindings(textures);
      model.draw(this.context.renderPass);
    }
  }
  /**
   * This function loads all textures from incoming resolved promises/data from the loaders by calling `dataToTexture`
   */
  loadTexture(channelData) {
    const textures = {
      volume0: null,
      volume1: null,
      volume2: null,
      volume3: null,
      volume4: null,
      volume5: null
    };
    if (this.state.textures) {
      Object.values(this.state.textures).forEach((tex) => tex?.delete());
    }
    if (channelData && Object.keys(channelData).length > 0 && channelData.data) {
      const { height, width, depth } = channelData;
      channelData.data.forEach((d2, i3) => {
        textures[`volume${i3}`] = this.dataToTexture(d2, width, height, depth);
      }, this);
      for (const key in textures) {
        if (!textures.volume0)
          throw new Error("Bad texture state!");
        if (!textures[key])
          textures[key] = textures.volume0;
      }
      this.setState({
        textures,
        scaleMatrix: new Matrix4().scale(
          this.props.physicalSizeScalingMatrix.transformPoint([
            width,
            height,
            depth
          ])
        )
      });
    }
  }
  /**
   * This function creates textures from the data
   */
  dataToTexture(data, width, height, depth) {
    const attrs = getRenderingAttrs();
    const texture = this.context.device.createTexture({
      width,
      height,
      depth,
      dimension: "3d",
      data: attrs.cast?.(data) ?? data,
      format: attrs.format,
      mipmaps: false,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge",
        addressModeW: "clamp-to-edge"
      }
    });
    return texture;
  }
};
XR3DLayer.layerName = "XR3DLayer";
XR3DLayer.defaultProps = defaultProps$12;
async function getVolume({
  source: source3,
  selection,
  onUpdate = () => {
  },
  downsampleDepth = 1,
  signal
}) {
  const { shape, labels, dtype } = source3;
  const { height, width } = getImageSize(source3);
  const depth = shape[labels.indexOf("z")];
  const depthDownsampled = Math.max(1, Math.floor(depth / downsampleDepth));
  const rasterSize = height * width;
  const name2 = `${dtype}Array`;
  const TypedArray = globalThis[name2];
  const volumeData = new TypedArray(rasterSize * depthDownsampled);
  await Promise.all(
    new Array(depthDownsampled).fill(0).map(async (_2, z2) => {
      const depthSelection = {
        ...selection,
        z: z2 * downsampleDepth
      };
      const { data: rasterData } = await source3.getRaster({
        selection: depthSelection,
        signal
      });
      let r2 = 0;
      onUpdate();
      while (r2 < rasterSize) {
        const volIndex = z2 * rasterSize + (rasterSize - r2 - 1);
        const rasterIndex = (width - r2 - 1) % width + width * Math.floor(r2 / width);
        volumeData[volIndex] = rasterData[rasterIndex];
        r2 += 1;
      }
      onUpdate();
    })
  );
  return {
    data: volumeData,
    height,
    width,
    depth: depthDownsampled
  };
}
var getTextLayer = (text, viewport, id) => {
  return new text_layer_default({
    id: `text-${id}`,
    coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
    data: [
      {
        text,
        position: viewport.position
      }
    ],
    getColor: [220, 220, 220, 255],
    getSize: 25,
    sizeUnits: "meters",
    sizeScale: 2 ** -viewport.zoom,
    fontFamily: "Helvetica"
  });
};
var defaultProps16 = {
  pickable: false,
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  contrastLimits: { type: "array", value: [], compare: true },
  channelsVisible: { type: "array", value: [], compare: true },
  selections: { type: "array", value: [], compare: true },
  resolution: { type: "number", value: 0, compare: true },
  domain: { type: "array", value: [], compare: true },
  loader: {
    type: "object",
    value: [
      {
        getRaster: async () => ({ data: [], height: 0, width: 0 }),
        dtype: "Uint16",
        shape: [1],
        labels: ["z"]
      }
    ],
    compare: true
  },
  xSlice: { type: "array", value: null, compare: true },
  ySlice: { type: "array", value: null, compare: true },
  zSlice: { type: "array", value: null, compare: true },
  clippingPlanes: { type: "array", value: [], compare: true },
  onUpdate: { type: "function", value: () => {
  }, compare: true },
  useProgressIndicator: { type: "boolean", value: true, compare: true },
  extensions: {
    type: "array",
    value: [new ColorPalette3DExtensions.AdditiveBlendExtension()],
    compare: true
  }
};
var VolumeLayer = class extends composite_layer_default {
  clearState() {
    this.setState({
      height: null,
      width: null,
      depth: null,
      data: null,
      physicalSizeScalingMatrix: null,
      resolutionMatrix: null,
      progress: 0,
      abortController: null
    });
  }
  finalizeState() {
    this.state.abortController.abort();
  }
  updateState({ oldProps, props }) {
    const loaderChanged = props.loader !== oldProps.loader;
    const resolutionChanged = props.resolution !== oldProps.resolution;
    const selectionsChanged = props.selections !== oldProps.selections;
    if (resolutionChanged) {
      this.clearState();
    }
    if (loaderChanged || selectionsChanged || resolutionChanged) {
      const {
        loader,
        selections = [],
        resolution,
        onViewportLoad
      } = this.props;
      const source3 = loader[resolution];
      let progress = 0;
      const totalRequests = (source3.shape[source3.labels.indexOf("z")] >> resolution) * selections.length;
      const onUpdate = () => {
        progress += 0.5 / totalRequests;
        if (this.props.onUpdate) {
          this.props.onUpdate({ progress });
        }
        this.setState({ progress });
      };
      const abortController = new AbortController();
      this.setState({ abortController });
      const { signal } = abortController;
      const volumePromises = selections.map(
        (selection) => getVolume({
          selection,
          source: source3,
          onUpdate,
          downsampleDepth: 2 ** resolution,
          signal
        })
      );
      const physicalSizeScalingMatrix = getPhysicalSizeScalingMatrix(
        loader[resolution]
      );
      Promise.all(volumePromises).then((volumes) => {
        if (onViewportLoad) {
          onViewportLoad(volumes);
        }
        const volume = {
          data: volumes.map((d2) => d2.data),
          width: volumes[0]?.width,
          height: volumes[0]?.height,
          depth: volumes[0]?.depth
        };
        this.setState({
          ...volume,
          physicalSizeScalingMatrix,
          resolutionMatrix: new Matrix4().scale(2 ** resolution)
        });
      });
    }
  }
  renderLayers() {
    const { loader, id, resolution, useProgressIndicator } = this.props;
    const { dtype } = loader[resolution];
    const {
      data,
      width,
      height,
      depth,
      progress,
      physicalSizeScalingMatrix,
      resolutionMatrix
    } = this.state;
    if (!(width && height) && useProgressIndicator) {
      const { viewport } = this.context;
      return getTextLayer(
        `Loading Volume ${String((progress || 0) * 100).slice(0, 5)}%...`,
        viewport,
        id
      );
    }
    return new XR3DLayer(this.props, {
      channelData: { data, width, height, depth },
      id: `XR3DLayer-${0}-${height}-${width}-${0}-${resolution}-${id}`,
      physicalSizeScalingMatrix,
      parameters: {
        [GLEnum.CULL_FACE]: true,
        [GLEnum.CULL_FACE_MODE]: GLEnum.FRONT,
        [GLEnum.DEPTH_TEST]: false,
        blendFunc: [GLEnum.SRC_ALPHA, GLEnum.ONE],
        blend: true
      },
      resolutionMatrix,
      dtype
    });
  }
};
VolumeLayer.layerName = "VolumeLayer";
VolumeLayer.defaultProps = defaultProps16;
export {
  deck_default as Deck,
  ImageLayer,
  MultiscaleImageLayer,
  orthographic_view_default as OrthographicView,
  loadOmeZarr,
  registry2 as registry
};
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

lerc/LercDecode.js:
  (* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve *)
*/
//# sourceMappingURL=zarr-viewer-bundle.js.map
