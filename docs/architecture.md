# evostitch Web Architecture

Browser-based viewer for gigapixel microscopy mosaics generated by the core pipeline.

---

## Overview

The web component is a static site with two viewer technologies: DZI pyramids via OpenSeadragon and OME-Zarr volumes via Viv 0.19 + deck.gl 9. It consists of three pages:

1. **Catalog page** (`index.html`) - Grid of available mosaics with thumbnails
2. **DZI Viewer** (`viewer.html`) - Full-screen image viewer with navigation (OpenSeadragon)
3. **Zarr Viewer** (`zarr-viewer.html`) - OME-Zarr 3D Explorer with Z-navigation, channels, prefetch (Viv/deck.gl)

```
User browses catalog → Clicks mosaic card → Viewer loads DZI tiles from R2
                     → Clicks 3D mosaic  → Zarr viewer loads OME-Zarr chunks from R2
```

---

## Module Structure

```
web/
├── index.html              # Catalog page
├── viewer.html             # DZI viewer page (loads OpenSeadragon)
├── zarr-viewer.html        # OME-Zarr 3D Explorer (loads Viv/deck.gl bundle)
├── sw.js                   # Service worker: DZI tile + zarr chunk caching (v1.4.1)
├── dist/
│   └── zarr-viewer-bundle.js  # ESM bundle: Viv 0.19 + deck.gl 9 (built via npm run build:zarr)
├── build/
│   └── bundle-zarr-viewer.js  # esbuild script for zarr bundle
├── js/
│   ├── catalog.js             # Catalog loading and card rendering
│   ├── viewer.js              # DZI viewer initialization, scale bar, Z-navigation
│   ├── telemetry.js           # Tile load performance measurement
│   ├── tile-prioritizer.js    # Request prioritization and Z-prefetch (W2)
│   ├── network-detect.js      # Network speed detection (W3)
│   ├── quality-adapt.js       # Adaptive quality based on network (W4)
│   ├── blur-up-loader.js      # Progressive tile resolution (blur-up loading)
│   ├── zarr-viewport-math.js  # Shared viewport geometry: zoom→level, bounds, tile ranges (W10)
│   ├── zarr-prefetch.js       # Viewport-aware Z-plane prefetching for OME-Zarr viewer (W10)
│   ├── zarr-render-opt.js     # Z-debounce, zoom capping, RAF batching for Zarr viewer
│   ├── zarr-3d-loader.js      # Explicit "Load 3D" mode with viewport-scoped prefetch
│   ├── zarr-viewer.js         # ES module: OME-Zarr 3D Explorer controller (Viv/deck.gl)
│   ├── zarr-perf-test.js      # Performance test runner for zarr viewer
│   ├── loading-indicator.js   # Dual-arc progress ring for tile loading
│   ├── jpeg-zarr-codec.js     # JPEG zarr codec: WASM primary (libjpeg-turbo), canvas fallback
│   ├── browser-decode.js      # Browser detection for decode strategy
│   ├── worker-pool.js         # Web Worker pool management
│   ├── tile-decoder-worker.js # Off-thread tile decoding worker
│   └── worker-tile-source.js  # OSD integration for worker decoding
├── wasm/
│   ├── jpeg-decode.js         # Emscripten JS glue (MODULARIZE=1, EXPORT_NAME=JpegDecodeModule)
│   ├── jpeg-decode.wasm       # WASM libjpeg-turbo binary (247 KB, grayscale decode only)
│   ├── CHECKSUMS.sha256       # SHA-256 hashes of built artifacts
│   └── LICENSE.libjpeg-turbo  # libjpeg-turbo BSD/IJG license
├── build/
│   └── libjpeg-turbo-wasm/    # WASM build infrastructure
│       ├── CMakeLists.txt     # Emscripten build config
│       ├── jpeg-decode-wrapper.c  # C wrapper (init, decode_gray, destroy, version)
│       ├── build.sh           # One-command build (pins libjpeg-turbo 3.0.4 + Emscripten 3.1.51)
│       └── README.md          # Build prerequisites and instructions
├── css/
│   └── style.css       # Shared styles (dark theme)
├── mosaics/
│   └── catalog.json    # Mosaic registry (metadata for all available mosaics)
└── CNAME               # GitHub Pages custom domain (evostitch.net)
```

> **W8 note:** `zarr-cache.js` was removed in this sprint. JS-level caching is now handled entirely by the service worker (`sw.js`).

---

## Key Components

### catalog.js

Loads `mosaics/catalog.json` and renders mosaic cards with thumbnails.

| Function | Purpose |
|----------|---------|
| `init()` | Fetch catalog, render cards |
| `createMosaicCard()` | Build card HTML with thumbnail, title, dimensions |
| `formatNumber()` | Format large numbers (e.g., "12.3k") |

**Data flow:**
```
Fetch catalog.json → Parse mosaic entries → Render cards → Link to viewer.html?mosaic={id}
```

### viewer.js

Initializes OpenSeadragon and handles 2D/3D viewing modes.

| Function | Purpose |
|----------|---------|
| `init()` | Load metadata, detect 2D vs 3D, initialize viewer |
| `init2D()` | Single-plane DZI viewer |
| `initZStack()` | Multi-plane viewer with Z-slider |
| `updateScaleBar()` | Adaptive scale bar based on zoom level |
| `updateCoordinates()` | Display cursor position in micrometers |
| `setZPlane()` | Switch visible Z-plane (opacity toggle) |
| `preloadAdjacentPlanes()` | Warm cache for smooth Z-navigation |
| `getDeviceConfig()` | Adaptive cache sizing based on device memory |

**Viewer modes:**

| Mode | Condition | Behavior |
|------|-----------|----------|
| 2D | `zCount == 1` | Single DZI tile source |
| 3D | `zCount > 1` | All Z-planes loaded, opacity switching |

### tile-prioritizer.js

Optimizes tile loading order for 3D mosaics (W2 request prioritization).

| Function | Purpose |
|----------|---------|
| `init(viewer, options)` | Initialize prioritizer with OSD viewer |
| `setCurrentZ(z)` | Update current Z-plane (triggers reprioritization and velocity tracking) |
| `clearQueue()` | Clear pending tile requests |
| `destroy()` | Disable prioritizer and restore original behavior |
| `getState()` | Get debugging state info |

**How it works:**

1. **Priority Queue:** Wraps `ImageLoader.addJob` to queue requests by priority
2. **Priority Levels:** VIEWPORT_CURRENT_Z (1) > VIEWPORT_ADJACENT_Z (2) > PREFETCH (3)
3. **Animation Throttling:** Reduces concurrent requests during pan/zoom (2 vs 6)
4. **Z-Plane Awareness:** Reprioritizes queue when user changes Z-plane

**Predictive Z-Prefetch:**

Tracks Z-navigation velocity to prefetch tiles in the direction of travel:

| Navigation Speed | Prefetch Behavior |
|------------------|-------------------|
| Slow (< 1 plane/sec) | Prefetch ±1 adjacent planes (default) |
| Fast (≥ 1 plane/sec) | Prefetch 1-5 planes ahead in velocity direction + 1 behind |

The depth of prefetch scales with navigation speed: `depth = min(5, ceil(velocity / 2))`. This enables smooth scrubbing through Z-stacks without waiting for tiles.

**Expected improvement:** -94% Z-transition wait time on fast scroll.

**Heartbeat System:**

The heartbeat ensures tile requests are processed even when OpenSeadragon stops firing events:

| Component | Purpose |
|-----------|---------|
| `startHeartbeat()` | Starts 500ms interval when jobs are queued |
| `stopHeartbeat()` | Stops interval when queue is empty and no mismatch |
| `processQueue()` | Dispatches pending jobs to OSD loader by priority |

**How it works:**

1. Jobs are added via wrapped `ImageLoader.addJob` → queued by priority
2. Heartbeat ticks every 500ms while jobs are pending
3. Each tick: dispatches jobs up to available loader slots
4. When queue empties: checks resolution state, stops if OK

**Resolution Detection and Fix:**

After tiles stop loading, there can be a resolution mismatch: OSD displays low-res (preloaded) tiles when zoomed in, but doesn't request higher-res tiles because it thinks it has coverage.

| Function | Purpose |
|----------|---------|
| `getDrawnTileLevel()` | Returns highest tile level currently rendered |
| `getNeededTileLevel()` | Calculates level needed for ~1:1 pixel mapping at current zoom |
| `checkResolutionState()` | Compares drawn vs needed, returns `{ drawnLevel, neededLevel, mismatch }` |
| `triggerResolutionFix()` | Clears OSD coverage cache and forces redraw |

**Fix mechanism:**

1. Heartbeat detects `drawnLevel < neededLevel` (mismatch)
2. `triggerResolutionFix()` clears `tiledImage._coverage` (OSD's tile tracking)
3. `viewer.forceRedraw()` triggers OSD to recalculate needed tiles
4. OSD requests higher-res tiles since it no longer thinks area is covered
5. Cooldown (2s) prevents infinite loops for same Z-plane/zoom level

**Console API:**

```javascript
evostitch.tilePrioritizer.getState()   // { enabled, currentZ, pendingJobs, isAnimating, zVelocity, predictedPlanes, ... }
evostitch.tilePrioritizer.setDebug(true) // Enable debug logging
evostitch.tilePrioritizer.setDiagnostic(true) // Enable heartbeat/resolution diagnostic logging
evostitch.tilePrioritizer.checkResolutionState() // { drawnLevel, neededLevel, mismatch, fullyLoaded }
```

### telemetry.js

Measures tile load performance to distinguish cold (network) vs warm (browser cache) loads.

| Function | Purpose |
|----------|---------|
| `recordTileLoad()` | Record a tile load event (called by viewer.js) |
| `getStats()` | Get aggregated statistics by zoom level |
| `logSummary()` | Log summary to console |
| `clearStats()` | Clear all telemetry data |
| `flushToStorage()` | Force flush pending data to localStorage |

**How it works:**

1. **Measurement:** Uses `PerformanceResourceTiming` API to get actual tile load duration
2. **Classification:** Tiles loading < 50ms → "warm" (cache hit), ≥ 50ms → "cold" (network)
3. **Batching:** Writes batched in memory, flushed every 5s or 50 tiles (avoids blocking main thread)
4. **Persistence:** Data stored in `localStorage['evostitch_tile_telemetry']`

**Console API:**

```javascript
evostitch.telemetry.getStats()    // View stats: { byZoom, totals: { coldCount, coldAvgMs, warmCount, warmAvgMs } }
evostitch.telemetry.logSummary()  // Log: "cold=206 tiles (avg 135ms), warm=72 tiles (avg 1ms)"
evostitch.telemetry.clearStats()  // Reset all data
```

### sw.js (Service Worker)

Caches DZI tiles and OME-Zarr chunks for offline access and improved repeat-visit performance (W1, W12).

**Caching strategies:**

| Request Type | Strategy | Cache | Rationale |
|-------------|----------|-------|-----------|
| DZI tiles (`_files/{level}/{x}_{y}.{ext}`) | Cache-first | `evostitch-tiles-v1.4.1` | Tiles are immutable |
| DZI descriptors (`.dzi`) | Cache-first | `evostitch-tiles-v1.4.1` | Also immutable |
| Zarr chunks (R2 domain + numeric path) | Cache-first | `evostitch-zarr-v1.4.1` | Chunks are immutable |
| Zarr metadata (`.zarray`, `.zattrs`, `.zgroup`) | Network-first | `evostitch-zarr-v1.4.1` | Metadata may change |
| Static assets (HTML, JS, CSS) | Network-first | `evostitch-static-v1.4.1` | Allow code updates |
| Other requests | Pass through | — | No caching |

**Dual-domain support (W12):**

The SW intercepts zarr requests from both R2 domains:
- `pub-db7ffa4b7df04b76aaae379c13562977.r2.dev` (original R2 public URL, HTTP/1.1)
- `data.evostitch.net` (custom domain via Cloudflare, HTTP/2)

`isZarrChunkRequest()` and `isZarrMetadataRequest()` both check the `R2_DOMAINS` array.

**Configuration:**

| Setting | Value | Purpose |
|---------|-------|---------|
| `MAX_TILE_CACHE_ENTRIES` | 5000 | Maximum DZI tiles in SW cache |
| `MAX_ZARR_CACHE_ENTRIES` | 10000 | Maximum zarr chunks in SW cache |
| `CACHE_TRIM_BATCH_SIZE` | 500 | Entries evicted when trimming |
| `SW_VERSION` | 1.4.0 | Cache name version |

**LRU eviction:** When cache exceeds limits, oldest entries are evicted. Access tracking done by delete+put on cache hit.

**Registration:** Service worker is registered in both `viewer.html` and `zarr-viewer.html` via inline script tags.

**Page communication:** SW responds to `MessageChannel` postMessage for cache management:

```javascript
window.evostitch.sw.getStats()       // { totalEntries, cacheSize }
window.evostitch.sw.clearCache()     // Clear zarr cache
window.evostitch.sw.getCacheContents() // List cached URLs
```

### network-detect.js

Detects network speed conditions for adaptive quality decisions (W3).

| Function | Purpose |
|----------|---------|
| `init()` | Initialize detection, set up change listeners |
| `getSpeed()` | Get current classification: `fast`, `medium`, `slow`, `unknown` |
| `isSlow()` / `isFast()` | Convenience checks |
| `recordTileLoad(ms)` | Record tile load time (fallback detection) |
| `addChangeListener(fn)` | Subscribe to speed changes |
| `getInfo()` | Get detailed diagnostics |

**Detection methods (in priority order):**

1. **Navigator.connection API** (if supported): Uses `effectiveType` (4g/3g/2g) or `downlink` Mbps
2. **Tile load timing fallback**: Averages recent tile loads to classify speed

**Hysteresis:** To prevent UI flicker from rapid speed changes, the fallback detector requires 3 consecutive classifications to a new speed before transitioning state.

**Speed thresholds:**

| Source | Fast | Medium | Slow |
|--------|------|--------|------|
| Navigator.connection effectiveType | 4g | 3g | 2g, slow-2g |
| Navigator.connection downlink | ≥5 Mbps | ≥1 Mbps | <1 Mbps |
| Tile load timing (fallback) | ≤150ms | ≤500ms | >500ms |

**Console API:**

```javascript
evostitch.networkDetect.getSpeed()    // 'fast' | 'medium' | 'slow' | 'unknown'
evostitch.networkDetect.getInfo()     // { speed, effectiveType, downlink, rtt, ... }
evostitch.networkDetect.setDebug(true) // Enable debug logging
```

### quality-adapt.js

Adjusts tile quality based on network conditions to improve slow-network UX (W4).

| Function | Purpose |
|----------|---------|
| `init(viewer, options)` | Initialize with OSD viewer |
| `setQuality(level)` | Manually set quality: `high`, `medium`, `low`, `auto` |
| `getQuality()` | Get current setting |
| `getEffectiveQuality()` | Get actual quality being used |
| `isManualOverride()` | Check if user overrode auto quality |
| `addChangeListener(fn)` | Subscribe to quality changes |
| `getState()` | Get debugging state |

**Quality levels:**

| Level | Zoom Reduction | Effect |
|-------|---------------|--------|
| `high` | 0 levels | Full resolution |
| `medium` | 2 levels | Skip top 2 DZI levels (1/4 resolution) |
| `low` | 4 levels | Skip top 4 DZI levels (1/16 resolution) |
| `auto` | Varies | Network-adaptive |

**Network-to-quality mapping:**

| Network Speed | Auto Quality |
|---------------|-------------|
| fast | high |
| medium | medium |
| slow | low |
| unknown | medium |

**Progressive enhancement:** After loading tiles at reduced quality, checks if network improved and upgrades quality if possible (delay: 5s, requires 20+ tiles loaded).

**Console API:**

```javascript
evostitch.qualityAdapt.getQuality()          // 'auto' | 'high' | 'medium' | 'low'
evostitch.qualityAdapt.getEffectiveQuality() // What's actually being used
evostitch.qualityAdapt.setQuality('high')    // Manual override
evostitch.qualityAdapt.getState()            // Full debugging state
evostitch.qualityAdapt.setDebug(true)        // Enable debug logging
```

### blur-up-loader.js

Shows low-resolution placeholder tiles while high-res tiles load, improving perceived performance on slow networks.

| Function | Purpose |
|----------|---------|
| `init(viewer, options)` | Initialize with OSD viewer |
| `destroy()` | Disable loader and clean up |
| `getState()` | Get debugging state |
| `clearAllPlaceholders()` | Remove all active placeholders |

**How it works:**

1. **Intercept tile-loading:** When OSD starts loading a tile, schedule a placeholder display
2. **Delay before showing:** Only show placeholder if tile takes longer than 100ms (configurable)
3. **Lower-level tile:** Request tile from 3 levels lower (8x smaller) as placeholder
4. **Position overlay:** Display placeholder as absolute-positioned image over the loading tile area
5. **Remove on load:** When full-res tile loads, remove placeholder

**Configuration:**

| Setting | Default | Purpose |
|---------|---------|---------|
| `placeholderLevelOffset` | 3 | Levels below target for placeholder (3 = 8x smaller) |
| `minPlaceholderLevel` | 0 | Don't create placeholders for very low zoom levels |
| `placeholderDelayMs` | 100 | Only show placeholder if tile takes longer than this |
| `maxConcurrentPlaceholders` | 4 | Limit concurrent placeholder requests |

**Expected impact:** -88% time-to-first-visual on slow networks.

**Console API:**

```javascript
evostitch.blurUpLoader.getState()              // { enabled, activePlaceholders, pendingPlaceholderCount }
evostitch.blurUpLoader.setDebug(true)          // Enable debug logging
evostitch.blurUpLoader.clearAllPlaceholders()  // Remove all placeholders
```

### loading-indicator.js

Dual-arc SVG progress ring showing tile loading progress.

| Function | Purpose |
|----------|---------|
| `init()` | Create and inject indicator DOM elements |
| `show()` | Display indicator (with 300ms delay to avoid flash) |
| `hide()` | Hide indicator and reset progress |
| `setProgress(xy, z)` | Update progress (0-1 for XY tiles, 0-1 for Z-planes) |
| `getState()` | Get debugging state |

**Visual design:**

- Outer arc: XY tile completion (current plane)
- Inner arc: Z-plane readiness (±2 adjacent planes)
- 300ms display delay to avoid flash on fast loads
- Smooth opacity transitions

**Accessibility:**

- `role="progressbar"` with `aria-valuenow`/`aria-label`
- Live region announcer for screen readers
- `prefers-reduced-motion` support

**Console API:**

```javascript
evostitch.loadingIndicator.show()           // Show with 300ms delay
evostitch.loadingIndicator.setProgress(0.5, 0.8)  // 50% XY, 80% Z
evostitch.loadingIndicator.hide()           // Hide and reset
evostitch.loadingIndicator.getState()       // { initialized, isLoading, visible, xyProgress, zProgress }
```

### zarr-viewport-math.js (W10)

Shared viewport geometry for zarr modules. Extracted from `zarr-3d-loader.js` so `zarr-prefetch.js` can reuse the same zoom→level, viewState→bounds, and bounds→tileRange logic.

| Function | Purpose |
|----------|---------|
| `zoomToLevel(zoom, numLevels)` | Map deck.gl zoom to zarr resolution level index |
| `viewStateToBounds(viewState, containerSize)` | Compute visible data bounds in full-res pixels |
| `boundsToTileRange(bounds, levelInfo, margin)` | Convert bounds to tile coordinates with margin |

**Dependencies:** None (pure math, no DOM or network).

**Console API:**

```javascript
evostitch.viewportMath.zoomToLevel(-2, 10)        // → 2
evostitch.viewportMath.viewStateToBounds(vs, size) // → { minX, maxX, minY, maxY }
evostitch.viewportMath.boundsToTileRange(bounds, levelInfo, 2) // → { minTileX, maxTileX, ... }
```

### zarr-3d-loader.js

Explicit "Load 3D" mode for the OME-Zarr viewer. Instead of fighting Viv's tile cache invalidation on Z-switches, this module prefetches all visible chunks across all Z-planes at the current viewport, then enables smooth Z-scrubbing via SW cache hits.

| Function | Purpose |
|----------|---------|
| `init(config)` | Initialize with zarr metadata, viewport callbacks |
| `startLoad()` | Begin prefetching all Z-planes for current viewport |
| `cancelLoad(reason)` | Cancel in-progress prefetch, return to 2D |
| `exit3D(reason)` | Exit 3D mode, return to 2D |
| `onViewStateChange(viewState)` | Hook for deck.gl viewport changes |
| `calculateBudget()` | Compute chunk count for current viewport |
| `getMode()` | Current state: `2D`, `LOADING`, or `3D_READY` |
| `getProgress()` | Loading progress: `{ completed, total, percent }` |
| `is3DReady()` | Whether Z-slider should be shown |

**State machine:**

```
[2D] --click Load 3D--> [LOADING] --all cached--> [3D_READY]
 ^                          |                          |
 |     cancel/pan/zoom      |     pan outside region   |
 +--------------------------+     or zoom level change  |
 +----------------------------------------------------------+
```

**How it works:**

1. In 2D mode, "Load 3D" button shows chunk estimate for current viewport
2. User clicks button → viewport is captured, all Z-plane chunks are prefetched
3. Fetches go through normal `fetch()` → SW intercepts and caches automatically
4. On completion, Z-slider appears. Every Z-switch is a SW cache hit
5. Containment check on every pan/zoom: exits 3D if viewport leaves cached region

**Viewport math:** Delegates to shared `zarr-viewport-math.js` (W10), with graceful fallback stubs if the module is missing.

| Step | Source | Purpose |
|------|--------|---------|
| 1 | `viewportMath.zoomToLevel()` | Map deck.gl zoom to zarr resolution level |
| 2 | `viewportMath.viewStateToBounds()` | Compute visible data bounds |
| 3 | `viewportMath.boundsToTileRange()` | Convert to tile coordinates with 1-tile margin |
| 4 | `generateChunkUrls()` (local) | Build all chunk URLs |

**Configuration:**

| Setting | Default | Purpose |
|---------|---------|---------|
| `maxChunks` | 5000 | Budget limit; button disabled when exceeded |
| `concurrency` | 6 | Parallel prefetch requests |
| `consecutiveErrorLimit` | 5 | Pause and show retry after N consecutive errors |

**Console API:**

```javascript
evostitch.zarr3DLoader.getMode()          // '2D' | 'LOADING' | '3D_READY'
evostitch.zarr3DLoader.getProgress()      // { completed, total, percent }
evostitch.zarr3DLoader.calculateBudget()  // { total, tilesPerPlane, withinBudget, levelIdx }
evostitch.zarr3DLoader.setDebug(true)     // Enable debug logging
```

### zarr-viewer.js (ES Module)

Main controller for the OME-Zarr 3D Explorer. Uses Viv 0.19 `loadOmeZarr` + `MultiscaleImageLayer` on deck.gl 9's `Deck` with `OrthographicView`.

| Function | Purpose |
|----------|---------|
| `init()` | Await SW ready, load zarr, initialize deck.gl viewer |
| `loadZarr(zarrParam)` | Load OME-Zarr dataset via Viv's `loadOmeZarr` |
| `updateLayer()` | Create/update MultiscaleImageLayer with current Z, channels |
| `onViewportLoad()` | Callback when all visible tiles finish loading |
| `getPerfStats()` | Return timing + cache stats for performance monitoring |

**Key props on MultiscaleImageLayer (W7/W9):**

| Prop | Value | Purpose |
|------|-------|---------|
| `refinementStrategy` | `'best-available'` | Show old Z-plane as placeholder during Z-switch (W9) |
| `selections` | `[{ z, t, c }]` | Current Z/channel — in `updateTriggers.getTileData` |

**Z-switch UX (W9):** No opacity flicker. Old frame stays at opacity 1.0. On `onViewportLoad`, subtle pulse 0.92→1.0 over 100ms. Generation counter skips stale callbacks. Smart loading indicator (150ms delay).

**Console API:**

```javascript
evostitch.zarrViewer.getPerfStats() // { zSwitchTime, cacheHitRate, ... }
```

### zarr-prefetch.js

Viewport-aware predictive Z-plane prefetching for the OME-Zarr viewer. Prefetches chunks for adjacent Z-planes so Viv tile reloads on Z-switch hit SW cache.

| Function | Purpose |
|----------|---------|
| `init(config)` | Initialize with store URL, level count, viewport callbacks |
| `onZChange(newZ)` | Trigger prefetch of adjacent Z-planes |
| `onViewportLoad()` | Track late fetch count (tiles still pending at viewport load) |
| `getStats()` | Return prefetch metrics |
| `destroy()` | Clean up state, abort pending fetches |

**Viewport-aware filtering (W10):** Only prefetches chunks visible in the current viewport + 2-tile margin. Uses `zarr-viewport-math.js` for geometry. Falls back to all chunks when viewport info unavailable.

**Metrics (W10):**

| Stat | Description |
|------|-------------|
| `lateFetchCount` | Tiles still pending when viewport load fires |
| `totalZSwitches` | Total Z-change events |
| `prefetchedBytes` | Total bytes prefetched (from Content-Length) |
| `prefetchedBytesPerZSwitch` | Bytes per Z-switch (efficiency metric) |

**Console API:**

```javascript
evostitch.zarrPrefetch.getStats()   // { lateFetchCount, totalZSwitches, prefetchedBytes, ... }
evostitch.zarrPrefetch.setDebug(true)
```

### zarr-render-opt.js

Z-switch rendering optimizations: 50ms debounce, zoom capping, RAF batching.

| Function | Purpose |
|----------|---------|
| `init(config)` | Initialize with deck reference |
| `requestZUpdate(z)` | Debounced Z-switch (50ms) |
| `isInitialized()` | Check if module is ready |

**Console API:**

```javascript
evostitch.zarrRenderOpt.isInitialized() // true/false
```

### jpeg-zarr-codec.js

JPEG codec for zarrita registry. Decodes JPEG-compressed zarr chunks (codec ID `imagecodecs_jpeg`).

| Function/Property | Purpose |
|-------------------|---------|
| `decode(bytes)` | Decode JPEG chunk → `Uint8Array` pixels (WASM or canvas path) |
| `getState()` | Return telemetry: `wasmState`, `decodeCount`, `fallbackCount`, `avgDecodeMs` |

**Decode paths:**

| Path | Pipeline | Latency (512x512) | When |
|------|----------|-------------------|------|
| WASM (primary) | JPEG → WASM libjpeg-turbo `TJPF_GRAY` → `Uint8Array` | 1-3ms | `JpegDecodeModule` available |
| Canvas (fallback) | JPEG → `createImageBitmap` → `OffscreenCanvas` → R-channel | 40-70ms | WASM unavailable |

**State machine:** `uninitialized → initializing → ready | failed`. One-way degrade: once `failed`, always uses canvas fallback. Single warning on fallback (not repeated).

**Safety checks:**
- Version coherency: `JPEG_DECODE_VERSION = 1` must match C wrapper
- Dimension guard: `MAX_CHUNK_DIM = 4096` — rejects oversized images
- Buffer growth: pre-allocated WASM buffers grow on `-3` (output too small), with decompressor reinit

**Console API:**

```javascript
evostitch.jpegCodec.getState()  // { wasmState, decodeCount, fallbackCount, avgDecodeMs }
```

### WASM libjpeg-turbo Build (web/build/libjpeg-turbo-wasm/)

Custom WASM build of libjpeg-turbo for in-browser JPEG decoding. Produces `jpeg-decode.{js,wasm}`.

**Build:** libjpeg-turbo 3.0.4 + Emscripten 3.1.51, `-Oz -flto`, emmalloc, wasm-opt post-process. Uses standard jpeglib.h API (decode-only). Binary: 247 KB.

**C wrapper exports:** `_jpeg_decode_init()`, `_jpeg_decode_gray(src, srcSize, dst, dstSize, widthPtr, heightPtr)`, `_jpeg_decode_destroy()`, `_jpeg_decode_version()`.

**Build command:** `cd web/build/libjpeg-turbo-wasm && ./build.sh`

### browser-decode.js

Detects browser capabilities and provides optimal decode strategy.

| Function | Purpose |
|----------|---------|
| `init()` | Run browser detection |
| `getStrategy()` | Get recommended decode strategy: `worker` or `main-thread` |
| `getInfo()` | Get detection results |
| `decodeMainThread(url)` | Fallback decode using Image.decode() |

**Browser detection:**

- Chromium: Uses `window.chrome` detection
- Firefox: Uses `InstallTrigger` or user agent
- Safari: User agent after excluding Chrome

**Console API:**

```javascript
evostitch.browserDecode.getInfo()  // { browser: 'chromium', canUseWorkers: true, strategy: 'worker' }
```

### worker-pool.js

Manages a pool of Web Workers for parallel tile decoding.

| Function | Purpose |
|----------|---------|
| `init(options)` | Initialize pool (size defaults to `navigator.hardwareConcurrency`) |
| `decode(url)` | Decode tile via worker, returns Promise<ImageBitmap> |
| `getState()` | Get pool status |
| `terminate()` | Shut down all workers |
| `setDebug(enabled)` | Enable/disable debug logging |

**Pool sizing:**

- Default: `navigator.hardwareConcurrency || 4`
- Maximum: 12 workers
- Round-robin task distribution

**Console API:**

```javascript
evostitch.workerPool.decode(url)  // Returns Promise<ImageBitmap>
evostitch.workerPool.getState()   // { initialized, workerCount, pendingJobs, nextJobId }
evostitch.workerPool.setDebug(true)
```

### tile-decoder-worker.js

Web Worker that performs off-thread tile decoding.

**Message protocol:**

```javascript
// Input
{ id: number, url: string }

// Output (success)
{ id: number, bitmap: ImageBitmap, success: true }

// Output (error)
{ id: number, success: false, error: string }
```

**Decode process:**

1. `fetch(url)` with credentials omit
2. `response.blob()` to get Blob
3. `createImageBitmap(blob)` for off-thread decode
4. Transfer ImageBitmap back (zero-copy)

### worker-tile-source.js

Integrates worker pool with OpenSeadragon's tile loading.

| Function | Purpose |
|----------|---------|
| `init(viewer, options)` | Initialize with OSD viewer |
| `getStats()` | Get decode statistics |
| `setEnabled(bool)` | Enable/disable worker decoding |
| `setDebug(enabled)` | Enable/disable debug logging |

**Integration approach:**

- Hooks `viewer.imageLoader.addJob` to intercept tile requests
- Same-origin tiles: decoded via worker pool
- Cross-origin tiles: fallback to standard OSD loader (CORS limitation)

**CORS limitation:**

Workers cannot fetch cross-origin resources without CORS headers. Tiles from R2 CDN require `Access-Control-Allow-Origin: *` header for worker decoding.

**Console API:**

```javascript
evostitch.workerTileSource.getStats()  // { enabled, workerDecodes, fallbackDecodes, errors, workerPoolState }
evostitch.workerTileSource.setDebug(true)
```

---

## Performance Optimization Modules

### DZI Viewer (W1-W4)

The W1-W4 modules work together to optimize DZI viewer performance, particularly for 3D mosaics and slow networks.

#### DZI Module Dependency Graph

```
┌─────────────────┐
│  network-detect │ ◄── Loaded first (no dependencies)
└────────┬────────┘
         │ speed changes
         ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  quality-adapt  │     │ tile-prioritizer│     │ blur-up-loader  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                      │                       │
         │ zoom constraints     │ request priority      │ placeholder overlays
         ▼                      ▼                       ▼
┌───────────────────────────────────────────────────────────────────┐
│                          viewer.js                                │
│                     (OpenSeadragon viewer)                        │
└────────────────────────────────┬──────────────────────────────────┘
                                 │ fetch requests
                                 ▼
                          ┌─────────────┐
                          │    sw.js    │ ◄── Intercepts all requests
                          └─────────────┘
```

#### DZI Initialization Order

1. **sw.js** - Registered on page load (viewer.html inline script)
2. **network-detect** - Initialized by quality-adapt.init()
3. **tile-prioritizer** - Initialized after OSD viewer ready
4. **quality-adapt** - Initialized after OSD viewer ready, listens to network-detect
5. **blur-up-loader** - Initialized after OSD viewer ready, hooks tile-loading events

#### DZI Data Flow

```
1. User navigates viewer
2. OpenSeadragon requests tiles
3. tile-prioritizer reorders requests by Z-plane priority
4. Requests go to sw.js:
   - Cache hit → immediate response
   - Cache miss → fetch from R2 CDN, cache result
5. Tile loads reported to network-detect (fallback classification)
6. quality-adapt adjusts zoom constraints based on network speed
```

### OME-Zarr Viewer (W7-W12)

The zarr viewer modules optimize OME-Zarr 3D volume browsing. Key technologies: Viv 0.19, deck.gl 9, luma.gl 9.

#### Zarr Module Dependency Graph

```
┌─────────────────────┐
│ zarr-viewport-math  │ ◄── Loaded first (pure math, no dependencies)
└──────────┬──────────┘
           │ zoomToLevel, viewStateToBounds, boundsToTileRange
           ▼
┌──────────────────┐     ┌──────────────────┐     ┌──────────────────┐
│  zarr-prefetch   │     │ zarr-render-opt  │     │  zarr-3d-loader  │
│  (viewport-aware │     │ (50ms debounce,  │     │ ("Load 3D" mode) │
│   Z-prefetch)    │     │  zoom cap, RAF)  │     │                  │
└──────────────────┘     └──────────────────┘     └──────────────────┘
           │                      │                       │
           │ adjacent Z chunks    │ debounced Z update    │ bulk Z-plane prefetch
           ▼                      ▼                       ▼
┌───────────────────────────────────────────────────────────────────┐
│                     zarr-viewer.js (ES module)                    │
│          Viv 0.19 MultiscaleImageLayer + deck.gl 9 Deck           │
│          refinementStrategy: 'best-available' (W9)                │
└────────────────────────────────┬──────────────────────────────────┘
                                 │ fetch requests (R2 chunks)
                                 ▼
                     ┌───────────────────────┐
                     │        sw.js          │
                     │ Dual-domain: R2 + CDN │ ◄── Cache-first for chunks
                     │ evostitch-zarr-v1.4.1 │    Network-first for metadata
                     └───────────────────────┘
```

#### Zarr IIFE Load Order (zarr-viewer.html)

1. **sw.js** - Registered via inline script, sets `window._swReady` promise
2. **loading-indicator.js** - Progress ring UI
3. **zarr-viewport-math.js** - Shared viewport geometry (W10)
4. **zarr-prefetch.js** - Viewport-aware Z-plane prefetching (W10)
5. **zarr-render-opt.js** - Debounce, zoom cap, RAF batching
6. **zarr-3d-loader.js** - "Load 3D" mode
7. **wasm/jpeg-decode.js** - Emscripten glue (defines `JpegDecodeModule` global)
8. **jpeg-zarr-codec.js** - JPEG zarr codec IIFE (WASM primary, canvas fallback; sets `window._ImagecodecsJpegCodec`)
9. **zarr-viewer.js** - ES module (registers codec via zarrita `registry.set()` if IIFE loaded)

#### Zarr Data Flow

```
1. zarr-viewer.js init() awaits _swReady, then calls loadOmeZarr(storeUrl)
2. Viv creates MultiscaleImageLayer with refinementStrategy: 'best-available'
3. On Z-switch:
   a. zarr-render-opt debounces (50ms)
   b. zarr-viewer.js calls updateLayer() with new Z selection
   c. Viv invalidates tile cache, requests new chunks
   d. deck.gl shows old Z-plane content as placeholder (best-available)
   e. zarr-prefetch prefetches adjacent Z-planes (viewport-filtered)
   f. SW intercepts chunk fetches:
      - Cache hit → immediate (sub-ms)
      - Cache miss → fetch from data.evostitch.net (HTTP/2)
   g. onViewportLoad fires → subtle opacity pulse, prefetch metrics updated
```

---

## Integration with Core Pipeline

The web viewer consumes output from both DZI generation and OME-Zarr conversion:

```
core/                                    R2 Cloud Storage
┌────────────────────┐                  ┌──────────────────────────┐
│ evostitch publish  │ ──rclone──────→ │ DZI tiles                │
│ (generates DZI)    │                  │ (pub-*.r2.dev)           │
└────────────────────┘                  └────────────┬─────────────┘
                                                     │ viewer.js
┌────────────────────┐                  ┌────────────▼─────────────┐
│ bioformats2raw     │ ──rclone──────→ │ OME-Zarr chunks          │
│ (generates Zarr)   │                  │ (data.evostitch.net)     │
└────────────────────┘                  └────────────┬─────────────┘
                                                     │ zarr-viewer.js
                                                     ▼
                                        Viv loadOmeZarr → deck.gl
```

### DZI Structure (2D)

```
{mosaic_id}/
├── metadata.json       # Width, height, scale, title
├── {name}.dzi          # DZI descriptor
└── {name}_files/       # Tile pyramid
    ├── 0/              # Lowest resolution
    ├── 1/
    └── ...             # Highest resolution
```

### DZI Structure (3D Z-stack)

```
{mosaic_id}/
├── metadata.json       # width, height, scale, zCount, zLabels, zSpacing
├── z_00/
│   ├── mosaic.dzi
│   └── mosaic_files/
├── z_01/
│   ├── mosaic.dzi
│   └── mosaic_files/
└── ...
```

### OME-Zarr Structure

```
mosaic_3d_zarr/
├── 0/                          # Root multiscale group
│   ├── .zgroup                 # Zarr group metadata
│   ├── .zattrs                 # OME-Zarr multiscales metadata
│   ├── 0/                      # Level 0 (finest resolution)
│   │   ├── .zarray             # Array metadata (shape, chunks, dtype, compressor)
│   │   └── {t}/{c}/{z}/{y}/{x} # Chunk data (dimension_separator: /)
│   ├── 1/                      # Level 1 (2x downsampled)
│   └── ...                     # Up to ~10 resolution levels
```

Chunks: `[1,1,1,512,512]` (TCZYX order), dtype `uint8`.

**Compression codecs:**

| Version | Codec | Path | Size | Decode |
|---------|-------|------|------|--------|
| V2 | blosc(zstd, clevel=5) | `mosaic_3d_zarr_v2/` | 187.5 GiB | WASM zstd |
| V3 | JPEG Q=95 (`imagecodecs_jpeg`) | `mosaic_3d_zarr_v3/` | 61 GiB (3.1x) | WASM libjpeg-turbo |

**Production default:** V3 (JPEG). V2 accessible via `?zarr=mosaic_3d_zarr_v2`.

URL pattern: `https://data.evostitch.net/mosaic_3d_zarr_v3/0/{level}/{t}/{c}/{z}/{y}/{x}`

---

## OpenSeadragon Configuration

Key settings in `OSD_CONFIG`:

| Setting | Value | Purpose |
|---------|-------|---------|
| `showNavigator` | true | Mini-map in corner |
| `maxZoomPixelRatio` | 2 | Allow 2x native zoom |
| `maxImageCacheCount` | 500 (base) | Tile cache size |
| `imageLoaderLimit` | 4 | Concurrent tile requests |

### Device-Adaptive Settings

Cache sizes adjust based on `navigator.deviceMemory`:

| Device Tier | Memory | Cache Base | Preload Radius |
|-------------|--------|------------|----------------|
| Mobile | < 4 GB | 150 tiles | ±1 plane |
| Standard | 4-8 GB | 200 tiles | ±2 planes |
| High | 8+ GB | 300 tiles | ±2 planes |

---

## Z-Stack Navigation

For 3D mosaics, all Z-planes are loaded into OpenSeadragon's world. Only one plane is visible at a time (opacity = 1), others are hidden (opacity = 0).

**Controls:**
- Slider: Direct plane selection
- Arrow Up/Down: Step through planes
- Shift+Scroll: Navigate Z while zooming normally
- Home/End: Jump to first/last plane

**Preloading:** Adjacent planes within `preloadRadius` have `setPreload(true)` for smoother transitions.

---

## Coordinate System

Coordinates displayed match QuPath conventions:
- Origin: top-left
- Units: micrometers (µm)
- Y increases downward

Conversion: `µm = pixel * scaleUmPerPixel`

The `metadata.json` provides scale from core's OME-TIFF metadata.

---

## Deployment

Static files deployed to GitHub Pages from `web/` directory.
- Custom domain: evostitch.net (configured via CNAME file)
- DZI tiles served from Cloudflare R2 (`pub-*.r2.dev`)
- OME-Zarr chunks served from R2 custom domain: `data.evostitch.net` (HTTP/2, Cloudflare CDN)
- Cache-Control headers set via Cloudflare Transform Rules: chunks `immutable` (1yr), metadata `max-age=3600` (1hr)
- See `web/docs/metadata-runbook.md` for CDN purge and SW update procedures

---

## Performance Testing

Automated harness for measuring viewer performance under controlled conditions.

### Structure

```
web/tests/perf/
├── config.js           # Test matrix configuration
├── metrics-collector.js # Browser-side instrumentation
└── run-harness.js      # Main test runner
```

### Usage

```bash
# Full test matrix (all conditions)
npm run perf-test

# Quick test (reduced matrix for fast iteration)
npm run perf-test:quick
```

### Test Matrix

| Dimension | Values |
|-----------|--------|
| Network | Unthrottled, Fast 3G (1.6Mbps), Slow 3G (400kbps) |
| Cache | Cold (cleared), Warm (primed) |
| Viewport | Desktop (1920x1080), Mobile (375x812) |

### Metrics Captured

| Metric | Description |
|--------|-------------|
| `timeToFirstTile` | Time from navigation to first tile loaded (ms) |
| `timeToViewportComplete` | Time until all visible tiles loaded (ms) |
| `p50TileLoad` | Median tile load latency (ms) |
| `p95TileLoad` | 95th percentile tile load latency (ms) |

### Output

Results written to `docs/performance-baseline.json`:

```json
{
  "timestamp": "2026-01-13T...",
  "mosaic": "3x3x3-test",
  "conditions": [
    {
      "conditions": { "network": "fast-3g", "cache": "cold", "viewport": "desktop" },
      "metrics": { "timeToFirstTile": 234, "timeToViewportComplete": 1892, "p50TileLoad": 145 }
    }
  ]
}
```

### Implementation Notes

- Uses Playwright with Chrome DevTools Protocol for network throttling
- Browser-side metrics collector injected via `addInitScript`
- Viewer exposes OSD instance via `document.getElementById('viewer').viewer`
- Environment variable `PERF_VIEWER_URL` overrides default viewer URL for local testing

### Known Limitations

- **Warm cache tests:** Each Playwright browser context has isolated cache. The "warm" cache test warms in a separate browser from the test browser, so warm results may not reflect actual browser cache behavior. This is a known limitation pending future enhancement.
